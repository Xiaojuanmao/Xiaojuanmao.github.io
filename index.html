<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Xiaojuanmao&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Coding Life">
<meta property="og:type" content="website">
<meta property="og:title" content="Xiaojuanmao's Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Xiaojuanmao's Blog">
<meta property="og:description" content="Coding Life">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Xiaojuanmao's Blog">
<meta name="twitter:description" content="Coding Life">
  
    <link rel="alternative" href="/atom.xml" title="Xiaojuanmao&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Xiaojuanmao&#39;s Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Life began in 1990</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Volley框架解析-七-Request解析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/01/16/Volley框架解析-七-Request解析/" class="article-date">
  <time datetime="2016-01-16T10:10:44.000Z" itemprop="datePublished">2016-01-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/16/Volley框架解析-七-Request解析/">Volley框架解析(七)-----Request解析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>###1. 前言(可直接无视跳过= =<br>&#160;&#160;&#160;&#160;·一路过关斩将= =，从最顶层一路看代码，了解了request队列的调度程序，request结果的处理方式，以及request请求出错的处理方式，对请求结果进行缓存方面的工作等等。这篇博客就轮到Volley中的主角出场了，那就是—<code>Request.java</code>，前面一直在说request，但是一直都没有介绍到Request是个什么东西，这么重要的东西怎么能忘记呢，其实小达也搞不清楚整个框架的介绍顺序，沿着接口自顶向下的延展开来，支路多了之后就只能慢慢的道来，request的来迟深感抱歉orz。</p>
<p>###2. Request.java<br>&#160;&#160;&#160;&#160;Volley封装的一个抽象类，Request.java提供了很大的便利性，可供我们自定义Request,之前在使用Volley的时候自定义了一些reuqest的，也总结过自定义request的方法，在这篇博客中有提到<a href="http://blog.csdn.net/jing_unique_da/article/details/45101331" title="Volley使用技巧-----自定义Request" target="_blank" rel="external">Volley使用技巧—–自定义Request</a>。下面就开始分析<code>Request.java</code>的源码。</p>
<pre><code>/**
 * Base class for all network requests.
 * 在volley中涉及到的所有request的基础类
 *
 * @param &lt;T&gt; The type of parsed response this request expects.
 * 泛型类T是请求端希望服务器能返回的数据类型
 *
 * 关于其实现的一个Comparable接口，从字面上来看就是&quot;可比较的&quot;
 * 官方的解释如下：
 * This interface should be implemented by all classes that wish to define 
 * a natural order of their instances. sort(List) and java.util.Arrays#sort 
 * can then be used to automatically sort lists of classes that implement this interface.
 * 意思就是说如果你希望你的类在一个list中能够使用sort等函数自动排序的话，就实现这个接口吧= =
 * (需要重写里面的方法compareTo(), 里面是比较了两个request的优先级)
 */
public abstract class Request&lt;T&gt; implements Comparable&lt;Request&lt;T&gt;&gt; {

    /**
     * Default encoding for POST or PUT parameters. See {@link #getParamsEncoding()}.
     * POST或者是PUT请求参数的默认编码格式 &quot;UTF-8&quot;
     */
    private static final String DEFAULT_PARAMS_ENCODING = &quot;UTF-8&quot;;

    /**
     * Supported request methods.
     * 支持的请求方式，有各种,常用的GET, POST, PUT应该是比较熟悉
     */
    public interface Method {
        int DEPRECATED_GET_OR_POST = -1;
        int GET = 0;
        int POST = 1;
        int PUT = 2;
        int DELETE = 3;
        int HEAD = 4;
        int OPTIONS = 5;
        int TRACE = 6;
        int PATCH = 7;
    }

    /**
     * An event log tracing the lifetime of this request; for debugging. 
     * 为了debug方便，volley弄了一套VolleyLog
     * 在一个request整个生命周期内不停的打出log
     * 都可以方便从log监控该request现在的情况
     */
    private final MarkerLog mEventLog = MarkerLog.ENABLED ? new MarkerLog() : null;

    /**
     * Request method of this request.  Currently supports GET, POST, PUT, DELETE, HEAD, OPTIONS,
     * TRACE, and PATCH.
     * 当前request涉及到的请求方式
     * 目前所支持的有GET, POST, PUT等
     */
    private final int mMethod;

    /** 
     * URL of this request.
     * 原始Url
     */
    private final String mUrl;

    /**
     * The redirect url to use for 3xx http responses 
     * request重定向之后的url
     */
    private String mRedirectUrl;

    /** The unique identifier of the request 
     *  从后面可以看出在构造request的时候
     *  mIdentifier是通过createIdentifier()函数
     *  由传入的url和请求的method以及当前系统时间还有一个计数器counter构造出的
     *  独一无二的身份标识
     */
    private String mIdentifier;

    /** 
     * Default tag for {@link TrafficStats}. 
     * 
     */
    private final int mDefaultTrafficStatsTag;

    /** Listener interface for errors. */
    private final Response.ErrorListener mErrorListener;

    /** Sequence number of this request, used to enforce FIFO ordering. */
    private Integer mSequence;

    /** The request queue this request is associated with. */
    private RequestQueue mRequestQueue;

    /** Whether or not responses to this request should be cached. */
    private boolean mShouldCache = true;

    /** Whether or not this request has been canceled. */
    private boolean mCanceled = false;

    /** Whether or not a response has been delivered for this request yet. */
    private boolean mResponseDelivered = false;

    // A cheap variant of request tracing used to dump slow requests.
    private long mRequestBirthTime = 0;

    /** 
     * Threshold at which we should log the request (even when debug logging is not enabled). 
     * 用来判定是否打出将一个request打出slow_request的log的时间阀值
     * 如果request响应时间超过了这个阀值，则会打出log，说明一下情况
     */
    private static final long SLOW_REQUEST_THRESHOLD_MS = 3000;

    /**
     * The retry policy for this request. 
     * 在前面已经介绍到了，RetryPolicy.java及其默认实现类
     * 是用来处理request重新发送的一种策略，也就是重试方针
     * 里面记录着重试的最大次数以及当前重试了几次等
     */
    private RetryPolicy mRetryPolicy;

    /**
     * When a request can be retrieved from cache but must be refreshed from
     * the network, the cache entry will be stored here so that in the event of
     * a &quot;Not Modified&quot; response, we can be sure it hasn&apos;t been evicted from cache.
     *
     * 当一个请求的结果有缓存但是需要从服务器刷新一下的时候
     * 缓存的入口，在向服务器发送条件请求时，服务器返回304之后
     * 就可以从这个缓存的入口找到该请求在本地对应的缓存数据了。= =直接拿来用咯
     */
    private Cache.Entry mCacheEntry = null;

    /** An opaque token tagging this request; used for bulk cancellation. 
     *  一个关于该request的不公开透明的token，用于批量取消
     * 在RequestQueue.java中会用到这个mTag
     * 用mTag可以取消request
     */
    private Object mTag;

    /**
     * Creates a new request with the given URL and error listener.  Note that
     * the normal response listener is not provided here as delivery of responses
     * is provided by subclasses, who have a better idea of how to deliver an
     * already-parsed response.
     *
     * 根据给定的url和errorListener创建一个新的request
     * 需要注意的是这里并没有涉及到responseListener方面的设置
     * 因为将其放在request的子类去设置能更好的去传递一个已经解析好了的response
     *
     * 这个方法已经不推荐使用了，推荐使用下面的一个构造方法，因为这个方法存在默认的method
     * 没有很大的自由度去自定义request
     *
     * @deprecated Use {@link #Request(int, String, com.android.volley.Response.ErrorListener)}.
     */
    @Deprecated
    public Request(String url, Response.ErrorListener listener) {
        this(Method.DEPRECATED_GET_OR_POST, url, listener);
    }

    /**
     * Creates a new request with the given method (one of the values from {@link Method}),
     * URL, and error listener.  Note that the normal response listener is not provided here as
     * delivery of responses is provided by subclasses, who have a better idea of how to deliver
     * an already-parsed response.
     * 
     * setRetryPolicy()该方法设置了request所谓的“重试策略”。
     * 跳转到DefaultRetryPolicy.java(系列博客的第四篇---Volley框架解析(四))
     */
    public Request(int method, String url, Response.ErrorListener listener) {
        mMethod = method;
        mUrl = url;
        mIdentifier = createIdentifier(method, url);
        mErrorListener = listener;
        setRetryPolicy(new DefaultRetryPolicy());

        mDefaultTrafficStatsTag = findDefaultTrafficStatsTag(url);
    }

    /**
     * Return the method for this request.  Can be one of the values in {@link Method}.
     */
    public int getMethod() {
        return mMethod;
    }

    /**
     * Set a tag on this request. Can be used to cancel all requests with this
     * tag by {@link RequestQueue#cancelAll(Object)}.
     *
     * 为了方便从网络请求队列里面取消request，可以通过打tag的方式
     * @return This Request object to allow for chaining.
     */
    public Request&lt;?&gt; setTag(Object tag) {
        mTag = tag;
        return this;
    }

    /**
     * Returns this request&apos;s tag.
     * @see Request#setTag(Object)
     */
    public Object getTag() {
        return mTag;
    }

    /**
     * @return this request&apos;s {@link com.android.volley.Response.ErrorListener}.
     */
    public Response.ErrorListener getErrorListener() {
        return mErrorListener;
    }

    /**
     * @return A tag for use with {@link TrafficStats#setThreadStatsTag(int)}
     */
    public int getTrafficStatsTag() {
        return mDefaultTrafficStatsTag;
    }

    /**
     * @return The hashcode of the URL&apos;s host component, or 0 if there is none.
     * 返回了request的url中的host的hashcode
     */
    private static int findDefaultTrafficStatsTag(String url) {
        if (!TextUtils.isEmpty(url)) {
            Uri uri = Uri.parse(url);
            if (uri != null) {
                String host = uri.getHost();
                if (host != null) {
                    return host.hashCode();
                }
            }
        }
        return 0;
    }

    /**
     * Sets the retry policy for this request.
     * 给request设置重试策略
     * @return This Request object to allow for chaining.
     */
    public Request&lt;?&gt; setRetryPolicy(RetryPolicy retryPolicy) {
        mRetryPolicy = retryPolicy;
        return this;
    }

    /**
     * Adds an event to this request&apos;s event log; for debugging.
     */
    public void addMarker(String tag) {
        if (MarkerLog.ENABLED) {
            mEventLog.add(tag, Thread.currentThread().getId());
        } else if (mRequestBirthTime == 0) {
            mRequestBirthTime = SystemClock.elapsedRealtime();
        }
    }

    /**
     * Notifies the request queue that this request has finished (successfully or with error).
     * 该函数用来告诉request队列，当前的request已经完成了(包括成功和失败)
     * &lt;p&gt;Also dumps all events from this request&apos;s event log; for debugging.&lt;/p&gt;
     */
    void finish(final String tag) {

        /**
         * 告诉RequestQueue，这个tag对应的request已经结束了
         * ReuqestQueue会将这个request移出队列
         * 并将具有相同cacheKey的等待中reuqest全部移除
         */
        if (mRequestQueue != null) {
            mRequestQueue.finish(this);
        }

        /**
         * 如果允许打出log
         * 则log提示这个request已经结束了
         */
        if (MarkerLog.ENABLED) {
            final long threadId = Thread.currentThread().getId();
            if (Looper.myLooper() != Looper.getMainLooper()) {
                // If we finish marking off of the main thread, we need to
                // actually do it on the main thread to ensure correct ordering.
                Handler mainThread = new Handler(Looper.getMainLooper());
                mainThread.post(new Runnable() {
                    @Override
                    public void run() {
                        mEventLog.add(tag, threadId);
                        mEventLog.finish(this.toString());
                    }
                });
                return;
            }

            mEventLog.add(tag, threadId);
            mEventLog.finish(this.toString());
        } else {
            long requestTime = SystemClock.elapsedRealtime() - mRequestBirthTime;
            if (requestTime &gt;= SLOW_REQUEST_THRESHOLD_MS) {
                VolleyLog.d(&quot;%d ms: %s&quot;, requestTime, this.toString());
            }
        }
    }

    /**
     * Associates this request with the given queue. The request queue will be notified when this
     * request has finished.
     * 
     * 将和request相关的那个RequestQueue与request关联起来
     * 持有一个对象的引用
     * 在request结束的时候好通知RequestQueue
     * 
     * @return This Request object to allow for chaining.
     */
    public Request&lt;?&gt; setRequestQueue(RequestQueue requestQueue) {
        mRequestQueue = requestQueue;
        return this;
    }

    /**
     * Sets the sequence number of this request.  Used by {@link RequestQueue}.
     * 在RequestQueue中调用，request加入到RequestQueue的时候
     * 需要开始排队等待处理
     * 这个函数的作用就是发号码牌给每个request(排队专用，想的还比较周到= =)
     * @return This Request object to allow for chaining.
     */
    public final Request&lt;?&gt; setSequence(int sequence) {
        mSequence = sequence;
        return this;
    }

    /**
     * Returns the sequence number of this request.
     */
    public final int getSequence() {
        if (mSequence == null) {
            throw new IllegalStateException(&quot;getSequence called before setSequence&quot;);
        }
        return mSequence;
    }

    /**
     * Returns the URL of this request.
     * 返回真实访问的url,如果有重定向出现
     * 则真实url是重定向后的url
     * 否则是原始的url
     */
    public String getUrl() {
        return (mRedirectUrl != null) ? mRedirectUrl : mUrl;
    }

    /**
     * Returns the URL of the request before any redirects have occurred.
     * 返回最原始的url,在任何重定向发生之前
     */
    public String getOriginUrl() {
        return mUrl;
    }

    /**
     * Returns the identifier of the request.
     */
    public String getIdentifier() {
        return mIdentifier;
    }

    /**
     * Sets the redirect url to handle 3xx http responses.
     * 发生重定向之后可以通过该函数来设置重定向后的url
     */
    public void setRedirectUrl(String redirectUrl) {
        mRedirectUrl = redirectUrl;
    }

    /**
     * Returns the cache key for this request.  
     * By default, this is the URL.
     * 默认使用url来作为cacheKey
     */
    public String getCacheKey() {
        return getUrl();
    }

    /**
     * Annotates this request with an entry retrieved for it from cache.
     * Used for cache coherency support.
     * 
     * @return This Request object to allow for chaining.
     */
    public Request&lt;?&gt; setCacheEntry(Cache.Entry entry) {
        mCacheEntry = entry;
        return this;
    }

    /**
     * Returns the annotated cache entry, or null if there isn&apos;t one.
     */
    public Cache.Entry getCacheEntry() {
        return mCacheEntry;
    }

    /**
     * Mark this request as canceled.  No callback will be delivered.
     */
    public void cancel() {
        mCanceled = true;
    }

    /**
     * Returns true if this request has been canceled.
     */
    public boolean isCanceled() {
        return mCanceled;
    }

    /**
     * Returns a list of extra HTTP headers to go along with this request. Can
     * throw {@link AuthFailureError} as authentication may be required to
     * provide these values.
     * 返回在Request中的HTTPheader，这个里面存放了一些关于Request的基本信息
     * 例如请求方式，cookie等东西
     * @throws AuthFailureError In the event of auth failure
     */
    public Map&lt;String, String&gt; getHeaders() throws AuthFailureError {
        return Collections.emptyMap();
    }

    /**
     * Returns a Map of POST parameters to be used for this request, or null if
     * a simple GET should be used.  Can throw {@link AuthFailureError} as
     * authentication may be required to provide these values.
     * 返回request中用于POST请求的一些参数
     * 这些参数以键值对的形式存在，如果是GET方法，则传回Null
     *　
     * &lt;p&gt;Note that only one of getPostParams() and getPostBody() can return a non-null
     * value.&lt;/p&gt;
     * @throws AuthFailureError In the event of auth failure
     *
     * @deprecated Use {@link #getParams()} instead.
     */
    @Deprecated
    protected Map&lt;String, String&gt; getPostParams() throws AuthFailureError {
        return getParams();
    }

    /**
     * Returns which encoding should be used when converting POST parameters returned by
     * {@link #getPostParams()} into a raw POST body.
     * 
     * 
     * &lt;p&gt;This controls both encodings:
     * &lt;ol&gt;
     *     &lt;li&gt;The string encoding used when converting parameter names and values into bytes prior
     *         to URL encoding them.&lt;/li&gt;
     *     &lt;li&gt;The string encoding used when converting the URL encoded parameters into a raw
     *         byte array.&lt;/li&gt;
     * &lt;/ol&gt;
     *
     * @deprecated Use {@link #getParamsEncoding()} instead.
     */
    @Deprecated
    protected String getPostParamsEncoding() {
        return getParamsEncoding();
    }

    /**
     * @deprecated Use {@link #getBodyContentType()} instead.
     * 返回请求体的内容种类
     * 包括application/json等内容
     */
    @Deprecated
    public String getPostBodyContentType() {
        return getBodyContentType();
    }

    /**
     * Returns the raw POST body to be sent.
     * 该函数被建议不要使用了，用getBody代替
     * 
     * @throws AuthFailureError In the event of auth failure
     *
     * @deprecated Use {@link #getBody()} instead.
     */
    @Deprecated
    public byte[] getPostBody() throws AuthFailureError {
        // Note: For compatibility with legacy clients of volley, this implementation must remain
        // here instead of simply calling the getBody() function because this function must
        // call getPostParams() and getPostParamsEncoding() since legacy clients would have
        // overridden these two member functions for POST requests.
        Map&lt;String, String&gt; postParams = getPostParams();
        if (postParams != null &amp;&amp; postParams.size() &gt; 0) {
            return encodeParameters(postParams, getPostParamsEncoding());
        }
        return null;
    }

    /**
     * Returns a Map of parameters to be used for a POST or PUT request.  Can throw
     * {@link AuthFailureError} as authentication may be required to provide these values.
     *
     * &lt;p&gt;Note that you can directly override {@link #getBody()} for custom data.&lt;/p&gt;
     *
     * @throws AuthFailureError in the event of auth failure
     */
    protected Map&lt;String, String&gt; getParams() throws AuthFailureError {
        return null;
    }

    /**
     * Returns which encoding should be used when converting POST or PUT parameters returned by
     * {@link #getParams()} into a raw POST or PUT body.
     *
     * &lt;p&gt;This controls both encodings:
     * &lt;ol&gt;
     *     &lt;li&gt;The string encoding used when converting parameter names and values into bytes prior
     *         to URL encoding them.&lt;/li&gt;
     *     &lt;li&gt;The string encoding used when converting the URL encoded parameters into a raw
     *         byte array.&lt;/li&gt;
     * &lt;/ol&gt;
     */
    protected String getParamsEncoding() {
        return DEFAULT_PARAMS_ENCODING;
    }

    /**
     * Returns the content type of the POST or PUT body.
     * 返回请求体的内容种类
     */
    public String getBodyContentType() {
        return &quot;application/x-www-form-urlencoded; charset=&quot; + getParamsEncoding();
    }

    /**
     * Returns the raw POST or PUT body to be sent.
     * 返回将要发送的request的POST主体
     * 
     * &lt;p&gt;By default, the body consists of the request parameters in
     * application/x-www-form-urlencoded format. When overriding this method, consider overriding
     * {@link #getBodyContentType()} as well to match the new body format.
     *
     * @throws AuthFailureError in the event of auth failure
     */
    public byte[] getBody() throws AuthFailureError {
        Map&lt;String, String&gt; params = getParams();
        if (params != null &amp;&amp; params.size() &gt; 0) {
            return encodeParameters(params, getParamsEncoding());
        }
        return null;
    }

    /**
     * Converts &lt;code&gt;params&lt;/code&gt; into an application/x-www-form-urlencoded encoded string.
     * 将请求里面包含的参数转码
     */
    private byte[] encodeParameters(Map&lt;String, String&gt; params, String paramsEncoding) {
        StringBuilder encodedParams = new StringBuilder();
        try {
            for (Map.Entry&lt;String, String&gt; entry : params.entrySet()) {
                encodedParams.append(URLEncoder.encode(entry.getKey(), paramsEncoding));
                encodedParams.append(&apos;=&apos;);
                encodedParams.append(URLEncoder.encode(entry.getValue(), paramsEncoding));
                encodedParams.append(&apos;&amp;&apos;);
            }
            return encodedParams.toString().getBytes(paramsEncoding);
        } catch (UnsupportedEncodingException uee) {
            throw new RuntimeException(&quot;Encoding not supported: &quot; + paramsEncoding, uee);
        }
    }

    /**
     * Set whether or not responses to this request should be cached.
     *
     * @return This Request object to allow for chaining.
     */
    public final Request&lt;?&gt; setShouldCache(boolean shouldCache) {
        mShouldCache = shouldCache;
        return this;
    }

    /**
     * Returns true if responses to this request should be cached.
     */
    public final boolean shouldCache() {
        return mShouldCache;
    }

    /**
     * Priority values.  Requests will be processed from higher priorities to
     * lower priorities, in FIFO order.
     * request将按照优先级从高到低，先进先出的顺序被处理
     */
    public enum Priority {
        LOW,
        NORMAL,
        HIGH,
        IMMEDIATE
    }

    /**
     * Returns the {@link Priority} of this request; {@link Priority#NORMAL} by default.
     * 返回request的优先级
     * 默认为normal
     */
    public Priority getPriority() {
        return Priority.NORMAL;
    }

    /**
     * Returns the socket timeout in milliseconds per retry attempt. (This value can be changed
     * per retry attempt if a backoff is specified via backoffTimeout()). If there are no retry
     * attempts remaining, this will cause delivery of a {@link TimeoutError} error.
     * 返回每次超时请求时间阀值
     * 每次retry如果返回的是请求超时的结果，则timeout会逐渐变大
     * 如果
     */
    public final int getTimeoutMs() {
        return mRetryPolicy.getCurrentTimeout();
    }

    /**
     * Returns the retry policy that should be used  for this request.
     */
    public RetryPolicy getRetryPolicy() {
        return mRetryPolicy;
    }

    /**
     * Mark this request as having a response delivered on it.  This can be used
     * later in the request&apos;s lifetime for suppressing identical responses.
     */
    public void markDelivered() {
        mResponseDelivered = true;
    }

    /**
     * Returns true if this request has had a response delivered for it.
     */
    public boolean hasHadResponseDelivered() {
        return mResponseDelivered;
    }

    /**
     * Subclasses must implement this to parse the raw network response
     * and return an appropriate response type. This method will be
     * called from a worker thread.  The response will not be delivered
     * if you return null.
     * 子类必须要实现这个方法来解析network response并返回一个合适的返回类型
     * 
     * @param response Response from the network
     * @return The parsed response, or null in the case of an error
     */
    abstract protected Response&lt;T&gt; parseNetworkResponse(NetworkResponse response);

    /**
     * Subclasses can override this method to parse &apos;networkError&apos; and return a more specific error.
     * 子类重写这个方法，来解析networkError
     * &lt;p&gt;The default implementation just returns the passed &apos;networkError&apos;.&lt;/p&gt;
     *
     * @param volleyError the error retrieved from the network
     * @return an NetworkError augmented with additional information
     */
    protected VolleyError parseNetworkError(VolleyError volleyError) {
        return volleyError;
    }

    /**
     * Subclasses must implement this to perform delivery of the parsed
     * response to their listeners.  The given response is guaranteed to
     * be non-null; responses that fail to parse are not delivered.
     *
     * 子类必须实现这个方法来传递一个解析好了的response
     *
     * @param response The parsed response returned by
     * {@link #parseNetworkResponse(NetworkResponse)}
     */
    abstract protected void deliverResponse(T response);

    /**
     * Delivers error message to the ErrorListener that the Request was
     * initialized with.
     *
     * @param error Error details
     */
    public void deliverError(VolleyError error) {
        if (mErrorListener != null) {
            mErrorListener.onErrorResponse(error);
        }
    }

    /**
     * Our comparator sorts from high to low priority, and secondarily by
     * sequence number to provide FIFO ordering.
     * Request类实现了Comparable类
     * 需要重写compareTo()方法
     * 来达到能够将两个request相互比较的目的
     * 这里面的比较策略是通过看两request的优先级大小
     * 高优先级的排在前面，相等的优先级就按照排队时候发放的序列号来比较
     * (在RequestQueue.java中的add()函数里会给每个加入到队列中的request发放一个sequence)
     */
    @Override
    public int compareTo(Request&lt;T&gt; other) {
        Priority left = this.getPriority();
        Priority right = other.getPriority();

        // High-priority requests are &quot;lesser&quot; so they are sorted to the front.
        // Equal priorities are sorted by sequence number to provide FIFO ordering.
        return left == right ?
                this.mSequence - other.mSequence :
                right.ordinal() - left.ordinal();
    }

    /**
     * 重写toString()方法
     * 提供在打印request的时候的一些数据
     * 也方便序列化
     */
    @Override
    public String toString() {
        String trafficStatsTag = &quot;0x&quot; + Integer.toHexString(getTrafficStatsTag());
        return (mCanceled ? &quot;[X] &quot; : &quot;[ ] &quot;) + getUrl() + &quot; &quot; + trafficStatsTag + &quot; &quot;
                + getPriority() + &quot; &quot; + mSequence;
    }

    private static long sCounter;
    /**
     *  sha1(Request:method:url:timestamp:counter)
     * 
     * @param method http method
     * @param url               http request url
     * @return sha1 hash string
     */
    private static String createIdentifier(final int method, final String url) {
        return InternalUtils.sha1Hash(&quot;Request:&quot; + method + &quot;:&quot; + url +
                &quot;:&quot; + System.currentTimeMillis() + &quot;:&quot; + (sCounter++));
    }
}
</code></pre><p>&#160;&#160;&#160;&#160;在<code>Request.java</code>的基础上，Volley示范性的扩展了<code>StringReuqest.java</code>以及<code>JSONArrayRequest.java</code>等等，在这里就不分析源代码了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/01/16/Volley框架解析-七-Request解析/" data-id="cijh2hrk0000e7nuthykp6jlb" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Volley/">Volley</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Volley框架解析-六-Cache接口及其默认实现类解析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/01/16/Volley框架解析-六-Cache接口及其默认实现类解析/" class="article-date">
  <time datetime="2016-01-16T10:10:37.000Z" itemprop="datePublished">2016-01-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/16/Volley框架解析-六-Cache接口及其默认实现类解析/">Volley框架解析(六)-----Cache接口及其默认实现类解析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>###1. 前言(可直接无视跳过<br>&#160;&#160;&#160;&#160;不知不觉Volley的源码分析到了Cache接口部分了，前面涉及到网络的部分都介绍完了，在处理网络请求返回的数据时，会根据request结果是否需要缓存来进行不同的处理。如需要缓存结果，就涉及到了<code>Cache.java</code>及其默认实现类<code>DiskBasedCache.java</code>。 其实在之前什么都不知道的时候，认为缓存是个非常神秘的东西，可能是人类对于未知的恐惧和敬畏嘛orz，后来在用到另外一个牛掰的网络请求框架<a href="https://github.com/koush/ion" title="ion" target="_blank" rel="external">ion</a>的时候，在自己app的目录下面看到一个ion的文件夹= =，进去之后发现了好多balabala乱七八糟的打不开的文件，突然明白了，估计是看到本地缓存的文件了。扯远了= =，开始源代码的分析。</p>
<p>###2. Cache.java<br>&#160;&#160;&#160;&#160;用于处理缓存的接口，里面有很多抽象的方法等着被实现，里面还有一个static类<code>Entry</code>,里面有些关于缓存的单元信息。(例如，缓存的内容，缓存过期的时间，缓存需要刷新的时间等等）。</p>
<pre><code>package com.android.volley;

/**
 * An interface for a cache keyed by a String with * a byte array as data.
 * 一个用于缓存的接口
 */
public interface Cache {
    /**
     * Retrieves an entry from the cache.
     * 用来获取缓存的入口，通过传入的key
     * 
     * @param key Cache key
     * 这个key应该是request对应其缓存的唯一key
     *
     * @return An {@link Entry} or null in the event of a cache miss
     */
    public Entry get(String key);

    /**
     * Adds or replaces an entry to the cache.
     * 添加或者给request更新缓存
     * @param key Cache key
     * @param entry Data to store and metadata for cache coherency, TTL, etc.
     */
    public void put(String key, Entry entry);

    /**
     * Performs any potentially long-running actions needed to initialize the cache;
     * will be called from a worker thread.
     */
    public void initialize();

    /**
     * Invalidates an entry in the cache.
     * 这个函数是将key对应的缓存置于过期
     * 分为fully expire和soft expire， 目前还不知道是什么意思 = =
     * 
     * @param key Cache key
     * @param fullExpire True to fully expire the entry, false to soft expire
     */
    public void invalidate(String key, boolean fullExpire);

    /**
     * Removes an entry from the cache.
     * 将key对应的缓存直接移除掉
     * 
     * @param key Cache key
     */
    public void remove(String key);

    /**
     * Empties the cache.
     * 清除所有的缓存
     */
    public void clear();

    /**
     * Data and metadata for an entry returned by the cache.
     */
    public static class Entry {
        /** The data returned from cache. */
        public byte[] data;

        /** ETag for cache coherency. */
        public String etag;

        /** Date of this response as reported by the server. */
        public long serverDate;

        /** The last modified date for the requested object. */
        public long lastModified;

        /** TTL for this record.
         *  根据后面的isExpired()函数来看
         *  该条数据的意思应该是缓存过期的时间 
         */
        public long ttl;

        /** Soft TTL for this record. 
         *  根据refreshNeeded()函数来看
         *  意思是需要更新缓存的时间点
         */
        public long softTtl;

        /** Immutable response headers as received from server; must be non-null. */
        public Map&lt;String, String&gt; responseHeaders = Collections.emptyMap();

       /** 
         * True if the entry is expired. 
         * 用来查看缓存是否过期了
         */
        public boolean isExpired() {
            return this.ttl &lt; System.currentTimeMillis();
        }

        /** True if a refresh is needed from the original data source. */
        public boolean refreshNeeded() {
            return this.softTtl &lt; System.currentTimeMillis();
        }
    }

}
</code></pre><p>###3. DiskBasedCache.java<br>&#160;&#160;&#160;&#160;实现了Cache.java接口，专门和本地存储的文件打交道，负责缓存的写入与读取。涉及到了一部分InputStream和OutputStream还有File的知识。</p>
<pre><code>/**
 * Cache implementation that caches files directly onto the hard disk in the specified
 * directory. The default disk usage size is 5MB, but is configurable.
 * 实现了Cache接口
 * 专门用于和本地文件交互的一个类
 * 存入缓存和取出缓存等功能
 */
public class DiskBasedCache implements Cache {

    /** 
     * Map of the Key, CacheHeader pairs 
     * CacheHeader.java为本类中的一个static类
     * 里面存放着一些
     */
    private final Map&lt;String, CacheHeader&gt; mEntries =
            new LinkedHashMap&lt;String, CacheHeader&gt;(16, .75f, true);

    /** 
     * Total amount of space currently used by the cache in bytes. 
     * 当前缓存的总大小
     */
    private long mTotalSize = 0;

    /** 
     * The root directory to use for the cache. 
     * 缓存的根目录
     */
    private final File mRootDirectory;

    /** 
     * The maximum size of the cache in bytes. 
     * 缓存能接受的最大字节数
     */
    private final int mMaxCacheSizeInBytes;

    /** 
     * Default maximum disk usage in bytes.
     * 默认缓存能使用的最大空间
     */
    private static final int DEFAULT_DISK_USAGE_BYTES = 5 * 1024 * 1024;

    /** 
     * High water mark percentage for the cache
     * 类似于水位警戒线一样的标识
     */
    private static final float HYSTERESIS_FACTOR = 0.9f;

    /** 
     * Magic number for current version of cache file format. 
     * 
     */
    private static final int CACHE_MAGIC = 0x20150306;

    /**
     * Constructs an instance of the DiskBasedCache at the specified directory.
     * 在指定的目录下面创建一个DiskBasedCache
     *
     * @param rootDirectory The root directory of the cache.
     * @param maxCacheSizeInBytes The maximum size of the cache in bytes.
     */
    public DiskBasedCache(File rootDirectory, int maxCacheSizeInBytes) {
        mRootDirectory = rootDirectory;
        mMaxCacheSizeInBytes = maxCacheSizeInBytes;
    }

    /**
     * Constructs an instance of the DiskBasedCache at the specified directory using
     * the default maximum cache size of 5MB.
     * @param rootDirectory The root directory of the cache.
     */
    public DiskBasedCache(File rootDirectory) {
        this(rootDirectory, DEFAULT_DISK_USAGE_BYTES);
    }

    /**
     * Clears the cache. Deletes all cached files from disk.
     * 清除当前目录下的缓存，删除所有缓存文件 
     */
    @Override
    public synchronized void clear() {
        File[] files = mRootDirectory.listFiles();
        if (files != null) {
            for (File file : files) {
                file.delete();
            }
        }
        mEntries.clear();
        mTotalSize = 0;
        VolleyLog.d(&quot;Cache cleared.&quot;);
    }

    /**
     * Returns the cache entry with the specified key if it exists, null otherwise.
     * 通过特殊的key，来获取与缓存交流的接口(entry)
     * 如果没有的话则返回null
     */
    @Override
    public synchronized Entry get(String key) {

        CacheHeader entry = mEntries.get(key);
        // if the entry does not exist, return.
        if (entry == null) {
            return null;
        }

        //依据key获取缓存的文件，如果不存在则创建一个
        File file = getFileForKey(key);

        CountingInputStream cis = null;

        try {

            cis = new CountingInputStream(new BufferedInputStream(new FileInputStream(file)));
            CacheHeader.readHeader(cis); // eat header
            byte[] data = streamToBytes(cis, (int) (file.length() - cis.bytesRead));
            return entry.toCacheEntry(data);

        } catch (IOException e) {
            VolleyLog.d(&quot;%s: %s&quot;, file.getAbsolutePath(), e.toString());
            remove(key);
            return null;
        }  catch (NegativeArraySizeException e) {
            VolleyLog.d(&quot;%s: %s&quot;, file.getAbsolutePath(), e.toString());
            remove(key);
            return null;
        } finally {
            if (cis != null) {
                try {
                    cis.close();
                } catch (IOException ioe) {
                    return null;
                }
            }
        }
    }

    /**
     * Initializes the DiskBasedCache by scanning for all files currently in the
     * specified root directory. Creates the root directory if necessary.
     * 对缓存目录的初始化工作，检查目录是否存在
     * 如果不存在就给重新创建一个
     */
    @Override
    public synchronized void initialize() {
        if (!mRootDirectory.exists()) {
            if (!mRootDirectory.mkdirs()) {
                VolleyLog.e(&quot;Unable to create cache dir %s&quot;, mRootDirectory.getAbsolutePath());
            }
            return;
        }

        /**
         * 如果缓存目录已经存在了
         * 则将缓存目录下面的文件都扫描一遍
         * 将关于缓存文件的部分信息加载到内存中来
         * 方便后面对缓存的查询等工作
         */

        File[] files = mRootDirectory.listFiles();
        if (files == null) {
            return;
        }
        for (File file : files) {
            BufferedInputStream fis = null;
            try {
                fis = new BufferedInputStream(new FileInputStream(file));
                CacheHeader entry = CacheHeader.readHeader(fis);
                entry.size = file.length();
                putEntry(entry.key, entry);
            } catch (IOException e) {
                if (file != null) {
                   file.delete();
                }
            } finally {
                try {
                    if (fis != null) {
                        fis.close();
                    }
                } catch (IOException ignored) { }
            }
        }
    }

    /**
     * Invalidates an entry in the cache.
     * 将key对应的缓存作废
     * 如果fullExpire为true，则将整个entry作废
     * 如果为false,则只是软作废，也就是将缓存置于需要刷新的状态
     *
     * @param key Cache key
     * @param fullExpire True to fully expire the entry, false to soft expire
     */
    @Override
    public synchronized void invalidate(String key, boolean fullExpire) {
        Entry entry = get(key);
        if (entry != null) {
            entry.softTtl = 0;
            if (fullExpire) {
                entry.ttl = 0;
            }
            put(key, entry);
        }

    }

    /**
     * Puts the entry with the specified key into the cache.
     * 将entry中包含的信息存放到key对应的缓存文件中去
     */
    @Override
    public synchronized void put(String key, Entry entry) {

        pruneIfNeeded(entry.data.length);

        File file = getFileForKey(key);
        try {
            BufferedOutputStream fos = new BufferedOutputStream(new FileOutputStream(file));
            CacheHeader e = new CacheHeader(key, entry);
            boolean success = e.writeHeader(fos);
            if (!success) {
                fos.close();
                VolleyLog.d(&quot;Failed to write header for %s&quot;, file.getAbsolutePath());
                throw new IOException();
            }
            fos.write(entry.data);
            fos.close();
            putEntry(key, e);
            return;
        } catch (IOException e) {
        }
        boolean deleted = file.delete();
        if (!deleted) {
            VolleyLog.d(&quot;Could not clean up file %s&quot;, file.getAbsolutePath());
        }
    }

    /**
     * Removes the specified key from the cache if it exists.
     */
    @Override
    public synchronized void remove(String key) {
        boolean deleted = getFileForKey(key).delete();
        removeEntry(key);
        if (!deleted) {
            VolleyLog.d(&quot;Could not delete cache entry for key=%s, filename=%s&quot;,
                    key, getFilenameForKey(key));
        }
    }

    /**
     * Creates a pseudo-unique filename for the specified cache key.
     * 通过给定的key，前半段的hashCode和后半段的hashCode连接起来
     * 作为一个独一无二的文件名
     * @param key The key to generate a file name for.
     * @return A pseudo-unique filename.
     */
    private String getFilenameForKey(String key) {
        int firstHalfLength = key.length() / 2;
        String localFilename = String.valueOf(key.substring(0, firstHalfLength).hashCode());
        localFilename += String.valueOf(key.substring(firstHalfLength).hashCode());
        return localFilename;
    }

    /**
     * Returns a file object for the given cache key.
     * 通过调用getFilenameForKey()方法来获取相对路径
     */
    public File getFileForKey(String key) {
        return new File(mRootDirectory, getFilenameForKey(key));
    }

    /**
     * Prunes the cache to fit the amount of bytes specified.
     * 从已有的缓存中清除数据
     * 直到扫出了一片neededSapce大小的空地为止
     * @param neededSpace The amount of bytes we are trying to fit into the cache.
     */
    private void pruneIfNeeded(int neededSpace) {
        if ((mTotalSize + neededSpace) &lt; mMaxCacheSizeInBytes) {
            return;
        }
        if (VolleyLog.DEBUG) {
            VolleyLog.v(&quot;Pruning old cache entries.&quot;);
        }

        long before = mTotalSize;
        int prunedFiles = 0;
        long startTime = SystemClock.elapsedRealtime();

        Iterator&lt;Map.Entry&lt;String, CacheHeader&gt;&gt; iterator = mEntries.entrySet().iterator();

        while (iterator.hasNext()) {

            Map.Entry&lt;String, CacheHeader&gt; entry = iterator.next();

            CacheHeader e = entry.getValue();

            boolean deleted = getFileForKey(e.key).delete();

            if (deleted) {
                mTotalSize -= e.size;
            } else {
               VolleyLog.d(&quot;Could not delete cache entry for key=%s, filename=%s&quot;,
                       e.key, getFilenameForKey(e.key));
            }
            iterator.remove();
            prunedFiles++;

            /**
             * 一直清除缓存
             * 直到存入这个neededSapce之后还有一小部分空余的地方
             */
            if ((mTotalSize + neededSpace) &lt; mMaxCacheSizeInBytes * HYSTERESIS_FACTOR) {
                break;
            }
        }

        if (VolleyLog.DEBUG) {
            VolleyLog.v(&quot;pruned %d files, %d bytes, %d ms&quot;,
                    prunedFiles, (mTotalSize - before), SystemClock.elapsedRealtime() - startTime);
        }
    }

    /**
     * Puts the entry with the specified key into the cache.
     * 将目录下指定的缓存加载到mEntries中去
     * 为了方便之后对缓存的读写操作
     * 全部读写一遍放在内存里面，对查询什么的都会方便很多
     *
     * @param key The key to identify the entry by.
     * @param entry The entry to cache.
     */
    private void putEntry(String key, CacheHeader entry) {
        if (!mEntries.containsKey(key)) {
            mTotalSize += entry.size;
        } else {
            CacheHeader oldEntry = mEntries.get(key);
            mTotalSize += (entry.size - oldEntry.size);
        }
        mEntries.put(key, entry);
    }

    /**
     * Removes the entry identified by &apos;key&apos; from the cache.
     */
    private void removeEntry(String key) {
        CacheHeader entry = mEntries.get(key);
        if (entry != null) {
            mTotalSize -= entry.size;
            mEntries.remove(key);
        }
    }

    /**
     * Reads the contents of an InputStream into a byte[].
     * 从InputStream中读取指定长度的数据
     * 
     */
    private static byte[] streamToBytes(InputStream in, int length) throws IOException {
        byte[] bytes = new byte[length];
        int count;
        int pos = 0;
        while (pos &lt; length &amp;&amp; ((count = in.read(bytes, pos, length - pos)) != -1)) {
            pos += count;
        }
        if (pos != length) {
            throw new IOException(&quot;Expected &quot; + length + &quot; bytes, read &quot; + pos + &quot; bytes&quot;);
        }
        return bytes;
    }

    /**
     * Handles holding onto the cache headers for an entry.
     */
    // Visible for testing.
    static class CacheHeader {
        /** 
         * The size of the data identified by this CacheHeader. (This is not
         * serialized to disk.
         * 
         * CacheHeader所表示的数据段的大小 
         */
        public long size;

        /** 
         * The key that identifies the cache entry. 
         * 这个key应该是request对应其缓存的唯一key
         */
        public String key;

        /** 
         * ETag for cache coherence.
         *
         */
        public String etag;

        /** 
         * Date of this response as reported by the server. 
         * 缓存起来的数据返回的日期
         */
        public long serverDate;

        /** 
         * The last modified date for the requested object. 
         * 最后一次更改的时间
         */
        public long lastModified;

        /** 
         * TTL for this record. 
         * ping时候返回的TTL=128的概念如下
         * TTL：生存时间
         * 指定数据报被路由器丢弃之前允许通过的网段数量。
         * TTL 是由发送主机设置的，以防止数据包不断在 IP 互联网络上永不终止地循环。转发 IP 数据包时，要求路由器至少将 TTL 减小 1。
         *  
         * 但是= =，注意这里的和上面的那种不是一个概念，这里只是模拟了上面的概念，但也是用来标志缓存存活时间的。
         */
        public long ttl;

        /** 
         * Soft TTL for this record. 
         * 
         * 根据refreshNeeded()函数来看
         * 意思是需要更新缓存的时间点
         */
        public long softTtl;

        /** 
         * Headers from the response resulting in this cache entry. 
         * 用来指向上一次response的header
         */
        public Map&lt;String, String&gt; responseHeaders;

        private CacheHeader() { }

        /**
         * Instantiates a new CacheHeader object
         * @param key The key that identifies the cache entry
         * @param entry The cache entry.
         */
        public CacheHeader(String key, Entry entry) {
            this.key = key;
            this.size = entry.data.length;
            this.etag = entry.etag;
            this.serverDate = entry.serverDate;
            this.lastModified = entry.lastModified;
            this.ttl = entry.ttl;
            this.softTtl = entry.softTtl;
            this.responseHeaders = entry.responseHeaders;
        }

        /**
         * Reads the header off of an InputStream and returns a CacheHeader object.
         * 从InputStream中读取数据并组建一个CacheHeader对象实例
         * @param is The InputStream to read from.
         * @throws IOException
         */
        public static CacheHeader readHeader(InputStream is) throws IOException {
            CacheHeader entry = new CacheHeader();
            int magic = readInt(is);
            if (magic != CACHE_MAGIC) {
                // don&apos;t bother deleting, it&apos;ll get pruned eventually
                throw new IOException();
            }
            entry.key = readString(is);
            entry.etag = readString(is);
            if (entry.etag.equals(&quot;&quot;)) {
                entry.etag = null;
            }
            entry.serverDate = readLong(is);
            entry.lastModified = readLong(is);
            entry.ttl = readLong(is);
            entry.softTtl = readLong(is);
            entry.responseHeaders = readStringStringMap(is);

            return entry;
        }

        /**
         * Creates a cache entry for the specified data.
         * 从CacheHeader转换成Entry类的实例
         */
        public Entry toCacheEntry(byte[] data) {
            Entry e = new Entry();
            e.data = data;
            e.etag = etag;
            e.serverDate = serverDate;
            e.lastModified = lastModified;
            e.ttl = ttl;
            e.softTtl = softTtl;
            e.responseHeaders = responseHeaders;
            return e;
        }


        /**
         * Writes the contents of this CacheHeader to the specified OutputStream.
         * 将CacheHeader里面的数据写入指定的OutputStream中
         */
        public boolean writeHeader(OutputStream os) {
            try {
                writeInt(os, CACHE_MAGIC);
                writeString(os, key);
                writeString(os, etag == null ? &quot;&quot; : etag);
                writeLong(os, serverDate);
                writeLong(os, lastModified);
                writeLong(os, ttl);
                writeLong(os, softTtl);
                writeStringStringMap(responseHeaders, os);
                os.flush();
                return true;
            } catch (IOException e) {
                VolleyLog.d(&quot;%s&quot;, e.toString());
                return false;
            }
        }

    }

    /**
     * 继承了FilterInputStream
     * 没啥特别的= =
     */

    private static class CountingInputStream extends FilterInputStream {

        private int bytesRead = 0;

        private CountingInputStream(InputStream in) {
            super(in);
        }

        @Override
        public int read() throws IOException {
            int result = super.read();
            if (result != -1) {
                bytesRead++;
            }
            return result;
        }

        @Override
        public int read(byte[] buffer, int offset, int count) throws IOException {
            int result = super.read(buffer, offset, count);
            if (result != -1) {
                bytesRead += result;
            }
            return result;
        }
    }

    /*
     * Homebrewed simple serialization system used for reading and writing cache
     * headers on disk. Once upon a time, this used the standard Java
     * Object{Input,Output}Stream, but the default implementation relies heavily
     * on reflection (even for standard types) and generates a ton of garbage.
     * 
     */

    /**
     * Simple wrapper around {@link InputStream#read()} that throws EOFException
     * instead of returning -1.
     * 如果文件读到了末尾直接抛出异常
     */
    private static int read(InputStream is) throws IOException {
        int b = is.read();
        if (b == -1) {
            throw new EOFException();
        }
        return b;
    }

    /**
     * 刚开始看到这里的时候没有明白是什么意思= =
     * 就不明白了，好好的一个int类型的数据
     * 为什么非要分段写入呢，一个字节一个字节的写入
     * 后来查了资料才发现，OutputStream及其子类的write()方法
     * 一次都只能写入一个byte，int类型有4个byte，分四次写入没什么问题咯
     */

    static void writeInt(OutputStream os, int n) throws IOException {
        os.write((n &gt;&gt; 0) &amp; 0xff);
        os.write((n &gt;&gt; 8) &amp; 0xff);
        os.write((n &gt;&gt; 16) &amp; 0xff);
        os.write((n &gt;&gt; 24) &amp; 0xff);
    }

    static int readInt(InputStream is) throws IOException {
        int n = 0;
        n |= (read(is) &lt;&lt; 0);
        n |= (read(is) &lt;&lt; 8);
        n |= (read(is) &lt;&lt; 16);
        n |= (read(is) &lt;&lt; 24);
        return n;
    }

    static void writeLong(OutputStream os, long n) throws IOException {
        os.write((byte)(n &gt;&gt;&gt; 0));
        os.write((byte)(n &gt;&gt;&gt; 8));
        os.write((byte)(n &gt;&gt;&gt; 16));
        os.write((byte)(n &gt;&gt;&gt; 24));
        os.write((byte)(n &gt;&gt;&gt; 32));
        os.write((byte)(n &gt;&gt;&gt; 40));
        os.write((byte)(n &gt;&gt;&gt; 48));
        os.write((byte)(n &gt;&gt;&gt; 56));
    }

    static long readLong(InputStream is) throws IOException {
        long n = 0;
        n |= ((read(is) &amp; 0xFFL) &lt;&lt; 0);
        n |= ((read(is) &amp; 0xFFL) &lt;&lt; 8);
        n |= ((read(is) &amp; 0xFFL) &lt;&lt; 16);
        n |= ((read(is) &amp; 0xFFL) &lt;&lt; 24);
        n |= ((read(is) &amp; 0xFFL) &lt;&lt; 32);
        n |= ((read(is) &amp; 0xFFL) &lt;&lt; 40);
        n |= ((read(is) &amp; 0xFFL) &lt;&lt; 48);
        n |= ((read(is) &amp; 0xFFL) &lt;&lt; 56);
        return n;
    }

    static void writeString(OutputStream os, String s) throws IOException {
        byte[] b = s.getBytes(&quot;UTF-8&quot;);
        writeLong(os, b.length);
        os.write(b, 0, b.length);
    }

    static String readString(InputStream is) throws IOException {
        int n = (int) readLong(is);
        byte[] b = streamToBytes(is, n);
        return new String(b, &quot;UTF-8&quot;);
    }

    static void writeStringStringMap(Map&lt;String, String&gt; map, OutputStream os) throws IOException {
        if (map != null) {
            writeInt(os, map.size());
            for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) {
                writeString(os, entry.getKey());
                writeString(os, entry.getValue());
            }
        } else {
            writeInt(os, 0);
        }
    }

    /**
     * 从InputStream中读取key类型为String，值类型也为String的Map
     */ 
    static Map&lt;String, String&gt; readStringStringMap(InputStream is) throws IOException {
        int size = readInt(is);
        Map&lt;String, String&gt; result = (size == 0)
                ? Collections.&lt;String, String&gt;emptyMap()
                : new HashMap&lt;String, String&gt;(size);
        for (int i = 0; i &lt; size; i++) {

            //将读出来的byte[]转换成String

            String key = readString(is).intern();
            String value = readString(is).intern();
            result.put(key, value);
        }
        return result;
    }
}
</code></pre><p>&#160;&#160;&#160;&#160;涉及到缓存读写的这个实现类当时阅读的时候还是花了不少时间的= =，人太笨了没办法orz，有什么不妥的地方还望各位juju多多指教，小达感激不尽0.0。下面还有Request.java等类等着去解析呢，Volley中的主角要登场了╭(╯^╰)╮。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/01/16/Volley框架解析-六-Cache接口及其默认实现类解析/" data-id="cijh2hrjt00067nut26zpqmet" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Volley/">Volley</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Volley框架解析-五-HttpStack接口及其默认实现类解析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/01/16/Volley框架解析-五-HttpStack接口及其默认实现类解析/" class="article-date">
  <time datetime="2016-01-16T10:10:29.000Z" itemprop="datePublished">2016-01-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/16/Volley框架解析-五-HttpStack接口及其默认实现类解析/">Volley框架解析(五)-----HttpStack接口及其默认实现类解析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1-__u524D_u8A00_28_u53EF_u76F4_u63A5_u65E0_u89C6_u8DF3_u8FC7_3D__3D"><a href="#1-__u524D_u8A00_28_u53EF_u76F4_u63A5_u65E0_u89C6_u8DF3_u8FC7_3D__3D" class="headerlink" title="1. 前言(可直接无视跳过= ="></a>1. 前言(可直接无视跳过= =</h3><p>&#160;&#160;&#160;&#160;历经前面的四篇，终于涉及到网络请求核心的内容了，前面都在做一些准备工作，以及对request队列调度以及维护工作。之前一直说，<code>httpResponse = mHttpStack.performRequest(request, headers);</code>这句话是网络请求的核心，因为这句话一出来，神不知鬼不觉的request就被发出去了，并且还带回来一个HttpResponse的实例= =，有没有感觉被忽悠了，今天就深入进去一探究竟0.0。</p>
<h3 id="2-_HttpStack-java"><a href="#2-_HttpStack-java" class="headerlink" title="2. HttpStack.java"></a>2. HttpStack.java</h3><p>&#160;&#160;&#160;&#160;接口类，里面包含了一个方法，<code>performRequest()</code>。</p>
<pre><code>/**
 * An HTTP stack abstraction.
 */
public interface HttpStack {
    /**
     * Performs an HTTP request with the given parameters.
     * 用传入给定的参数来模拟Http请求
     * 
     * A GET request is sent if request.getPostBody() == null. A POST request is sent otherwise,
     * and the Content-Type header is set to request.getPostBodyContentType().
     * 如果传入的request.getPostBody()为空，则发送一个Get类型的请求，否则发送一个Post类型请求
     * 
     * @param request the request to perform
     * 即将发送的初始请求，也是volley自己写的= =，进去看看
     * (还需要添加上额外的header
     * 
     * @param additionalHeaders additional headers to be sent together with
     *         {@link Request#getHeaders()}
     * 需要添加到该request上的header的信息
     *
     * @return the HTTP response
     *
     */
    public HttpResponse performRequest(Request&lt;?&gt; request, Map&lt;String, String&gt; additionalHeaders)
        throws IOException, AuthFailureError;

}
</code></pre><h3 id="3-_HttpClientStack-java"><a href="#3-_HttpClientStack-java" class="headerlink" title="3. HttpClientStack.java"></a>3. HttpClientStack.java</h3><p>&#160;&#160;&#160;&#160;当sdk版本小于2.3时，Volley会选择用HttpClient来实现请求的发送。</p>
<pre><code>/**
 * An HttpStack that performs request over an {@link HttpClient}.
 * 在sdk小于2.3的时候
 * 选用HttpClient来实现网络请求
 */
public class HttpClientStack implements HttpStack {

    /**
     * 官方文档
     * Interface for an HTTP client. 
     * HTTP clients encapsulate a smorgasbord of objects required to execute HTTP requests while handling cookies, 
     * authentication, connection management, and other features. 
     * HTTP Clients将发送http请求需要需要做出的信息
     * Thread safety of HTTP clients depends on the implementation and configuration of the specific client. 
     * 
     */
    protected final HttpClient mClient;

    //Http请求头里面的固定格式
    private final static String HEADER_CONTENT_TYPE = &quot;Content-Type&quot;;

    public HttpClientStack(HttpClient client) {
        mClient = client;
    }

    //在组合出一个请求的过程中，向请求体中添加Header的方法，Header是以键值对的形式存在的
    private static void addHeaders(HttpUriRequest httpRequest, Map&lt;String, String&gt; headers) {
        for (String key : headers.keySet()) {
            httpRequest.setHeader(key, headers.get(key));
        }
    }

    /**
     * NameValuePair 官方文档
     * A simple class encapsulating an attribute/value pair. 
     * 
     * 该函数将传入的Map里面存放的值进一步转化成由NameValuePair子类组成的数组中
     */
    @SuppressWarnings(&quot;unused&quot;)
    private static List&lt;NameValuePair&gt; getPostParameterPairs(Map&lt;String, String&gt; postParams) {
        List&lt;NameValuePair&gt; result = new ArrayList&lt;NameValuePair&gt;(postParams.size());
        for (String key : postParams.keySet()) {
            result.add(new BasicNameValuePair(key, postParams.get(key)));
        }
        return result;
    }


     //该函数也就是实现HttpStack接口需要实现的方法，用来执行Request的方法
    @Override
    public HttpResponse performRequest(Request&lt;?&gt; request, Map&lt;String, String&gt; additionalHeaders)
            throws IOException, AuthFailureError {

        /**
         * 传入请求体和额外需要添加入的头部
         * 生成并返回一个HttpUriRequest
         */
        HttpUriRequest httpRequest = createHttpRequest(request, additionalHeaders);

        /**
         * 这个方法在前面实现了，将这些传入的键值对全部添加到httpRequest里面去
         */
        addHeaders(httpRequest, additionalHeaders);
        addHeaders(httpRequest, request.getHeaders());

        /**
         * 一个protected方法，留给子类可以实现的方法(本类中并没有什么东西)，在这里会调用。
         */
        onPrepareRequest(httpRequest);

        /**
         * HttpParams 官方文档
         * Represents a collection of HTTP protocol and framework parameters. 
         * 说白了就是Http协议和框架的相关参数
         */
        HttpParams httpParams = httpRequest.getParams();
        int timeoutMs = request.getTimeoutMs();

        /**
         * HttpConnectionParams 官方文档
         * An adaptor for accessing connection parameters in HttpParams. 
         * 一个用来访问请求参数的适配器
         * Note that the implements relation to CoreConnectionPNames is for compatibility with existing application code only. 
         * References to the parameter names should use the interface, not this class. 
         */

        /* Sets the timeout until a connection is established.
         * 该方法用来设置时间限制，
         * A value of zero means the timeout is not used. The default value is zero. 
         * 如果timeout设置为0则表示该限时没有启用，默认为0
         */
        HttpConnectionParams.setConnectionTimeout(httpParams, 5000);

        /**
         * Sets the default socket timeout (SO_TIMEOUT) in milliseconds which is the timeout for waiting for data. 
         * 设置请求发出后等待网络响应并返回数据的限时
         * A timeout value of zero is interpreted as an infinite timeout. 
         * 如果timeout值为0则意味着无限等待，没有等待限时，同时也是默认的值
         * This value is used when no socket timeout is set in the method parameters. 
         */
        HttpConnectionParams.setSoTimeout(httpParams, timeoutMs);

        /**
         * 执行了HttpClient类中的execute方法
         * 方法描述为 Executes a request using the default context.
         * 方法结束后将返回一个HttpResponse，也就是请求的结果类
         */ 
        return mClient.execute(httpRequest);
    }

    /**
     * Creates the appropriate subclass of HttpUriRequest for passed in request.
     * 根据传入的Request种类不同
     * 创建不同的HttpUriRequest子类(也就是下面的HttpGet等等)
     * 下面做的工作和HurlStack.java里面做的工作差不多
     * 设置header,以及是否需要传入请求携带的参数
     * 只是本类中用HttpClient实现，后者用的是HttpURLConnection实现的
     */
    @SuppressWarnings(&quot;deprecation&quot;)
    /* protected */ static HttpUriRequest createHttpRequest(Request&lt;?&gt; request,
            Map&lt;String, String&gt; additionalHeaders) throws AuthFailureError {
        switch (request.getMethod()) {
            case Method.DEPRECATED_GET_OR_POST: {
                // This is the deprecated way that needs to be handled for backwards compatibility.
                // If the request&apos;s post body is null, then the assumption is that the request is
                // GET.  Otherwise, it is assumed that the request is a POST.
                byte[] postBody = request.getPostBody();
                if (postBody != null) {
                    HttpPost postRequest = new HttpPost(request.getUrl());
                    postRequest.addHeader(HEADER_CONTENT_TYPE, request.getPostBodyContentType());
                    HttpEntity entity;
                    entity = new ByteArrayEntity(postBody);
                    postRequest.setEntity(entity);
                    return postRequest;
                } else {
                    return new HttpGet(request.getUrl());
                }
            }
            case Method.GET:
                return new HttpGet(request.getUrl());
            case Method.DELETE:
                return new HttpDelete(request.getUrl());
            case Method.POST: {
                HttpPost postRequest = new HttpPost(request.getUrl());
                postRequest.addHeader(HEADER_CONTENT_TYPE, request.getBodyContentType());
                setEntityIfNonEmptyBody(postRequest, request);
                return postRequest;
            }
            case Method.PUT: {
                HttpPut putRequest = new HttpPut(request.getUrl());
                putRequest.addHeader(HEADER_CONTENT_TYPE, request.getBodyContentType());
                setEntityIfNonEmptyBody(putRequest, request);
                return putRequest;
            }
            case Method.HEAD:
                return new HttpHead(request.getUrl());
            case Method.OPTIONS:
                return new HttpOptions(request.getUrl());
            case Method.TRACE:
                return new HttpTrace(request.getUrl());
            case Method.PATCH: {
                HttpPatch patchRequest = new HttpPatch(request.getUrl());
                patchRequest.addHeader(HEADER_CONTENT_TYPE, request.getBodyContentType());
                setEntityIfNonEmptyBody(patchRequest, request);
                return patchRequest;
            }
            default:
                throw new IllegalStateException(&quot;Unknown request method.&quot;);
        }
    }

    private static void setEntityIfNonEmptyBody(HttpEntityEnclosingRequestBase httpRequest,
            Request&lt;?&gt; request) throws AuthFailureError {
        byte[] body = request.getBody();
        if (body != null) {
            HttpEntity entity = new ByteArrayEntity(body);
            httpRequest.setEntity(entity);
        }
    }

    /**
     * Called before the request is executed using the underlying HttpClient.
     *
     * &lt;p&gt;Overwrite in subclasses to augment the request.&lt;/p&gt;
     */
    protected void onPrepareRequest(HttpUriRequest request) throws IOException {
        // Nothing.
    }

    /**
     * The HttpPatch class does not exist in the Android framework, so this has been defined here.
     * = =在HttpUriClient的子类中没有支持Patch的请求方法
     * 在这里volley实现了= =
     */
    public static final class HttpPatch extends HttpEntityEnclosingRequestBase {

        public final static String METHOD_NAME = &quot;PATCH&quot;;

        public HttpPatch() {
            super();
        }

        public HttpPatch(final URI uri) {
            super();
            setURI(uri);
        }

        /**
         * @throws IllegalArgumentException if the uri is invalid.
         */
        public HttpPatch(final String uri) {
            super();
            setURI(URI.create(uri));
        }

        @Override
        public String getMethod() {
            return METHOD_NAME;
        }

    }
}
</code></pre><h3 id="4-HurlStack-java"><a href="#4-HurlStack-java" class="headerlink" title="4.HurlStack.java"></a>4.HurlStack.java</h3><p>&#160;&#160;&#160;&#160;在sdk大于2.3的android手机上，Volley选择用HttpURLConnection来实现网络请求。</p>
<pre><code>/**
 * An {@link HttpStack} based on {@link HttpURLConnection}.
 */

/**
 * 当os version 版本在2.3以上，也就是sdk &gt;= 9 的时候
 * 选用这个接口作为HttpStack， 用到了HttpURLConnection
 * 关于HttpURLConnection,官方解释为：
 * An URLConnection for HTTP (RFC 2616) used to send and receive data over the web.
 * Data may be of any type and length. 
 * This class may be used to send and receive streaming data whose length is not known in advance.
 * 用来发送和接受数据，数据可以为任意的形式及长度
 * 这个类常用来发送和接受数据流里面长度不定的数据.
 */
public class HurlStack implements HttpStack {

    /*
     * 请求header中的一个关键字
     * content-type代表着被发送的请求中主体内容
     * 可以设置application/json等格式
     */
    private static final String HEADER_CONTENT_TYPE = &quot;Content-Type&quot;;

    /**
     * An interface for transforming URLs before use.
     * 一个用来在使用url之前，将url处理的接口工具
     * 可能是用来规范url格式的一个工具= =
     */ 
    public interface UrlRewriter {
        /**
         * Returns a URL to use instead of the provided one, or null to indicate
         * this URL should not be used at all.
         */
        public String rewriteUrl(String originalUrl);
    }

    private final UrlRewriter mUrlRewriter;

    /**
     * The abstract factory implementation to create SSLSockets.
     * 是一个抽象工厂类，用来创建SSLSockets（还是不懂是个什么鬼
     * 
     * 对于SSLSocket，官方的解释是这样的：
     * The extension of Socket providing secure protocols like SSL (Secure Sockets Layer) or TLS (Transport Layer Security).
     * 是Socket的子类，并在之基础上新增了类似于SSL或者TLS等等的安全协议.
     */
    private final SSLSocketFactory mSslSocketFactory;

    public HurlStack() {
        this(null);
    }

    /**
     * @param urlRewriter Rewriter to use for request URLs
     */
    public HurlStack(UrlRewriter urlRewriter) {
        this(urlRewriter, null);
    }

    /**
     * @param urlRewriter Rewriter to use for request URLs
     * @param sslSocketFactory SSL factory to use for HTTPS connections
     */
    public HurlStack(UrlRewriter urlRewriter, SSLSocketFactory sslSocketFactory) {
        mUrlRewriter = urlRewriter;
        mSslSocketFactory = sslSocketFactory;
    }


    /**
     * 该函数为HttpStack的接口
     */
    @Override
    public HttpResponse performRequest(Request&lt;?&gt; request, Map&lt;String, String&gt; additionalHeaders)
            throws IOException, AuthFailureError {
        /**
         * 得到请求的url
         */
        String url = request.getUrl();

        /**
         * 创建一个新的HashMap
         * 用来存放请求的header的信息
         */
        HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();

        /**
         * 将原request(volley自己封装的一个request类)中的header
         * 和另外需要添加入header的信息都整合起来
         */
        map.putAll(request.getHeaders());
        map.putAll(additionalHeaders);


        if (mUrlRewriter != null) {
            String rewritten = mUrlRewriter.rewriteUrl(url);
            if (rewritten == null) {
                throw new IOException(&quot;URL blocked by rewriter: &quot; + url);
            }
            url = rewritten;
        }

        /**
         * 将url字符串形式规范成一个URL的类对象
         */
        URL parsedUrl = new URL(url);

        /**
         * HurlStack类是在sdk&gt;=2.3的android版本上使用的
         * 这里面用到了HttpURLConnection类
         * 在函数里面打开了并返回了一个HttpURLConnection
         * 设置了HttpURLConnection的响应超时阀值
         */
        HttpURLConnection connection = openConnection(parsedUrl, request);

        /**
         * 开始给HttpURLConnection添加header的信息
         * 用addRequestProperty()函数将header以键值对的形式填入
         */
        for (String headerName : map.keySet()) {
            connection.addRequestProperty(headerName, map.get(headerName));
        }

        /**
         * 根据request种类的不同
         * 分别用不同的方式来处理其中的参数
         */
        setConnectionParametersForRequest(connection, request);

        // Initialize HttpResponse with data from the HttpURLConnection.
        ProtocolVersion protocolVersion = new ProtocolVersion(&quot;HTTP&quot;, 1, 1);

        int responseCode = connection.getResponseCode();
        if (responseCode == -1) {
            // -1 is returned by getResponseCode() if the response code could not be retrieved.
            // Signal to the caller that something was wrong with the connection.
            throw new IOException(&quot;Could not retrieve response code from HttpUrlConnection.&quot;);
        }
        StatusLine responseStatus = new BasicStatusLine(protocolVersion,
                connection.getResponseCode(), connection.getResponseMessage());

        BasicHttpResponse response = new BasicHttpResponse(responseStatus);

        response.setEntity(entityFromConnection(connection));

        for (Entry&lt;String, List&lt;String&gt;&gt; header : connection.getHeaderFields().entrySet()) {
            if (header.getKey() != null) {
                Header h = new BasicHeader(header.getKey(), header.getValue().get(0));
                response.addHeader(h);
            }
        }
        return response;
    }

    /**
     * Initializes an {@link HttpEntity} from the given {@link HttpURLConnection}.
     * @param connection
     * @return an HttpEntity populated with data from &lt;code&gt;connection&lt;/code&gt;.
     */
    private static HttpEntity entityFromConnection(HttpURLConnection connection) {
        BasicHttpEntity entity = new BasicHttpEntity();
        InputStream inputStream;
        try {
            inputStream = connection.getInputStream();
        } catch (IOException ioe) {
            inputStream = connection.getErrorStream();
        }
        entity.setContent(inputStream);
        entity.setContentLength(connection.getContentLength());
        entity.setContentEncoding(connection.getContentEncoding());
        entity.setContentType(connection.getContentType());
        return entity;
    }

    /**
     * Create an {@link HttpURLConnection} for the specified {@code url}.
     */
    protected HttpURLConnection createConnection(URL url) throws IOException {

        return (HttpURLConnection) url.openConnection();
    }

    /**
     * Opens an {@link HttpURLConnection} with parameters.
     * 通过给的url和参数，打开一个HttpURLConnection
     * @param url
     * @return an open connection
     * @throws IOException
     */
    private HttpURLConnection openConnection(URL url, Request&lt;?&gt; request) throws IOException {

        HttpURLConnection connection = createConnection(url);

        /**
         * 通过Request.java中的函数
         * 获取到该request上所设置的服务器最大响应时间阀值
         * 该阀值默认是2500ms，而且可能会随着retry的次数而增大
         */
        int timeoutMs = request.getTimeoutMs();

        /**
         * 给connection设置上请求超时时间
         */
        connection.setConnectTimeout(timeoutMs);
        connection.setReadTimeout(timeoutMs);
        connection.setUseCaches(false);
        connection.setDoInput(true);

        /**
         * use caller-provided custom SslSocketFactory, if any, for HTTPS
         * 请求方面的安全问题，暂时还不清清楚
         */
        if (&quot;https&quot;.equals(url.getProtocol()) &amp;&amp; mSslSocketFactory != null) {
            ((HttpsURLConnection)connection).setSSLSocketFactory(mSslSocketFactory);
        }

        return connection;
    }

    @SuppressWarnings(&quot;deprecation&quot;)
    /* package */
    /**
     * switch不同的请求方法
     * 来以不同的方式给HttpURLConnection添加请求参数
     */ 
    static void setConnectionParametersForRequest(HttpURLConnection connection,
            Request&lt;?&gt; request) throws IOException, AuthFailureError {
        switch (request.getMethod()) {

            /**
             * 在构造Request的时候如果没有指明请求方式
             * DEPRECATED_GET_OR_POST为其默认值
             * 通过postBody是否为Null来区别POST和GET
             * 这两种最常用的请求方式
             */
            case Method.DEPRECATED_GET_OR_POST:
                // This is the deprecated way that needs to be handled for backwards compatibility.
                // If the request&apos;s post body is null, then the assumption is that the request is
                // GET.  Otherwise, it is assumed that the request is a POST.
                /**
                 * 不要用这个参数了= =，因为不能处理什么DELETE之类的
                 * 该方法已经过时了。
                 */
                byte[] postBody = request.getPostBody();
                if (postBody != null) {
                    // Prepare output. There is no need to set Content-Length explicitly,
                    // since this is handled by HttpURLConnection using the size of the prepared
                    // output stream.

                    /**
                     * 设置是否输出
                     */
                    connection.setDoOutput(true);

                    /**
                     * 给connection设置请求的方式
                     */
                    connection.setRequestMethod(&quot;POST&quot;);

                    /**
                     * 设置http请求头中的content-type参数
                     */
                    connection.addRequestProperty(HEADER_CONTENT_TYPE,
                            request.getPostBodyContentType());
                    DataOutputStream out = new DataOutputStream(connection.getOutputStream());
                    out.write(0);
                    out.close();
                }
                break;
            case Method.GET:
                // Not necessary to set the request method because connection defaults to GET but
                // being explicit here.
                connection.setRequestMethod(&quot;GET&quot;);
                break;
            case Method.DELETE:
                connection.setRequestMethod(&quot;DELETE&quot;);
                break;
            case Method.POST:
                connection.setRequestMethod(&quot;POST&quot;);
                addBodyIfExists(connection, request);
                break;
            case Method.PUT:
                connection.setRequestMethod(&quot;PUT&quot;);
                addBodyIfExists(connection, request);
                break;
            case Method.HEAD:
                connection.setRequestMethod(&quot;HEAD&quot;);
                break;
            case Method.OPTIONS:
                connection.setRequestMethod(&quot;OPTIONS&quot;);
                break;
            case Method.TRACE:
                connection.setRequestMethod(&quot;TRACE&quot;);
                break;
            case Method.PATCH:
                connection.setRequestMethod(&quot;PATCH&quot;);
                addBodyIfExists(connection, request);
                break;
            default:
                throw new IllegalStateException(&quot;Unknown method type.&quot;);
        }
    }

    /**
     * 如果存在请求参数的话
     * 获取到connection的输出流对象
     * 并创建一个DataOutputStream对象
     * 用于向服务器写入需要传递的参数
     */
    private static void addBodyIfExists(HttpURLConnection connection, Request&lt;?&gt; request)
            throws IOException, AuthFailureError {
        byte[] body = request.getBody();
        if (body != null) {
            connection.setDoOutput(true);
            connection.addRequestProperty(HEADER_CONTENT_TYPE, request.getBodyContentType());
            DataOutputStream out = new DataOutputStream(connection.getOutputStream());
            out.write(body);
            out.close();
        }
    }
}
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/01/16/Volley框架解析-五-HttpStack接口及其默认实现类解析/" data-id="cijh2hrjv00087nutnqh52v1y" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Volley/">Volley</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Volley框架解析-四-Network接口及其默认实现类解析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/01/16/Volley框架解析-四-Network接口及其默认实现类解析/" class="article-date">
  <time datetime="2016-01-16T10:10:22.000Z" itemprop="datePublished">2016-01-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/16/Volley框架解析-四-Network接口及其默认实现类解析/">Volley框架解析(四)-----Network接口及其默认实现类解析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>###1. 前言(可直接无视跳过<br>&#160;&#160;&#160;&#160;前面的三篇Volley框架解析文章已经从Volley对外暴露的接口Volley.java开始，向下慢慢深入到了RequestQueue.java，这个Volley中比较核心的类，然后又分析了Volley中负责主要request调度工作的两类Dispatcher，<code>NetworkDispatcher</code>以及<code>CacheDispatcher</code>。应该是将一个request从新建，到加入队列中等待处理，如何被处理以及返回结果或者error这一系列的流程理顺了。</p>
<p>&#160;&#160;&#160;&#160;但是对于一些细节的问题还是不清楚，例如request究竟是如何发送出去，通过<code>NetworkResponse networkResponse = mNetwork.performRequest(request);</code>这么一句话就返回了结果(response)，这里面发生了些什么还不得而知，还有<code>Network#performRequest()</code>和<code>HttpStack#performRequest()</code>这两个函数之间有什么区别和联系等等。</p>
<p>###2. Network.java<br>&#160;&#160;&#160;&#160;最早接触到Network这个类是在<code>Volley.java</code>中的<code>newRequestQueue()</code>函数里面，<code>Network network = new BasicNetwork(stack);</code>创建了一个Network接口引用，并指向了一个Volley中的默认实现类的实例<code>BasicNetwork.java</code>，这个默认实现类也会在这篇博客的后面详细的解析。</p>
<p>&#160;&#160;&#160;&#160;经过前面几篇博客的分析，<code>Volley.java</code>仅仅是持有而没有使用，仅将这个引用传递给了<code>NetworkDispatcher.java</code>中，只有在<code>NetworkDispatcher.java</code>类中用到了这个Network接口，在<code>NetowkrDispatcher.java</code>中存在着这么一行代码，</p>
<pre><code>NetworkResponse networkResponse = mNetwork.performRequest(request);
</code></pre><p>&#160;&#160;&#160;&#160;仅仅用了一句话就将request发送出去了，并且还拿回来了一个<code>NetworkResponse.java</code>类对象。里面发生了什么= =，先进去Network.java里面看看：</p>
<pre><code>package com.android.volley;

/**
 * An interface for performing requests.
 */
public interface Network {
    /**
     * Performs the specified request.
     * 用来发送特定的请求
     *
     * @param request Request to process
     * 即将被发送的request
     *
     * @return A {@link NetworkResponse} with data and caching metadata; will never be null
     * 请求之后返回的response, 是volley自己构造出来的一个response
     * 里面包含了返回的请求码等等。
     *
     * @throws VolleyError on errors
     */
    public NetworkResponse performRequest(Request&lt;?&gt; request) throws VolleyError;
}
</code></pre><p>&#160;&#160;&#160;&#160;对，没有看错= =，就这么点东西，仅仅一个抽象方法而已，Network.java就是一个等待被实现的接口，想看真东西，还需要进去<code>Network network = new BasicNetwork(stack);</code>里面所提到的<code>BasicNetwork.java</code>看看。</p>
<p>###3. BasicNetwork.java<br>&#160;&#160;&#160;&#160;<code>Network.java</code>接口的默认实现类，该类里面会处理一些request发送前后的处理工作，主要是对请求返回的httpResponse处理，以及对请求失败进行retry或者抛出异常的处理。</p>
<pre><code>package com.android.volley.toolbox;

/**
 * A network performing Volley requests over an {@link HttpStack}.
 * 一个用来执行Volley中request的类
 * 在HttpStack的基础之上
 * 因为主要还是调用HttpStack接口的performRequest
 * 在这个里面的performRequest主要还是做一些整理工作
 * 比如将｛@link HttpStack#performRequest()｝方法返回的HttpResponse
 * 解析成Volley自己实现的NetworkResponse.java
 */

public class BasicNetwork implements Network {

    //是否允许打lo的boolean常变量
    protected static final boolean DEBUG = VolleyLog.DEBUG;

    /**
     * 这是一个阀值，用来判断一个request是否请求响应过慢了= =
     * 在后面的作用就是，如果响应时间超过了这个阀值
     * 打出log说明这个request有些慢，为了更好的反应request当前状态
     */
    private static int SLOW_REQUEST_THRESHOLD_MS = 3000;

    /**
     * 默认ByteArrayPool的大小
     * 现在只需要知道ByteArrayPool.java是Volley用来从输入流中读取数据并将其转换成字节数组的工具即可
     * 在这篇博客后面会介绍，表担心~= =
     */
    private static int DEFAULT_POOL_SIZE = 4096;

    /**
     * 网络请求的真正接口
     * 为什么这么说咧，BasicNetwork里面的performRequest()函数
     * 调用了HttpStack里的performRequest()，真正的网络请求还是通过HttpStack里面的方法实现的
     * 在Volley中实现了HttpStack接口的类有两个 HurlStack.java和HttpClientStack.java
     * 针对了不同Android系统版本，用不同的方法实现了请求。
     */
    protected final HttpStack mHttpStack;

    //表急，后面会介绍到的，现在知道是一个用于数据转换的工具类就好了
    protected final ByteArrayPool mPool;

    /**
     * @param httpStack HTTP stack to be used
     * 传入的HttpStack实现类引用
     * 整个网络请求的较核心部分就在HttpStack实现类上面咯
     */
    public BasicNetwork(HttpStack httpStack) {
        // If a pool isn&apos;t passed in, then build a small default pool that will give us a lot of
        // benefit and not use too much memory.
        this(httpStack, new ByteArrayPool(DEFAULT_POOL_SIZE));
    }

    /**
     * @param httpStack HTTP stack to be used
     * @param pool a buffer pool that improves GC performance in copy operations
     * Volley接口分离的很明显，而且在构造函数里面也提供了很多种
     * 可以定制出适合自己的ByteArrayPool衍生类
     * 当然也可以自己来实现HttpStack的衍生类
     */
    public BasicNetwork(HttpStack httpStack, ByteArrayPool pool) {
        mHttpStack = httpStack;
        mPool = pool;
    }

    /**
     * 这个方法重写的是Network的方法
     * 在这个里面再调用HttpStack里面的performRequest方法
     */
    @Override
    public NetworkResponse performRequest(Request&lt;?&gt; request) throws VolleyError {

        /**
         * Returns milliseconds since boot, including time spent in sleep.
         * 为了方便计算每个request所用的时间
         * 在处理每个request之前都记下此刻unix时间戳
         */
        long requestStart = SystemClock.elapsedRealtime();

        /**
         * 进入死循环= =
         * 还没弄清楚为什么要死循环
         */
        while (true) {

            /**
             * 指向HttpResponse实例的引用
             * 是调用HttpStack方法performRequest()之后返回的结果
             */
            HttpResponse httpResponse = null;

            /**
             * 返回的HttpResponse还需要经过处理
             * 并不是返回回来就是能直接使用的数据
             * 需要通过上面的ByteArrayPool将Entity转换成byte[]
             * 这个就是指向解析后的byte[]的
             */
            byte[] responseContents = null;

            //用来存放response里面header的信息，包含了状态码等
            Map&lt;String, String&gt; responseHeaders = Collections.emptyMap();


            try {
                /**
                 * Gather headers.
                 * 设置header
                 * 从缓存中收集上次相同request的信息
                 */
                Map&lt;String, String&gt; headers = new HashMap&lt;String, String&gt;();

                /**
                 * 将缓存的信息加入到headers中
                 * headers会跟随request一起发送给服务器
                 * 在函数的定义处会讲解
                 */
                addCacheHeaders(headers, request.getCacheEntry());

                /**
                 * 通过调用HttpStack接口的performRequest()方法
                 * 获取服务器返回的HttpResponse
                 */
                httpResponse = mHttpStack.performRequest(request, headers);

                /**
                 * The first line of a Response message is the Status-Line, 
                 * consisting of the protocol version followed by a numeric status code and its associated textual phrase
                 * with each element separated by SP characters. 
                 * No CR or LF is allowed except in the final CRLF sequence.
                 * 请求返回的response第一行就是包含了状态码的一行
                 */
                StatusLine statusLine = httpResponse.getStatusLine();
                int statusCode = statusLine.getStatusCode();

                /**
                 * 将头部解析成键值对的形式再返回
                 */
                responseHeaders = convertHeaders(httpResponse.getAllHeaders());

                /**
                 * Handle cache validation.
                 * 处理缓存信息
                 * 如果返回的状态码是304(HttpStatus.SC_NOT_MODIFIED)
                 * 则进行如下的处理
                 */
                if (statusCode == HttpStatus.SC_NOT_MODIFIED) {

                    /**
                     * 如果缓存为空的话
                     * 那就说明该请求的返回的response的body就是null
                     * 直接构造一个NetworkResponse返回
                     */
                    Entry entry = request.getCacheEntry();
                    if (entry == null) {
                        return new NetworkResponse(HttpStatus.SC_NOT_MODIFIED, null,
                                responseHeaders, true,
                                SystemClock.elapsedRealtime() - requestStart);
                    }

                    // A HTTP 304 response does not have all header fields. We
                    // have to use the header fields from the cache entry plus
                    // the new ones from the response.
                    // http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.5
                    /**
                     * 一个返回码为304的HttpResponse的header缺少一些信息
                     * 需要我们将cache中的一些header信息加入到其中
                     * 这样组成一个完整的NetworkResponse返回
                     */
                    entry.responseHeaders.putAll(responseHeaders);
                    return new NetworkResponse(HttpStatus.SC_NOT_MODIFIED, entry.data,
                            entry.responseHeaders, true,
                            SystemClock.elapsedRealtime() - requestStart);
                }

                /**
                 * Handle moved resources
                 * 处理了重定向的问题
                 * 并将request的mRedirectUrl设定成了新的url
                 */
                if (statusCode == HttpStatus.SC_MOVED_PERMANENTLY || statusCode == HttpStatus.SC_MOVED_TEMPORARILY) {
                    String newUrl = responseHeaders.get(&quot;Location&quot;);
                    request.setRedirectUrl(newUrl);
                }

                /**
                 * Some responses such as 204s do not have content.  We must check.
                 * 204(无内容)服务器成功处理了请求，但没有返回任何内容。
                 * 
                 */
                if (httpResponse.getEntity() != null) {
                    /**
                     * 如果entity不为Null
                     * 将其转换成byte数组
                     * 利用之前提到过的ByteArrayPool.java类
                     */
                  responseContents = entityToBytes(httpResponse.getEntity());
                } else {
                  // Add 0 byte response as a way of honestly representing a
                  // no-content request.
                  responseContents = new byte[0];
                }

                /**
                 * if the request is slow, log it.
                 * 获取request已经占用的时间(requestLifetime)
                 * 判断是否需要打出request的超时状态
                 */
                long requestLifetime = SystemClock.elapsedRealtime() - requestStart;
                logSlowRequests(requestLifetime, request, responseContents, statusLine);

                /**
                 * 如果状态码位于200之下或者是299之上(200-299 用于表示请求成功)
                 * 则抛出IOException异常= =为什么非要抛出这个异常
                 * 在前面过滤掉了(304等情况)
                 */
                if (statusCode &lt; 200 || statusCode &gt; 299) {
                    throw new IOException();
                }

                /**
                 * 经过上面的层层过滤
                 * 最后留下了200~299之间的请求成功response
                 * 通过HttpResponse里面的信息构造出一个volley自己封装的NetworkResponse对象
                 */
                return new NetworkResponse(statusCode, responseContents, responseHeaders, false,
                        SystemClock.elapsedRealtime() - requestStart);

                /**
                 * 抛出了异常之后，会用attemptREtryOnException()方法来尝试retry
                 * 主要做的工作就是看是否还有retry的机会，如果有则不停通过这个死循环
                 * 进行请求，直到请求成功或者请求的机会用完为止
                 */
            } catch (SocketTimeoutException e) {
                attemptRetryOnException(&quot;socket&quot;, request, new TimeoutError());
            } catch (ConnectTimeoutException e) {·
                attemptRetryOnException(&quot;connection&quot;, request, new TimeoutError());
            } catch (MalformedURLException e) {
                throw new RuntimeException(&quot;Bad URL &quot; + request.getUrl(), e);
            } catch (IOException e) {
                /**
                 * 状态码在0~200以及299之上的response
                 * 处理的套路
                 */
                int statusCode = 0;
                NetworkResponse networkResponse = null;
                if (httpResponse != null) {
                    statusCode = httpResponse.getStatusLine().getStatusCode();
                } else {
                    //如果状态码为0，则抛出NoConnectionError
                    throw new NoConnectionError(e);
                }
                /**
                 * 如果有重定向的情况发生
                 * 用log打出
                 */
                if (statusCode == HttpStatus.SC_MOVED_PERMANENTLY || 
                        statusCode == HttpStatus.SC_MOVED_TEMPORARILY) {
                    VolleyLog.e(&quot;Request at %s has been redirected to %s&quot;, request.getOriginUrl(), request.getUrl());
                } else {
                    VolleyLog.e(&quot;Unexpected response code %d for %s&quot;, statusCode, request.getUrl());
                }

                /**
                 * 如果返回的content内容不为Null
                 * 则构造出一个NetworkResponse
                 * 否则抛出NetworkError
                 */
                if (responseContents != null) {

                    networkResponse = new NetworkResponse(statusCode, responseContents,
                            responseHeaders, false, SystemClock.elapsedRealtime() - requestStart);

                    /**
                     * 抛出了异常之后，会用attemptREtryOnException()方法来尝试retry
                     * 主要做的工作就是看是否还有retry的机会，如果有则不停通过这个死循环
                     * 进行请求，直到请求成功或者请求的机会用完为止
                     */
                    if (statusCode == HttpStatus.SC_UNAUTHORIZED ||
                            statusCode == HttpStatus.SC_FORBIDDEN) {
                        attemptRetryOnException(&quot;auth&quot;,
                                request, new AuthFailureError(networkResponse));
                    } else if (statusCode == HttpStatus.SC_MOVED_PERMANENTLY || 
                                statusCode == HttpStatus.SC_MOVED_TEMPORARILY) {
                        attemptRetryOnException(&quot;redirect&quot;,
                                request, new AuthFailureError(networkResponse));
                    } else {
                        // TODO: Only throw ServerError for 5xx status codes.
                        throw new ServerError(networkResponse);
                    }
                } else {
                    throw new NetworkError(networkResponse);
                }
            }
        }
    }

    /**
     * Logs requests that took over SLOW_REQUEST_THRESHOLD_MS to complete.
     * 如果request用时超出了预先设定的阀值
     * 则打出log用于debug时候的提示
     */
    private void logSlowRequests(long requestLifetime, Request&lt;?&gt; request,
            byte[] responseContents, StatusLine statusLine) {
        if (DEBUG || requestLifetime &gt; SLOW_REQUEST_THRESHOLD_MS) {
            VolleyLog.d(&quot;HTTP response for request=&lt;%s&gt; [lifetime=%d], [size=%s], &quot; +
                    &quot;[rc=%d], [retryCount=%s]&quot;, request, requestLifetime,
                    responseContents != null ? responseContents.length : &quot;null&quot;,
                    statusLine.getStatusCode(), request.getRetryPolicy().getCurrentRetryCount());
        }
    }

    /**
     * Attempts to prepare the request for a retry. If there are no more attempts remaining in the
     * request&apos;s retry policy, a timeout exception is thrown.
     * 每次尝试都会使retry机会减少1，如果机会没有了，则抛出请求超时的exception
     *
     * @param request The request to use.
     */
    private static void attemptRetryOnException(String logPrefix, Request&lt;?&gt; request,
            VolleyError exception) throws VolleyError {
        RetryPolicy retryPolicy = request.getRetryPolicy();
        int oldTimeout = request.getTimeoutMs();

        try {
            retryPolicy.retry(exception);
        } catch (VolleyError e) {
            request.addMarker(
                    String.format(&quot;%s-timeout-giveup [timeout=%s]&quot;, logPrefix, oldTimeout));
            throw e;
        }
        request.addMarker(String.format(&quot;%s-retry [timeout=%s]&quot;, logPrefix, oldTimeout));
    }



    /**
     * 添加上缓存的header
     * 如果有之前的缓存的信息
     * 将里面的信息取出放入header中
     * 
     * 这里面涉及到了一个条件请求
     * 如果有缓存的话，header上面会带上一个If-Modified-Since关键字
     * 服务器会先比较信息modified的时间，如果服务端的数据没有发生变化就返回304(也就是上面的 HttpStatus.SC_NOT_MODIFIED)
     * 如果服务器的数据发生了变化，则会返回状态码200以及请求需要的数据(意思就是本地的数据需要刷新了，缓存不管用了)
     */
    private void addCacheHeaders(Map&lt;String, String&gt; headers, Cache.Entry entry) {
        // If there&apos;s no cache entry, we&apos;re done.
        if (entry == null) {
            return;
        }

        if (entry.etag != null) {
            headers.put(&quot;If-None-Match&quot;, entry.etag);
        }

        if (entry.lastModified &gt; 0) {
            Date refTime = new Date(entry.lastModified);
            headers.put(&quot;If-Modified-Since&quot;, DateUtils.formatDate(refTime));
        }
    }


    protected void logError(String what, String url, long start) {
        long now = SystemClock.elapsedRealtime();
        VolleyLog.v(&quot;HTTP ERROR(%s) %d ms to fetch %s&quot;, what, (now - start), url);
    }

    /** 
     * Reads the contents of HttpEntity into a byte[].
     * 从HttpEntity中读取数据，并通过ByteArrayPool将其转换成byte[]
     * 暂时不用管太多= =，等后面介绍到ByteArrayPool.java的时候就会明白
     */
    private byte[] entityToBytes(HttpEntity entity) throws IOException, ServerError {

        PoolingByteArrayOutputStream bytes =
                new PoolingByteArrayOutputStream(mPool, (int) entity.getContentLength());

        byte[] buffer = null;

        try {
            InputStream in = entity.getContent();
            if (in == null) {
                throw new ServerError();
            }

            /**
             * 获取一个大小为1024的缓冲区
             */
            buffer = mPool.getBuf(1024);

            int count;
            //将content的内容通过流每次最大读出1024个byte, 全部读出并写入bytes
            while ((count = in.read(buffer)) != -1) {
                bytes.write(buffer, 0, count);
            }
            return bytes.toByteArray();
        } finally {
            try {
                // Close the InputStream and release the resources by &quot;consuming the content&quot;.
                entity.consumeContent();
            } catch (IOException e) {
                // This can happen if there was an exception above that left the entity in
                // an invalid state.
                VolleyLog.v(&quot;Error occured when calling consumingContent&quot;);
            }
            /**
             * 在所有工作完成之后
             * 需要将从mPool中拿出的buffer缓冲区回收
             */
            mPool.returnBuf(buffer);
            bytes.close();
        }
    }

    /**
     * Converts Headers[] to Map&lt;String, String&gt;.
     * 将返回的response里面的header[]
     * 全部转换成Map里面的键值对形式
     */
    protected static Map&lt;String, String&gt; convertHeaders(Header[] headers) {
        Map&lt;String, String&gt; result = new TreeMap&lt;String, String&gt;(String.CASE_INSENSITIVE_ORDER);
        for (int i = 0; i &lt; headers.length; i++) {
            result.put(headers[i].getName(), headers[i].getValue());
        }
        return result;
    }
}
</code></pre><p>###4. ByteArrayPool.java<br>&#160;&#160;&#160;&#160;ByteArrayPool.java是用来将HttpResponse中Entity通过stream的形式转换成byte[],主要的作用是提供缓冲区，用来辅助流数据的读取，在使用完成之后需要将使用过的缓冲区还给ByteArrayPool，ByteArrayPool里会对这些byte[]进行简单的回收处理。</p>
<pre><code>/**
 * 用来给外界提供byte[]作为缓冲区的一个工具类
 */
public class ByteArrayPool {
    /**
     * The buffer pool, arranged both by last use and by buffer size 
     */
    private List&lt;byte[]&gt; mBuffersByLastUse = new LinkedList&lt;byte[]&gt;();
    private List&lt;byte[]&gt; mBuffersBySize = new ArrayList&lt;byte[]&gt;(64);

    /**
     * The total size of the buffers in the pool
     * 缓冲池的当前大小
     */
    private int mCurrentSize = 0;

    /**
     * The maximum aggregate size of the buffers in the pool. Old buffers are discarded to stay
     * under this limit.
     * 缓冲池当前的大小的阀值
     * 超过了该值则会对缓冲池进行回收处理
     */
    private final int mSizeLimit;

    /**
     * Compares buffers by size
     * 比较两个缓冲区的大小的规则
     * 如果返回一个负数，则表示前一个数要小
     * 如果返回0，则表示两个数字相等
     * 如果返回一个正数，则表示后一个数要小
     * 
     */
    protected static final Comparator&lt;byte[]&gt; BUF_COMPARATOR = new Comparator&lt;byte[]&gt;() {
        @Override
        public int compare(byte[] lhs, byte[] rhs) {
            return lhs.length - rhs.length;
        }
    };

    /**
     * @param sizeLimit the maximum size of the pool, in bytes
     * 用来修改缓冲池的大小阀值
     */
    public ByteArrayPool(int sizeLimit) {
        mSizeLimit = sizeLimit;
    }

    /**
     * Returns a buffer from the pool if one is available in the requested size, or allocates a new
     * one if a pooled one is not available.
     * 从mBuffersBySize中调出一个缓冲区来
     * 如果大小符合要求，则直接返回给调用者
     * 如果没有符合要求的，直接创建一个新的byte[]返回
     *
     * @param len the minimum size, in bytes, of the requested buffer. The returned buffer may be
     *        larger.
     * @return a byte[] buffer is always returned.
     */
    public synchronized byte[] getBuf(int len) {
        for (int i = 0; i &lt; mBuffersBySize.size(); i++) {
            byte[] buf = mBuffersBySize.get(i);
            if (buf.length &gt;= len) {
                mCurrentSize -= buf.length;
                mBuffersBySize.remove(i);
                mBuffersByLastUse.remove(buf);
                return buf;
            }
        }
        return new byte[len];
    }

    /**
     * Returns a buffer to the pool, throwing away old buffers if the pool would exceed its allotted
     * size.
     * 
     * @param buf the buffer to return to the pool.
     */
    public synchronized void returnBuf(byte[] buf) {

        //如果buf为空或者超出了规定的大小，不管就行了，这种缓冲区用不着回收，因为= =根本就不符合要求嘛

        if (buf == null || buf.length &gt; mSizeLimit) {
            return;
        }

        //如果buf符合要求，则将其加入到最近使用的队列中去

        mBuffersByLastUse.add(buf);

        /**
         * 通过二分查找，比较规则为BUF_COMPARATOR，找出新进来的buf应该处于的位置
         * 随后将buf插入到mBufferBySize的队列里面
         */
        int pos = Collections.binarySearch(mBuffersBySize, buf, BUF_COMPARATOR);
        if (pos &lt; 0) {
            pos = -pos - 1;
        }

        mBuffersBySize.add(pos, buf);

        //当前总缓冲区大小变大
        mCurrentSize += buf.length;

        //对整个缓冲池的大小做出调整
        trim();
    }

    /**
     * Removes buffers from the pool until it is under its size limit.
     * 调整缓冲区的大小
     * 直到mCurrentSize在限制大小之下
     */
    private synchronized void trim() {

        while (mCurrentSize &gt; mSizeLimit) {
            byte[] buf = mBuffersByLastUse.remove(0);
            mBuffersBySize.remove(buf);
            mCurrentSize -= buf.length;
        }
    }

}
</code></pre><h3 id="5-_RetryPolicy-java"><a href="#5-_RetryPolicy-java" class="headerlink" title="5. RetryPolicy.java"></a>5. RetryPolicy.java</h3><p>&#160;&#160;&#160;&#160;在BasicNetwork.java这个类中，通过死循环加上try,catch的方式，不停的对一个request进行重复的处理，里面涉及到了<code>RetryPolicy.java</code>接口以及其默认实现类，这个接口是用来专门处理一个request在发送以及得到服务器响应返回结果的过程中出现的问题。通过有限次数的不断扩大request响应时间阀值，再次发送request的方式来达到一个retry的目的。和<code>Network.java</code>类似的，<code>RetryPolicy.java</code>也仅仅就是提供了抽象方法，想把具体的实现内容弄明白还需要去默认实现类<code>DefaultRetryPolicy.java</code>中去。</p>
<pre><code>package com.android.volley;

/**
 * Retry policy for a request.
 * 该类用来管理request的调整及重新发送
 * 所谓调整就是将request响应时间(timeout)放宽
 */
public interface RetryPolicy {

    /**
     * Returns the current timeout (used for logging).
     */
    public int getCurrentTimeout();

    /**
     * Returns the current retry count (used for logging).
     */
    public int getCurrentRetryCount();

    /**
     * Prepares for the next retry by applying a backoff to the timeout.
     * 为下一次request做好准备，通过不停地来放宽timeout时间限制
     * 在DefaultRetryPolicy.java中好理解一些
     * 
     * @param error The error code of the last attempt.
     * @throws VolleyError In the event that the retry could not be performed (for example if we
     * ran out of attempts), the passed in error is thrown.
     */
    public void retry(VolleyError error) throws VolleyError;
}
</code></pre><h3 id="5-_DefaultRetryPolicy-java"><a href="#5-_DefaultRetryPolicy-java" class="headerlink" title="5. DefaultRetryPolicy.java"></a>5. DefaultRetryPolicy.java</h3><p>&#160;&#160;&#160;&#160;<code>DefaultRetryPolicy.java</code>描述了对待Volley中涉及Network的request的策略方针，可以理解为重试策略方针，也就是对那些在网络请求失败的request处理方法。里面包含了retry的最大次数(<code>mMaxNumRetries</code>)，当前请求次数(<code>mCurrentRetryCount</code>)以及请求超时的时间阀值(<code>mCurrentTimeoutMs</code>)等。每个Request里面都包含了一个<code>RetryPolicy.java</code>实现类，在处理的时候可以通过<code>getRetryPolicy()</code>方法获得。</p>
<pre><code>package com.android.volley;

/**
 * Default retry policy for requests.
 */
public class DefaultRetryPolicy implements RetryPolicy {
    /** 
     * The current timeout in milliseconds. 
     * 请求超时的时间数
     */
    private int mCurrentTimeoutMs;

    /** 
     * The current retry count.
     * 当前请求的重试次数
     */
    private int mCurrentRetryCount;

    /** 
     * The maximum number of attempts. 
     * 重复尝试的最大次数
     **/
    private final int mMaxNumRetries;

    /** 
     * The backoff multiplier for the policy.
     * 暂时不明白这个有什么用
     * 根据后面的来看好像是一个用于放宽timeout时间限制的系数
     * 这个系数越大每次retry的时候放宽的程度也就越大
     */
    private final float mBackoffMultiplier;

    /** The default socket timeout in milliseconds */
    public static final int DEFAULT_TIMEOUT_MS = 2500;

    /** The default number of retries */
    public static final int DEFAULT_MAX_RETRIES = 0;

    /** The default backoff multiplier */
    public static final float DEFAULT_BACKOFF_MULT = 1f;


    /**
     * Constructs a new retry policy using the default timeouts.
     * 默认的构造器，2.5s的超时，
     * 最大重试数为0，也就是request请求超时了就不要再自动重试了
     */
    public DefaultRetryPolicy() {
        this(DEFAULT_TIMEOUT_MS, DEFAULT_MAX_RETRIES, DEFAULT_BACKOFF_MULT);
    }

    /**
     * Constructs a new retry policy.
     * @param initialTimeoutMs The initial timeout for the policy.
     * @param maxNumRetries The maximum number of retries.
     * @param backoffMultiplier Backoff multiplier for the policy.
     */
    public DefaultRetryPolicy(int initialTimeoutMs, int maxNumRetries, float backoffMultiplier) {
        mCurrentTimeoutMs = initialTimeoutMs;
        mMaxNumRetries = maxNumRetries;
        mBackoffMultiplier = backoffMultiplier;
    }

    /**
     * Returns the current timeout.
     */
    @Override
    public int getCurrentTimeout() {
        return mCurrentTimeoutMs;
    }

    /**
     * Returns the current retry count.
     */
    @Override
    public int getCurrentRetryCount() {
        return mCurrentRetryCount;
    }

    /**
     * Returns the backoff multiplier for the policy.
     */
    public float getBackoffMultiplier() {
        return mBackoffMultiplier;
    }

    /**
     * Prepares for the next retry by applying a backoff to the timeout.
     * 该方法定义在RetryPolicy.java中。
     * 为下一次重试request做准备，好像是通过延长服务器响应时间的限制 = =
     * 每次对timeout的时间限制都放宽了mBackoffMultiplier个单位。让服务器多一点时间去响应
     * 
     * @param error The error code of the last attempt.
     * 最后一次request服务器给出的错误码
     */
    @Override
    public void retry(VolleyError error) throws VolleyError {
        mCurrentRetryCount++;
        mCurrentTimeoutMs += (mCurrentTimeoutMs * mBackoffMultiplier);
        if (!hasAttemptRemaining()) {
            throw error;
        }
    }

    /**
     * Returns true if this policy has attempts remaining, false otherwise.
     * 这个是用来判断是否还有retry机会的
     */
    protected boolean hasAttemptRemaining() {
        return mCurrentRetryCount &lt;= mMaxNumRetries;
    }
}
</code></pre><p>&#160;&#160;&#160;&#160;到这里对<code>Network.java</code>接口以及<code>RetryPolicy.java</code>接口的代码就分析完了，现在是清楚了在<code>NetworkDispatcher.java</code>调用了<code>mNetwork.performRequest()</code>之后发生了什么事情，还弄清楚了request在网络请求发送之后，出现了各种问题会怎么处理(重试策略)，但还不知道最核心的网络请求是如何发生的，也就是在<code>BasicNetwork.java</code>中的下面这行代码。</p>
<pre><code>httpResponse = mHttpStack.performRequest(request, headers);
</code></pre><p>&#160;&#160;&#160;&#160;这行代码就涉及到了后面的<code>HttpStack.java</code>接口及其两个实现类了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/01/16/Volley框架解析-四-Network接口及其默认实现类解析/" data-id="cijh2hrjr00037nut8ikm69jo" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Volley/">Volley</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Volley框架解析-三-Dispatcher解析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/01/16/Volley框架解析-三-Dispatcher解析/" class="article-date">
  <time datetime="2016-01-16T10:10:13.000Z" itemprop="datePublished">2016-01-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/16/Volley框架解析-三-Dispatcher解析/">Volley框架解析(三)-----Dispatcher解析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>###题外话(可直接无视，跳过~<br>&#160;&#160;&#160;&#160;在上一篇博客中结合volley源代码分析了<code>Volley.java</code>和<code>RequestQueue.java</code>这两个类，不知道代码全贴上去了，会不会看着很烦的嗯= =，当时看源代码的时候心里就有些不淡定，满屏幕看不懂的东西，但是个人觉得源代码和注释一起看才方便，一段代码一段解释会感觉有点摸不着头脑= =。前面的博客中一直提到了<code>Dispatcher</code>这种的东西，有<code>mNetworkDispatcher</code>和<code>mCacheDispatcher</code>之类的，这篇博客就开始进一步的介绍Volley中的Dispatcher。</p>
<hr>
<h3 id="1-__u7B80_u4ECB"><a href="#1-__u7B80_u4ECB" class="headerlink" title="1. 简介"></a>1. 简介</h3><p>&#160;&#160;&#160;&#160;在Volley中涉及到了两类的Dispatcher,一类是涉及到缓存的<code>CacheDispatcher.java</code>，另外一类是用来处理网络方面request的<code>NetworkDispatcher.java</code>，最开始出现这两个Dispatcher是在<code>RequestQueue#start()</code>中，再来回顾一下start方法中的代码：</p>
<pre><code>public void start() {
    stop();  // Make sure any currently running dispatchers are stopped.
    // Create the cache dispatcher and start it.
    mCacheDispatcher = new CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);
    mCacheDispatcher.start();

    // Create network dispatchers (and corresponding threads) up to the pool size.
    for (int i = 0; i &lt; mDispatchers.length; i++) {
        NetworkDispatcher networkDispatcher = new NetworkDispatcher(mNetworkQueue, mNetwork,
                mCache, mDelivery);
        mDispatchers[i] = networkDispatcher;
        networkDispatcher.start();
    }
}
</code></pre><p>&#160;&#160;&#160;&#160;先暂停了所有的dispatcher，然后又新建了dispatcher并start()。让dispatcher开始工作，实际上这些dispatcher继承了Thread类，是独立于主线程之外的工作线程，这样可以使RequestQueue中request的加入和处理同时进行。下面就结合CacheDispatcher和NetworkDispatcher两个类的代码来分析,Volley中是如何对request来进行调度和处理的。</p>
<h3 id="2-_CacheDispatcher-java"><a href="#2-_CacheDispatcher-java" class="headerlink" title="2. CacheDispatcher.java"></a>2. CacheDispatcher.java</h3><pre><code>package com.android.volley;

import android.os.Process;

import java.util.concurrent.BlockingQueue;

/**
 * Provides a thread for performing cache triage on a queue of requests.
 * 提供一个用来处理涉及到缓存的requests的线程
 * 
 * Requests added to the specified cache queue are resolved from cache.
 * Any deliverable response is posted back to the caller via a
 * {@link ResponseDelivery}.  Cache misses and responses that require
 * refresh are enqueued on the specified network queue for processing
 * by a {@link NetworkDispatcher}.
 * CacheDispatcher用来处理缓存队列里面(mCacheQueue)中的request
 * 任何符合delivery要求的response都会被通过ResponseDelivery的接口传递给caller
 * 有些cache丢失了或者是cache中的数据需要更新的，都将会交给NetworkDispatcher去处理
 * 交给NetworkDispatcher处理的方法就是直接放到mNetworkQueue中去
 * 因为NetworkDispatcher总是从mNetworkQueue中取出request来进行处理的
 */


public class CacheDispatcher extends Thread {

    private static final boolean DEBUG = VolleyLog.DEBUG;

    /** 
     * The queue of requests coming in for triage. 
     * 将要被处理的涉及到缓存的Request存放在这个阻塞队列里
     * 等着咯，这个mCacheQueue和RequestQueue中的mCacheQueue指向的队列是同一个
     * 也就是说整个Volley在运行的时候只有一个mCacheQueue
     */
    private final BlockingQueue&lt;Request&lt;?&gt;&gt; mCacheQueue;

    /** 
     * The queue of requests going out to the network. 
     * 这个阻塞队里里面存着的可是要去进行网络访问的request
     * 开始还不明白这里不应该是涉及到访问缓存的request
     * 怎么有个这东西出来了，其实看到后面了就会发现，缓存里面有两个过期时间
     * 在后面会介绍到Cache.java类，Cache.Entry类中涉及到了
     * ttl 和 softTtl这两个long型的数据，用来标识缓存是否已经过期了
     * 或者是否需要去检查是否要更新缓存的两个间隔时间
     */
    private final BlockingQueue&lt;Request&lt;?&gt;&gt; mNetworkQueue;

    /** 
     * The cache to read from. 
     * 用于读写缓存的接口
     * 这个接口也是在Volley中只有一个
     * mCacheDispatcher和mNetworkDispatcher公用的
     */
    private final Cache mCache;

    /** 
     * For posting responses. 
     * ResponseDelivery对象引用，用来将request的结果传递给caller
     * 在NetworkDispatcher里面也有出现
     * 这个也是从RequestQueue中传递过来的，公用
     */
    private final ResponseDelivery mDelivery;

    /** 
     * Used for telling us to die. 
     * 直译 ： 用来告诉我们去死= = (shit)
     * 然而 ： 这个变量用来标志这个dispatcher是否要继续工作下去
     * 如果为true就结束本线程中的死循环
     */
    private volatile boolean mQuit = false;

    /**
     * Creates a new cache triage dispatcher thread.  You must call {@link #start()}
     * in order to begin processing.
     * 构造函数咯，创建一个存放需要访问缓存的request的调度线程
     * 在创建之后需要将其用start()启动
     * 
     * @param cacheQueue Queue of incoming requests for triage
     * 存放request的缓存队列
     * @param networkQueue Queue to post requests that require network to
     * 存放涉及network的网络队列
     * @param cache Cache interface to use for resolution
     * 用来处理缓存读写问题的接口
     * @param delivery Delivery interface to use for posting responses
     * 用来反馈结果的接口
     */
    public CacheDispatcher(
            BlockingQueue&lt;Request&lt;?&gt;&gt; cacheQueue, BlockingQueue&lt;Request&lt;?&gt;&gt; networkQueue,
            Cache cache, ResponseDelivery delivery) {
        mCacheQueue = cacheQueue;
        mNetworkQueue = networkQueue;
        mCache = cache;
        mDelivery = delivery;
    }

    /**
     * Forces this dispatcher to quit immediately.  If any requests are still in
     * the queue, they are not guaranteed to be processed.
     * 将标志位mQuit置为true,在每次死循环的最后会判断该标志位
     */
    public void quit() {
        mQuit = true;
        interrupt();
    }

    /**
     * 前面提到了CacheDispatcher继承了Thread类
     * 这里就重写了run()方法
     * 当外面调用了mCacheDispatcher.start()之后
     * run()里面的方法就开始执行了
     */
    @Override
    public void run() {

        if (DEBUG) VolleyLog.v(&quot;start new dispatcher&quot;);
        /**
         * 给自己设置了线程的优先级
         * THREAD_PRIORITY_BACKGROUND的优先级是0x0000000a(也就是10)
         * 还有其他的很多种优先级，该优先级处于较高的位置
         */
        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);

        /**
         * Make a blocking call to initialize the cache.
         * 在读写缓存之前做一些初始化工作，例如扫描缓存目录是否存在等
         * 这个暂时先不用管里面的内容，等介绍到Cache.java的时候就会明白
         */
        mCache.initialize();


        /**
         * 从这里开始就进入了死循环的状态
         * 除非出现了什么没有catch的exception
         * 或者是mQuit标志位被置成了true
         * 这个死循环将一直进行下去= =
         * 总感觉有什么不妥的地方，感觉死循环怪怪的噢
         */
        while (true) {
            /**
             * 和NetworkDispatcher里面的流程没有什么太大的变化
             * 还是一个死循环不停的从CacheQueue中取出Request
             */
            try {
                /**
                 * Get a request from the cache triage queue, blocking until
                 * at least one is available.
                 * 从缓存request队列里面取出等待处理的request
                 * 如果没有可取出的request，则会在这里阻塞
                 * 这个是PriorityBlockingQueue#take()函数的作用
                 * 
                 */
                final Request&lt;?&gt; request = mCacheQueue.take();

                /**
                 * 给每个request添加上一个打log的标志
                 * 为了debug的需要
                 */
                request.addMarker(&quot;cache-queue-take&quot;);

                /**
                 * If the request has been canceled, don&apos;t bother dispatching it.
                 * 如果正在处理的这个请求被取消了
                 * 中断对该request的处理，continue去处理下一个request的调度
                 * 调用Request#finish()方法，传入的参数是为了debug方便，打出request调度进度的log
                 */
                if (request.isCanceled()) {
                    request.finish(&quot;cache-discard-canceled&quot;);
                    continue;
                }

                /**
                 * 在这里NetworkDispatcher和CacheDispatcher出现了一点差异
                 * NetworkDispatcher.java在这一步就直接开始网络请求了
                 * 
                 * 由于是CacheDispatcher.java，肯定是主要以Cahce为主的
                 * CacheDispatcher在这里先看看有没有缓存
                 * 如果没有缓存则马上将这个request加入到NetworkQueue中
                 * (意思好像就是= =兄弟你排错队了)
                 * 然后继续喊下一个request来被处理
                 */
                // Attempt to retrieve this item from cache.
                Cache.Entry entry = mCache.get(request.getCacheKey());
                if (entry == null) {
                    request.addMarker(&quot;cache-miss&quot;);
                    // Cache miss; send off to the network dispatcher.
                    mNetworkQueue.put(request);
                    continue;
                }

                /**
                 * 能到这一步的request不简单了
                 * 肯定是被上面的mCache.get(cacheKey)查到了有缓存的(毕竟有靠山的伤不起)
                 * 有缓存还不能太大意= =，万一缓存尼玛是个过期的就惨了= =
                 * 先用entry.isExpired()函数检查一番
                 * 过期了照样还是给我滚到NetworkQueue中去排队
                 *
                 * 继续喊下一个request来
                 */
                // If it is completely expired, just send it to the network.
                if (entry.isExpired()) {
                    request.addMarker(&quot;cache-hit-expired&quot;);
                    request.setCacheEntry(entry);
                    mNetworkQueue.put(request);
                    continue;
                }

                /**
                 * 哎哟，能到这一步的request更加不简单了，不仅仅有缓存
                 * 而且还是能用的缓存，没有过期的诶，这才是有真的靠山= =
                 *
                 * 将缓存的信息都拿出来，组成一个NetworkResponse
                 * 就像是刚刚从网络上获取出来的一样，再形成一个Response.java对象
                 * 但是不要着急把这个response直接传回caller，这个response还没确定是否需要refresh
                 */

                // We have a cache hit; parse its data for delivery back to the request.
                request.addMarker(&quot;cache-hit&quot;);

                /**
                 * 将一个由缓存中的数据创建的NetworkResponse.java对象
                 * 通过Request#parseNetworkResponse()方法
                 * 来解析成一个Response.java对象
                 */
                Response&lt;?&gt; response = request.parseNetworkResponse(
                        new NetworkResponse(entry.data, entry.responseHeaders));

                //为了方便debug，对request每一个时期的状态都需要添加不同的log信息
                request.addMarker(&quot;cache-hit-parsed&quot;);

                if (!entry.refreshNeeded()) {
                    // Completely unexpired cache hit. Just deliver the response.
                    /**
                     * 如果缓存不需要刷新的话，直接传回给caller
                     */
                    mDelivery.postResponse(request, response);
                } else {
                    // Soft-expired cache hit. We can deliver the cached response,
                    // but we need to also send the request to the network for
                    // refreshing.
                    /**
                     * 如果需要刷新的话，将这个response中的intermediate参数置为true
                     * 然后再传递给caller，
                     * 随后将请求发送到服务器进行刷新
                     */
                    request.addMarker(&quot;cache-hit-refresh-needed&quot;);
                    request.setCacheEntry(entry);

                    /**
                     * Mark the response as intermediate.
                     * 将这个response标记成中间产物，也就不是最终的response
                     * 
                     */
                    response.intermediate = true;

                    /** 
                     * Post the intermediate response back to the user and have
                     * the delivery then forward the request along to the network.
                     * poseResponse()方法中的Runnable是在response被传递给caller了之后
                     * 再执行的，在ResponseDelivery.java中有注释
                     * 
                     */
                    mDelivery.postResponse(request, response, new Runnable() {
                        @Override
                        public void run() {
                            try {
                                //将request加入到网络请求队列中去
                                mNetworkQueue.put(request);
                            } catch (InterruptedException e) {
                                // Not much we can do about this.
                            }
                        }
                    });
                }

            } catch (InterruptedException e) {
                //当cacheQueue中没有request之后就会捕捉到异常
                // We may have been interrupted because it was time to quit.
                if (mQuit) {
                    return;
                }
                continue;
            }
        }
    }
}
</code></pre><h3 id="3-_NetworkDispatcher-java"><a href="#3-_NetworkDispatcher-java" class="headerlink" title="3. NetworkDispatcher.java"></a>3. NetworkDispatcher.java</h3><pre><code>package com.android.volley;

import android.annotation.TargetApi;
import android.net.TrafficStats;
import android.os.Build;
import android.os.Process;
import android.os.SystemClock;

import java.util.concurrent.BlockingQueue;

/**
 * Provides a thread for performing network dispatch from a queue of requests.
 * 提供一个线程专门用来从请求队列(NetworkQueue)里面调度网络请求
 * 
 * Requests added to the specified queue are processed from the network via a
 * specified {@link Network} interface. Responses are committed to cache, if
 * eligible, using a specified {@link Cache} interface. Valid responses and
 * errors are posted back to the caller via a {@link ResponseDelivery}.
 *
 * 被加入到RequestQueue中的request会被NetWork的接口进一步加工处理.
 * 如果从网络返回的response是符合条件的，则会被添加到缓存中去。
 * 有效的response将通过ResponseDelivery返回给调用者
 */
public class NetworkDispatcher extends Thread {
    /** 
     * The queue of requests to service. 
     * 这个queue就是RequestQueue.java中的mNetworkQueue
     */
    private final BlockingQueue&lt;Request&lt;?&gt;&gt; mQueue;

    /** 
     * The network interface for processing requests. 
     * 处理request的接口，其中的方法是performRequest()
     */
    private final Network mNetwork;     

    /** 
     * The cache to write to. 
     * 处理缓存的接口
     */
    private final Cache mCache;

    /** 
     * For posting responses and errors. 
     * 用来传递response和error的deliver.
     */
    private final ResponseDelivery mDelivery;

    /** 
     * Used for telling us to die. 、
     * 这里使用到了volatile变量
     * 这个volatile类似于final之类的修饰词
     * 是用来保证每次mQuit被读取的时候都是最新的
     * 避免了读取的值和实际变量的值不同的情况
     * 可以参考这篇博客，讲解的比较详细：
     * http://www.cnblogs.com/aigongsi/archive/2012/04/01/2429166.html
     */
    private volatile boolean mQuit = false;

    /**
     * Creates a new network dispatcher thread.  You must call {@link #start()}
     * in order to begin processing.
     * 构造器，用于创建一个新的网络调度线程，必须要调用call来开始处理request
     * 
     * @param queue Queue of incoming requests for triage
     * 等待处理的request队列
     * @param network Network interface to use for performing requests
     * @param cache Cache interface to use for writing responses to cache
     * @param delivery Delivery interface to use for posting responses
     */
    public NetworkDispatcher(BlockingQueue&lt;Request&lt;?&gt;&gt; queue,
            Network network, Cache cache,
            ResponseDelivery delivery) {
        mQueue = queue;
        mNetwork = network;
        mCache = cache;
        mDelivery = delivery;
    }

    /**
     * Forces this dispatcher to quit immediately.  If any requests are still in
     * the queue, they are not guaranteed to be processed.
     * 强制调度器立刻退出，不再调度request。
     * 
     */
    public void quit() {
        mQuit = true;
        interrupt();
    }

    /**
     * 这里涉及到了TrafficStats类，官方解释如下：
     * Class that provides network traffic statistics. 
     * 这个类提供网络流量统计的服务。
     * These statistics include bytes transmitted and received and network packets transmitted and received, 
     * over all interfaces, over the mobile interface, and on a per-UID basis.
     * 这些被统计的流量包括传输的字节数和收到的字节数以及网络数据包
     * These statistics may not be available on all platforms. 
     * If the statistics are not supported by this device, UNSUPPORTED will be returned.
     * 这些数据并不是在所有的平台上都可以用
     * 如果不可用，则会返回UNSPPORTED
     * 貌似是每个request都统计一下网络流量= =
     */
    @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
    private void addTrafficStatsTag(Request&lt;?&gt; request) {
        // Tag the request (if API &gt;= 14)
        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.ICE_CREAM_SANDWICH) {
            TrafficStats.setThreadStatsTag(request.getTrafficStatsTag());
        }
    }

    /**
     * 由于NetworkDispatcher继承自Thread，重写了run()方法
     * 里面的内容都会在另启动一个线程来执行
     * 在CacheDispatcher中有很多相似的地方
     */
    @Override
    public void run() {
        /**
         * 给自己设置了线程的优先级
         * THREAD_PRIORITY_BACKGROUND的优先级是0x0000000a(也就是10)
         * 还有其他的很多种优先级，该优先级处于较高的位置
         */
        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);

        Request&lt;?&gt; request;

        /**
         * 进入了一个死循环状态
         * 开始不停的工作
         */
        while (true) {

            /**
             * elapsedRealtime()函数返回的是线程从启动到现在的总时间
             * 也包括线程睡眠时间在内
             * 单看这一句看不出什么门道，结合在后面的异常处理时会用到startTimeMs
             * 这里是记录一个request开始的时刻点，到后面再次调用elapsedRealtime()
             * 两个变量相减得到了request花费了多长的时间
             */
            long startTimeMs = SystemClock.elapsedRealtime();
            /**
             * release previous request object to avoid leaking request object when mQueue is drained.
             * 释放前面的一个Request对象，以免因为Request对象不停的申请而导致内存泄漏
             */
            request = null;

            /**
             * 尝试着从RequestQueue中取出一个Request，对其进行处理
             * 可能会因为某些原因(可能是队列中没有元素了)会抛出异常
             * 这个时候就捕捉异常并检验是否要退出了，需要退出则return
             * 不需要退出则继续下一次循环，看有没有Request可以拿到
             */
            try {
                // Take a request from the queue.
                request = mQueue.take();
            } catch (InterruptedException e) {
                // We may have been interrupted because it was time to quit.
                if (mQuit) {
                    return;
                }
                continue;
            }

            /**
             * 到这一步的时候，request应该是指向了一个Request
             * 下面开始向服务器发送这个Request
             */

            try {
                request.addMarker(&quot;network-queue-take&quot;);

                // If the request was cancelled already, do not perform the
                // network request.
                if (request.isCanceled()) {
                    request.finish(&quot;network-discard-cancelled&quot;);
                    continue;
                }

                addTrafficStatsTag(request);

                /**
                 * Perform the network request.
                 * 直接调用mNetwork的接口，发送request并获得NetworkResponse
                 */
                NetworkResponse networkResponse = mNetwork.performRequest(request);
                request.addMarker(&quot;network-http-complete&quot;);

                // If the server returned 304 AND we delivered a response already,
                // we&apos;re done -- don&apos;t deliver a second identical response.
                if (networkResponse.notModified &amp;&amp; request.hasHadResponseDelivered()) {
                    request.finish(&quot;not-modified&quot;);
                    continue;
                }

                /**
                 * Parse the response here on the worker thread.
                 * 在工作线程上面直接解析结果
                 * 并且封装成一个Response对象
                 */
                Response&lt;?&gt; response = request.parseNetworkResponse(networkResponse);
                request.addMarker(&quot;network-parse-complete&quot;);

                /** Write to cache if applicable.
                 *  如果符合要求，能写入缓存的话，就写到缓存里面
                 */
                // TODO: Only update cache metadata instead of entire record for 304s.

                /**
                 * 在这里看到作者的TODO了，还能改进的地方就是在出现了返回码是
                 * 304的情况时，只更新缓存中的元数据(也就是response的主体)
                 * 而不是整个cache的记录下来,有些重复的数据可以不用理会.
                 */
                if (request.shouldCache() &amp;&amp; response.cacheEntry != null) {
                    mCache.put(request.getCacheKey(), response.cacheEntry);
                    request.addMarker(&quot;network-cache-written&quot;);
                }

                /**
                 * 将Request.java中的变量mResponseDelivered置成true
                 * 标志着这个request的结果已经传回给了caller
                 */

                request.markDelivered();

                /**
                 * 通过ResponseDelivery的接口将包装好了的Response返回给调用者
                 */
                mDelivery.postResponse(request, response);

            } catch (VolleyError volleyError) {
                /**
                 * 设置了request从队列中取出到服务器出现异常反应
                 * 所花费的时间
                 */
                volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);

                /**
                 * 将网络请求的错误通过ResponseDelivery传递给调用者
                 * 告诉它这.....不幸的一切
                 */
                parseAndDeliverNetworkError(request, volleyError);

            } catch (Exception e) {
                VolleyLog.e(e, &quot;Unhandled exception %s&quot;, e.toString());
                VolleyError volleyError = new VolleyError(e);
                volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);
                mDelivery.postError(request, volleyError);
            }
        }
    }

    private void parseAndDeliverNetworkError(Request&lt;?&gt; request, VolleyError error) {
        error = request.parseNetworkError(error);
        mDelivery.postError(request, error);
    }
}
</code></pre><p>&#160;&#160;&#160;&#160;当时看完了CacheDispatcher.java之后，再看NetworkDispatcher.java的时候，就会觉得这两个类非常的相似，run()函数里面的东西有些都差不多，都是进行一个死循环，从阻塞队列里面取出request，针对不同的情况做出不同的处理。</p>
<p>&#160;&#160;&#160;&#160;从Volley.java暴露给外部的api开始，一直到现在，已经慢慢的了解了Volley中有一个RequestQueue对象，所有的request都在里面排着队等待被处理，RequestQueue里面还有一个CacheDispatcher和几个NetworkDispatcher,分别负责着不同种类的request。接下来要介绍的就是Volley中<code>Network.java</code>接口以及其默认实现类<code>BasicNetwork.java</code>,还有涉及缓存读写的接口<code>Cache.java</code>以及其默认实现类<code>DiskBasedCache.java</code>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/01/16/Volley框架解析-三-Dispatcher解析/" data-id="cijh2hrjz000c7nutl55gfgiw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Volley/">Volley</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Volley框架解析-二-Volley及RequestQueue解析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/01/16/Volley框架解析-二-Volley及RequestQueue解析/" class="article-date">
  <time datetime="2016-01-16T10:10:02.000Z" itemprop="datePublished">2016-01-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/16/Volley框架解析-二-Volley及RequestQueue解析/">Volley框架解析(二)-----Volley及RequestQueue解析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="u9898_u5916_u8BDD_28_u53EF_u76F4_u63A5_u65E0_u89C6_u8DF3_u8FC7"><a href="#u9898_u5916_u8BDD_28_u53EF_u76F4_u63A5_u65E0_u89C6_u8DF3_u8FC7" class="headerlink" title="题外话(可直接无视跳过"></a>题外话(可直接无视跳过</h3><p>&#160;&#160;&#160;&#160;是第一次比较完整的去阅读一个框架的源码，刚开始看的时候可以说是除了认识几个基本的<code>public, interface, final</code>等关键词之外，其他的一律不通orz，而且还不知道从哪里下手。后来磨蹭了好久还是慢慢的静下心来，对照着Java文档和Android文档查阅，刚开始都是陌生的，慢慢的在源码旁边打上注释，多看两遍就会get了。</p>
<p>&#160;&#160;&#160;&#160;有些地方在一个.java文件里面是无法理解用处的，这样的先直接跳过不要纠结，看到对应用的地方就会恍然大悟了。还总结出了一个小技巧就是从框架暴露给外面的接口开始阅读，因为框架里面是一层一层往上的，底层是为了上层服务的，所以从接口开始阅读能很好的向下展开。</p>
<p>&#160;&#160;&#160;&#160;前面一篇对Volley做了一个初步的介绍以及从整体上的一个解析，只是简单的描述了Request在Volley中是如何被处理的。从这篇博客开始将从最顶层一步一步的向下挖掘每一行代码，从最开始调用的地方<code>RequestQueue mQueue = Volley.newRequestQueue(mContext)</code>开始。</p>
<hr>
<h3 id="1-_Volley-java"><a href="#1-_Volley-java" class="headerlink" title="1. Volley.java"></a>1. Volley.java</h3><p>&#160;&#160;&#160;&#160;Volley.java是Volley整个框架对外暴露的接口，里面有四个重载的同名静态函数，方便直接使用。下面结合源代码来分析，主要是代码里面的注释。</p>
<pre><code>

    package com.android.volley.toolbox;

	import android.content.Context;
	import android.content.pm.PackageInfo;
	import android.content.pm.PackageManager.NameNotFoundException;
	import android.net.http.AndroidHttpClient;
	import android.os.Build;
	
	import com.android.volley.Network;
	import com.android.volley.RequestQueue;
	
	import java.io.File;
	
	public class Volley {

	    /** Default on-disk cache directory. */
	    private static final String DEFAULT_CACHE_DIR = "volley";
	
	    /**
	     * Creates a default instance of the worker pool and calls {@link RequestQueue#start()} on it.
	     * You may set a maximum size of the disk cache in bytes.
	     * 创建一个默认的线程池，并将其启动
	     * 还能通过构造函数来设置缓存的最大容量，默认的是5*1024*1024个字节
	     *
	     * @param context A {@link Context} to use for creating the cache dir.
	     * 用于创建缓存目录的context
	     * @param stack An {@link HttpStack} to use for the network, or null for default.
	     * HttpStack可以通过外面自定义之后传入，也可以不管直接用默认的
	     * @param maxDiskCacheBytes the maximum size of the disk cache, in bytes. Use -1 for default size.
	     * 最大缓存的字节数
	     * @return A started {@link RequestQueue} instance.
	     */
	    public static RequestQueue newRequestQueue(Context context, HttpStack stack, int maxDiskCacheBytes) {
	
	    	//通过context，创建用于缓存文件的目录
	        File cacheDir = new File(context.getCacheDir(), DEFAULT_CACHE_DIR);
	
	        String userAgent = "volley/0";
	        
	        try {
	            String packageName = context.getPackageName();
	
	            /**
	             * 关于PackageInfo，官方文档的解释如下：
	             * Overall information about the contents of a package.
	             * This corresponds to all of the information collected from AndroidManifest.xml.
	             * 该类作为Package信息的基类，还有很多子类例如：ApplicationInfo、 ComponentInfo等。
	             * 这些类包含了一些关于安装包的信息，icon,label等
	             */
	            PackageInfo info = context.getPackageManager().getPackageInfo(packageName, 0);
	            //获取到了Package的版本号
	            userAgent = packageName + "/" + info.versionCode;
	
	        } catch (NameNotFoundException e) {
	        }
	
	        /**
	         * HttpStack是一个用于网络请求的接口
	         * 如果传入的stack为空，则根据当前系统的版本号，来选择不同的实现了HttpStack(Volley自己的一个接口)的类对象
	         * 高于android2.3就用HurlStack(实现了HttpStack接口，基于HttpsURLConnection)
	         * 低于android2.3就用HttpClientStack(实现了HttpStack接口，基于HttpClient)
	         */
	        if (stack == null) {
	            if (Build.VERSION.SDK_INT >= 9) {
	                stack = new HurlStack();
	            } else {
	                // Prior to Gingerbread, HttpUrlConnection was unreliable.
	                // See: http://android-developers.blogspot.com/2011/09/androids-http-clients.html
	                stack = new HttpClientStack(AndroidHttpClient.newInstance(userAgent));
	            }
	        }
	
	        /**
	         * 创建了一个用于发送特定请求的Network类对象
	         * 该接口中有一个与HttpStack接口中同名的方法(performRequest)
	         * 但是参数的内容不同， 返回的类型也有所区别
	         * Network的返回类型是自定义的一个NetworkResponse类
	         * 而HttpStack返回的是HttpResponse
	         * (HttpResponse是java.apache.http中的一个类，里面包含了服务器返回的一些数据)
	         * 
	         * 将stack传入到了已经实现了Network接口的一个BasicNetwork类中
	         * 在后面发送Request请求的时候会调用Network.performRequest()
	         * 然后在Network.performRequest()函数中会继续调用HttpStack.performRequest()
	         * 真正的网络请求发出是在HttpStack.performRequest()中进行的
	         */
	
	        Network network = new BasicNetwork(stack);
	        
	        /**
	         * 创建一个RequestQueue引用
	         * RequestQueue是volley实现的一个请求调度队列
	         * 用来分发处理request
	         * 后面会分析RequestQueue.java
	         */
	        RequestQueue queue;
	
	        /**
	         * 根据是否设置了最大缓存字节数
	         * 来用不同的构造器生成RequestQueue对象
	         * 其中第一个构造参数为一个实现了Cache.java接口的默认缓存读写类DiskBasedCache.java
	         * 现在只需要知道它是用来专门处理缓存的就可以了，后面也会对源码做出分析
	         * 第二个参数是接口Network.java类的引用，在上面两排不远处可以看到BasicNetwork.java
	         * 它是用来实现网络请求的一个类。
	         */        
	        if (maxDiskCacheBytes <= -1)="" {="" no="" maximum="" size="" specified="" queue="new" requestqueue(new="" diskbasedcache(cachedir),="" network);="" }="" else="" disk="" cache="" diskbasedcache(cachedir,="" maxdiskcachebytes),="" 启动了创建的requestqueue对象，里面的各种工作线程开始工作="" queue.start();="" return="" queue;="" **="" *="" 下面的三个构造器最后都是调用了第一个构造器="" 不用做进一步的解释了吧="" creates="" a="" default instance="" of="" the="" worker="" pool="" and="" calls="" {@link="" requestqueue#start()}="" on="" it.="" you="" may="" set="" in="" bytes.="" @param="" context="" context}="" to="" use="" for="" creating="" dir.="" maxdiskcachebytes="" cache,="" -1="" size.="" @return="" started="" requestqueue}="" instance.="" public="" static="" requestqueue="" newrequestqueue(context="" context,="" int="" maxdiskcachebytes)="" newrequestqueue(context,="" null,="" maxdiskcachebytes);="" stack="" an="" httpstack}="" network,="" or="" null="" default.="" httpstack="" stack)="" stack,="" -1);="" context)="" null);="" <="" code=""></=></code></pre><p>&#160;&#160;&#160;&#160;简单的说，Volley.java的用处就只有一个，创建并启动一个RequestQueue对象，可以有四个构造器供我们选择，可以通过继承其接口衍生出自己的一套网络请求部分的实现(继承HttpStack接口),还可以定义缓存大小的限制。对于框架的使用者来说自由度还是很大的，不是固定死只能通过默认实现来使用Volley,提供接口能使框架的灵活性大大提升，在自己写代码的过程中也要注意这个问题。</p>
<hr>
<p>###2. RequestQueue.java<br>&#160;&#160;&#160;&#160;RequestQueue可以说是Volley中最核心的部分了，所有的request都要从这边进来，等待工作线程的调度，调度完成之后从里面的ResponseDelivery返回给caller。下面是RequestQueue.java的所有代码以及每行代码的用途，读了几遍才弄清楚了这个东西的作用，之前都迷糊的不行orz。</p>
<pre><code>
    package com.android.volley;

	import android.os.Handler;
	import android.os.Looper;
	
	import java.util.ArrayList;
	import java.util.HashMap;
	import java.util.HashSet;
	import java.util.LinkedList;
	import java.util.List;
	import java.util.Map;
	import java.util.Queue;
	import java.util.Set;
	import java.util.concurrent.PriorityBlockingQueue;
	import java.util.concurrent.atomic.AtomicInteger;
	
	/**
	 * A request dispatch queue with a thread pool of dispatchers.
	 * 
	 *
	 * Calling {@link #add(Request)} will enqueue the given Request for dispatch,
	 * resolving from either cache or network on a worker thread, and then delivering
	 * a parsed response on the main thread.
	 * 调用mQueue.add(Request)函数将一个request放入请求调度队列中排队，将在工作线程中，
	 * 从网络或者缓存两个方面对request进行分类并处理，将response返回给主线程中。
	 */
	public class RequestQueue {
	
	    /** 
	     * Callback interface for completed requests. 
	     * request完成之后的回掉接口
	     * 其中的T用到了java的泛型，是Request调用者所期待返回的数据类型
	     * 例如String或者是Integer
	     */
	    public static interface RequestFinishedListener<t> {
	        /**
	         * Called when a request has finished processing. 
	         * 当一个Request被处理完成时来调用
	         * = =其实从方法的名字来看也能看出来
	         */
	        public void onRequestFinished(Request<t> request);
	    }
	
	    /**
	     * Used for generating monotonically-increasing sequence numbers for requests. 
	     * 用来为request生成单调递增的有序数字，刚才是不知道这里是干什么用的= =
	     * 在这里纠结了一小段时间就继续看了下去，直到在add()函数里面看到了这个的用处
	     * 在request被add()进来的时候会给每个request发一个类似于排队的序号一样的数字，就是用这个类来实现的
	     * 
	     * 官方的解释是：An int value that may be updated atomically. 
	     * An AtomicInteger is used in applications such as atomically incremented counters, and cannot be used as a replacement for an Integer.
	     * However, this class does extend Number to allow uniform access by tools and utilities that deal with numerically-based classes.
	     * 这个类是在需要自动递增计数器的应用中使用的，但是不能作为一个Integer的替代品。
	     * 但是这个类确实是继承自Number类的，其允许处理数字的一些工具来统一访问= =。。
	     */
	    private AtomicInteger mSequenceGenerator = new AtomicInteger();
	
	    /**
	     * Staging area for requests that already have a duplicate request in flight.
	     * 用HashMap来形成一个筹备区域，这个筹备区域是为重复的request准备的。
	     * 每个对应的cacheKey都有一个Queue来存储，因为相同的请求有时不止一个。
	     * 这些重复的request已经有一个在被处理了，其他的不用重复处理，在这个HashMap里面等着拿结果就可以了
	     * <ul>
	     *     <li>containsKey(cacheKey) indicates that there is a request in flight for the given cache
	     *          key.
	     *         用containsKey(String cacheKey)可以判定一个已经发送出去的请求是否有重复的请求。
	     *     </li>
	     *     <li>get(cacheKey) returns waiting requests for the given cache key. The in flight request
	     *          is <em>not</em> contained in that list. Is null if no requests are staged.</li>
	     *         get()方法会返回一个queue，这个queue有可能是空的，也有可能里面存放着具有相同cacheKey的一系列request
	     * </ul>
	     */
	    private final Map<string, queue<request<?="">>> mWaitingRequests =
	            new HashMap<string, queue<request<?="">>>();
	
	    /**
	     * The set of all requests currently being processed by this RequestQueue. A Request
	     * will be in this set if it is waiting in any queue or currently being processed by
	     * any dispatcher.
	     *
	     * 一个容纳着所有request的HashSet。
	     * 如果一个request正在被调度或者正处于等待状态，该request就在这个集合之中。
	     * 这么说的话，RequestQueue里面主要存储request的集合就是这个了。
	     * 在外面调用add(Request request)的时候，也就是加入到了这个HashSet之中。
	     */
	    private final Set<request<?>> mCurrentRequests = new HashSet<request<?>>();
	
	    /** 
	     * The cache triage queue. 
	     * 运用到了优先队列
	     * 也就是里面的每个元素都会有一个优先级，优先级高的比优先级低的要先调度。
	     * 这个队列里面存放着需要访问缓存的一些Request，等待着调度器(dispatcher)的处理
	     * 后面慢慢的会介绍到dispatcher
	     */
	    private final PriorityBlockingQueue<request<?>> mCacheQueue =
	        new PriorityBlockingQueue<request<?>>();
	
	    /** 
	     * The queue of requests that are actually going out to the network.
	     * 网络请求队列
	     * 要通过网络在服务器上请求数据的request
	     * 还包括一些缓存出了点小问题的request也会被加入到这里
	     * 在后面的代码中能够看到
	     */
	    private final PriorityBlockingQueue<request<?>> mNetworkQueue =
	        new PriorityBlockingQueue<request<?>>();
	
	    /** 
	     * Number of network request dispatcher threads to start. 
	     * 网络请求调度线程池中线程的默认数量。
	     */
	    private static final int DEFAULT_NETWORK_THREAD_POOL_SIZE = 4;
	
	    /** 
	     * Cache interface for retrieving and storing responses. 
	     * 缓存的接口，用来从缓存中取出response或者存储response到缓存中。
	     */
	    private final Cache mCache;
	
	    /** 
	     * Network interface for performing requests. 
	     * 网络接口，用来进行网络请求。
	     */
	    private final Network mNetwork;
	
	    /**
	     * Response delivery mechanism. 
	     * 响应交付机制
	     * 请求最后的结果(Response.java实例)通过mDelivery中的方法传回
	     * 这个过程需要在工作线程中才能看到，也就是在介绍dispatcher里面能看到
	     */
	    private final ResponseDelivery mDelivery;
	
	    /**
	     * The network dispatchers. 
	     * 网络调度线程池
	     * 因为是涉及到网络的一个框架，工作的效率不能低
	     * 多开几个网络调度器线程来一起工作
	     */
	    private NetworkDispatcher[] mDispatchers;
	
	    /** 
	     * The cache dispatcher. 
	     * 缓存调度线程(和上面的差不多吧= =，但是不是线程池了)
	     * 处理了涉及到缓存的request
	     */
	    private CacheDispatcher mCacheDispatcher;
	
	    /**
	     * 这个貌似是和listener差不多的用处
	     * 每个request结束之后，就会通知所有已经注册过的listener(所谓注册无非就是实现了RequestFinishedListener.java这个接口
	     * 然后再将自己传入，加入到这个ArrayList里面来)
	     * 在{@link #finish()}里面会用到这个ArrayList
	     */
	    private List<requestfinishedlistener> mFinishedListeners =
	            new ArrayList<requestfinishedlistener>();
	
	    /**
	     * Creates the worker pool. Processing will not begin until {@link #start()} is called.
	     * 创建工作线程，在start()调用之后开始不停的工作
	     *
	     * @param cache A Cache to use for persisting responses to disk
	     * 涉及到内存访问的接口
	     * @param network A Network interface for performing HTTP requests
	     * 用来进行HTTP请求的网络接口
	     * @param threadPoolSize Number of network dispatcher threads to create
	     * 网络请求线程池，里面放着很多个线程，可以同时处理多个需要网络访问的request
	     * @param delivery A ResponseDelivery interface for posting responses and errors
	     * 一个用来传递resposne和error的接口
	     */
	    public RequestQueue(Cache cache, Network network, int threadPoolSize,
	            ResponseDelivery delivery) {
	        mCache = cache;
	        mNetwork = network;
	        mDispatchers = new NetworkDispatcher[threadPoolSize];
	        mDelivery = delivery;
	    }
	
	    /**
	     * Creates the worker pool. Processing will not begin until {@link #start()} is called.
	     *
	     * @param cache A Cache to use for persisting responses to disk
	     * @param network A Network interface for performing HTTP requests
	     * @param threadPoolSize Number of network dispatcher threads to create
	     */
	    public RequestQueue(Cache cache, Network network, int threadPoolSize) {
	        this(cache, network, threadPoolSize,
	                new ExecutorDelivery(new Handler(Looper.getMainLooper())));
	    }
	
	    /**
	     * Creates the worker pool. Processing will not begin until {@link #start()} is called.
	     *
	     * @param cache A Cache to use for persisting responses to disk
	     * @param network A Network interface for performing HTTP requests
	     */
	    public RequestQueue(Cache cache, Network network) {
	        this(cache, network, DEFAULT_NETWORK_THREAD_POOL_SIZE);
	    }
	
	    /**
	     * Starts the dispatchers in this queue.
	     * 先将所有的调度线程都停止
	     * 再重新创建并启动
	     * 将mNetworkQueue和mCacheQueue传入到dispatcher中
	     * 方便从queue中取出request来进行处理
	     * 将mDelivery接口传入，方便将请求结果返回
	     * 
	     * cacheDispatcher创建一个就够了，networkDispatcher创建了多个
	     * network花费时间比较长，需要开多个线程来工作
	     */
	    public void start() {
	        stop();  // Make sure any currently running dispatchers are stopped.
	        // Create the cache dispatcher and start it.
	        mCacheDispatcher = new CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);
	        mCacheDispatcher.start();
	
	        // Create network dispatchers (and corresponding threads) up to the pool size.
	        for (int i = 0; i < mDispatchers.length; i++) {
	            NetworkDispatcher networkDispatcher = new NetworkDispatcher(mNetworkQueue, mNetwork,
	                    mCache, mDelivery);
	            mDispatchers[i] = networkDispatcher;
	            networkDispatcher.start();
	        }
	    }
	
	    /**
	     * Stops the cache and network dispatchers.
	     * 将所有正在工作状态的dispatcher挨个退出
	     */
	    public void stop() {
	        if (mCacheDispatcher != null) {
	            mCacheDispatcher.quit();
	        }
	        for (int i = 0; i < mDispatchers.length; i++) {
	            if (mDispatchers[i] != null) {
	                mDispatchers[i].quit();
	            }
	        }
	    }
	
	    /**
	     * Gets a sequence number.
	     *
	     * incrementAndGet() : Atomically increments by one the current value.
	     * 自动向上涨一个单位然后返回当前值
	     * 在后面的{@link RequestQueue#add(Request)}函数中能看到这个的作用
	     * 用到了在前面提到过的AtomicInteger类
	     */
	    public int getSequenceNumber() {
	        return mSequenceGenerator.incrementAndGet();
	    }
	
	    /**
	     * Gets the {@link Cache} instance being used.
	     * 返回当前正在使用的cache引用
	     */
	    public Cache getCache() {
	        return mCache;
	    }
	
	    /**
	     * A simple predicate or filter interface for Requests, for use by
	     * {@link RequestQueue#cancelAll(RequestFilter)}.
	     * 一个request的过滤器
	     * 上面说是给cancelAll用的，应该是设置一个RequestFilter之后
	     * 将一类的request全都取消掉，至于具体的规则就需要重写里面的函数
	     * 定义规则了
	     */
	    public interface RequestFilter {
	        public boolean apply(Request<?> request);
	    }
	
	    /**
	     * Cancels all requests in this queue for which the given filter applies.
	     * 从外面传入一个RequestFilter
	     * 按照传入的规则取消所有符合规则的request
	     * @param filter The filtering function to use
	     */
	    public void cancelAll(RequestFilter filter) {
	        synchronized (mCurrentRequests) {
	            for (Request<?> request : mCurrentRequests) {
	                if (filter.apply(request)) {
	                    request.cancel();
	                }
	            }
	        }
	    }
	
	    /**
	     * Cancels all requests in this queue with the given tag. Tag must be non-null
	     * 依据request上面的tag来取消
	     * and equality is by identity.
	     */
	    public void cancelAll(final Object tag) {
	        if (tag == null) {
	            throw new IllegalArgumentException("Cannot cancelAll with a null tag");
	        }
	        cancelAll(new RequestFilter() {
	            @Override
	            public boolean apply(Request<?> request) {
	                return request.getTag() == tag;
	            }
	        });
	    }
	
	    /**
	     * Adds a Request to the dispatch queue.
	     * 将新的request加入到总的等待队列中去
	     * 一个request被处理之前都要待的地方
	     * mCurrentRequests里面存放着所有的request 
	     *
	     * @param request The request to service
	     * 被传入的request，等待被处理
	     * @return The passed-in request
	     * 将加入的request返回回去
	     */
	    public <t> Request<t> add(Request<t> request) {
	        // Tag the request as belonging to this queue and add it to the set of current requests.
	        request.setRequestQueue(this);
	
	        /**
	         * 在向mCurrentRequest中添加request的时候
	         * 锁住不允许其他的线程进行访问操作
	         * 对于synchronized:可用来给对象和方法或者代码块加锁，
	         * 当它锁定一个方法或者一个代码块的时候，同一时刻最多只有一个线程执行这段代码。
	         * 当两个并发线程访问同一个对象object中的这个加锁同步代码块时，一个时间内只能有一个线程得到执行。
	         * 另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。
	         * 
	         */
	        synchronized (mCurrentRequests) {
	            mCurrentRequests.add(request);
	        }
	
	        /**
	         * Process requests in the order they are added.
	         * 在加入到mCurrentQueue中排队的时候
	         * 就像我们排队一样会给我们一个对应的号码牌
	         * 只是这里用了getSequenceNumber()函数来自动的发放号码牌
	         */
	        request.setSequence(getSequenceNumber());
	        request.addMarker("add-to-queue");
	
	        /** 
	         * If the request is uncacheable, skip the cache queue and go straight to the network.
	         * 检查这个request是否是不可缓存的
	         * 也就是这个request所返回的response是否需要缓存下来
	         */
	        if (!request.shouldCache()) {
	
	            /**
	             * 如果不需要缓存的话
	             * 直接将这个request加入到网络队列中去
	             * 并且返回该request
	             */
	            mNetworkQueue.add(request);
	            return request;
	        }
	
	        /**
	         * Insert request into stage if there's already a request with the same cache key in flight.
	         * = =尼玛我这是什么记性，看见这个mWaittingRequests居然不认识了
	         * 向前翻到变量声明的地方，清清楚楚的写着专门存放重复请求的地方
	         * 根据需要缓存的request生成的特殊标记cacheKey
	         * 当然不涉及到缓存的request在上面几行代码被过滤处理了
	         */
	        synchronized (mWaitingRequests) {
	
	            /**
	             * 先获取到这个request的cacheKey
	             * 看看有没有和它相同的request已经处于天上飞的状态了
	             * (我觉得这里的in flight应该说的是已经发送过了的)
	             * 在后面会说明
	             */
	            String cacheKey = request.getCacheKey();
	
	            if (mWaitingRequests.containsKey(cacheKey)) {
	
	                /**
	                 * There is already a request in flight. Queue up.
	                 * 如果在等待的队列里面存在着cacheKey对应的一个Queue
	                 * 则说明在这个request之前，已经有相同的request发送出去过了
	                 * 那么现在需要做的就是将这个request加入到cacheKey对应的Queue存起来
	                 * 如果对应的Queue是null,就自己创建一个新的，再把request放入
	                 * 
	                 * 这个request就不再会被放入到mCacheQueue中去了
	                 * 就是坐等数据的意思= =
	                 */
	                Queue<request<?>> stagedRequests = mWaitingRequests.get(cacheKey);
	                if (stagedRequests == null) {
	                    stagedRequests = new LinkedList<request<?>>();
	                }
	                stagedRequests.add(request);
	                mWaitingRequests.put(cacheKey, stagedRequests);
	                if (VolleyLog.DEBUG) {
	                    VolleyLog.v("Request for cacheKey=%s is in flight, putting on hold.", cacheKey);
	                }
	            } else {
	                /**
	                 * Insert 'null' queue for this cacheKey, indicating there is now a request in flight.
	                 * 如果这个涉及到cache的request在它之前根本就没有和他相同的request
	                 * 直接以这个cacheKey为key，放一个null进去
	                 * 表示这是第一个么= =
	                 * 搞不懂为什么要这个样子设计，为什么不直接新建一个Queue进去呢
	                 */
	                mWaitingRequests.put(cacheKey, null);
	                mCacheQueue.add(request);
	            }
	            return request;
	        }
	    }
	
	    /**
	     * Called from {@link Request#finish(String)}, indicating that processing of the given request
	     * has finished.
	     * 从Request中的finish()方法调用开始，预示着给出的request已经结束
	     * <p>Releases waiting requests for <code>request.getCacheKey()</code> if
	     *      <code>request.shouldCache()</code>.</p>
	     * 将处于mWaittingQueue中具有相同cacheKey的一组request全部释放
	     * 也就是把上面那些坐等数据的request全部取出来，response发送回去
	     */
	    <t> void finish(Request<t> request) {
	        // Remove from the set of requests currently being processed.
	        /**
	         * 将mCurrentRequests锁住
	         * 一个时间段内只有一个线程可以访问该对象
	         * 将已经结束的request从队列中移除
	         */
	        synchronized (mCurrentRequests) {
	            mCurrentRequests.remove(request);
	        }
	
	        /**
	         * 通知所有注册过的监听器
	         * 告诉它们，request已经finish了
	         */
	        synchronized (mFinishedListeners) {
	          for (RequestFinishedListener<t> listener : mFinishedListeners) {
	            listener.onRequestFinished(request);
	          }
	        }
	
	        /**
	         * 如果该request涉及到需要缓存
	         * 则将mWaitingRequests中具有相同cacheKey的request
	         * 全部取出放入到缓存队列中等待CacheDispatcher的调度
	         */
	        if (request.shouldCache()) {
	            synchronized (mWaitingRequests) {
	                String cacheKey = request.getCacheKey();
	                Queue<request<?>> waitingRequests = mWaitingRequests.remove(cacheKey);
	                if (waitingRequests != null) {
	                    if (VolleyLog.DEBUG) {
	                        VolleyLog.v("Releasing %d waiting requests for cacheKey=%s.",
	                                waitingRequests.size(), cacheKey);
	                    }
	                    // Process all queued up requests. They won't be considered as in flight, but
	                    // that's not a problem as the cache has been primed by 'request'.
	                    mCacheQueue.addAll(waitingRequests);
	                }
	            }
	        }
	    }
	
	    /**
	     * 下面两个方法就是所谓注册监听器和取消注册的函数
	     */
	    public  <t> void addRequestFinishedListener(RequestFinishedListener<t> listener) {
	      synchronized (mFinishedListeners) {
	        mFinishedListeners.add(listener);
	      }
	    }
	
	    /**
	     * Remove a RequestFinishedListener. Has no effect if listener was not previously added.
	     */
	    public  <t> void removeRequestFinishedListener(RequestFinishedListener<t> listener) {
	      synchronized (mFinishedListeners) {
	        mFinishedListeners.remove(listener);
	      }
	    }
	}
	
</t></t></t></t></request<?></t></t></t></request<?></request<?></t></t></t></requestfinishedlistener></requestfinishedlistener></request<?></request<?></request<?></request<?></request<?></request<?></string,></string,></t></t></code></pre><p>&#160;&#160;&#160;&#160;上面介绍了Volley.java和RequestQueue.java两大类，Volley是对外的入口，而RequestQueue是Volley框架中最核心的部分了。如果注释上面有写错了或者有疑问的地方，还请各位直接指出在下一篇博客中将继续向下深入，结合源代码分析什么是Dispatcher。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/01/16/Volley框架解析-二-Volley及RequestQueue解析/" data-id="cijh2hrjx000a7nutr7w0py9a" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Volley/">Volley</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Volley框架解析-一-整体介绍" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/01/16/Volley框架解析-一-整体介绍/" class="article-date">
  <time datetime="2016-01-16T10:06:40.000Z" itemprop="datePublished">2016-01-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/16/Volley框架解析-一-整体介绍/">Volley框架解析(一)-----整体介绍</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>&#160;&#160;&#160;&#160;感谢各位菊苣，<a href="https://github.com/grumoon" title="grumoon" target="_blank" rel="external">grumoon</a>,<a href="https://github.com/huxian99" title="huxian99" target="_blank" rel="external">huxian99</a>,<a href="https://github.com/trinea" title="trinea" target="_blank" rel="external">trinea</a>,<a href="http://blog.csdn.net/guolin_blog" title="郭霖juju" target="_blank" rel="external">郭霖juju</a>的图片素材，以及详细的分析。</p>
<p>&#160;&#160;&#160;&#160;其他菊苣关于Volley解析的链接如下：</p>
<p>&#160;&#160;&#160;&#160;<a href="http://www.codekk.com/open-source-project-analysis/detail/Android/grumoon/Volley%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90" target="_blank" rel="external">codeKK—Volley源码解析</a></p>
<p>&#160;&#160;&#160;&#160;<a href="http://blog.csdn.net/guolin_blog/article/details/17482095/" title="郭霖juju" target="_blank" rel="external">郭霖juju—Android Volley完全解析(一)，初识Volley的基本用法</a></p>
<hr>
<p>##题外话(可直接跳过orz<br>&#160;&#160;&#160;&#160;在Android路上的第一个涉及到网络的项目中，就用到了Volley，当时也就照着网上的方法用了用，用到后面发现满足不了需求之后，尝试着去自定义了一些request，自己去结合Volley来处理服务器返回的cookie。第一个项目已经过去时间比较长了，突然想到想深入的了解下Volley,于是就开始了Volley源码之旅…..本人比较笨，需要比其他人花更多的时间来消化，没办法orz。看了比较长的一段时间后，把自己边看边写的笔记拿出来和大家分享。</p>
<p>##1. Volley简介</p>
<p>####1.1 Volley是什么<br>&#160;&#160;&#160;&#160;Volley是Google推出的Android异步网络请求框架和图片加载的框架。适合数据量小的,通信频繁的各种请求,官方已经封装好了各种API,而且还提供了很灵活的自定义请求接口,不仅使用起来方便,可扩展性也很强。来一张google配图 (也是偷的orz，pia~, 啊哦，表打脸…<br><img src="https://raw.githubusercontent.com/android-cn/android-open-project-analysis/master/tool-lib/network/volley/image/volley.png" alt="volley"></p>
<p>&#160;&#160;&#160;&#160;可以通过下面的几种途径获取到volley的代码：</p>
<pre><code>git clone https://android.googlesource.com/platform/frameworks/volley  

jar包下载地址： http://www.kwstu.com/ResourcesView/kwstu_201441183330928 
</code></pre><p>####1.2 整体框架<br>&#160;&#160;&#160;&#160;这是从上面提到的菊苣那里拿来的一张图，十分感谢Orz,这张图大致的分析出了Volley中Request从开始到结束需要经历的一个流程，在后面会详细的分析request每一步的动向，这里先简单的做个介绍。<br><img src="https://raw.githubusercontent.com/android-cn/android-open-project-analysis/master/tool-lib/network/volley/image/design.png" alt="design"></p>
<p>&#160;&#160;&#160;&#160;最开始用到Volley发送请求的时候需要通过如下的几行代码(注意给应用添加网络访问的权限)，</p>
<pre><code>//先新建一个请求队列(RequestQueue)
RequestQueue mQueue = Volley.newRequestQueue(context); 

//新建一个request
StringRequest stringRequest = new StringRequest(&quot;http://www.xxxxxxx.com&quot;,  
                    new Response.Listener&lt;String&gt;() {  
                        @Override  
                        public void onResponse(String response) {  
                            Log.d(&quot;TAG&quot;, response);  
                        }  
                    }, new Response.ErrorListener() {  
                        @Override  
                        public void onErrorResponse(VolleyError error) {  
                            Log.e(&quot;TAG&quot;, error.getMessage(), error);  
                        }  
                    });

//将request加入到队列(RequestQueue)当中
mQueue.add(stringRequest); 
</code></pre><p>&#160;&#160;&#160;&#160;做完上面的这些工作,如果不出问题，等着request返回结果就可以了。结合上面的图片，mQueue(<strong>RequestQueue</strong>)被创建之后，会启动新的工作线程(<strong>dispatcher</strong>)开始工作，mQueue里面有专门用来存放request的容器，只要没被stop,这些工作线程会不停的从容器中取出request进行处理,工作线程大致分为两类：</p>
<ol>
<li>处理有缓存存在的request的dispatcher。该工作线程会涉及到从之前存储的有效缓存(<strong>cache</strong>)中读取数据并返回给调用者。</li>
<li>处理网络请求的request的dispatcher。该工作线程会涉及到从网络(<strong>network</strong>)获取有效的数据，并返回合适数据给调用者，并会根据request的设置来决定是否将请求结果缓存到本地。</li>
</ol>
<p>&#160;&#160;&#160;&#160;在工作线程得到了请求响应结果response之后，会将response交给<strong>ResponseDelivery</strong>来处理并通过回调传递给调用者。</p>
<p>&#160;&#160;&#160;&#160;通过上面的介绍，应该能大致的了解volley中，一个request创建并加入到RequestQueue之后大致的一个走向。</p>
<p>####1.3 基础类的简介<br>&#160;&#160;&#160;&#160;在Volley中一共有43个类(不知道当前阅读的是否为最新版本的，不过核心类差不了很远）,主要介绍一下核心类以及其在Volley中起的作用，后面会对核心类的每行代码进行展开分析。</p>
<p><strong>Volley.java:</strong> 从上面的用法<code>Volley.newRequestQueue</code>就能看出，Volley类是对外的接口，里面仅有4个重载了的<code>newRequestQueue()</code>函数，用来以各种不同的方式创建并启动一个RequestQueue。</p>
<p><strong>RequestQueue.java:</strong> 外界通过Volley中的接口来创建其实例，RequestQueue的作用就是存放所有add进来的Request(所有的Request不仅会存放在<code>mCurrentRequests</code>里面，其原型是一个HashSet。而且Request还会被分类存放在<code>mCacheQueue</code>和<code>mNetworkQueue</code>中，分类的标准是是否涉及到网络数据的获取),并且里面会有两类调度器<code>mDispatchers</code>和<code>mCacheDispatcher</code>来负责处理Request。前者用来处理涉及到网络的Request，后者用来处理直接从缓存中获取数据的Request。它俩获得了数据之后都会交给<code>mDelivery</code>(ResponseDelivery.java的实例)来传递回caller。</p>
<p><strong>Request.java:</strong> 请求类的基类，所有请求类都从该类继承。里面包含了请求方法(POST,GET等)，用户可自定义符合需求的Request，自由度很大。</p>
<p><strong>NetworkDispatcher.java:</strong> 处理网络请求的调度器，继承自<code>Thread</code>类，其中包含了用于存储涉及网络请求的<code>mQueue</code>，以及用于网络请求的接口类<code>mNetwork</code>(Network.java实例)。在被停止之前进行死循环，调度器会不停的从<code>mQueue</code>中取出request来处理，将结果通过<code>mCache</code>(Cache.java实例)写入本地缓存中，通过<code>mDelivery</code>(ResponseDelivery.java实例)将结果回传给caller。</p>
<p><strong>CacheDispatcher.java:</strong> 处理缓存请求的调度器，继承自<code>Thread</code>类，包含了用于存储涉及缓存请求的队列<code>mCacheQueue</code>，和上面的网络调度器工作原理类似。只是从缓存中取出数据再通过<code>mDelivery</code>返回给caller。</p>
<p><strong>ResponseDelivery.java:</strong> 一个用于将Response传递给调用者的回调接口，包含了两类回调方法，<code>postResponse(Request&lt;?&gt; request, Response&lt;?&gt; response, Runnable runnable)</code>和<code>postError(Request&lt;?&gt; request, VolleyError error)</code>。</p>
<p><strong>Network.java:</strong> 用于网络请求调用的接口，包含一个方法<code>performRequest()</code>。</p>
<p><strong>BasicNetwork.java:</strong> 继承了Network类，是Volley中默认使用的网络请求处理工具类。在该类里面会处理Request发送前的一系列工作，以及发送工作和发送后返回NetworkResponse的解析工作。里面真正实现网络请求的发送工作是利用了其中的<code>mHttpStack</code>(HttpStack.java实例)。</p>
<p><strong>HttpStack.java:</strong> 网络请求接口类，包含一个方法<code>performRequest(Request&lt;?&gt; request, Map&lt;String, String&gt; additionalHeaders)</code>。该方法和BasicNetwork类中实现的方法<code>performRequest(Request&lt;?&gt; request)</code>不同。前者在后者的方法中被调用，来实现真正的网络请求。</p>
<p><strong>HurlStack.java:</strong> 实现了HttpStack接口，在android版本在2.3之上的系统中，通过HttpURLConnection类实现网络请求。</p>
<p><strong>HttpClientStack.java:</strong> 实现了HttpStack接口，在android版本在2.3之下的系统中，通过HttpClient类实现网络请求。</p>
<p><strong>Cache.java:</strong> 读写缓存类的接口类，抽象出了一系列有关缓存读写的方法。</p>
<p><strong>DiskBasedCache.java:</strong> 继承并实现了Cache中的一系列方法，是Volley中默认使用的缓存读写工具类。</p>
<p><strong>Response.java:</strong> Volley自定义的bean类，Request通过上面实现了HttpStack接口的两种实现方法发出之后，会返回相应的<code>NetworkResponse</code>类实例，这个类是<code>org.apache.http</code>包里面的类，<code>NetworkResponse</code>实例返回后，解析出有用的信息，并组成Response实例。</p>
<p>&#160;&#160;&#160;&#160;上面简单的介绍了Volley中的核心类，再盗用一张图orz，再次感谢上面的菊苣们。<img src="https://raw.githubusercontent.com/android-cn/android-open-project-analysis/master/tool-lib/network/volley/image/Volley-run-flow-chart.png" alt="design"></p>
<p>&#160;&#160;&#160;&#160;上图清晰的画出了，请求从加入到队列，怎么被分步骤处理，分缓存和网络两条路径，先查询是否存在请求对应的缓存，如存在有效缓存则直接取出缓存数据返回给调用者，如不存在有效缓存则从网络获取数据，写入缓存并返回将结果返回给调用者。</p>
<p>&#160;&#160;&#160;&#160;对Volley整体上的简单介绍就先到这里了，后面会将阅读源码时候的笔记整理之后再和大家分享。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/01/16/Volley框架解析-一-整体介绍/" data-id="cijh2hrk1000g7nutx5vlz9q2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Volley/">Volley</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Ubuntu上结合Github用Hexo搭建博客" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/01/16/Ubuntu上结合Github用Hexo搭建博客/" class="article-date">
  <time datetime="2016-01-16T08:14:54.000Z" itemprop="datePublished">2016-01-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/16/Ubuntu上结合Github用Hexo搭建博客/">Ubuntu上结合Github用Hexo搭建博客</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>这就是标题</strong><br>&#160;&#160;&#160;&#160;之前用过CSDN，其他的都没怎么用，什么博客园之类的技术平台，身边的小伙子们都齐刷刷的搭好了自己的技术博客，自己心里也有点痒痒了，抽了个小时间来折腾下。毕竟Hexo已经6的飞起了。</p>
<p><strong>为什么写这个东西</strong><br>&#160;&#160;&#160;&#160;为什么写这篇，网上那么多关于Hexo搭建博客的，各种大神博客齐飞，是，我承认我肯定是看了他们的博客之后，自己弄了半天才写出的这个东西。那我这么说吧，写这个东西纯粹是为了给我的小波可(博客)过一个生日不行？嗯？？刚生下来的小波可还需要用我日后的经验积累来投食，所以从现在开始我要好好的养它。废话说多了点，在华丽丽的分割线下面，是小波可诞生的日志。</p>
<hr>
<h3 id="u7B80_u4ECB"><a href="#u7B80_u4ECB" class="headerlink" title="简介"></a>简介</h3><p>&#160;&#160;&#160;&#160;在搭建博客的过程中会涉及到下面这些东西：</p>
<ol>
<li>Hexo</li>
<li>Git</li>
<li>Github Pages</li>
<li>Npm</li>
<li>Nodejs</li>
</ol>
<p><strong><a href="https://github.com/hexojs/hexo" target="_blank" rel="external">Hexo</a></strong></p>
<p>&#160;&#160;&#160;&#160;说了这么多，什么是Hexo呢，首先它肯定是不能吃的，因为吃了会胃疼，不吃就不会。其次它流弊的作者给它定义如下：</p>
<pre><code>一款基于Node.js的简单、快速、强大的静态博客框架
</code></pre><p><strong>Hexo搭建博客和github有什么关系</strong></p>
<p>&#160;&#160;&#160;&#160;那Hexo就是一个博客框架，关Github什么事情呢，这还被你说对了，还真不怎么和github相关，用hexo弄一个博客出来很简单。当然你也可以选择用wordpress来结合hexo，只是这里选择用github pages服务，那又说到了一个东西:<strong>github pages</strong>。</p>
<p><strong><a href="https://pages.github.com/" target="_blank" rel="external">Github Pages</a></strong></p>
<p>&#160;&#160;&#160;&#160;上面是网址，可以自己进去看看，简单的说就是github提供的一种用来展示托管在自己github仓库上的静态网页。github pages也有自己的一套框架，只用github pages也可以搭建自己的博客。</p>
<p><strong><a href="https://www.npmjs.com/" target="_blank" rel="external">Npm</a></strong></p>
<p>&#160;&#160;&#160;&#160;一个NodeJs包管理和分发工具，全称为Node Package Manager。和Ruby的gem，Python的pypi类似。通过npm能快速的部署hexo框架，毕竟hexo基于nodejs。</p>
<p><strong><a href="https://nodejs.org/en/" target="_blank" rel="external">Node.js</a></strong></p>
<p>&#160;&#160;&#160;&#160;Node是一个Javascript运行环境(runtime)。实际上它是对Google V8引擎进行了封装。V8引 擎执行Javascript的速度非常快，性能非常好。Node对一些特殊用例进行了优化，提供了替代的API，使得V8在非浏览器环境下运行得更好。</p>
<h3 id="u5B89_u88C5"><a href="#u5B89_u88C5" class="headerlink" title="安装"></a>安装</h3><h4 id="1-__u5B89_u88C5Node-js"><a href="#1-__u5B89_u88C5Node-js" class="headerlink" title="1. 安装Node.js"></a>1. 安装Node.js</h4><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;在Ubuntu下面部署很容易的= =,在终端输入：</p>
<pre><code>sudo apt-get install --yes nodejs
</code></pre><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Nodejs的部署工作就完成了。其他的Linux发行版可以参照下面的教程<a href="https://github.com/nodejs/node-v0.x-archive/wiki/Installing-Node.js-via-package-manager" target="_blank" rel="external">Installing Node.js via package manager</a></p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;也可以在Node的官网上直接<a href="https://nodejs.org/en/download/" target="_blank" rel="external">下载</a>安装。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;安装好之后，在终端输入nodejs即可进入到nodejs的交互模式中。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<strong>Note</strong><br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;需要注意一个问题就是，在hexo中的nodejs文件在运行时使用的是<code>node xxx/js</code>这样的形式，而在Ubuntu下面直接运行<code>node xxx.js</code>会失败，报错为<code>/usr/bin/env: node: No such file or directory</code>，网上有些说是和node的版本有关，实际上是因为NodeJs在Ubuntu上默认安装之后，需要<code>nodejs xxx.js</code>这样用，解决方法为创建如下软链接，保证可以运行<code>node xxx.js</code>:</p>
<pre><code>ln -s /usr/bin/nodejs /usr/bin/node
</code></pre><h4 id="2-__u5B89_u88C5npm"><a href="#2-__u5B89_u88C5npm" class="headerlink" title="2. 安装npm"></a>2. 安装npm</h4><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;在终端输入：</p>
<pre><code>sudo apt-get install npm
</code></pre><h4 id="3-__u5B89_u88C5hexo"><a href="#3-__u5B89_u88C5hexo" class="headerlink" title="3. 安装hexo"></a>3. 安装hexo</h4><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;终端输入：</p>
<pre><code>npm install hexo-cli -g
</code></pre><p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;在这里可能会报错，由于没有root权限导致无法安装hexo，<code>sudo su</code>root一下再安装一次就好了。</p>
<p>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;到这里就完成了对Hexo的初步安装了，直接在终端输入<code>hexo</code>会出现相关的信息。</p>
<h4 id="4-__u5B89_u88C5git"><a href="#4-__u5B89_u88C5git" class="headerlink" title="4. 安装git"></a>4. 安装git</h4><p>&#160;&#160;&#160;&#160;首先安装git</p>
<pre><code>sudo apt-get update
sudo apt-get install git
</code></pre><p>&#160;&#160;&#160;&#160;设置用户信息</p>
<pre><code>$ git config --global user.name &quot;Xiaojuanmao&quot;//用户名
$ git config --global user.email  &quot;daque@hustunique.com&quot;//填写自己的邮箱
</code></pre><p>&#160;&#160;&#160;&#160;检查SSH keys</p>
<pre><code>$ cd ~/. ssh
</code></pre><p>&#160;&#160;&#160;&#160;如果提示No such file or directory 说明你是第一次使用git。按照如下步骤处理SSH Keys，如果存在SSH Keys，则直接跳过下面分割线内的部分。</p>
<hr>
<p><strong>配置SSH Keys</strong></p>
<ul>
<li><p>生成新的SSH Keys</p>
<pre><code>$ ssh-keygen -t rsa -C &quot;邮件地址@youremail.com&quot;
</code></pre><p>  会出现下面的提示：</p>
<pre><code>Generating public/private rsa key pair.
Enter file in which to save the key
(/Users/your_user_directory/.ssh/id_rsa):
</code></pre><p>  直接回车，存储在默认的目录下面。系统会提示输入密码，密码的作用是在向仓库提交代码的时候用到，可以防止其他人向自己的仓库提交代码。输入密码后，相关的会生成.ssh文件。</p>
</li>
<li><p>添加新的SSH Keys到GitHub</p>
<p>  通过下面的命令进入目录，该目录下存放着刚才生成的密钥文件</p>
<pre><code>$ cd ~/. ssh
</code></pre><p>  登陆github系统。点击右上角的 Account Settings—-&gt;SSH Public keys —-&gt; add another public keys。打开刚才目录下面的<code>id_rsa.pub</code>文件，将文件内容复制到key文本框中就可以了。</p>
</li>
<li><p>测试SSH<br>  可以输入下面的命令，测试SSH是否设置成功</p>
<pre><code>ssh -T git@github.com
</code></pre><p>  如果出现下面的信息，则说明设置成功</p>
<pre><code>Hi XXX! You&apos;ve successfully authenticated, but GitHub does not provide shell access.
</code></pre><p>  <strong>Note</strong><br>  也可能会报出错误：<code>Agent admitted failure to sign using the key.Permission denied (publickey).</code>这是由于没有将新建的ssh密钥加入，下面的命令可以解决：</p>
<pre><code>ssh-add   ~/.ssh/id_rsa
</code></pre></li>
</ul>
<hr>
<h3 id="u4F7F_u7528"><a href="#u4F7F_u7528" class="headerlink" title="使用"></a>使用</h3><h4 id="1-__u4F7F_u7528github_u521B_u5EFA_u535A_u5BA2_u4ED3_u5E93"><a href="#1-__u4F7F_u7528github_u521B_u5EFA_u535A_u5BA2_u4ED3_u5E93" class="headerlink" title="1. 使用github创建博客仓库"></a>1. 使用github创建博客仓库</h4><p>&#160;&#160;&#160;&#160;在github上创建一个仓库，<strong>仓库的名字和用户名必须对应</strong>，如我的帐户名为<code>Xiaojuanmao</code>,则创建的仓库名称为<code>Xiaojuanmao.github.io</code>。这样存放在github上的远程仓库就准备好了，下面来用hexo来初始化本地的仓库内容。</p>
<h4 id="2-_Hexo_u521D_u59CB_u5316"><a href="#2-_Hexo_u521D_u59CB_u5316" class="headerlink" title="2. Hexo初始化"></a>2. Hexo初始化</h4><p>&#160;&#160;&#160;&#160;在主文件夹下创建一个hexo文件夹，进入文件夹，在终端输入如下的命令</p>
<pre><code>hexo init
</code></pre><p>&#160;&#160;&#160;&#160;会给出这样的反馈：<code>INFO  Copying data to ~/hexo INFO  You are almost done! Don&#39;t forget to run &#39;npm install&#39; before you start blogging with Hexo!</code></p>
<p>&#160;&#160;&#160;&#160;接着按照上面的提示，输入命令</p>
<pre><code>npm install
</code></pre><p>&#160;&#160;&#160;&#160;会自动在目录下面安装node_modules。接着在命令行中启动本地的服务器，可以用来预览个人博客的样子：</p>
<pre><code>hexo server
</code></pre><p>&#160;&#160;&#160;&#160;反馈信息会提示已经在挂在了本地的服务器：<code>INFO  Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.</code></p>
<p>&#160;&#160;&#160;&#160;在浏览器中打开<code>http://0.0.0.0&quot;4000/</code>可以看到网页的整个框架已经生成了。有个默认的主题，如果觉得这个主题不好看，hexo还有好多主题可供更换。</p>
<h4 id="3-__u6DFB_u52A0_u6587_u7AE0"><a href="#3-__u6DFB_u52A0_u6587_u7AE0" class="headerlink" title="3. 添加文章"></a>3. 添加文章</h4><p>&#160;&#160;&#160;&#160;打开命令行，进入到hexo的目录下，利用如下的命令，可以新建一个.md格式的文件。</p>
<pre><code>hexo new &quot;My New Post&quot;
反馈信息：INFO  Created: ~/hexo/source/_posts/My-New-Post.md
</code></pre><p>&#160;&#160;&#160;&#160;刷新刚才的<code>localhost:4000</code>，就能看到一篇新的博客出现了，用起来还是炒鸡方便的。创建之后再去编辑这个.md文件，写自己想写的内容就可以了。</p>
<h4 id="4-__u751F_u6210_u9759_u6001_u7F51_u9875"><a href="#4-__u751F_u6210_u9759_u6001_u7F51_u9875" class="headerlink" title="4. 生成静态网页"></a>4. 生成静态网页</h4><p>&#160;&#160;&#160;&#160;下面的命令生成静态的网页，在将本地的内容部署到github上面去之前，一定要先执行这个步骤。</p>
<pre><code>hexo generate
   或者 hexo g
</code></pre><p>&#160;&#160;&#160;&#160;执行完之后，会在./public的目录下生成一系列的.html,.css文件。</p>
<h4 id="5-__u90E8_u7F72_u5230Github"><a href="#5-__u90E8_u7F72_u5230Github" class="headerlink" title="5. 部署到Github"></a>5. 部署到Github</h4><p>&#160;&#160;&#160;&#160;在和github完成对接之前，需要去配置hexo自己的配置文件<code>_config.yml</code>。关于这个文件里面的一些内容，需要进行一些修改：</p>
<pre><code># Hexo Configuration
## Docs: http://hexo.io/docs/configuration.html
## Source: https://github.com/hexojs/hexo/

# Site
title: Xiaojuanmao&apos;s Blog # 网站的标题
subtitle: Life began in 1990 # 网站的副标题
description: Coding Life # 显示在网页最下面的描述，类似于tag
author: Xiaoxiaoda
email: daque@hustunique.com
language: zh_CN
timezone:

# Deployment
## Docs: http://hexo.io/docs/deployment.html
deploy:
  type: git #这里不要写github了，hexo3.0之后用git代替了github
  repository: git@github.com:Xiaojuanmao/Xiaojuanmao.github.io.git # 填写自己的git仓库地址，之前创建好了的
  branch: master
</code></pre><p>&#160;&#160;&#160;&#160;更改完配置文件之后保存，通过下面的命令部署到github上：</p>
<pre><code>hexo generate 或者 hexo g  #生成静态网页
hexo deploy 或者 hexo d #部署到github
上面两个命令可以和并为 hexo d -g
</code></pre><p><strong>Note</strong><br>&#160;&#160;&#160;&#160;部署的过程中可能会出现如下的问题：</p>
<pre><code>ERROR Deployer not found: github
</code></pre><p>&#160;&#160;&#160;&#160;遇到这个不要慌，是hexo升级到3.0之后用git代替了github，所以需要再输入下面的命令，安装git的deployer</p>
<pre><code>npm install hexo-deployer-git --save
</code></pre><p>&#160;&#160;&#160;&#160;安装之后就可以将静态的网页部署到github的远程仓库上面。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/01/16/Ubuntu上结合Github用Hexo搭建博客/" data-id="cijh2hrj400007nutqj0nrc01" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Hexo/">Hexo</a></li></ul>

    </footer>
  </div>
  
</article>


  
  
</section>
        
          <aside id="sidebar">
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/">Hexo</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Volley/">Volley</a><span class="tag-list-count">7</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/Volley/" style="font-size: 20px;">Volley</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">一月 2016</a><span class="archive-list-count">8</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/01/16/Volley框架解析-七-Request解析/">Volley框架解析(七)-----Request解析</a>
          </li>
        
          <li>
            <a href="/2016/01/16/Volley框架解析-六-Cache接口及其默认实现类解析/">Volley框架解析(六)-----Cache接口及其默认实现类解析</a>
          </li>
        
          <li>
            <a href="/2016/01/16/Volley框架解析-五-HttpStack接口及其默认实现类解析/">Volley框架解析(五)-----HttpStack接口及其默认实现类解析</a>
          </li>
        
          <li>
            <a href="/2016/01/16/Volley框架解析-四-Network接口及其默认实现类解析/">Volley框架解析(四)-----Network接口及其默认实现类解析</a>
          </li>
        
          <li>
            <a href="/2016/01/16/Volley框架解析-三-Dispatcher解析/">Volley框架解析(三)-----Dispatcher解析</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 Xiaoxiaoda<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>