<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh_CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="volley," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="Volley框架解析(四)—–Network接口及其默认实现类解析1. 前言&amp;#160;&amp;#160;&amp;#160;&amp;#160;前面的三篇Volley框架解析文章已经从Volley对外暴露的接口Volley.java开始，向下慢慢深入到了RequestQueue.java，这个Volley中比较核心的类，然后又分析了Volley中负责主要request调度工作的两类Dispatcher，Network">
<meta property="og:type" content="article">
<meta property="og:title" content="Volley框架解析-四-Network接口及其实现">
<meta property="og:url" content="http://xiaojuanmao.github.io/2017/03/20/Volley框架解析-四-Network接口及其实现/index.html">
<meta property="og:site_name" content="Retro41's Life">
<meta property="og:description" content="Volley框架解析(四)—–Network接口及其默认实现类解析1. 前言&amp;#160;&amp;#160;&amp;#160;&amp;#160;前面的三篇Volley框架解析文章已经从Volley对外暴露的接口Volley.java开始，向下慢慢深入到了RequestQueue.java，这个Volley中比较核心的类，然后又分析了Volley中负责主要request调度工作的两类Dispatcher，Network">
<meta property="og:updated_time" content="2017-03-21T06:38:09.107Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Volley框架解析-四-Network接口及其实现">
<meta name="twitter:description" content="Volley框架解析(四)—–Network接口及其默认实现类解析1. 前言&amp;#160;&amp;#160;&amp;#160;&amp;#160;前面的三篇Volley框架解析文章已经从Volley对外暴露的接口Volley.java开始，向下慢慢深入到了RequestQueue.java，这个Volley中比较核心的类，然后又分析了Volley中负责主要request调度工作的两类Dispatcher，Network">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://xiaojuanmao.github.io/2017/03/20/Volley框架解析-四-Network接口及其实现/"/>





  <title> Volley框架解析-四-Network接口及其实现 | Retro41's Life </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh_CN">

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Retro41's Life</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Begin in 1990</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            Über
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archiv
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://xiaojuanmao.github.io/2017/03/20/Volley框架解析-四-Network接口及其实现/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Retro41">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Retro41's Life">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Retro41's Life" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Volley框架解析-四-Network接口及其实现
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-20T23:34:06+08:00">
                2017-03-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="Volley框架解析-四-—–Network接口及其默认实现类解析"><a href="#Volley框架解析-四-—–Network接口及其默认实现类解析" class="headerlink" title="Volley框架解析(四)—–Network接口及其默认实现类解析"></a>Volley框架解析(四)—–Network接口及其默认实现类解析</h2><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>&#160;&#160;&#160;&#160;前面的三篇Volley框架解析文章已经从Volley对外暴露的接口Volley.java开始，向下慢慢深入到了RequestQueue.java，这个Volley中比较核心的类，然后又分析了Volley中负责主要request调度工作的两类Dispatcher，<code>NetworkDispatcher</code>以及<code>CacheDispatcher</code>。应该是将一个request从新建，到加入队列中等待处理，如何被处理以及返回结果或者error这一系列的流程理顺了。</p>
<p>&#160;&#160;&#160;&#160;但是对于一些细节的问题还是不清楚，例如request究竟是如何发送出去，通过<code>NetworkResponse networkResponse = mNetwork.performRequest(request);</code>这么一句话就返回了结果(response)，这里面发生了些什么还不得而知，还有<code>Network#performRequest()</code>和<code>HttpStack#performRequest()</code>这两个函数之间有什么区别和联系等等。</p>
<a id="more"></a>
<h3 id="2-Network-java"><a href="#2-Network-java" class="headerlink" title="2. Network.java"></a><a href="#2-_Network-java" title="2\. Network.java"></a>2. Network.java</h3><p>&#160;&#160;&#160;&#160;最早接触到Network这个类是在<code>Volley.java</code>中的<code>newRequestQueue()</code>函数里面，<code>Network network = new BasicNetwork(stack);</code>创建了一个Network接口引用，并指向了一个Volley中的默认实现类的实例<code>BasicNetwork.java</code>，这个默认实现类也会在这篇博客的后面详细的解析。</p>
<p>&#160;&#160;&#160;&#160;经过前面几篇博客的分析，<code>Volley.java</code>仅仅是持有而没有使用，仅将这个引用传递给了<code>NetworkDispatcher.java</code>中，只有在<code>NetworkDispatcher.java</code>类中用到了这个Network接口，在<code>NetowkrDispatcher.java</code>中存在着这么一行代码，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NetworkResponse networkResponse = mNetwork.performRequest(request);</div></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;仅仅用了一句话就将request发送出去了，并且还拿回来了一个<code>NetworkResponse.java</code>类对象。里面发生了什么= =，先进去Network.java里面看看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">package com.android.volley;</div><div class="line"></div><div class="line">/**</div><div class="line"> * An interface for performing requests.</div><div class="line"> */</div><div class="line">public interface Network &#123;</div><div class="line">    /**</div><div class="line">     * Performs the specified request.</div><div class="line">     * 用来发送特定的请求</div><div class="line">     *</div><div class="line">     * @param request Request to process</div><div class="line">     * 即将被发送的request</div><div class="line">     *</div><div class="line">     * @return A &#123;@link NetworkResponse&#125; with data and caching metadata; will never be null</div><div class="line">     * 请求之后返回的response, 是volley自己构造出来的一个response</div><div class="line">     * 里面包含了返回的请求码等等。</div><div class="line">     *</div><div class="line">     * @throws VolleyError on errors</div><div class="line">     */</div><div class="line">    public NetworkResponse performRequest(Request&lt;?&gt; request) throws VolleyError;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对，没有看错= =，就这么点东西，仅仅一个抽象方法而已，Network.java就是一个等待被实现的接口，想看真东西，还需要进去<code>Network network = new BasicNetwork(stack);</code>里面所提到的<code>BasicNetwork.java</code>看看。</p>
<h3 id="3-BasicNetwork-java"><a href="#3-BasicNetwork-java" class="headerlink" title="3. BasicNetwork.java"></a><a href="#3-_BasicNetwork-java" title="3\. BasicNetwork.java"></a>3. BasicNetwork.java</h3><p><code>Network.java</code>接口的默认实现类，该类里面会处理一些request发送前后的处理工作，主要是对请求返回的httpResponse处理，以及对请求失败进行retry或者抛出异常的处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div><div class="line">346</div><div class="line">347</div><div class="line">348</div><div class="line">349</div><div class="line">350</div><div class="line">351</div><div class="line">352</div><div class="line">353</div><div class="line">354</div><div class="line">355</div><div class="line">356</div><div class="line">357</div><div class="line">358</div><div class="line">359</div><div class="line">360</div><div class="line">361</div><div class="line">362</div><div class="line">363</div><div class="line">364</div><div class="line">365</div><div class="line">366</div><div class="line">367</div><div class="line">368</div><div class="line">369</div><div class="line">370</div><div class="line">371</div><div class="line">372</div><div class="line">373</div><div class="line">374</div><div class="line">375</div><div class="line">376</div><div class="line">377</div><div class="line">378</div><div class="line">379</div><div class="line">380</div><div class="line">381</div><div class="line">382</div><div class="line">383</div><div class="line">384</div><div class="line">385</div><div class="line">386</div><div class="line">387</div><div class="line">388</div><div class="line">389</div><div class="line">390</div><div class="line">391</div><div class="line">392</div><div class="line">393</div><div class="line">394</div><div class="line">395</div><div class="line">396</div><div class="line">397</div><div class="line">398</div><div class="line">399</div><div class="line">400</div><div class="line">401</div><div class="line">402</div><div class="line">403</div><div class="line">404</div><div class="line">405</div><div class="line">406</div><div class="line">407</div><div class="line">408</div><div class="line">409</div><div class="line">410</div><div class="line">411</div><div class="line">412</div><div class="line">413</div><div class="line">414</div><div class="line">415</div><div class="line">416</div><div class="line">417</div><div class="line">418</div><div class="line">419</div><div class="line">420</div><div class="line">421</div><div class="line">422</div><div class="line">423</div><div class="line">424</div></pre></td><td class="code"><pre><div class="line">package com.android.volley.toolbox;</div><div class="line"></div><div class="line">/**</div><div class="line"> * A network performing Volley requests over an &#123;@link HttpStack&#125;.</div><div class="line"> * 一个用来执行Volley中request的类</div><div class="line"> * 在HttpStack的基础之上</div><div class="line"> * 因为主要还是调用HttpStack接口的performRequest</div><div class="line"> * 在这个里面的performRequest主要还是做一些整理工作</div><div class="line"> * 比如将｛@link HttpStack#performRequest()｝方法返回的HttpResponse</div><div class="line"> * 解析成Volley自己实现的NetworkResponse.java</div><div class="line"> */</div><div class="line"></div><div class="line">public class BasicNetwork implements Network &#123;</div><div class="line"></div><div class="line">    //是否允许打lo的boolean常变量</div><div class="line">    protected static final boolean DEBUG = VolleyLog.DEBUG;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 这是一个阀值，用来判断一个request是否请求响应过慢了= =</div><div class="line">     * 在后面的作用就是，如果响应时间超过了这个阀值</div><div class="line">     * 打出log说明这个request有些慢，为了更好的反应request当前状态</div><div class="line">     */</div><div class="line">    private static int SLOW_REQUEST_THRESHOLD_MS = 3000;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 默认ByteArrayPool的大小</div><div class="line">     * 现在只需要知道ByteArrayPool.java是Volley用来从输入流中读取数据并将其转换成字节数组的工具即可</div><div class="line">     * 在这篇博客后面会介绍，表担心~= =</div><div class="line">     */</div><div class="line">    private static int DEFAULT_POOL_SIZE = 4096;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 网络请求的真正接口</div><div class="line">     * 为什么这么说咧，BasicNetwork里面的performRequest()函数</div><div class="line">     * 调用了HttpStack里的performRequest()，真正的网络请求还是通过HttpStack里面的方法实现的</div><div class="line">     * 在Volley中实现了HttpStack接口的类有两个 HurlStack.java和HttpClientStack.java</div><div class="line">     * 针对了不同Android系统版本，用不同的方法实现了请求。</div><div class="line">     */</div><div class="line">    protected final HttpStack mHttpStack;</div><div class="line"></div><div class="line">    //表急，后面会介绍到的，现在知道是一个用于数据转换的工具类就好了</div><div class="line">    protected final ByteArrayPool mPool;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * @param httpStack HTTP stack to be used</div><div class="line">     * 传入的HttpStack实现类引用</div><div class="line">     * 整个网络请求的较核心部分就在HttpStack实现类上面咯</div><div class="line">     */</div><div class="line">    public BasicNetwork(HttpStack httpStack) &#123;</div><div class="line">        // If a pool isn&apos;t passed in, then build a small default pool that will give us a lot of</div><div class="line">        // benefit and not use too much memory.</div><div class="line">        this(httpStack, new ByteArrayPool(DEFAULT_POOL_SIZE));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * @param httpStack HTTP stack to be used</div><div class="line">     * @param pool a buffer pool that improves GC performance in copy operations</div><div class="line">     * Volley接口分离的很明显，而且在构造函数里面也提供了很多种</div><div class="line">     * 可以定制出适合自己的ByteArrayPool衍生类</div><div class="line">     * 当然也可以自己来实现HttpStack的衍生类</div><div class="line">     */</div><div class="line">    public BasicNetwork(HttpStack httpStack, ByteArrayPool pool) &#123;</div><div class="line">        mHttpStack = httpStack;</div><div class="line">        mPool = pool;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 这个方法重写的是Network的方法</div><div class="line">     * 在这个里面再调用HttpStack里面的performRequest方法</div><div class="line">     */</div><div class="line">    @Override</div><div class="line">    public NetworkResponse performRequest(Request&lt;?&gt; request) throws VolleyError &#123;</div><div class="line"></div><div class="line">        /**</div><div class="line">         * Returns milliseconds since boot, including time spent in sleep.</div><div class="line">         * 为了方便计算每个request所用的时间</div><div class="line">         * 在处理每个request之前都记下此刻unix时间戳</div><div class="line">         */</div><div class="line">        long requestStart = SystemClock.elapsedRealtime();</div><div class="line"></div><div class="line">        /**</div><div class="line">         * 进入死循环= =</div><div class="line">         * 还没弄清楚为什么要死循环</div><div class="line">         */</div><div class="line">        while (true) &#123;</div><div class="line"></div><div class="line">            /**</div><div class="line">             * 指向HttpResponse实例的引用</div><div class="line">             * 是调用HttpStack方法performRequest()之后返回的结果</div><div class="line">             */</div><div class="line">            HttpResponse httpResponse = null;</div><div class="line"></div><div class="line">            /**</div><div class="line">             * 返回的HttpResponse还需要经过处理</div><div class="line">             * 并不是返回回来就是能直接使用的数据</div><div class="line">             * 需要通过上面的ByteArrayPool将Entity转换成byte[]</div><div class="line">             * 这个就是指向解析后的byte[]的</div><div class="line">             */</div><div class="line">            byte[] responseContents = null;</div><div class="line"></div><div class="line">            //用来存放response里面header的信息，包含了状态码等</div><div class="line">            Map&lt;String, String&gt; responseHeaders = Collections.emptyMap();</div><div class="line"></div><div class="line">            try &#123;</div><div class="line">                /**</div><div class="line">                 * Gather headers.</div><div class="line">                 * 设置header</div><div class="line">                 * 从缓存中收集上次相同request的信息</div><div class="line">                 */</div><div class="line">                Map&lt;String, String&gt; headers = new HashMap&lt;String, String&gt;();</div><div class="line"></div><div class="line">                /**</div><div class="line">                 * 将缓存的信息加入到headers中</div><div class="line">                 * headers会跟随request一起发送给服务器</div><div class="line">                 * 在函数的定义处会讲解</div><div class="line">                 */</div><div class="line">                addCacheHeaders(headers, request.getCacheEntry());</div><div class="line"></div><div class="line">                /**</div><div class="line">                 * 通过调用HttpStack接口的performRequest()方法</div><div class="line">                 * 获取服务器返回的HttpResponse</div><div class="line">                 */</div><div class="line">                httpResponse = mHttpStack.performRequest(request, headers);</div><div class="line"></div><div class="line">                /**</div><div class="line">                 * The first line of a Response message is the Status-Line, </div><div class="line">                 * consisting of the protocol version followed by a numeric status code and its associated textual phrase</div><div class="line">                 * with each element separated by SP characters. </div><div class="line">                 * No CR or LF is allowed except in the final CRLF sequence.</div><div class="line">                 * 请求返回的response第一行就是包含了状态码的一行</div><div class="line">                 */</div><div class="line">                StatusLine statusLine = httpResponse.getStatusLine();</div><div class="line">                int statusCode = statusLine.getStatusCode();</div><div class="line"></div><div class="line">                /**</div><div class="line">                 * 将头部解析成键值对的形式再返回</div><div class="line">                 */</div><div class="line">                responseHeaders = convertHeaders(httpResponse.getAllHeaders());</div><div class="line"></div><div class="line">                /**</div><div class="line">                 * Handle cache validation.</div><div class="line">                 * 处理缓存信息</div><div class="line">                 * 如果返回的状态码是304(HttpStatus.SC_NOT_MODIFIED)</div><div class="line">                 * 则进行如下的处理</div><div class="line">                 */</div><div class="line">                if (statusCode == HttpStatus.SC_NOT_MODIFIED) &#123;</div><div class="line"></div><div class="line">                    /**</div><div class="line">                     * 如果缓存为空的话</div><div class="line">                     * 那就说明该请求的返回的response的body就是null</div><div class="line">                     * 直接构造一个NetworkResponse返回</div><div class="line">                     */</div><div class="line">                    Entry entry = request.getCacheEntry();</div><div class="line">                    if (entry == null) &#123;</div><div class="line">                        return new NetworkResponse(HttpStatus.SC_NOT_MODIFIED, null,</div><div class="line">                                responseHeaders, true,</div><div class="line">                                SystemClock.elapsedRealtime() - requestStart);</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    // A HTTP 304 response does not have all header fields. We</div><div class="line">                    // have to use the header fields from the cache entry plus</div><div class="line">                    // the new ones from the response.</div><div class="line">                    // http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.5</div><div class="line">                    /**</div><div class="line">                     * 一个返回码为304的HttpResponse的header缺少一些信息</div><div class="line">                     * 需要我们将cache中的一些header信息加入到其中</div><div class="line">                     * 这样组成一个完整的NetworkResponse返回</div><div class="line">                     */</div><div class="line">                    entry.responseHeaders.putAll(responseHeaders);</div><div class="line">                    return new NetworkResponse(HttpStatus.SC_NOT_MODIFIED, entry.data,</div><div class="line">                            entry.responseHeaders, true,</div><div class="line">                            SystemClock.elapsedRealtime() - requestStart);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                /**</div><div class="line">                 * Handle moved resources</div><div class="line">                 * 处理了重定向的问题</div><div class="line">                 * 并将request的mRedirectUrl设定成了新的url</div><div class="line">                 */</div><div class="line">                if (statusCode == HttpStatus.SC_MOVED_PERMANENTLY || statusCode == HttpStatus.SC_MOVED_TEMPORARILY) &#123;</div><div class="line">                    String newUrl = responseHeaders.get(&quot;Location&quot;);</div><div class="line">                    request.setRedirectUrl(newUrl);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                /**</div><div class="line">                 * Some responses such as 204s do not have content.  We must check.</div><div class="line">                 * 204(无内容)服务器成功处理了请求，但没有返回任何内容。</div><div class="line">                 * </div><div class="line">                 */</div><div class="line">                if (httpResponse.getEntity() != null) &#123;</div><div class="line">                    /**</div><div class="line">                     * 如果entity不为Null</div><div class="line">                     * 将其转换成byte数组</div><div class="line">                     * 利用之前提到过的ByteArrayPool.java类</div><div class="line">                     */</div><div class="line">                  responseContents = entityToBytes(httpResponse.getEntity());</div><div class="line">                &#125; else &#123;</div><div class="line">                  // Add 0 byte response as a way of honestly representing a</div><div class="line">                  // no-content request.</div><div class="line">                  responseContents = new byte[0];</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                /**</div><div class="line">                 * if the request is slow, log it.</div><div class="line">                 * 获取request已经占用的时间(requestLifetime)</div><div class="line">                 * 判断是否需要打出request的超时状态</div><div class="line">                 */</div><div class="line">                long requestLifetime = SystemClock.elapsedRealtime() - requestStart;</div><div class="line">                logSlowRequests(requestLifetime, request, responseContents, statusLine);</div><div class="line"></div><div class="line">                /**</div><div class="line">                 * 如果状态码位于200之下或者是299之上(200-299 用于表示请求成功)</div><div class="line">                 * 则抛出IOException异常= =为什么非要抛出这个异常</div><div class="line">                 * 在前面过滤掉了(304等情况)</div><div class="line">                 */</div><div class="line">                if (statusCode &lt; 200 || statusCode &gt; 299) &#123;</div><div class="line">                    throw new IOException();</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                /**</div><div class="line">                 * 经过上面的层层过滤</div><div class="line">                 * 最后留下了200~299之间的请求成功response</div><div class="line">                 * 通过HttpResponse里面的信息构造出一个volley自己封装的NetworkResponse对象</div><div class="line">                 */</div><div class="line">                return new NetworkResponse(statusCode, responseContents, responseHeaders, false,</div><div class="line">                        SystemClock.elapsedRealtime() - requestStart);</div><div class="line"></div><div class="line">                /**</div><div class="line">                 * 抛出了异常之后，会用attemptREtryOnException()方法来尝试retry</div><div class="line">                 * 主要做的工作就是看是否还有retry的机会，如果有则不停通过这个死循环</div><div class="line">                 * 进行请求，直到请求成功或者请求的机会用完为止</div><div class="line">                 */</div><div class="line">            &#125; catch (SocketTimeoutException e) &#123;</div><div class="line">                attemptRetryOnException(&quot;socket&quot;, request, new TimeoutError());</div><div class="line">            &#125; catch (ConnectTimeoutException e) &#123;·</div><div class="line">                attemptRetryOnException(&quot;connection&quot;, request, new TimeoutError());</div><div class="line">            &#125; catch (MalformedURLException e) &#123;</div><div class="line">                throw new RuntimeException(&quot;Bad URL &quot; + request.getUrl(), e);</div><div class="line">            &#125; catch (IOException e) &#123;</div><div class="line">                /**</div><div class="line">                 * 状态码在0~200以及299之上的response</div><div class="line">                 * 处理的套路</div><div class="line">                 */</div><div class="line">                int statusCode = 0;</div><div class="line">                NetworkResponse networkResponse = null;</div><div class="line">                if (httpResponse != null) &#123;</div><div class="line">                    statusCode = httpResponse.getStatusLine().getStatusCode();</div><div class="line">                &#125; else &#123;</div><div class="line">                    //如果状态码为0，则抛出NoConnectionError</div><div class="line">                    throw new NoConnectionError(e);</div><div class="line">                &#125;</div><div class="line">                /**</div><div class="line">                 * 如果有重定向的情况发生</div><div class="line">                 * 用log打出</div><div class="line">                 */</div><div class="line">                if (statusCode == HttpStatus.SC_MOVED_PERMANENTLY || </div><div class="line">                        statusCode == HttpStatus.SC_MOVED_TEMPORARILY) &#123;</div><div class="line">                    VolleyLog.e(&quot;Request at %s has been redirected to %s&quot;, request.getOriginUrl(), request.getUrl());</div><div class="line">                &#125; else &#123;</div><div class="line">                    VolleyLog.e(&quot;Unexpected response code %d for %s&quot;, statusCode, request.getUrl());</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                /**</div><div class="line">                 * 如果返回的content内容不为Null</div><div class="line">                 * 则构造出一个NetworkResponse</div><div class="line">                 * 否则抛出NetworkError</div><div class="line">                 */</div><div class="line">                if (responseContents != null) &#123;</div><div class="line"></div><div class="line">                    networkResponse = new NetworkResponse(statusCode, responseContents,</div><div class="line">                            responseHeaders, false, SystemClock.elapsedRealtime() - requestStart);</div><div class="line"></div><div class="line">                    /**</div><div class="line">                     * 抛出了异常之后，会用attemptREtryOnException()方法来尝试retry</div><div class="line">                     * 主要做的工作就是看是否还有retry的机会，如果有则不停通过这个死循环</div><div class="line">                     * 进行请求，直到请求成功或者请求的机会用完为止</div><div class="line">                     */</div><div class="line">                    if (statusCode == HttpStatus.SC_UNAUTHORIZED ||</div><div class="line">                            statusCode == HttpStatus.SC_FORBIDDEN) &#123;</div><div class="line">                        attemptRetryOnException(&quot;auth&quot;,</div><div class="line">                                request, new AuthFailureError(networkResponse));</div><div class="line">                    &#125; else if (statusCode == HttpStatus.SC_MOVED_PERMANENTLY || </div><div class="line">                                statusCode == HttpStatus.SC_MOVED_TEMPORARILY) &#123;</div><div class="line">                        attemptRetryOnException(&quot;redirect&quot;,</div><div class="line">                                request, new AuthFailureError(networkResponse));</div><div class="line">                    &#125; else &#123;</div><div class="line">                        // TODO: Only throw ServerError for 5xx status codes.</div><div class="line">                        throw new ServerError(networkResponse);</div><div class="line">                    &#125;</div><div class="line">                &#125; else &#123;</div><div class="line">                    throw new NetworkError(networkResponse);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Logs requests that took over SLOW_REQUEST_THRESHOLD_MS to complete.</div><div class="line">     * 如果request用时超出了预先设定的阀值</div><div class="line">     * 则打出log用于debug时候的提示</div><div class="line">     */</div><div class="line">    private void logSlowRequests(long requestLifetime, Request&lt;?&gt; request,</div><div class="line">            byte[] responseContents, StatusLine statusLine) &#123;</div><div class="line">        if (DEBUG || requestLifetime &gt; SLOW_REQUEST_THRESHOLD_MS) &#123;</div><div class="line">            VolleyLog.d(&quot;HTTP response for request=&lt;%s&gt; [lifetime=%d], [size=%s], &quot; +</div><div class="line">                    &quot;[rc=%d], [retryCount=%s]&quot;, request, requestLifetime,</div><div class="line">                    responseContents != null ? responseContents.length : &quot;null&quot;,</div><div class="line">                    statusLine.getStatusCode(), request.getRetryPolicy().getCurrentRetryCount());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Attempts to prepare the request for a retry. If there are no more attempts remaining in the</div><div class="line">     * request&apos;s retry policy, a timeout exception is thrown.</div><div class="line">     * 每次尝试都会使retry机会减少1，如果机会没有了，则抛出请求超时的exception</div><div class="line">     *</div><div class="line">     * @param request The request to use.</div><div class="line">     */</div><div class="line">    private static void attemptRetryOnException(String logPrefix, Request&lt;?&gt; request,</div><div class="line">            VolleyError exception) throws VolleyError &#123;</div><div class="line">        RetryPolicy retryPolicy = request.getRetryPolicy();</div><div class="line">        int oldTimeout = request.getTimeoutMs();</div><div class="line"></div><div class="line">        try &#123;</div><div class="line">            retryPolicy.retry(exception);</div><div class="line">        &#125; catch (VolleyError e) &#123;</div><div class="line">            request.addMarker(</div><div class="line">                    String.format(&quot;%s-timeout-giveup [timeout=%s]&quot;, logPrefix, oldTimeout));</div><div class="line">            throw e;</div><div class="line">        &#125;</div><div class="line">        request.addMarker(String.format(&quot;%s-retry [timeout=%s]&quot;, logPrefix, oldTimeout));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 添加上缓存的header</div><div class="line">     * 如果有之前的缓存的信息</div><div class="line">     * 将里面的信息取出放入header中</div><div class="line">     * </div><div class="line">     * 这里面涉及到了一个条件请求</div><div class="line">     * 如果有缓存的话，header上面会带上一个If-Modified-Since关键字</div><div class="line">     * 服务器会先比较信息modified的时间，如果服务端的数据没有发生变化就返回304(也就是上面的 HttpStatus.SC_NOT_MODIFIED)</div><div class="line">     * 如果服务器的数据发生了变化，则会返回状态码200以及请求需要的数据(意思就是本地的数据需要刷新了，缓存不管用了)</div><div class="line">     */</div><div class="line">    private void addCacheHeaders(Map&lt;String, String&gt; headers, Cache.Entry entry) &#123;</div><div class="line">        // If there&apos;s no cache entry, we&apos;re done.</div><div class="line">        if (entry == null) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (entry.etag != null) &#123;</div><div class="line">            headers.put(&quot;If-None-Match&quot;, entry.etag);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (entry.lastModified &gt; 0) &#123;</div><div class="line">            Date refTime = new Date(entry.lastModified);</div><div class="line">            headers.put(&quot;If-Modified-Since&quot;, DateUtils.formatDate(refTime));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    protected void logError(String what, String url, long start) &#123;</div><div class="line">        long now = SystemClock.elapsedRealtime();</div><div class="line">        VolleyLog.v(&quot;HTTP ERROR(%s) %d ms to fetch %s&quot;, what, (now - start), url);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /** </div><div class="line">     * Reads the contents of HttpEntity into a byte[].</div><div class="line">     * 从HttpEntity中读取数据，并通过ByteArrayPool将其转换成byte[]</div><div class="line">     * 暂时不用管太多= =，等后面介绍到ByteArrayPool.java的时候就会明白</div><div class="line">     */</div><div class="line">    private byte[] entityToBytes(HttpEntity entity) throws IOException, ServerError &#123;</div><div class="line"></div><div class="line">        PoolingByteArrayOutputStream bytes =</div><div class="line">                new PoolingByteArrayOutputStream(mPool, (int) entity.getContentLength());</div><div class="line"></div><div class="line">        byte[] buffer = null;</div><div class="line"></div><div class="line">        try &#123;</div><div class="line">            InputStream in = entity.getContent();</div><div class="line">            if (in == null) &#123;</div><div class="line">                throw new ServerError();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            /**</div><div class="line">             * 获取一个大小为1024的缓冲区</div><div class="line">             */</div><div class="line">            buffer = mPool.getBuf(1024);</div><div class="line"></div><div class="line">            int count;</div><div class="line">            //将content的内容通过流每次最大读出1024个byte, 全部读出并写入bytes</div><div class="line">            while ((count = in.read(buffer)) != -1) &#123;</div><div class="line">                bytes.write(buffer, 0, count);</div><div class="line">            &#125;</div><div class="line">            return bytes.toByteArray();</div><div class="line">        &#125; finally &#123;</div><div class="line">            try &#123;</div><div class="line">                // Close the InputStream and release the resources by &quot;consuming the content&quot;.</div><div class="line">                entity.consumeContent();</div><div class="line">            &#125; catch (IOException e) &#123;</div><div class="line">                // This can happen if there was an exception above that left the entity in</div><div class="line">                // an invalid state.</div><div class="line">                VolleyLog.v(&quot;Error occured when calling consumingContent&quot;);</div><div class="line">            &#125;</div><div class="line">            /**</div><div class="line">             * 在所有工作完成之后</div><div class="line">             * 需要将从mPool中拿出的buffer缓冲区回收</div><div class="line">             */</div><div class="line">            mPool.returnBuf(buffer);</div><div class="line">            bytes.close();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Converts Headers[] to Map&lt;String, String&gt;.</div><div class="line">     * 将返回的response里面的header[]</div><div class="line">     * 全部转换成Map里面的键值对形式</div><div class="line">     */</div><div class="line">    protected static Map&lt;String, String&gt; convertHeaders(Header[] headers) &#123;</div><div class="line">        Map&lt;String, String&gt; result = new TreeMap&lt;String, String&gt;(String.CASE_INSENSITIVE_ORDER);</div><div class="line">        for (int i = 0; i &lt; headers.length; i++) &#123;</div><div class="line">            result.put(headers[i].getName(), headers[i].getValue());</div><div class="line">        &#125;</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="4-ByteArrayPool-java"><a href="#4-ByteArrayPool-java" class="headerlink" title="4. ByteArrayPool.java"></a><a href="#4-_ByteArrayPool-java" title="4\. ByteArrayPool.java"></a>4. ByteArrayPool.java</h3><p>ByteArrayPool.java是用来将HttpResponse中Entity通过stream的形式转换成byte[],主要的作用是提供缓冲区，用来辅助流数据的读取，在使用完成之后需要将使用过的缓冲区还给ByteArrayPool，ByteArrayPool里会对这些byte[]进行简单的回收处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 用来给外界提供byte[]作为缓冲区的一个工具类</div><div class="line"> */</div><div class="line">public class ByteArrayPool &#123;</div><div class="line">    /**</div><div class="line">     * The buffer pool, arranged both by last use and by buffer size </div><div class="line">     */</div><div class="line">    private List&lt;byte[]&gt; mBuffersByLastUse = new LinkedList&lt;byte[]&gt;();</div><div class="line">    private List&lt;byte[]&gt; mBuffersBySize = new ArrayList&lt;byte[]&gt;(64);</div><div class="line"></div><div class="line">    /**</div><div class="line">     * The total size of the buffers in the pool</div><div class="line">     * 缓冲池的当前大小</div><div class="line">     */</div><div class="line">    private int mCurrentSize = 0;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * The maximum aggregate size of the buffers in the pool. Old buffers are discarded to stay</div><div class="line">     * under this limit.</div><div class="line">     * 缓冲池当前的大小的阀值</div><div class="line">     * 超过了该值则会对缓冲池进行回收处理</div><div class="line">     */</div><div class="line">    private final int mSizeLimit;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Compares buffers by size</div><div class="line">     * 比较两个缓冲区的大小的规则</div><div class="line">     * 如果返回一个负数，则表示前一个数要小</div><div class="line">     * 如果返回0，则表示两个数字相等</div><div class="line">     * 如果返回一个正数，则表示后一个数要小</div><div class="line">     * </div><div class="line">     */</div><div class="line">    protected static final Comparator&lt;byte[]&gt; BUF_COMPARATOR = new Comparator&lt;byte[]&gt;() &#123;</div><div class="line">        @Override</div><div class="line">        public int compare(byte[] lhs, byte[] rhs) &#123;</div><div class="line">            return lhs.length - rhs.length;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * @param sizeLimit the maximum size of the pool, in bytes</div><div class="line">     * 用来修改缓冲池的大小阀值</div><div class="line">     */</div><div class="line">    public ByteArrayPool(int sizeLimit) &#123;</div><div class="line">        mSizeLimit = sizeLimit;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Returns a buffer from the pool if one is available in the requested size, or allocates a new</div><div class="line">     * one if a pooled one is not available.</div><div class="line">     * 从mBuffersBySize中调出一个缓冲区来</div><div class="line">     * 如果大小符合要求，则直接返回给调用者</div><div class="line">     * 如果没有符合要求的，直接创建一个新的byte[]返回</div><div class="line">     *</div><div class="line">     * @param len the minimum size, in bytes, of the requested buffer. The returned buffer may be</div><div class="line">     *        larger.</div><div class="line">     * @return a byte[] buffer is always returned.</div><div class="line">     */</div><div class="line">    public synchronized byte[] getBuf(int len) &#123;</div><div class="line">        for (int i = 0; i &lt; mBuffersBySize.size(); i++) &#123;</div><div class="line">            byte[] buf = mBuffersBySize.get(i);</div><div class="line">            if (buf.length &gt;= len) &#123;</div><div class="line">                mCurrentSize -= buf.length;</div><div class="line">                mBuffersBySize.remove(i);</div><div class="line">                mBuffersByLastUse.remove(buf);</div><div class="line">                return buf;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return new byte[len];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Returns a buffer to the pool, throwing away old buffers if the pool would exceed its allotted</div><div class="line">     * size.</div><div class="line">     * </div><div class="line">     * @param buf the buffer to return to the pool.</div><div class="line">     */</div><div class="line">    public synchronized void returnBuf(byte[] buf) &#123;</div><div class="line"></div><div class="line">        //如果buf为空或者超出了规定的大小，不管就行了，这种缓冲区用不着回收，因为= =根本就不符合要求嘛</div><div class="line"></div><div class="line">        if (buf == null || buf.length &gt; mSizeLimit) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //如果buf符合要求，则将其加入到最近使用的队列中去</div><div class="line"></div><div class="line">        mBuffersByLastUse.add(buf);</div><div class="line"></div><div class="line">        /**</div><div class="line">         * 通过二分查找，比较规则为BUF_COMPARATOR，找出新进来的buf应该处于的位置</div><div class="line">         * 随后将buf插入到mBufferBySize的队列里面</div><div class="line">         */</div><div class="line">        int pos = Collections.binarySearch(mBuffersBySize, buf, BUF_COMPARATOR);</div><div class="line">        if (pos &lt; 0) &#123;</div><div class="line">            pos = -pos - 1;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        mBuffersBySize.add(pos, buf);</div><div class="line"></div><div class="line">        //当前总缓冲区大小变大</div><div class="line">        mCurrentSize += buf.length;</div><div class="line"></div><div class="line">        //对整个缓冲池的大小做出调整</div><div class="line">        trim();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Removes buffers from the pool until it is under its size limit.</div><div class="line">     * 调整缓冲区的大小</div><div class="line">     * 直到mCurrentSize在限制大小之下</div><div class="line">     */</div><div class="line">    private synchronized void trim() &#123;</div><div class="line"></div><div class="line">        while (mCurrentSize &gt; mSizeLimit) &#123;</div><div class="line">            byte[] buf = mBuffersByLastUse.remove(0);</div><div class="line">            mBuffersBySize.remove(buf);</div><div class="line">            mCurrentSize -= buf.length;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="5-RetryPolicy-java"><a href="#5-RetryPolicy-java" class="headerlink" title="5. RetryPolicy.java"></a><a href="#5-_RetryPolicy-java" title="5\. RetryPolicy.java"></a>5. RetryPolicy.java</h3><p>在BasicNetwork.java这个类中，通过死循环加上try,catch的方式，不停的对一个request进行重复的处理，里面涉及到了<code>RetryPolicy.java</code>接口以及其默认实现类，这个接口是用来专门处理一个request在发送以及得到服务器响应返回结果的过程中出现的问题。通过有限次数的不断扩大request响应时间阀值，再次发送request的方式来达到一个retry的目的。和<code>Network.java</code>类似的，<code>RetryPolicy.java</code>也仅仅就是提供了抽象方法，想把具体的实现内容弄明白还需要去默认实现类<code>DefaultRetryPolicy.java</code>中去。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">package com.android.volley;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Retry policy for a request.</div><div class="line"> * 该类用来管理request的调整及重新发送</div><div class="line"> * 所谓调整就是将request响应时间(timeout)放宽</div><div class="line"> */</div><div class="line">public interface RetryPolicy &#123;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Returns the current timeout (used for logging).</div><div class="line">     */</div><div class="line">    public int getCurrentTimeout();</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Returns the current retry count (used for logging).</div><div class="line">     */</div><div class="line">    public int getCurrentRetryCount();</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Prepares for the next retry by applying a backoff to the timeout.</div><div class="line">     * 为下一次request做好准备，通过不停地来放宽timeout时间限制</div><div class="line">     * 在DefaultRetryPolicy.java中好理解一些</div><div class="line">     * </div><div class="line">     * @param error The error code of the last attempt.</div><div class="line">     * @throws VolleyError In the event that the retry could not be performed (for example if we</div><div class="line">     * ran out of attempts), the passed in error is thrown.</div><div class="line">     */</div><div class="line">    public void retry(VolleyError error) throws VolleyError;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="6-DefaultRetryPolicy-java"><a href="#6-DefaultRetryPolicy-java" class="headerlink" title="6. DefaultRetryPolicy.java"></a><a href="#6-_DefaultRetryPolicy-java" title="6\. DefaultRetryPolicy.java"></a>6. DefaultRetryPolicy.java</h3><p><code>DefaultRetryPolicy.java</code>描述了对待Volley中涉及Network的request的策略方针，可以理解为重试策略方针，也就是对那些在网络请求失败的request处理方法。里面包含了retry的最大次数(<code>mMaxNumRetries</code>)，当前请求次数(<code>mCurrentRetryCount</code>)以及请求超时的时间阀值(<code>mCurrentTimeoutMs</code>)等。每个Request里面都包含了一个<code>RetryPolicy.java</code>实现类，在处理的时候可以通过<code>getRetryPolicy()</code>方法获得。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div></pre></td><td class="code"><pre><div class="line">package com.android.volley;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Default retry policy for requests.</div><div class="line"> */</div><div class="line">public class DefaultRetryPolicy implements RetryPolicy &#123;</div><div class="line">    /** </div><div class="line">     * The current timeout in milliseconds. </div><div class="line">     * 请求超时的时间数</div><div class="line">     */</div><div class="line">    private int mCurrentTimeoutMs;</div><div class="line"></div><div class="line">    /** </div><div class="line">     * The current retry count.</div><div class="line">     * 当前请求的重试次数</div><div class="line">     */</div><div class="line">    private int mCurrentRetryCount;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * The maximum number of attempts. </div><div class="line">     * 重复尝试的最大次数</div><div class="line">     **/</div><div class="line">    private final int mMaxNumRetries;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * The backoff multiplier for the policy.</div><div class="line">     * 暂时不明白这个有什么用</div><div class="line">     * 根据后面的来看好像是一个用于放宽timeout时间限制的系数</div><div class="line">     * 这个系数越大每次retry的时候放宽的程度也就越大</div><div class="line">     */</div><div class="line">    private final float mBackoffMultiplier;</div><div class="line"></div><div class="line">    /** The default socket timeout in milliseconds */</div><div class="line">    public static final int DEFAULT_TIMEOUT_MS = 2500;</div><div class="line"></div><div class="line">    /** The default number of retries */</div><div class="line">    public static final int DEFAULT_MAX_RETRIES = 0;</div><div class="line"></div><div class="line">    /** The default backoff multiplier */</div><div class="line">    public static final float DEFAULT_BACKOFF_MULT = 1f;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Constructs a new retry policy using the default timeouts.</div><div class="line">     * 默认的构造器，2.5s的超时，</div><div class="line">     * 最大重试数为0，也就是request请求超时了就不要再自动重试了</div><div class="line">     */</div><div class="line">    public DefaultRetryPolicy() &#123;</div><div class="line">        this(DEFAULT_TIMEOUT_MS, DEFAULT_MAX_RETRIES, DEFAULT_BACKOFF_MULT);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Constructs a new retry policy.</div><div class="line">     * @param initialTimeoutMs The initial timeout for the policy.</div><div class="line">     * @param maxNumRetries The maximum number of retries.</div><div class="line">     * @param backoffMultiplier Backoff multiplier for the policy.</div><div class="line">     */</div><div class="line">    public DefaultRetryPolicy(int initialTimeoutMs, int maxNumRetries, float backoffMultiplier) &#123;</div><div class="line">        mCurrentTimeoutMs = initialTimeoutMs;</div><div class="line">        mMaxNumRetries = maxNumRetries;</div><div class="line">        mBackoffMultiplier = backoffMultiplier;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Returns the current timeout.</div><div class="line">     */</div><div class="line">    @Override</div><div class="line">    public int getCurrentTimeout() &#123;</div><div class="line">        return mCurrentTimeoutMs;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Returns the current retry count.</div><div class="line">     */</div><div class="line">    @Override</div><div class="line">    public int getCurrentRetryCount() &#123;</div><div class="line">        return mCurrentRetryCount;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Returns the backoff multiplier for the policy.</div><div class="line">     */</div><div class="line">    public float getBackoffMultiplier() &#123;</div><div class="line">        return mBackoffMultiplier;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Prepares for the next retry by applying a backoff to the timeout.</div><div class="line">     * 该方法定义在RetryPolicy.java中。</div><div class="line">     * 为下一次重试request做准备，好像是通过延长服务器响应时间的限制 = =</div><div class="line">     * 每次对timeout的时间限制都放宽了mBackoffMultiplier个单位。让服务器多一点时间去响应</div><div class="line">     * </div><div class="line">     * @param error The error code of the last attempt.</div><div class="line">     * 最后一次request服务器给出的错误码</div><div class="line">     */</div><div class="line">    @Override</div><div class="line">    public void retry(VolleyError error) throws VolleyError &#123;</div><div class="line">        mCurrentRetryCount++;</div><div class="line">        mCurrentTimeoutMs += (mCurrentTimeoutMs * mBackoffMultiplier);</div><div class="line">        if (!hasAttemptRemaining()) &#123;</div><div class="line">            throw error;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Returns true if this policy has attempts remaining, false otherwise.</div><div class="line">     * 这个是用来判断是否还有retry机会的</div><div class="line">     */</div><div class="line">    protected boolean hasAttemptRemaining() &#123;</div><div class="line">        return mCurrentRetryCount &lt;= mMaxNumRetries;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>到这里对<code>Network.java</code>接口以及<code>RetryPolicy.java</code>接口的代码就分析完了，现在是清楚了在<code>NetworkDispatcher.java</code>调用了<code>mNetwork.performRequest()</code>之后发生了什么事情，还弄清楚了request在网络请求发送之后，出现了各种问题会怎么处理(重试策略)，但还不知道最核心的网络请求是如何发生的，也就是在<code>BasicNetwork.java</code>中的下面这行代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">httpResponse = mHttpStack.performRequest(request, headers);</div></pre></td></tr></table></figure>
<p>这行代码就涉及到了后面的<code>HttpStack.java</code>接口及其两个实现类了。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/volley/" rel="tag"># volley</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/03/01/Volley框架解析-三-Dispatcher解析/" rel="next" title="Volley框架解析(三)Dispatcher解析">
                <i class="fa fa-chevron-left"></i> Volley框架解析(三)Dispatcher解析
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/03/21/关于字符编码/" rel="prev" title="关于字符编码">
                关于字符编码 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            Inhaltsverzeichnis
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Übersicht
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Retro41" />
          <p class="site-author-name" itemprop="name">Retro41</p>
           
              <p class="site-description motion-element" itemprop="description">coding...</p>
          
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">Artikel</span>
              </a>
            </div>
          

          

          
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">Tags</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Volley框架解析-四-—–Network接口及其默认实现类解析"><span class="nav-number">1.</span> <span class="nav-text">Volley框架解析(四)—–Network接口及其默认实现类解析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-前言"><span class="nav-number">1.1.</span> <span class="nav-text">1. 前言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Network-java"><span class="nav-number">1.2.</span> <span class="nav-text">2. Network.java</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-BasicNetwork-java"><span class="nav-number">1.3.</span> <span class="nav-text">3. BasicNetwork.java</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-ByteArrayPool-java"><span class="nav-number">1.4.</span> <span class="nav-text">4. ByteArrayPool.java</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-RetryPolicy-java"><span class="nav-number">1.5.</span> <span class="nav-text">5. RetryPolicy.java</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-DefaultRetryPolicy-java"><span class="nav-number">1.6.</span> <span class="nav-text">6. DefaultRetryPolicy.java</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Retro41</span>
</div>


<div class="powered-by">
  Erstellt mit  <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  





  



  
  

  

  

  

  


  

</body>
</html>
