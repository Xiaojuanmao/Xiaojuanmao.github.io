<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>运输层 | Xiaojuanmao&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="运输层功能 ： 为不同主机上运行的应用进程之间提供逻辑通信(logical communication)
工作内容

发送方：把应用数据划分成报文段，交给网络层
接收方：将报文段重组成应用数据，交给应用层

运输层和网络层区别

网络层：不同主机之间的逻辑通信
运输层：应用进程之间的逻辑通信

运输层协议
用户数据报协议UDP
传输控制协议TCP
所提供的服务
进程间数据交付
差错检测
可靠的数据">
<meta property="og:type" content="article">
<meta property="og:title" content="运输层">
<meta property="og:url" content="http://yoursite.com/2016/03/31/运输层/index.html">
<meta property="og:site_name" content="Xiaojuanmao's Blog">
<meta property="og:description" content="运输层功能 ： 为不同主机上运行的应用进程之间提供逻辑通信(logical communication)
工作内容

发送方：把应用数据划分成报文段，交给网络层
接收方：将报文段重组成应用数据，交给应用层

运输层和网络层区别

网络层：不同主机之间的逻辑通信
运输层：应用进程之间的逻辑通信

运输层协议
用户数据报协议UDP
传输控制协议TCP
所提供的服务
进程间数据交付
差错检测
可靠的数据">
<meta property="og:updated_time" content="2016-03-31T09:15:54.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="运输层">
<meta name="twitter:description" content="运输层功能 ： 为不同主机上运行的应用进程之间提供逻辑通信(logical communication)
工作内容

发送方：把应用数据划分成报文段，交给网络层
接收方：将报文段重组成应用数据，交给应用层

运输层和网络层区别

网络层：不同主机之间的逻辑通信
运输层：应用进程之间的逻辑通信

运输层协议
用户数据报协议UDP
传输控制协议TCP
所提供的服务
进程间数据交付
差错检测
可靠的数据">
  
    <link rel="alternative" href="/atom.xml" title="Xiaojuanmao&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Xiaojuanmao&#39;s Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Life began in 1990</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-运输层" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/31/运输层/" class="article-date">
  <time datetime="2016-03-31T09:15:11.000Z" itemprop="datePublished">2016-03-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      运输层
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="u8FD0_u8F93_u5C42"><a href="#u8FD0_u8F93_u5C42" class="headerlink" title="运输层"></a>运输层</h2><p><strong>功能</strong> ： 为不同主机上运行的应用进程之间提供逻辑通信(logical communication)</p>
<p><strong>工作内容</strong></p>
<ul>
<li>发送方：把应用数据划分成报文段，交给网络层</li>
<li>接收方：将报文段重组成应用数据，交给应用层</li>
</ul>
<p><strong>运输层和网络层区别</strong></p>
<ul>
<li>网络层：不同主机之间的逻辑通信</li>
<li>运输层：应用进程之间的逻辑通信</li>
</ul>
<h3 id="u8FD0_u8F93_u5C42_u534F_u8BAE"><a href="#u8FD0_u8F93_u5C42_u534F_u8BAE" class="headerlink" title="运输层协议"></a>运输层协议</h3><ul>
<li>用户数据报协议UDP</li>
<li>传输控制协议TCP</li>
<li>所提供的服务<ul>
<li>进程间数据交付</li>
<li>差错检测</li>
<li>可靠的数据传输</li>
<li>拥塞控制</li>
</ul>
</li>
</ul>
<a id="more"></a>
<h3 id="u591A_u8DEF_u590D_u7528_u4E0E_u591A_u8DEF_u5206_u89E3"><a href="#u591A_u8DEF_u590D_u7528_u4E0E_u591A_u8DEF_u5206_u89E3" class="headerlink" title="多路复用与多路分解"></a>多路复用与多路分解</h3><p><strong>端口</strong></p>
<ul>
<li>让应用层的各种应用进程都能将其数据通过端口向下交付给运输层，以及让运输层知道应当将改报文段中的数据向上通过端口交付给应用层相应的进程</li>
<li>用来标志应用层的进程</li>
<li>端口用一个16bit端口号进行标志</li>
</ul>
<p><strong>套接字</strong></p>
<ul>
<li>TCP使用“连接”作为最基本的抽象，同时将TCP连接的端点称为<strong>套接字</strong></li>
<li>套接字由端口和IP地址等组成</li>
</ul>
<p><strong>报文段的投送</strong></p>
<ul>
<li>主机收到IP包<ul>
<li>每个数据包都有源IP地址和目的IP地址</li>
<li>每个数据包都携带一个传输层的数据报文段</li>
<li>每个数据报文段都有源、目的端口号</li>
</ul>
</li>
<li>主机根据“IP + 端口”将报文定向到相应的套接字</li>
</ul>
<p><strong>面向连接到复用和分用</strong></p>
<ul>
<li>TCP套接字由一个四元组来标示<br>  (源IP，源端口，目的IP，目的端口)</li>
<li>接收方主机根据四个值将报文段定向到相应的套接字</li>
<li>服务器主机同时支持多个并发的TCP套接字：<ul>
<li>每一个套接字都由其四元组来标识</li>
</ul>
</li>
</ul>
<h3 id="u65E0_u8FDE_u63A5_u8FD0_u8F93_3AUDP"><a href="#u65E0_u8FDE_u63A5_u8FD0_u8F93_3AUDP" class="headerlink" title="无连接运输:UDP"></a>无连接运输:UDP</h3><p><strong>UDP处理数据的流程</strong></p>
<ul>
<li><p>发送方</p>
<ul>
<li>从应用进程得到数据</li>
<li>附加上为多路复用/多路分解所需的源和目的端口号及差错检测信息，形成报文段</li>
<li>交给网络层，尽力而为的交付给接受主机</li>
</ul>
</li>
<li><p>接收方</p>
<ul>
<li>从网络层接收报文段(数据报)</li>
<li>根据目的端口号，将数据交付给相应的应用进程</li>
</ul>
</li>
</ul>
<p><strong>UDP通信事先无需握手，是无连接的</strong></p>
<p><strong>UDP优势</strong></p>
<ul>
<li>无须建立连接</li>
<li>简单</li>
<li>段首部开销小</li>
<li>无拥塞控制</li>
</ul>
<p><strong>UDP劣势</strong></p>
<ul>
<li>路由器中大量的分组溢出</li>
<li>减小TCP通信的速率</li>
</ul>
<p><strong>使用UDP可靠数据传输</strong></p>
<ul>
<li>在应用层实现数据的可靠传输</li>
<li>增加应用进程的实现难度</li>
</ul>
<p><strong>UPD的检查和</strong></p>
<ul>
<li>目标<ul>
<li>检查受到的报文段的差错</li>
</ul>
</li>
<li><p>发送方</p>
<ul>
<li>把报文段看作是16比特的序列</li>
<li>检查和：对报文段的所有16比特的和进行1的补运算</li>
<li>发送仿将计算校验和的结果写入UDP校验和字段中</li>
<li>增加伪首部：(源IP地址（4字节）、目的IP地址（4字节） 、0 （1字节） 、17 （UDP协议号，1字节） 、UDP长度（2字节）)</li>
</ul>
</li>
<li><p>接收方</p>
<ul>
<li>计算接收到的报文段的校验和</li>
<li>检查计算结果是否与收到报文段的校验和字段中的值相同<ul>
<li>不同—有错误</li>
<li>相同—没有检测到错误(可能还会有错误)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>可靠信道上的可靠传输—rdt1.0</strong></p>
<ul>
<li>底层信道完全可靠<ul>
<li>不会产生比特错误</li>
<li>不会丢失分组</li>
</ul>
</li>
<li>分别为发送仿和接收方建立FSM<ul>
<li>发送方将数据发送给底层信道</li>
<li>接收方从底层信道接受数据</li>
</ul>
</li>
</ul>
<p><strong>信道可能导致比特出现差错时—rdt2.x</strong></p>
<ul>
<li><p><strong>第一个版本—rdt2.0</strong></p>
<ul>
<li>假设<ul>
<li>分组比特可能会受损</li>
<li>所有传输的分组都将按序被接受，不会丢失</li>
</ul>
</li>
<li><p>处理机制</p>
<ul>
<li>如何判断分组受损—差错检测</li>
<li>如何通知发送方分组是否受损—接收方反馈(ACK和NAK,ACK为肯定，NAK为否定)</li>
<li>得知分组受损之后，发送方如何处理—出错重传</li>
</ul>
</li>
<li><p>实现重传：使用缓冲区缓存中已发出但未受到反馈的报文段</p>
</li>
<li>需要多大的缓冲区：接收方和发送方各一个报文段大小的缓冲区即可</li>
</ul>
</li>
<li><p><strong>第二个版本—rdt2.1</strong></p>
<ul>
<li>问题的引入<ul>
<li>ACK和NAK分组可能受损</li>
</ul>
</li>
<li>方法1<ul>
<li>增加足够的检查和比特，使接收方能够自我恢复比特差错</li>
<li>接收到出错的反馈时，直接发送当前数据分组</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>第三个版本—rdt2.2</strong></p>
<ul>
<li>针对2.1的改进<ul>
<li>只使用ACK</li>
<li>取消NAK，接收方对最后一个正确收到的分组发送ACK<ul>
<li>接收方必须明确指出被确认分组的序号</li>
<li>发送方收到的重复的ACK按照NAK来进行处理<ul>
<li>重传当前的分组</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>信道不但出错，而且丢包时—rdt3.0</strong></p>
<ul>
<li>假设<ul>
<li>底层信道不仅出现比特差错，而且可能丢包的现象</li>
</ul>
</li>
<li>需要解决的问题<ul>
<li>怎样检测丢包</li>
<li>发生丢包之后如何处理<ul>
<li>检查和技术、序号、ACK、重传</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>rdt3.0性能低下，报文段单个发送单个确认的方式限制了硬件方面的性能</strong></p>
<p><strong>提高性能的一种可行方法：流水线技术</strong></p>
<ul>
<li>允许发送仿发送多个分组无须等待确认<ul>
<li>必须增大序号范围</li>
<li>协议的发送方和接收方必须对分组进行缓存</li>
</ul>
</li>
<li><p>流水线技术相当于将多个报文段打包成一个大包发送，减少了RTT等待时间</p>
</li>
<li><p>工作原理</p>
<ul>
<li>分组首部用K比特字段表示序号</li>
<li>已被传输但还未确认的分组的许可序号范围可以看作是一个在序号范围内大小为N的“窗口(Window)”</li>
</ul>
</li>
<li><p>问题：当流水线技术中丢失一个分组后，如何进行重传</p>
<ul>
<li>GO-Back-N(GBN协议，也就是常说的滑动窗口协议)：其后分组全部重传</li>
<li>选择重传(SR)协议：仅选择该分组进行重传</li>
</ul>
</li>
</ul>
<h4 id="Go-Back-N_u534F_u8BAE"><a href="#Go-Back-N_u534F_u8BAE" class="headerlink" title="Go-Back-N协议"></a>Go-Back-N协议</h4><ul>
<li>上层调用。当上层调用rdt_send()时，发送方先检查窗口是否已满，如果窗口未满，则创建一个分组并将其发送，变量相应的更多。如果窗口已满，发送方只需要将数据返回给上层，或者将这个数据缓存起来，或者在窗口满了的情况下不允许上层调用rdt_send()接口。</li>
<li>收到ACK时。在GBN协议中，对序号为N的分组采用<strong>累积确认</strong>的方式，表示在N之前的所有分组都已经确认正确接收</li>
<li>超时事件。当超时事件发生之后，对第一个未确认的分组之后的所有已发送未确认的分组都进行重新发送。而在接收方那边，如果中途有个分组丢失，则其后的分组都将被丢弃或者暂时缓存，必须等待丢失的分组重新发送并确认之后，工作才能进行下去。</li>
</ul>
<h4 id="u9009_u62E9_u91CD_u4F20_28SR_29"><a href="#u9009_u62E9_u91CD_u4F20_28SR_29" class="headerlink" title="选择重传(SR)"></a>选择重传(SR)</h4><p>如果在使用GBN协议的时候，窗口长度为1000，第一个分组未被确认，则后面很多个分组都要被重新发送，选择重传协议就是通过让发送发功仅仅重传那些它怀疑在接收方出错的分组，避免了不必要的重传。</p>
<ul>
<li>上层受到数据。当从上层接收到数据之后，SR发送方检查下一个可用于该分组的序号。如果序号在发送仿的窗口内，则将数据打包并发送；否则就象在GBN中的一样，要么将数据缓存，要么将其返回给上层以便以后传输</li>
<li>超时。定时器再次被用来防止丢失分组。然而，现在每个分组必须拥有自己的逻辑定时器，因为超时之后只能发送一个分组。可以使用单个硬件定时器模拟多个逻辑定时器的操作。</li>
<li>收到ACK。如果收到ACK，且该分组序号在窗口内，则SR发送方将那个被确认的分组标记为已接受。如果该分组的序号等于send_base，则窗口基序号向前移动到具有最小序号的未确认分组处。如果窗口移动了并有序号落在窗口内的未发送分组，则发送这些分组。</li>
</ul>
<h4 id="u53EF_u9760_u6570_u636E_u4F20_u8F93_u673A_u5236_u4EE5_u53CA_u7528_u9014_u7684_u603B_u7ED3"><a href="#u53EF_u9760_u6570_u636E_u4F20_u8F93_u673A_u5236_u4EE5_u53CA_u7528_u9014_u7684_u603B_u7ED3" class="headerlink" title="可靠数据传输机制以及用途的总结"></a>可靠数据传输机制以及用途的总结</h4><table>
<thead>
<tr>
<th>机制</th>
<th>用途和说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>检查和</td>
<td>用于检测在一个传输分组中的比特错误</td>
</tr>
<tr>
<td>定时器</td>
<td>用于检测超时/重传一个分组，可能因为该分组在信道中丢失了。由于当一个分组延时但未丢失，或者当一个分组已经被接收方收到但从接收方发送的ACK丢失，也可能产生超时事件，所以接收方可能会收到一个分组的多个冗余拷贝</td>
</tr>
<tr>
<td>序号</td>
<td>用于为从发送方流向接收方的数据分组按顺序编号。所接受分组的序号间的空隙可使该接受方测出丢失的分组。具有相同序号的分组能够检测出冗余的分组</td>
</tr>
<tr>
<td>确认</td>
<td>接收方用于告知发送方一个分组或者一组分组已经被正确的接受到了。确认报文通常携带着被确认的分组或者多个分组的序号。确认可以是逐个的或累积的</td>
</tr>
<tr>
<td>窗口、流水线</td>
<td>发送方被限制仅能发送那些序号落在一个指定范围内的分组。通过允许一次发送多个分组但未被确认，发送方的利用率可在停等操作模式的基础上增加。窗口长度能够根据接收方接受和缓存报文的能力或者网络中拥塞程度这两种情况来进行设置</td>
</tr>
</tbody>
</table>
<h3 id="u9762_u5411_u8FDE_u63A5_u7684_u8FD0_u8F93_uFF1ATCP"><a href="#u9762_u5411_u8FDE_u63A5_u7684_u8FD0_u8F93_uFF1ATCP" class="headerlink" title="面向连接的运输：TCP"></a>面向连接的运输：TCP</h3><p>&#160;&#160;&#160;&#160;TCP是面向连接的，这是因为在一个应用进程可以开始向另一个应用进程发送数据之前，这两个进程必须先互相“握手”，即他们必须相互发送某些预备的报文段，以建立确保数据传输所需的参数。作为TCP连接建立的一部分，连接的双方都将初始化与TCP连接相关的许多TCP状态变量</p>
<p>&#160;&#160;&#160;&#160;所谓的连接只是保存在两端上的某些数据状态，中间的路由根本毫不知情，它们看到的是数据报，而不是连接。</p>
<h4 id="TCP_u8FDE_u63A5_u7279_u6027"><a href="#TCP_u8FDE_u63A5_u7279_u6027" class="headerlink" title="TCP连接特性"></a>TCP连接特性</h4><ul>
<li><strong>全双工服务(full-duplex service)</strong>：如果一台主机上的进程A与另外一台主机上的进程B存在TCP连接，那么应用层数据就能从B流向A的同时，也能从A流向B</li>
<li><strong>点对点(point-to-point)</strong>：在单个发送方与单个接收方之间的连接。</li>
</ul>
<p><strong>三次握手</strong></p>
<ul>
<li>客户机先向服务器发送一条特殊的TCP报文段，服务器用另一个特殊的TCP报文段来响应，最后，客户机再用第三个特殊报文段作为响应</li>
<li>前两个报文段不承载“有效载荷”，也就是不包含应用层数据，第三个可以承载有效载荷。</li>
</ul>
<h4 id="TCP_u6570_u636E_u4F20_u8F93"><a href="#TCP_u6570_u636E_u4F20_u8F93" class="headerlink" title="TCP数据传输"></a>TCP数据传输</h4><ul>
<li>客户端进程通过套接字传递数据，交给客户机中的TCP协议，TCP协议将数据引入在三次握手初期形成的<strong>发送缓存</strong>中</li>
<li>TCP协议不断从发送缓存中取出一块数据</li>
<li>每次存放入缓存或者取出缓存的最大报文段长(maximum segment size, MSS)通常根据最初确定的最大链路层帧长度来设置，即最大传输单元(maximum transmission unit, MTU)。这里的长度限制指的是报文段里应用层数据的长度，不包括TCP首部的长度。</li>
<li>TCP组成包括：一台主机上的缓存、变量和与另一个进程连接的套接字，以及另一台主机上的一套缓存、变量和一个进程连接的套接字。</li>
</ul>
<h4 id="TCP_u62A5_u6587_u6BB5_u7EC4_u6210"><a href="#TCP_u62A5_u6587_u6BB5_u7EC4_u6210" class="headerlink" title="TCP报文段组成"></a>TCP报文段组成</h4><h5 id="u9996_u90E8_u5B57_u6BB5"><a href="#u9996_u90E8_u5B57_u6BB5" class="headerlink" title="首部字段"></a>首部字段</h5><p>一般是20个字节。</p>
<ul>
<li>与UDP相同的首部字段：<strong>源端口号</strong>、<strong>目的端口号</strong>、<strong>检验和</strong></li>
<li>不同UDP字段：<ul>
<li>32比特的<strong>序号字段</strong>和32比特的<strong>确认号字段</strong>。用来实现可靠数据传输服务</li>
<li>16比特的<strong>接受窗口(receive window)</strong>字段，该字段用于流量控制。用于表示接收方愿意接受的字节数量</li>
<li>4比特的<strong>首部长度字段(header length field)</strong>，该字段指示了以32比特的字为单位的TCP首部的长度，由于下面的<strong>选项字段</strong>的原因，TCP首部的长度可以变化。</li>
<li>可选与变长的<strong>选项字段(options field)</strong>,该字段用于当发送方与接收方协商最大报文段长度(MSS)，或者在告诉网络环境下用作窗口调节因子时使用。</li>
<li>6比特的<strong>标志字段</strong>。ACK比特用于指示确认字段中的值是有效的。RST、SYN和FIN比特用于连接建立和拆除。PSH表示接收方应该立即将数据交给上层。URG表示报文段里存放着被发送方上层实体</li>
</ul>
</li>
</ul>
<p><strong>序号和确认号</strong><br>&#160;&#160;&#160;&#160;TCP序号建立在字节流之上，而不是建立在传送的报文段之上。序号为接收方期待从发送方接受到的数据序号，确认号是确认已经收到的数据序号。</p>
<ul>
<li><p>估算往返时间RTT</p>
<ul>
<li><strong>SampleRTT</strong>：每个报文段发送出去到收到ACK所用时长，也就是每个报文段的RTT</li>
<li><strong>EstimatedRTT</strong>：发送方维护的一个时间值，用来表示当前网络的加权时延，类似于平均时延，计算公式为<code>EstimatedRTT = 0.875 * EstimatedRTT + 0.125 * SampleRTT</code></li>
<li><strong>DevRTT</strong>：用来衡量当前网络时延的波动情况，<code>DevRTT = 0.75 * DevRTT + 0.25 * |SampleRTT - EstimatedRTT|</code></li>
<li><strong>TimeoutInterval</strong>:超时重传预估时间，计算公式<code>TimeoutInterval = EstimatedRTT + 4 * DevRTT</code></li>
</ul>
</li>
<li><p>累计确认<br>  &#160;&#160;&#160;&#160;发送方连续发送两个报文段，接收方实际接受到两个报文段并发出两个ACK，第一个报文段的ACK如果丢失，第二个报文段ACK到达，在第一个报文段还未超时的情况下，第一个报文段能够和第二个报文段同时被第二个报文段ACK确认</p>
</li>
<li><p>加倍超时间隔<br>  &#160;&#160;&#160;&#160;在报文段确认失败之后，重传报文段并将TimeOut时间扩大一倍，避免网络拥堵引起的不停重传浪费资源</p>
</li>
<li><p>快速重传<br>  &#160;&#160;&#160;&#160;在发送方发送报文的时候，如果收到的ACK中，有三个以上的ACK报文段中对同一个资源字段进行期待请求，也就是序号中相同的资源字段，发送方则会确认该资源报文段在传递给接受方的时候丢失，快速进行重传</p>
</li>
</ul>
<h4 id="TCP_u8FDE_u63A5_u7BA1_u7406"><a href="#TCP_u8FDE_u63A5_u7BA1_u7406" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h4><p><strong>三次握手建立连接</strong></p>
<ul>
<li><strong>第一步</strong>：客户端发送特殊的TCP报文段，不包含应用层数据，首部的标志位<strong>SYN</strong>会被置为1，这个特殊报文段也被称为<strong>SYN报文段</strong>。另外客户机会选择一个<strong>client_isn</strong>作为起始序号放在首部的序号字段。为了避免某些网络安全性攻击</li>
<li><strong>第二步</strong>：<strong>SYN报文段</strong>到达主机之后，主机就会分配TCP连接相关的缓存以及变量，并向客户端发送一个特殊的报文段，这个报文段也没有应用层数据。在这个步骤分配内存会很容易受到<strong>SYN洪泛的攻击</strong>。报文首部<strong>SYN</strong>字段被置为1，<strong>确认字段</strong>被置为<strong>client_isn + 1</strong>，服务器选择自己的<strong>序号</strong>为<strong>server_isn</strong>。这个报文被称为<strong>SYNACK</strong>字段。</li>
<li><strong>第三步</strong>：收到<strong>SYNACK</strong>之后，客户机为TCP连接分配缓存和变量。客户机发送一个报文段，用来确认连接已经建立，<strong>SYN</strong>为0,<strong>确认序号</strong>为<strong>server_isn+1</strong></li>
</ul>
<p><strong>四次挥手断开连接</strong><br>&#160;&#160;&#160;&#160;服务端和客户端都能够主动的断开连接，断开连接需要进行四次挥手的动作，TCP连接才算完全断开。下面以客户端主动断开连接为例。</p>
<ul>
<li><strong>第一步</strong>：发送一个特殊TCP报文段，首部标志为<strong>FIN</strong>为1</li>
<li><strong>第二步</strong>：服务器接受到之后，就向客户端发送一个ACK报文段</li>
<li><strong>第三步</strong>：服务器发送一个终止报文段，<strong>FIN</strong>为1</li>
<li><strong>第四步</strong>：客户端受到之后，发送ACK进行确认</li>
</ul>
<h4 id="u6D41_u91CF_u63A7_u5236"><a href="#u6D41_u91CF_u63A7_u5236" class="headerlink" title="流量控制"></a>流量控制</h4><p>&#160;&#160;&#160;&#160;TCP发送方在不停发送报文段的时候，根本没有考虑接受方的感受，只管发不管埋，接受方缓存炸了都不知道，还在不停的发。于是出现了流量控制，简单来说就是TCP发送端维护了一个称为<strong>接受窗口(receive window)</strong>的东西，这个东西里面存放了关于接受方的信息，也就是接收方那边的缓存还剩多少，用这个来控制发送方发送的速度以及是否继续发送。<br>&#160;&#160;&#160;&#160;接收方通过将缓存还有多少容量这条信息存放在发送给发送方的报文段中，以此来告知发送方接受窗口的相关信息。</p>
<p><strong>小问题</strong><br>&#160;&#160;&#160;&#160;如果当接收方接受窗口又满了，恰好这时没有什么报文段需要给发送方，发送方会一直以为窗口已满不再继续发送消息，而在接收方的缓存里的数据被处理完之后，发送方还是不会发送报文段，出现锁住了的情况。为了解决这个问题，TCP协议强制规定：当接收方的缓存已满的时候，发送方还是不停的发送包含一个字节的数据段，这些报文段会被接收方确认并返回ACK</p>
<p><strong>SYN洪泛攻击</strong><br>&#160;&#160;&#160;&#160;也就是利用在受到客户端发送的<strong>SYN报文段</strong>之后，服务端会立马分配资源的特性，不停的只发送<strong>SYN报文段</strong>，而不进行之后报文段的响应，让服务器快速的分配多个TCP需要的资源，而耗尽服务器资源。服务器会自动关闭处于等待后续两次握手的TCP连接，大约等待时间是30s，但是无济于事= =。<br>&#160;&#160;&#160;&#160;预防的方法也很简单，通过<strong>SYN Cookie</strong>以及修改下三次握手的流程即可。第一次握手的时候，服务器不会分配任何的资源，而是生成一个<strong>Cookie序列号</strong>，利用<strong>两端的IP地址以及其他的信息</strong>，将包含这个<strong>Cookie</strong>的报文段返回给客户端，客户端如果合法，就会返回一个ACK报文段，通过<strong>Cookie</strong>来验证这个客户端是否属于合法。如果客户端只会发送<strong>SYN报文段</strong>，不响应之后的握手，则属于不友好的访问，不用理会。</p>
<h4 id="u62E5_u585E_u63A7_u5236"><a href="#u62E5_u585E_u63A7_u5236" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><p>&#160;&#160;&#160;&#160;上面说到流量控制是没考虑过接收方的感受，但是在接收方和发送方不停你来我往的时候，有没有考虑过中间埋头干活的路由或者交换机的感受呢？于是拥塞控制便诞生了，用来顾虑中间交换机的感受，调节发送方的发送速率。</p>
<p>&#160;&#160;&#160;&#160;根据发送方的网络层是否为运输层提供显示的帮助来区分拥塞控制的方法：</p>
<ul>
<li><strong>端到端控制</strong>：网络层没有为运输层提供拥塞控制的显示支持，所以端系统只能通过对网络行为的观察，例如时延和分组丢失。TCP必须通过这种方式来进行拥塞控制，因为IP协议并没有提供显示支持</li>
<li><strong>网络辅助的拥塞控制</strong>：在这种情况中，网络层组件(例如路由器)会向运输层提供显示的支持，通过这种来自路由器的反馈信息来判断网络中的拥塞情况。分下面两种反馈情况<ul>
<li>路由器直接反馈给发送方</li>
<li>路由器经由接收方发送给发送方</li>
</ul>
</li>
</ul>
<h5 id="ATM_ABR_u62E5_u585E_u63A7_u5236_u5B9E_u4F8B"><a href="#ATM_ABR_u62E5_u585E_u63A7_u5236_u5B9E_u4F8B" class="headerlink" title="ATM ABR拥塞控制实例"></a>ATM ABR拥塞控制实例</h5><p>&#160;&#160;&#160;&#160;通过在发送的报文段中间夹杂一些<strong>资源管理信元(Resource Management)</strong>，这些RM信元在经过每个路由器的时候，会承载一些路由器上的信息，再经由接收方反馈给发送方，这样发送方就能获取到当前网络通路上的拥塞信息。数据信元以及RM信元能够包含一些特殊字段，例如</p>
<ul>
<li><strong>EFCI比特</strong>:显示转发拥塞指示比特，在数据信元中，路由器能够将经过的数据信元中的该标志位置为1，接收方收到之后就会存在记录，如果记录达到一定数量之后，再收到夹在数据信元中间的RM信元时，就会将RM信元里的<strong>CI</strong>比特位置为1，用来通知发送方，目前网络拥塞的状态。</li>
<li><strong>CI和NI比特</strong>：存在于RM信元中，<strong>CI</strong>为拥塞指示，<strong>NI</strong>为无增长，轻微拥塞的时候将<strong>NI</strong>置为1，严重的时候将<strong>CI</strong>置为1</li>
<li><strong>ER设置</strong>：用来表示当前网络通路上允许的最小可支持速率，也就是通路上所有交换机的最小性能。</li>
</ul>
<h4 id="TCP_u62E5_u585E_u63A7_u5236"><a href="#TCP_u62E5_u585E_u63A7_u5236" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h4><p>&#160;&#160;&#160;&#160;由于没有网络辅助来通知发送方当前网络的状况，TCP协议只能通过是否丢包和超时来较为被动的摸索网络状况，并粗略的来进行拥塞控制。TCP的拥塞控制具有下面几个特点：</p>
<ol>
<li>加性增、乘性减</li>
<li>慢启动</li>
<li>对超时事件作出反应</li>
<li>快速恢复</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/03/31/运输层/" data-id="cisoqwkfp0003bnuta33sowfc" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/net/">net</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/04/23/[译]ProtocolBuffers脚本生成代码/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          ProtocolBuffers脚本生成代码
        
      </div>
    </a>
  
  
    <a href="/2016/03/10/Java内存模型/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Java内存模型</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/EventBus/">EventBus</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Fresco/">Fresco</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/">Hexo</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LeetCode/">LeetCode</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/View/">View</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Volley/">Volley</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WebView/">WebView</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/net/">net</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/others/">others</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/wechat/">wechat</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/EventBus/" style="font-size: 13.33px;">EventBus</a> <a href="/tags/Fresco/" style="font-size: 10px;">Fresco</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/Java/" style="font-size: 10px;">Java</a> <a href="/tags/LeetCode/" style="font-size: 16.67px;">LeetCode</a> <a href="/tags/View/" style="font-size: 10px;">View</a> <a href="/tags/Volley/" style="font-size: 20px;">Volley</a> <a href="/tags/WebView/" style="font-size: 10px;">WebView</a> <a href="/tags/net/" style="font-size: 10px;">net</a> <a href="/tags/others/" style="font-size: 13.33px;">others</a> <a href="/tags/wechat/" style="font-size: 10px;">wechat</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">九月 2016</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">八月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">三月 2016</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">二月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">一月 2016</a><span class="archive-list-count">9</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/09/15/Fresco框架解析(一)------整体介绍/">Fresco框架解析(一)------整体介绍</a>
          </li>
        
          <li>
            <a href="/2016/09/14/279_Perfect Squares/">Perfect Squares</a>
          </li>
        
          <li>
            <a href="/2016/09/14/313_Super Ugly Number/">Super Ugly Number</a>
          </li>
        
          <li>
            <a href="/2016/09/14/关于正则表达式(Regular Expression)/">关于正则表达式(Regular Expression)</a>
          </li>
        
          <li>
            <a href="/2016/08/31/89_Gray Code/">Gray Code</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 Xiaoxiaoda<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>