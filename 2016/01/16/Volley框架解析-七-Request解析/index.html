<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Volley框架解析(七)-----Request解析 | Xiaojuanmao&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="1. 前言(可直接无视跳过= =&amp;#160;&amp;#160;&amp;#160;&amp;#160;·一路过关斩将= =，从最顶层一路看代码，了解了request队列的调度程序，request结果的处理方式，以及request请求出错的处理方式，对请求结果进行缓存方面的工作等等。这篇博客就轮到Volley中的主角出场了，那就是—Request.java，前面一直在说request，但是一直都没有介绍到Request是">
<meta property="og:type" content="article">
<meta property="og:title" content="Volley框架解析(七)-----Request解析">
<meta property="og:url" content="http://yoursite.com/2016/01/16/Volley框架解析-七-Request解析/index.html">
<meta property="og:site_name" content="Xiaojuanmao's Blog">
<meta property="og:description" content="1. 前言(可直接无视跳过= =&amp;#160;&amp;#160;&amp;#160;&amp;#160;·一路过关斩将= =，从最顶层一路看代码，了解了request队列的调度程序，request结果的处理方式，以及request请求出错的处理方式，对请求结果进行缓存方面的工作等等。这篇博客就轮到Volley中的主角出场了，那就是—Request.java，前面一直在说request，但是一直都没有介绍到Request是">
<meta property="og:updated_time" content="2016-01-16T12:12:00.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Volley框架解析(七)-----Request解析">
<meta name="twitter:description" content="1. 前言(可直接无视跳过= =&amp;#160;&amp;#160;&amp;#160;&amp;#160;·一路过关斩将= =，从最顶层一路看代码，了解了request队列的调度程序，request结果的处理方式，以及request请求出错的处理方式，对请求结果进行缓存方面的工作等等。这篇博客就轮到Volley中的主角出场了，那就是—Request.java，前面一直在说request，但是一直都没有介绍到Request是">
  
    <link rel="alternative" href="/atom.xml" title="Xiaojuanmao&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Xiaojuanmao&#39;s Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Life began in 1990</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Volley框架解析-七-Request解析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/01/16/Volley框架解析-七-Request解析/" class="article-date">
  <time datetime="2016-01-16T10:10:44.000Z" itemprop="datePublished">2016-01-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Volley框架解析(七)-----Request解析
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1-__u524D_u8A00_28_u53EF_u76F4_u63A5_u65E0_u89C6_u8DF3_u8FC7_3D__3D"><a href="#1-__u524D_u8A00_28_u53EF_u76F4_u63A5_u65E0_u89C6_u8DF3_u8FC7_3D__3D" class="headerlink" title="1. 前言(可直接无视跳过= ="></a>1. 前言(可直接无视跳过= =</h3><p>&#160;&#160;&#160;&#160;·一路过关斩将= =，从最顶层一路看代码，了解了request队列的调度程序，request结果的处理方式，以及request请求出错的处理方式，对请求结果进行缓存方面的工作等等。这篇博客就轮到Volley中的主角出场了，那就是—<code>Request.java</code>，前面一直在说request，但是一直都没有介绍到Request是个什么东西，这么重要的东西怎么能忘记呢，其实小达也搞不清楚整个框架的介绍顺序，沿着接口自顶向下的延展开来，支路多了之后就只能慢慢的道来，request的来迟深感抱歉orz。</p>
<a id="more"></a>
<h3 id="2-_Request-java"><a href="#2-_Request-java" class="headerlink" title="2. Request.java"></a>2. Request.java</h3><p>&#160;&#160;&#160;&#160;Volley封装的一个抽象类，Request.java提供了很大的便利性，可供我们自定义Request,之前在使用Volley的时候自定义了一些reuqest的，也总结过自定义request的方法，在这篇博客中有提到<a href="http://blog.csdn.net/jing_unique_da/article/details/45101331" title="Volley使用技巧-----自定义Request" target="_blank" rel="external">Volley使用技巧—–自定义Request</a>。下面就开始分析<code>Request.java</code>的源码。</p>
<pre><code>/**
 * Base class for all network requests.
 * 在volley中涉及到的所有request的基础类
 *
 * @param &lt;T&gt; The type of parsed response this request expects.
 * 泛型类T是请求端希望服务器能返回的数据类型
 *
 * 关于其实现的一个Comparable接口，从字面上来看就是&quot;可比较的&quot;
 * 官方的解释如下：
 * This interface should be implemented by all classes that wish to define 
 * a natural order of their instances. sort(List) and java.util.Arrays#sort 
 * can then be used to automatically sort lists of classes that implement this interface.
 * 意思就是说如果你希望你的类在一个list中能够使用sort等函数自动排序的话，就实现这个接口吧= =
 * (需要重写里面的方法compareTo(), 里面是比较了两个request的优先级)
 */
public abstract class Request&lt;T&gt; implements Comparable&lt;Request&lt;T&gt;&gt; {

    /**
     * Default encoding for POST or PUT parameters. See {@link #getParamsEncoding()}.
     * POST或者是PUT请求参数的默认编码格式 &quot;UTF-8&quot;
     */
    private static final String DEFAULT_PARAMS_ENCODING = &quot;UTF-8&quot;;

    /**
     * Supported request methods.
     * 支持的请求方式，有各种,常用的GET, POST, PUT应该是比较熟悉
     */
    public interface Method {
        int DEPRECATED_GET_OR_POST = -1;
        int GET = 0;
        int POST = 1;
        int PUT = 2;
        int DELETE = 3;
        int HEAD = 4;
        int OPTIONS = 5;
        int TRACE = 6;
        int PATCH = 7;
    }

    /**
     * An event log tracing the lifetime of this request; for debugging. 
     * 为了debug方便，volley弄了一套VolleyLog
     * 在一个request整个生命周期内不停的打出log
     * 都可以方便从log监控该request现在的情况
     */
    private final MarkerLog mEventLog = MarkerLog.ENABLED ? new MarkerLog() : null;

    /**
     * Request method of this request.  Currently supports GET, POST, PUT, DELETE, HEAD, OPTIONS,
     * TRACE, and PATCH.
     * 当前request涉及到的请求方式
     * 目前所支持的有GET, POST, PUT等
     */
    private final int mMethod;

    /** 
     * URL of this request.
     * 原始Url
     */
    private final String mUrl;

    /**
     * The redirect url to use for 3xx http responses 
     * request重定向之后的url
     */
    private String mRedirectUrl;

    /** The unique identifier of the request 
     *  从后面可以看出在构造request的时候
     *  mIdentifier是通过createIdentifier()函数
     *  由传入的url和请求的method以及当前系统时间还有一个计数器counter构造出的
     *  独一无二的身份标识
     */
    private String mIdentifier;

    /** 
     * Default tag for {@link TrafficStats}. 
     * 
     */
    private final int mDefaultTrafficStatsTag;

    /** Listener interface for errors. */
    private final Response.ErrorListener mErrorListener;

    /** Sequence number of this request, used to enforce FIFO ordering. */
    private Integer mSequence;

    /** The request queue this request is associated with. */
    private RequestQueue mRequestQueue;

    /** Whether or not responses to this request should be cached. */
    private boolean mShouldCache = true;

    /** Whether or not this request has been canceled. */
    private boolean mCanceled = false;

    /** Whether or not a response has been delivered for this request yet. */
    private boolean mResponseDelivered = false;

    // A cheap variant of request tracing used to dump slow requests.
    private long mRequestBirthTime = 0;

    /** 
     * Threshold at which we should log the request (even when debug logging is not enabled). 
     * 用来判定是否打出将一个request打出slow_request的log的时间阀值
     * 如果request响应时间超过了这个阀值，则会打出log，说明一下情况
     */
    private static final long SLOW_REQUEST_THRESHOLD_MS = 3000;

    /**
     * The retry policy for this request. 
     * 在前面已经介绍到了，RetryPolicy.java及其默认实现类
     * 是用来处理request重新发送的一种策略，也就是重试方针
     * 里面记录着重试的最大次数以及当前重试了几次等
     */
    private RetryPolicy mRetryPolicy;

    /**
     * When a request can be retrieved from cache but must be refreshed from
     * the network, the cache entry will be stored here so that in the event of
     * a &quot;Not Modified&quot; response, we can be sure it hasn&apos;t been evicted from cache.
     *
     * 当一个请求的结果有缓存但是需要从服务器刷新一下的时候
     * 缓存的入口，在向服务器发送条件请求时，服务器返回304之后
     * 就可以从这个缓存的入口找到该请求在本地对应的缓存数据了。= =直接拿来用咯
     */
    private Cache.Entry mCacheEntry = null;

    /** An opaque token tagging this request; used for bulk cancellation. 
     *  一个关于该request的不公开透明的token，用于批量取消
     * 在RequestQueue.java中会用到这个mTag
     * 用mTag可以取消request
     */
    private Object mTag;

    /**
     * Creates a new request with the given URL and error listener.  Note that
     * the normal response listener is not provided here as delivery of responses
     * is provided by subclasses, who have a better idea of how to deliver an
     * already-parsed response.
     *
     * 根据给定的url和errorListener创建一个新的request
     * 需要注意的是这里并没有涉及到responseListener方面的设置
     * 因为将其放在request的子类去设置能更好的去传递一个已经解析好了的response
     *
     * 这个方法已经不推荐使用了，推荐使用下面的一个构造方法，因为这个方法存在默认的method
     * 没有很大的自由度去自定义request
     *
     * @deprecated Use {@link #Request(int, String, com.android.volley.Response.ErrorListener)}.
     */
    @Deprecated
    public Request(String url, Response.ErrorListener listener) {
        this(Method.DEPRECATED_GET_OR_POST, url, listener);
    }

    /**
     * Creates a new request with the given method (one of the values from {@link Method}),
     * URL, and error listener.  Note that the normal response listener is not provided here as
     * delivery of responses is provided by subclasses, who have a better idea of how to deliver
     * an already-parsed response.
     * 
     * setRetryPolicy()该方法设置了request所谓的“重试策略”。
     * 跳转到DefaultRetryPolicy.java(系列博客的第四篇---Volley框架解析(四))
     */
    public Request(int method, String url, Response.ErrorListener listener) {
        mMethod = method;
        mUrl = url;
        mIdentifier = createIdentifier(method, url);
        mErrorListener = listener;
        setRetryPolicy(new DefaultRetryPolicy());

        mDefaultTrafficStatsTag = findDefaultTrafficStatsTag(url);
    }

    /**
     * Return the method for this request.  Can be one of the values in {@link Method}.
     */
    public int getMethod() {
        return mMethod;
    }

    /**
     * Set a tag on this request. Can be used to cancel all requests with this
     * tag by {@link RequestQueue#cancelAll(Object)}.
     *
     * 为了方便从网络请求队列里面取消request，可以通过打tag的方式
     * @return This Request object to allow for chaining.
     */
    public Request&lt;?&gt; setTag(Object tag) {
        mTag = tag;
        return this;
    }

    /**
     * Returns this request&apos;s tag.
     * @see Request#setTag(Object)
     */
    public Object getTag() {
        return mTag;
    }

    /**
     * @return this request&apos;s {@link com.android.volley.Response.ErrorListener}.
     */
    public Response.ErrorListener getErrorListener() {
        return mErrorListener;
    }

    /**
     * @return A tag for use with {@link TrafficStats#setThreadStatsTag(int)}
     */
    public int getTrafficStatsTag() {
        return mDefaultTrafficStatsTag;
    }

    /**
     * @return The hashcode of the URL&apos;s host component, or 0 if there is none.
     * 返回了request的url中的host的hashcode
     */
    private static int findDefaultTrafficStatsTag(String url) {
        if (!TextUtils.isEmpty(url)) {
            Uri uri = Uri.parse(url);
            if (uri != null) {
                String host = uri.getHost();
                if (host != null) {
                    return host.hashCode();
                }
            }
        }
        return 0;
    }

    /**
     * Sets the retry policy for this request.
     * 给request设置重试策略
     * @return This Request object to allow for chaining.
     */
    public Request&lt;?&gt; setRetryPolicy(RetryPolicy retryPolicy) {
        mRetryPolicy = retryPolicy;
        return this;
    }

    /**
     * Adds an event to this request&apos;s event log; for debugging.
     */
    public void addMarker(String tag) {
        if (MarkerLog.ENABLED) {
            mEventLog.add(tag, Thread.currentThread().getId());
        } else if (mRequestBirthTime == 0) {
            mRequestBirthTime = SystemClock.elapsedRealtime();
        }
    }

    /**
     * Notifies the request queue that this request has finished (successfully or with error).
     * 该函数用来告诉request队列，当前的request已经完成了(包括成功和失败)
     * &lt;p&gt;Also dumps all events from this request&apos;s event log; for debugging.&lt;/p&gt;
     */
    void finish(final String tag) {

        /**
         * 告诉RequestQueue，这个tag对应的request已经结束了
         * ReuqestQueue会将这个request移出队列
         * 并将具有相同cacheKey的等待中reuqest全部移除
         */
        if (mRequestQueue != null) {
            mRequestQueue.finish(this);
        }

        /**
         * 如果允许打出log
         * 则log提示这个request已经结束了
         */
        if (MarkerLog.ENABLED) {
            final long threadId = Thread.currentThread().getId();
            if (Looper.myLooper() != Looper.getMainLooper()) {
                // If we finish marking off of the main thread, we need to
                // actually do it on the main thread to ensure correct ordering.
                Handler mainThread = new Handler(Looper.getMainLooper());
                mainThread.post(new Runnable() {
                    @Override
                    public void run() {
                        mEventLog.add(tag, threadId);
                        mEventLog.finish(this.toString());
                    }
                });
                return;
            }

            mEventLog.add(tag, threadId);
            mEventLog.finish(this.toString());
        } else {
            long requestTime = SystemClock.elapsedRealtime() - mRequestBirthTime;
            if (requestTime &gt;= SLOW_REQUEST_THRESHOLD_MS) {
                VolleyLog.d(&quot;%d ms: %s&quot;, requestTime, this.toString());
            }
        }
    }

    /**
     * Associates this request with the given queue. The request queue will be notified when this
     * request has finished.
     * 
     * 将和request相关的那个RequestQueue与request关联起来
     * 持有一个对象的引用
     * 在request结束的时候好通知RequestQueue
     * 
     * @return This Request object to allow for chaining.
     */
    public Request&lt;?&gt; setRequestQueue(RequestQueue requestQueue) {
        mRequestQueue = requestQueue;
        return this;
    }

    /**
     * Sets the sequence number of this request.  Used by {@link RequestQueue}.
     * 在RequestQueue中调用，request加入到RequestQueue的时候
     * 需要开始排队等待处理
     * 这个函数的作用就是发号码牌给每个request(排队专用，想的还比较周到= =)
     * @return This Request object to allow for chaining.
     */
    public final Request&lt;?&gt; setSequence(int sequence) {
        mSequence = sequence;
        return this;
    }

    /**
     * Returns the sequence number of this request.
     */
    public final int getSequence() {
        if (mSequence == null) {
            throw new IllegalStateException(&quot;getSequence called before setSequence&quot;);
        }
        return mSequence;
    }

    /**
     * Returns the URL of this request.
     * 返回真实访问的url,如果有重定向出现
     * 则真实url是重定向后的url
     * 否则是原始的url
     */
    public String getUrl() {
        return (mRedirectUrl != null) ? mRedirectUrl : mUrl;
    }

    /**
     * Returns the URL of the request before any redirects have occurred.
     * 返回最原始的url,在任何重定向发生之前
     */
    public String getOriginUrl() {
        return mUrl;
    }

    /**
     * Returns the identifier of the request.
     */
    public String getIdentifier() {
        return mIdentifier;
    }

    /**
     * Sets the redirect url to handle 3xx http responses.
     * 发生重定向之后可以通过该函数来设置重定向后的url
     */
    public void setRedirectUrl(String redirectUrl) {
        mRedirectUrl = redirectUrl;
    }

    /**
     * Returns the cache key for this request.  
     * By default, this is the URL.
     * 默认使用url来作为cacheKey
     */
    public String getCacheKey() {
        return getUrl();
    }

    /**
     * Annotates this request with an entry retrieved for it from cache.
     * Used for cache coherency support.
     * 
     * @return This Request object to allow for chaining.
     */
    public Request&lt;?&gt; setCacheEntry(Cache.Entry entry) {
        mCacheEntry = entry;
        return this;
    }

    /**
     * Returns the annotated cache entry, or null if there isn&apos;t one.
     */
    public Cache.Entry getCacheEntry() {
        return mCacheEntry;
    }

    /**
     * Mark this request as canceled.  No callback will be delivered.
     */
    public void cancel() {
        mCanceled = true;
    }

    /**
     * Returns true if this request has been canceled.
     */
    public boolean isCanceled() {
        return mCanceled;
    }

    /**
     * Returns a list of extra HTTP headers to go along with this request. Can
     * throw {@link AuthFailureError} as authentication may be required to
     * provide these values.
     * 返回在Request中的HTTPheader，这个里面存放了一些关于Request的基本信息
     * 例如请求方式，cookie等东西
     * @throws AuthFailureError In the event of auth failure
     */
    public Map&lt;String, String&gt; getHeaders() throws AuthFailureError {
        return Collections.emptyMap();
    }

    /**
     * Returns a Map of POST parameters to be used for this request, or null if
     * a simple GET should be used.  Can throw {@link AuthFailureError} as
     * authentication may be required to provide these values.
     * 返回request中用于POST请求的一些参数
     * 这些参数以键值对的形式存在，如果是GET方法，则传回Null
     *　
     * &lt;p&gt;Note that only one of getPostParams() and getPostBody() can return a non-null
     * value.&lt;/p&gt;
     * @throws AuthFailureError In the event of auth failure
     *
     * @deprecated Use {@link #getParams()} instead.
     */
    @Deprecated
    protected Map&lt;String, String&gt; getPostParams() throws AuthFailureError {
        return getParams();
    }

    /**
     * Returns which encoding should be used when converting POST parameters returned by
     * {@link #getPostParams()} into a raw POST body.
     * 
     * 
     * &lt;p&gt;This controls both encodings:
     * &lt;ol&gt;
     *     &lt;li&gt;The string encoding used when converting parameter names and values into bytes prior
     *         to URL encoding them.&lt;/li&gt;
     *     &lt;li&gt;The string encoding used when converting the URL encoded parameters into a raw
     *         byte array.&lt;/li&gt;
     * &lt;/ol&gt;
     *
     * @deprecated Use {@link #getParamsEncoding()} instead.
     */
    @Deprecated
    protected String getPostParamsEncoding() {
        return getParamsEncoding();
    }

    /**
     * @deprecated Use {@link #getBodyContentType()} instead.
     * 返回请求体的内容种类
     * 包括application/json等内容
     */
    @Deprecated
    public String getPostBodyContentType() {
        return getBodyContentType();
    }

    /**
     * Returns the raw POST body to be sent.
     * 该函数被建议不要使用了，用getBody代替
     * 
     * @throws AuthFailureError In the event of auth failure
     *
     * @deprecated Use {@link #getBody()} instead.
     */
    @Deprecated
    public byte[] getPostBody() throws AuthFailureError {
        // Note: For compatibility with legacy clients of volley, this implementation must remain
        // here instead of simply calling the getBody() function because this function must
        // call getPostParams() and getPostParamsEncoding() since legacy clients would have
        // overridden these two member functions for POST requests.
        Map&lt;String, String&gt; postParams = getPostParams();
        if (postParams != null &amp;&amp; postParams.size() &gt; 0) {
            return encodeParameters(postParams, getPostParamsEncoding());
        }
        return null;
    }

    /**
     * Returns a Map of parameters to be used for a POST or PUT request.  Can throw
     * {@link AuthFailureError} as authentication may be required to provide these values.
     *
     * &lt;p&gt;Note that you can directly override {@link #getBody()} for custom data.&lt;/p&gt;
     *
     * @throws AuthFailureError in the event of auth failure
     */
    protected Map&lt;String, String&gt; getParams() throws AuthFailureError {
        return null;
    }

    /**
     * Returns which encoding should be used when converting POST or PUT parameters returned by
     * {@link #getParams()} into a raw POST or PUT body.
     *
     * &lt;p&gt;This controls both encodings:
     * &lt;ol&gt;
     *     &lt;li&gt;The string encoding used when converting parameter names and values into bytes prior
     *         to URL encoding them.&lt;/li&gt;
     *     &lt;li&gt;The string encoding used when converting the URL encoded parameters into a raw
     *         byte array.&lt;/li&gt;
     * &lt;/ol&gt;
     */
    protected String getParamsEncoding() {
        return DEFAULT_PARAMS_ENCODING;
    }

    /**
     * Returns the content type of the POST or PUT body.
     * 返回请求体的内容种类
     */
    public String getBodyContentType() {
        return &quot;application/x-www-form-urlencoded; charset=&quot; + getParamsEncoding();
    }

    /**
     * Returns the raw POST or PUT body to be sent.
     * 返回将要发送的request的POST主体
     * 
     * &lt;p&gt;By default, the body consists of the request parameters in
     * application/x-www-form-urlencoded format. When overriding this method, consider overriding
     * {@link #getBodyContentType()} as well to match the new body format.
     *
     * @throws AuthFailureError in the event of auth failure
     */
    public byte[] getBody() throws AuthFailureError {
        Map&lt;String, String&gt; params = getParams();
        if (params != null &amp;&amp; params.size() &gt; 0) {
            return encodeParameters(params, getParamsEncoding());
        }
        return null;
    }

    /**
     * Converts &lt;code&gt;params&lt;/code&gt; into an application/x-www-form-urlencoded encoded string.
     * 将请求里面包含的参数转码
     */
    private byte[] encodeParameters(Map&lt;String, String&gt; params, String paramsEncoding) {
        StringBuilder encodedParams = new StringBuilder();
        try {
            for (Map.Entry&lt;String, String&gt; entry : params.entrySet()) {
                encodedParams.append(URLEncoder.encode(entry.getKey(), paramsEncoding));
                encodedParams.append(&apos;=&apos;);
                encodedParams.append(URLEncoder.encode(entry.getValue(), paramsEncoding));
                encodedParams.append(&apos;&amp;&apos;);
            }
            return encodedParams.toString().getBytes(paramsEncoding);
        } catch (UnsupportedEncodingException uee) {
            throw new RuntimeException(&quot;Encoding not supported: &quot; + paramsEncoding, uee);
        }
    }

    /**
     * Set whether or not responses to this request should be cached.
     *
     * @return This Request object to allow for chaining.
     */
    public final Request&lt;?&gt; setShouldCache(boolean shouldCache) {
        mShouldCache = shouldCache;
        return this;
    }

    /**
     * Returns true if responses to this request should be cached.
     */
    public final boolean shouldCache() {
        return mShouldCache;
    }

    /**
     * Priority values.  Requests will be processed from higher priorities to
     * lower priorities, in FIFO order.
     * request将按照优先级从高到低，先进先出的顺序被处理
     */
    public enum Priority {
        LOW,
        NORMAL,
        HIGH,
        IMMEDIATE
    }

    /**
     * Returns the {@link Priority} of this request; {@link Priority#NORMAL} by default.
     * 返回request的优先级
     * 默认为normal
     */
    public Priority getPriority() {
        return Priority.NORMAL;
    }

    /**
     * Returns the socket timeout in milliseconds per retry attempt. (This value can be changed
     * per retry attempt if a backoff is specified via backoffTimeout()). If there are no retry
     * attempts remaining, this will cause delivery of a {@link TimeoutError} error.
     * 返回每次超时请求时间阀值
     * 每次retry如果返回的是请求超时的结果，则timeout会逐渐变大
     * 如果
     */
    public final int getTimeoutMs() {
        return mRetryPolicy.getCurrentTimeout();
    }

    /**
     * Returns the retry policy that should be used  for this request.
     */
    public RetryPolicy getRetryPolicy() {
        return mRetryPolicy;
    }

    /**
     * Mark this request as having a response delivered on it.  This can be used
     * later in the request&apos;s lifetime for suppressing identical responses.
     */
    public void markDelivered() {
        mResponseDelivered = true;
    }

    /**
     * Returns true if this request has had a response delivered for it.
     */
    public boolean hasHadResponseDelivered() {
        return mResponseDelivered;
    }

    /**
     * Subclasses must implement this to parse the raw network response
     * and return an appropriate response type. This method will be
     * called from a worker thread.  The response will not be delivered
     * if you return null.
     * 子类必须要实现这个方法来解析network response并返回一个合适的返回类型
     * 
     * @param response Response from the network
     * @return The parsed response, or null in the case of an error
     */
    abstract protected Response&lt;T&gt; parseNetworkResponse(NetworkResponse response);

    /**
     * Subclasses can override this method to parse &apos;networkError&apos; and return a more specific error.
     * 子类重写这个方法，来解析networkError
     * &lt;p&gt;The default implementation just returns the passed &apos;networkError&apos;.&lt;/p&gt;
     *
     * @param volleyError the error retrieved from the network
     * @return an NetworkError augmented with additional information
     */
    protected VolleyError parseNetworkError(VolleyError volleyError) {
        return volleyError;
    }

    /**
     * Subclasses must implement this to perform delivery of the parsed
     * response to their listeners.  The given response is guaranteed to
     * be non-null; responses that fail to parse are not delivered.
     *
     * 子类必须实现这个方法来传递一个解析好了的response
     *
     * @param response The parsed response returned by
     * {@link #parseNetworkResponse(NetworkResponse)}
     */
    abstract protected void deliverResponse(T response);

    /**
     * Delivers error message to the ErrorListener that the Request was
     * initialized with.
     *
     * @param error Error details
     */
    public void deliverError(VolleyError error) {
        if (mErrorListener != null) {
            mErrorListener.onErrorResponse(error);
        }
    }

    /**
     * Our comparator sorts from high to low priority, and secondarily by
     * sequence number to provide FIFO ordering.
     * Request类实现了Comparable类
     * 需要重写compareTo()方法
     * 来达到能够将两个request相互比较的目的
     * 这里面的比较策略是通过看两request的优先级大小
     * 高优先级的排在前面，相等的优先级就按照排队时候发放的序列号来比较
     * (在RequestQueue.java中的add()函数里会给每个加入到队列中的request发放一个sequence)
     */
    @Override
    public int compareTo(Request&lt;T&gt; other) {
        Priority left = this.getPriority();
        Priority right = other.getPriority();

        // High-priority requests are &quot;lesser&quot; so they are sorted to the front.
        // Equal priorities are sorted by sequence number to provide FIFO ordering.
        return left == right ?
                this.mSequence - other.mSequence :
                right.ordinal() - left.ordinal();
    }

    /**
     * 重写toString()方法
     * 提供在打印request的时候的一些数据
     * 也方便序列化
     */
    @Override
    public String toString() {
        String trafficStatsTag = &quot;0x&quot; + Integer.toHexString(getTrafficStatsTag());
        return (mCanceled ? &quot;[X] &quot; : &quot;[ ] &quot;) + getUrl() + &quot; &quot; + trafficStatsTag + &quot; &quot;
                + getPriority() + &quot; &quot; + mSequence;
    }

    private static long sCounter;
    /**
     *  sha1(Request:method:url:timestamp:counter)
     * 
     * @param method http method
     * @param url               http request url
     * @return sha1 hash string
     */
    private static String createIdentifier(final int method, final String url) {
        return InternalUtils.sha1Hash(&quot;Request:&quot; + method + &quot;:&quot; + url +
                &quot;:&quot; + System.currentTimeMillis() + &quot;:&quot; + (sCounter++));
    }
}
</code></pre><p>&#160;&#160;&#160;&#160;在<code>Request.java</code>的基础上，Volley示范性的扩展了<code>StringReuqest.java</code>以及<code>JSONArrayRequest.java</code>等等，在这里就不分析源代码了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/01/16/Volley框架解析-七-Request解析/" data-id="cillmjdzy000hodutyc5s3mxc" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Volley/">Volley</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/01/17/Ugly-Number/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Ugly Number
        
      </div>
    </a>
  
  
    <a href="/2016/01/16/Volley框架解析-六-Cache接口及其默认实现类解析/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Volley框架解析(六)-----Cache接口及其默认实现类解析</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/EventBus/">EventBus</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/">Hexo</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LintCode/">LintCode</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/View/">View</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Volley/">Volley</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WebView/">WebView</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/wechat/">wechat</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/EventBus/" style="font-size: 15px;">EventBus</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/LintCode/" style="font-size: 10px;">LintCode</a> <a href="/tags/View/" style="font-size: 10px;">View</a> <a href="/tags/Volley/" style="font-size: 20px;">Volley</a> <a href="/tags/WebView/" style="font-size: 10px;">WebView</a> <a href="/tags/wechat/" style="font-size: 10px;">wechat</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">三月 2016</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">二月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">一月 2016</a><span class="archive-list-count">9</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/03/07/EventBus解析-三-查找Subscribe方法/">EventBus解析-三-查找Subscribe方法</a>
          </li>
        
          <li>
            <a href="/2016/03/06/View事件分发机制/">View事件分发机制</a>
          </li>
        
          <li>
            <a href="/2016/03/04/Android微信第三方登录以及分享/">Android微信第三方登录以及分享</a>
          </li>
        
          <li>
            <a href="/2016/03/03/WebView使用总结/">WebView使用总结</a>
          </li>
        
          <li>
            <a href="/2016/02/28/EventBus解析-一-简单介绍/">EventBus解析(一)简单介绍</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 Xiaoxiaoda<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>