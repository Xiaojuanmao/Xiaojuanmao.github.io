{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1490078289111},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1490078289111},{"_id":"themes/next/.gitignore","hash":"5f09fca02e030b7676c1d312cd88ce8fbccf381c","modified":1490078289111},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1490078289111},{"_id":"themes/next/.javascript_ignore","hash":"f9ea3c5395f8feb225a24e2c32baa79afda30c16","modified":1490078289111},{"_id":"themes/next/.travis.yml","hash":"c42d9608c8c7fe90de7b1581a8dc3886e90c179e","modified":1490078289111},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1490078289111},{"_id":"themes/next/README.en.md","hash":"4ece25ee5f64447cd522e54cb0fffd9a375f0bd4","modified":1490078289111},{"_id":"themes/next/README.md","hash":"500b5606eb6a09c979d16128f8b00f4bf9bc95ac","modified":1490078289111},{"_id":"themes/next/_config.yml","hash":"b56308184649090992cab02f6550b3c28ff8b625","modified":1490078289111},{"_id":"themes/next/bower.json","hash":"5abc236d9cc2512f5457ed57c1fba76669eb7399","modified":1490078289111},{"_id":"themes/next/gulpfile.coffee","hash":"b00e93c5c8667a4fbed71046dc93ce6784bf6257","modified":1490078289111},{"_id":"themes/next/package.json","hash":"a042faed34835a52505643aa2d841cd2dcf5dff6","modified":1490078289115},{"_id":"source/_posts/Github-Hexo搭建个人博客.md","hash":"4540561f583fb25b5522b321b3a4ec0178a972bb","modified":1490078289107},{"_id":"source/_posts/React-Native笔记-一.md","hash":"a81554d40ede2c20b785073bdc6b4768ff13a381","modified":1490078289107},{"_id":"source/_posts/React-Native笔记-三.md","hash":"de7b9d64d2d060c0ae791b8c813da704654c9597","modified":1490078289107},{"_id":"source/_posts/React-Native笔记-二.md","hash":"2e48d99fa6efc0be297716cda05f17517b44ed4a","modified":1490078289107},{"_id":"source/_posts/Volley框架解析-一-整体介绍.md","hash":"f45cd4a3947e6228ac92fc0be2e23613f07ee702","modified":1490078289107},{"_id":"source/_posts/Volley框架解析-三-Dispatcher解析.md","hash":"af998908441b7db0ee2c56eae39150deb73c0944","modified":1490078289107},{"_id":"source/_posts/Volley框架解析-二-Volley以及RequestQueue解析.md","hash":"4cdbf78fb5efea42ade08d2ff85b9e64a1b68c62","modified":1490078289107},{"_id":"source/_posts/Volley框架解析-四-Network接口及其实现.md","hash":"aad138303370e1d8cb91e8273b81e494f342dfb5","modified":1490078289107},{"_id":"source/_posts/关于字符编码.md","hash":"269e427f33aa3370e68f4e26655cf01b081bebe6","modified":1490963803668},{"_id":"source/about/index.md","hash":"f6d65415af1c625f4063be519ce2c30174ae307c","modified":1490078289107},{"_id":"source/tags/index.md","hash":"81959eff6a04fd89a73868dde300a3ca69ed8e05","modified":1490078289107},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5ab257af816986cd0e53f9527a92d5934ac70ae9","modified":1490078289111},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"c2024ded82143807c28a299c5fe6b927ef3525ff","modified":1490078289111},{"_id":"themes/next/languages/de.yml","hash":"1fdea1f84b7f691f5b4dd4d2b43eeb27b10fa0c8","modified":1490078289111},{"_id":"themes/next/languages/default.yml","hash":"95ec5cdfb563854f231b76162a3494f6ecc5bf61","modified":1490078289111},{"_id":"themes/next/languages/en.yml","hash":"95ec5cdfb563854f231b76162a3494f6ecc5bf61","modified":1490078289111},{"_id":"themes/next/languages/fr-FR.yml","hash":"e98f1558347752a20019b71f0b1f9c8be1b34f42","modified":1490078289111},{"_id":"themes/next/languages/id.yml","hash":"34396bef27c4ab9e9a3c5d3e3aa94b0e3b3a7b0d","modified":1490078289111},{"_id":"themes/next/languages/ja.yml","hash":"49f12149edcc1892b26a6207328cda64da20116d","modified":1490078289111},{"_id":"themes/next/languages/ko.yml","hash":"b6bc5d6b0c000deb44099b42d3aebb8c49dbfca9","modified":1490078289111},{"_id":"themes/next/languages/pt-BR.yml","hash":"7742ba4c0d682cbe1d38305332ebc928abd754b5","modified":1490078289111},{"_id":"themes/next/languages/pt.yml","hash":"6b660b117314cad93f08757601df3adb04c68beb","modified":1490078289111},{"_id":"themes/next/languages/ru.yml","hash":"5022885d8955e1b91d8841048db272bf99c59a76","modified":1490078289111},{"_id":"themes/next/languages/zh-Hans.yml","hash":"40d01dc46d57f71c2ef635c45b295d4355456e90","modified":1490078289111},{"_id":"themes/next/languages/zh-hk.yml","hash":"19c23d21f262e24c06ee6ddfd51d2a6585304f88","modified":1490078289111},{"_id":"themes/next/languages/zh-tw.yml","hash":"68407799271c78ecc07f03d238257dd8c65ad42d","modified":1490078289111},{"_id":"themes/next/layout/_layout.swig","hash":"2c0c3547a5b470024326a33ae2779d5ee0252266","modified":1490078289111},{"_id":"themes/next/layout/archive.swig","hash":"b5b59d70fc1563f482fa07afd435752774ad5981","modified":1490078289115},{"_id":"themes/next/layout/category.swig","hash":"6422d196ceaff4220d54b8af770e7e957f3364ad","modified":1490078289115},{"_id":"themes/next/layout/index.swig","hash":"427d0b95b854e311ae363088ab39a393bf8fdc8b","modified":1490078289115},{"_id":"themes/next/layout/page.swig","hash":"3727fab9dadb967e9c2204edca787dc72264674a","modified":1490078289115},{"_id":"themes/next/layout/post.swig","hash":"e2e512142961ddfe77eba29eaa88f4a2ee43ae18","modified":1490078289115},{"_id":"themes/next/layout/schedule.swig","hash":"1f1cdc268f4ef773fd3ae693bbdf7d0b2f45c3a3","modified":1490078289115},{"_id":"themes/next/layout/tag.swig","hash":"07cf49c49c39a14dfbe9ce8e7d7eea3d4d0a4911","modified":1490078289115},{"_id":"themes/next/scripts/merge-configs.js","hash":"0c56be2e85c694247cfa327ea6d627b99ca265e8","modified":1490078289115},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1490078289123},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1490078289123},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1490078289123},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1490078289115},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1490078289111},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1490078289111},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"5864f5567ba5efeabcf6ea355013c0b603ee07f2","modified":1490078289111},{"_id":"themes/next/layout/_macro/post.swig","hash":"6243bc0778f87186ba78bb6022f40d719565fd19","modified":1490078289111},{"_id":"themes/next/layout/_macro/reward.swig","hash":"37e5b7c42ec17b9b6b786c5512bcc481a21c974e","modified":1490078289111},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"b57650032ed47b8bd357ec4dcc02d872fdd0e3e1","modified":1490078289111},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"14e785adeb0e671ba0ff9a553e6f0d8def6c670c","modified":1490078289111},{"_id":"themes/next/layout/_partials/comments.swig","hash":"970aa668680896262b1056bb5787fc9ec8754495","modified":1490078289111},{"_id":"themes/next/layout/_partials/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1490078289111},{"_id":"themes/next/layout/_partials/footer.swig","hash":"7172c6053118b7c291a56a7860128a652ae66b83","modified":1490078289111},{"_id":"themes/next/layout/_partials/head.swig","hash":"a0eafe24d1dae30c790ae35612154b3ffbbd5cce","modified":1490078289111},{"_id":"themes/next/layout/_partials/header.swig","hash":"665fee16093356d710f5c257b5e0d8e7416ab797","modified":1490078289111},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1490078289111},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1490078289111},{"_id":"themes/next/layout/_partials/search.swig","hash":"7b61e96508df70152b809ea5354236ab7f0d54f4","modified":1490078289111},{"_id":"themes/next/layout/_scripts/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1490078289111},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1490078289111},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1490078289111},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"4512867d80d9eddfc3a0f5fea3c456f33aa9d522","modified":1490078289115},{"_id":"themes/next/scripts/tags/button.js","hash":"62e6dbeb53d07627a048132c79630b45d9a8f2cc","modified":1490078289115},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1490078289115},{"_id":"themes/next/scripts/tags/exturl.js","hash":"79378f3a1cd90518b07808ed09156a3ab55ffa31","modified":1490078289115},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1490078289115},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1490078289115},{"_id":"themes/next/scripts/tags/note.js","hash":"6752925eedbdb939d8ec4d11bdfb75199f18dd70","modified":1490078289115},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1490078289115},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1490078289115},{"_id":"themes/next/source/images/avatar.gif","hash":"b1c80c326b0b41dab490a2dfedce6d571df3b78d","modified":1490078289115},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1490078289115},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1490078289115},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1490078289115},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1490078289115},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1490078289115},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1490078289115},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1490078289115},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1490078289115},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1490078289115},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1490078289115},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1490078289115},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1490078289115},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1490078289111},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1490078289111},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1490078289115},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1490078289115},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1490078289115},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1490078289115},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1490078289115},{"_id":"themes/next/layout/_components/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1490078289111},{"_id":"themes/next/layout/_components/algolia-search/dom.swig","hash":"636f1181dd5887a70b4a08ca8f655d4e46635792","modified":1490078289111},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1490078289111},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1490078289111},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"741f09b2ba4e440011c15f5d288b109b82c87f1b","modified":1490078289111},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1490078289111},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1490078289111},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1490078289111},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1490078289111},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"63315fcf210799f894208c9f512737096df84962","modified":1490078289111},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1490078289111},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1490078289111},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1490078289111},{"_id":"themes/next/layout/_scripts/third-party/analytics.swig","hash":"e46900412e28f529c26e25e6bada342006435a32","modified":1490078289111},{"_id":"themes/next/layout/_scripts/third-party/comments.swig","hash":"a279e1881208aff2f669fe235e9661ab825bc540","modified":1490078289111},{"_id":"themes/next/layout/_scripts/third-party/lean-analytics.swig","hash":"92dc60821307fc9769bea9b2d60adaeb798342af","modified":1490078289111},{"_id":"themes/next/layout/_scripts/third-party/localsearch.swig","hash":"ceb39c100c99900294ddee8b1ff81fcaf43873b5","modified":1490078289111},{"_id":"themes/next/layout/_scripts/third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1490078289111},{"_id":"themes/next/layout/_scripts/third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1490078289111},{"_id":"themes/next/layout/_scripts/third-party/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1490078289115},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1490078289115},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"715d5b40dc52f319fe4bff0325beb874774d9bd9","modified":1490078289115},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"78a83c38f69a8747bb74e420e6c9eeef1ea76525","modified":1490078289115},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"c8d35a6b9e3bff6d8fdb66de853065af9d37562d","modified":1490078289115},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"06f432f328a5b8a9ef0dbd5301b002aba600b4ce","modified":1490078289115},{"_id":"themes/next/source/css/_variables/base.styl","hash":"3c8dcf93db666ac6f9f8955b5d36a9419430862a","modified":1490078289115},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1490078289115},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"54ca0acff29a414e2c1b7c1790db22f0c775604c","modified":1490078289115},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1490078289115},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1490078289115},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1490078289115},{"_id":"themes/next/source/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1490078289115},{"_id":"themes/next/source/js/src/post-details.js","hash":"661806a916fa46566accb3222da1fb790decb725","modified":1490078289115},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1490078289115},{"_id":"themes/next/source/js/src/utils.js","hash":"86834fb60aad185634f8513b152d472a53d9ca08","modified":1490078289115},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1490078289119},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1490078289119},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1490078289119},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1490078289119},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1490078289119},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1490078289119},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"c1072942459fa0880e8a33a1bd929176b62b4171","modified":1490078289119},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1490078289119},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1490078289119},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1490078289119},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1490078289119},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1490078289123},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1490078289123},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1490078289123},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1490078289123},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1490078289123},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1490078289123},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1490078289123},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1490078289123},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1490078289123},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1490078289123},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1490078289123},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1490078289123},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1490078289123},{"_id":"themes/next/layout/_scripts/third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1490078289111},{"_id":"themes/next/layout/_scripts/third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1490078289111},{"_id":"themes/next/layout/_scripts/third-party/analytics/busuanzi-counter.swig","hash":"4fcbf57c4918528ab51d3d042cff92cf5aefb599","modified":1490078289111},{"_id":"themes/next/layout/_scripts/third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1490078289111},{"_id":"themes/next/layout/_scripts/third-party/analytics/facebook-sdk.swig","hash":"394d008e5e94575280407ad8a1607a028026cbc3","modified":1490078289111},{"_id":"themes/next/layout/_scripts/third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1490078289111},{"_id":"themes/next/layout/_scripts/third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1490078289111},{"_id":"themes/next/layout/_scripts/third-party/analytics/tencent-mta.swig","hash":"a652f202bd5b30c648c228ab8f0e997eb4928e44","modified":1490078289111},{"_id":"themes/next/layout/_scripts/third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1490078289111},{"_id":"themes/next/layout/_scripts/third-party/comments/disqus.swig","hash":"fb1d04ede838b52ca7541973f86c3810f1ad396e","modified":1490078289111},{"_id":"themes/next/layout/_scripts/third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1490078289111},{"_id":"themes/next/layout/_scripts/third-party/comments/gentie.swig","hash":"03592d1d731592103a41ebb87437fe4b0a4c78ca","modified":1490078289111},{"_id":"themes/next/layout/_scripts/third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1490078289111},{"_id":"themes/next/layout/_scripts/third-party/comments/livere.swig","hash":"7240f2e5ec7115f8abbbc4c9ef73d4bed180fdc7","modified":1490078289111},{"_id":"themes/next/layout/_scripts/third-party/comments/youyan.swig","hash":"af9dd8a4aed7d06cf47b363eebff48850888566c","modified":1490078289111},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"59ad08bcc6fe9793594869ac2b4c525021453e78","modified":1490078289115},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"26d18060b9a13cc3c3feb90c3ed48aed711095a1","modified":1490078289115},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"0dfb4b3ba3180d7285e66f270e1d3fa0f132c3d2","modified":1490078289115},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1490078289115},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1490078289115},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1490078289115},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1490078289115},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1490078289115},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"5304f99581da3a31de3ecec959b7adf9002fde83","modified":1490078289115},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1490078289115},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1490078289115},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"013619c472c7e4b08311c464fcbe9fcf5edde603","modified":1490078289115},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1490078289115},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1490078289115},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1490078289115},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1490078289115},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1490078289115},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"fda14bc35be2e1b332809b55b3d07155a833dbf4","modified":1490078289115},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1490078289115},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1490078289115},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1490078289115},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1490078289115},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"82bbaa6322764779a1ac2e2c8390ce901c7972e2","modified":1490078289115},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1490078289115},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1490078289115},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1490078289115},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"f15537cee1a9ef4fa1e72a1670ebce4097db8115","modified":1490078289115},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"7e18f08c2c82f71e83860f232d43d8b89865ac2e","modified":1490078289115},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1490078289115},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"e3e23751d4ad24e8714b425d768cf68e37de7ded","modified":1490078289115},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1490078289115},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"79da92119bc246fe05d1626ac98426a83ec90a94","modified":1490078289115},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1490078289119},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1490078289119},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1490078289119},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1490078289119},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1490078289119},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1490078289119},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1490078289119},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1490078289119},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1490078289119},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1490078289119},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1490078289119},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"4eda182cbcc046dbf449aef97c02c230cf80a494","modified":1490078289119},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1490078289119},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"fb5b49426dee7f1508500e698d1b3c6b04c8fcce","modified":1490078289119},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1490078289123},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1490078289123},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1490078289119},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1490078289123},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1490078289123},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1490078289119},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1490078289123},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"8994ffcce84deac0471532f270f97c44fea54dc0","modified":1490078289115},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1490078289115},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1490078289115},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"c890ce7fe933abad7baf39764a01894924854e92","modified":1490078289115},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1490078289115},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1490078289115},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1490078289115},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"4b7f81e1006e7acee3d1c840ccba155239f830cc","modified":1490078289115},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1490078289115},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"7778920dd105fa4de3a7ab206eeba30b1a7bac45","modified":1490078289115},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1490078289115},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1490078289115},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1490078289115},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1490078289115},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"beccb53dcd658136fb91a0c5678dea8f37d6e0b6","modified":1490078289115},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"8fae54591877a73dff0b29b2be2e8935e3c63575","modified":1490078289115},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1490078289115},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"b25132fe6a7ad67059a2c3afc60feabb479bdd75","modified":1490078289115},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1490078289115},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"b9a2e76f019a5941191f1263b54aef7b69c48789","modified":1490078289115},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1490078289115},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"e792c8dc41561c96d128e9b421187f1c3dc978a0","modified":1490078289115},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1490078289115},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"963105a531403d7aad6d9e5e23e3bfabb8ec065a","modified":1490078289115},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1490078289115},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"bfd806d0a9f21446a22df82ac02e37d0075cc3b5","modified":1490078289115},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"2e7ec9aaa3293941106b1bdd09055246aa3c3dc6","modified":1490078289115},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1490078289115},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"c44f6a553ec7ea5508f2054a13be33a62a15d3a9","modified":1490078289115},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1490078289115},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1490078289115},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"7690b9596ec3a49befbe529a5a2649abec0faf76","modified":1490078289115},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"b8e754c93aa2f3d762f7ffc93bc0e526a729e879","modified":1490078289115},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"234facd038f144bd0fe09a31ed1357c5d74c517f","modified":1490078289115},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1490078289115},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1490078289115},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1490078289115},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"b8969e1654eec89a0fd10d88b337fee9cb03cd44","modified":1490078289115},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1490078289115},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"74d0ba86f698165d13402670382a822c8736a556","modified":1490078289115},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"8fe1e55bc290e6aaf07cc644fe27b62107a272a8","modified":1490078289115},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1490078289115},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1490078289115},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1490078289115},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1490078289115},{"_id":"themes/next/source/css/_common/components/third-party/gentie.styl","hash":"586a3ec0f1015e7207cd6a2474362e068c341744","modified":1490078289115},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1490078289115},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"173490e21bece35a34858e8e534cf86e34561350","modified":1490078289115},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"42348219db93a85d2ee23cb06cebd4d8ab121726","modified":1490078289115},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1490078289115},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1490078289115},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1490078289115},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1490078289119},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1490078289119},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1490078289119},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1490078289119},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1490078289119},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1490078289119},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1490078289119},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1490078289119},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"c0522272bbaef2acb3d341912754d6ea2d0ecfc0","modified":1490078289119},{"_id":"public/about/index.html","hash":"d7290925a5cf1b4f6fff05d189bd327c613140e8","modified":1490963811733},{"_id":"public/tags/index.html","hash":"9feb7096aba8e222b86ca26f0bea5ca75d89f281","modified":1490963811733},{"_id":"public/archives/index.html","hash":"032e72a05d5770c8187efbba14126849c371d13d","modified":1490963811734},{"_id":"public/archives/2017/index.html","hash":"624fc17a084542ba8ba7b6a87046c005507697d8","modified":1490963811734},{"_id":"public/archives/2017/02/index.html","hash":"e6fced879da8e8470827621c719963e565de52a4","modified":1490963811734},{"_id":"public/archives/2017/03/index.html","hash":"eadbff11e9248302b28e1e4d6d188e04d2f1ad57","modified":1490963811734},{"_id":"public/tags/hexo/index.html","hash":"b281d24df7a2592ec2e8246716067548369e68d0","modified":1490963811734},{"_id":"public/tags/React-Native/index.html","hash":"9c2a683455e61088f64119e1d59c059f6c2e0e6d","modified":1490963811734},{"_id":"public/tags/volley/index.html","hash":"39daa82dcc03704b1379352625f7d1a9d24a1b68","modified":1490963811734},{"_id":"public/tags/other/index.html","hash":"78894b740925fdf24d31564885d6628b55d1a2fe","modified":1490963811734},{"_id":"public/2017/03/21/关于字符编码/index.html","hash":"c220fe14749036103d0ec15fbbc5f6887d6cb301","modified":1490963811734},{"_id":"public/2017/03/20/Volley框架解析-四-Network接口及其实现/index.html","hash":"787efba24fbaa5bdd0899e7ca0215443f08c630a","modified":1490963811735},{"_id":"public/2017/03/01/Volley框架解析-三-Dispatcher解析/index.html","hash":"84f102d977e75606e0c6cf0560d80401979e7047","modified":1490963811735},{"_id":"public/2017/02/28/Volley框架解析-二-Volley以及RequestQueue解析/index.html","hash":"9c4cc6f9c3f42107e6b5cb7fb2ecae4b25816826","modified":1490963811735},{"_id":"public/2017/02/26/Volley框架解析-一-整体介绍/index.html","hash":"3938ff723de5a58dbfec1d4b5737711676c319f3","modified":1490963811735},{"_id":"public/2017/02/24/React-Native笔记-三/index.html","hash":"96023966ff82968fe8e866ad67ad4d62eac967f3","modified":1490963811735},{"_id":"public/2017/02/24/React-Native笔记-二/index.html","hash":"dc1d18cc5c78c1e77fde559f525975b8db7b2531","modified":1490963811735},{"_id":"public/2017/02/24/React-Native笔记-一/index.html","hash":"fe344634479369f98d6b4eb3d2f44e1c4867076d","modified":1490963811735},{"_id":"public/2017/02/23/Github-Hexo搭建个人博客/index.html","hash":"583fcab5eb3d6ab0de47435796252b0af7394cf4","modified":1490963811735},{"_id":"public/index.html","hash":"566cc37804fb47f895249445927b5d10d532f093","modified":1490963811735},{"_id":"public/images/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1490963811751},{"_id":"public/images/avatar.gif","hash":"b1c80c326b0b41dab490a2dfedce6d571df3b78d","modified":1490963811751},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1490963811752},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1490963811752},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1490963811752},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1490963811752},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1490963811752},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1490963811752},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1490963811752},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1490963811752},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1490963811752},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1490963811752},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1490963811752},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1490963811752},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1490963811752},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1490963811752},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1490963811752},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1490963811752},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1490963811752},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1490963811752},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1490963811752},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1490963811752},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1490963811752},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1490963811753},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1490963812344},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1490963812354},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1490963812357},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1490963812358},{"_id":"public/js/src/algolia-search.js","hash":"54ca0acff29a414e2c1b7c1790db22f0c775604c","modified":1490963812365},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1490963812365},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1490963812365},{"_id":"public/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1490963812365},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1490963812365},{"_id":"public/js/src/post-details.js","hash":"661806a916fa46566accb3222da1fb790decb725","modified":1490963812365},{"_id":"public/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1490963812365},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1490963812365},{"_id":"public/js/src/utils.js","hash":"86834fb60aad185634f8513b152d472a53d9ca08","modified":1490963812365},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1490963812365},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1490963812365},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1490963812365},{"_id":"public/lib/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1490963812365},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1490963812365},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1490963812365},{"_id":"public/lib/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1490963812365},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1490963812365},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1490963812366},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1490963812366},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1490963812366},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1490963812366},{"_id":"public/js/src/schemes/pisces.js","hash":"79da92119bc246fe05d1626ac98426a83ec90a94","modified":1490963812366},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1490963812366},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1490963812366},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1490963812366},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1490963812366},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1490963812366},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1490963812366},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1490963812366},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1490963812366},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1490963812366},{"_id":"public/css/main.css","hash":"64acf9120323f080ed60e57daadfc22bd7698853","modified":1490963812366},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1490963812366},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1490963812366},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1490963812366},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1490963812366},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1490963812366},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1490963812366},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"4eda182cbcc046dbf449aef97c02c230cf80a494","modified":1490963812366},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"fb5b49426dee7f1508500e698d1b3c6b04c8fcce","modified":1490963812366},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1490963812366},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1490963812366},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1490963812367},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"c0522272bbaef2acb3d341912754d6ea2d0ecfc0","modified":1490963812370}],"Category":[],"Data":[],"Page":[{"title":"about","date":"2017-02-26T01:40:15.000Z","_content":"\n## 关于我\n\n暂时走在Android路上，对遇到的事物保持好奇心和积极性\n\n\n暂时呆在北京\n\n没什么想说的了，好好努力","source":"about/index.md","raw":"---\ntitle: about\ndate: 2017-02-26 09:40:15\n\n---\n\n## 关于我\n\n暂时走在Android路上，对遇到的事物保持好奇心和积极性\n\n\n暂时呆在北京\n\n没什么想说的了，好好努力","updated":"2017-03-21T06:38:09.107Z","path":"about/index.html","comments":1,"layout":"page","_id":"cj0xtcup80001k2j9bba6yki2","content":"<h2 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h2><p>暂时走在Android路上，对遇到的事物保持好奇心和积极性</p>\n<p>暂时呆在北京</p>\n<p>没什么想说的了，好好努力</p>\n","excerpt":"","more":"<h2 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h2><p>暂时走在Android路上，对遇到的事物保持好奇心和积极性</p>\n<p>暂时呆在北京</p>\n<p>没什么想说的了，好好努力</p>\n"},{"title":"tags","date":"2017-02-26T01:29:44.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2017-02-26 09:29:44\ntype: \"tags\"\n---\n","updated":"2017-03-21T06:38:09.107Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cj0xtcuvb000sk2j9gk1q5lcu","content":"","excerpt":"","more":""}],"Post":[{"title":"Github+Hexo搭建个人博客","date":"2017-02-22T16:52:12.000Z","_content":"\n# Ubuntu上结合Github用Hexo搭建博客\n\n### [](#u7B80_u4ECB \"简介\")简介\n在搭建博客的过程中会涉及到下面这些东西：\n\n1.  Hexo\n2.  Git\n3.  Github Pages\n4.  Npm\n5.  Nodejs\n\n**[Hexo](https://github.com/hexojs/hexo)**\n\n```\n一款基于Node.js的简单、快速、强大的静态博客框架\n\n```\n\n<!--more-->\n\n**Hexo搭建博客和github有什么关系**\n\n那Hexo就是一个博客框架，关Github什么事情呢，这还被你说对了，还真不怎么和github相关，用hexo弄一个博客出来很简单。当然你也可以选择用wordpress来结合hexo，只是这里选择用github pages服务，那又说到了一个东西:**github pages**。\n\n**[Github Pages](https://pages.github.com/)**\n\n上面是网址，可以自己进去看看，简单的说就是github提供的一种用来展示托管在自己github仓库上的静态网页。github pages也有自己的一套框架，只用github pages也可以搭建自己的博客。\n\n**[Npm](https://www.npmjs.com/)**\n\n一个NodeJs包管理和分发工具，全称为Node Package Manager。和Ruby的gem，Python的pypi类似。通过npm能快速的部署hexo框架，毕竟hexo基于nodejs。\n\n**[Node.js](https://nodejs.org/en/)**\n\nNode是一个Javascript运行环境(runtime)。实际上它是对Google V8引擎进行了封装。V8引 擎执行Javascript的速度非常快，性能非常好。Node对一些特殊用例进行了优化，提供了替代的API，使得V8在非浏览器环境下运行得更好。\n\n### [](#u5B89_u88C5 \"安装\")安装\n\n#### [](#1-__u5B89_u88C5Node-js \"1\\. 安装Node.js\")1\\. 安装Node.js\n\n在Ubuntu下面部署很容易的= =,在终端输入：\n\n```\nsudo apt-get install --yes nodejs\n\n```\n\nNodejs的部署工作就完成了。其他的Linux发行版可以参照下面的教程[Installing Node.js via package manager](https://github.com/nodejs/node-v0.x-archive/wiki/Installing-Node.js-via-package-manager)\n\n也可以在Node的官网上直接[下载](https://nodejs.org/en/download/)安装。\n\n安装好之后，在终端输入nodejs即可进入到nodejs的交互模式中。\n\n**Note**\n需要注意一个问题就是，在hexo中的nodejs文件在运行时使用的是`node xxx/js`这样的形式，而在Ubuntu下面直接运行`node xxx.js`会失败，报错为`/usr/bin/env: node: No such file or directory`，网上有些说是和node的版本有关，实际上是因为NodeJs在Ubuntu上默认安装之后，需要`nodejs xxx.js`这样用，解决方法为创建如下软链接，保证可以运行`node xxx.js`:\n\n```\nln -s /usr/bin/nodejs /usr/bin/node\n\n```\n\n#### [](#2-__u5B89_u88C5npm \"2\\. 安装npm\")2\\. 安装npm\n\n在终端输入：\n\n```\nsudo apt-get install npm\n\n```\n\n#### [](#3-__u5B89_u88C5hexo \"3\\. 安装hexo\")3\\. 安装hexo\n\n终端输入：\n\n```\nnpm install hexo-cli -g\n\n```\n\n在这里可能会报错，由于没有root权限导致无法安装hexo，`sudo su`root一下再安装一次就好了。\n\n到这里就完成了对Hexo的初步安装了，直接在终端输入`hexo`会出现相关的信息。\n\n#### [](#4-__u5B89_u88C5git \"4\\. 安装git\")4\\. 安装git\n\n首先安装git\n\n```\nsudo apt-get update\nsudo apt-get install git\n\n```\n\n设置用户信息\n\n```\n$ git config --global user.name \"Xiaojuanmao\"//用户名\n$ git config --global user.email  \"daque@hustunique.com\"//填写自己的邮箱\n\n```\n\n检查SSH keys\n\n```\n$ cd ~/. ssh\n\n```\n\n如果提示No such file or directory 说明你是第一次使用git。按照如下步骤处理SSH Keys，如果存在SSH Keys，则直接跳过下面分割线内的部分。\n\n* * *\n\n**配置SSH Keys**\n\n*   生成新的SSH Keys\n\n    ```\n    $ ssh-keygen -t rsa -C \"邮件地址@youremail.com\"\n\n    ```\n\n    会出现下面的提示：\n\n    ```\n    Generating public/private rsa key pair.\n    Enter file in which to save the key\n    (/Users/your_user_directory/.ssh/id_rsa):\n\n    ```\n\n    直接回车，存储在默认的目录下面。系统会提示输入密码，密码的作用是在向仓库提交代码的时候用到，可以防止其他人向自己的仓库提交代码。输入密码后，相关的会生成.ssh文件。\n\n*   添加新的SSH Keys到GitHub\n\n    通过下面的命令进入目录，该目录下存放着刚才生成的密钥文件\n\n    ```\n    $ cd ~/. ssh\n\n    ```\n\n    登陆github系统。点击右上角的 Account Settings—->SSH Public keys —-> add another public keys。打开刚才目录下面的`id_rsa.pub`文件，将文件内容复制到key文本框中就可以了。\n\n*   测试SSH\n    可以输入下面的命令，测试SSH是否设置成功\n\n    ```\n    ssh -T git@github.com\n\n    ```\n\n    如果出现下面的信息，则说明设置成功\n\n    ```\n    Hi XXX! You've successfully authenticated, but GitHub does not provide shell access.\n\n    ```\n\n    **Note**\n    也可能会报出错误：`Agent admitted failure to sign using the key.Permission denied (publickey).`这是由于没有将新建的ssh密钥加入，下面的命令可以解决：\n\n    ```\n    ssh-add   ~/.ssh/id_rsa\n\n    ```\n\n* * *\n\n### [](#u4F7F_u7528 \"使用\")使用\n\n#### [](#1-__u4F7F_u7528github_u521B_u5EFA_u535A_u5BA2_u4ED3_u5E93 \"1\\. 使用github创建博客仓库\")1\\. 使用github创建博客仓库\n在github上创建一个仓库，**仓库的名字和用户名必须对应**，如我的帐户名为`Xiaojuanmao`,则创建的仓库名称为`Xiaojuanmao.github.io`。这样存放在github上的远程仓库就准备好了，下面来用hexo来初始化本地的仓库内容。\n\n#### [](#2-_Hexo_u521D_u59CB_u5316 \"2\\. Hexo初始化\")2\\. Hexo初始化\n\n在主文件夹下创建一个hexo文件夹，进入文件夹，在终端输入如下的命令\n\n```\nhexo init\n\n```\n\n会给出这样的反馈：`INFO Copying data to ~/hexo INFO You are almost done! Don't forget to run 'npm install' before you start blogging with Hexo!`\n接着按照上面的提示，输入命令\n\n```\nnpm install\n\n```\n\n会自动在目录下面安装node_modules。接着在命令行中启动本地的服务器，可以用来预览个人博客的样子：\n\n```\nhexo server\n\n```\n\n反馈信息会提示已经在挂在了本地的服务器：`INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.`\n\n在浏览器中打开`http://0.0.0.0\"4000/`可以看到网页的整个框架已经生成了。有个默认的主题，如果觉得这个主题不好看，hexo还有好多主题可供更换。\n\n#### [](#3-__u6DFB_u52A0_u6587_u7AE0 \"3\\. 添加文章\")3\\. 添加文章\n\n打开命令行，进入到hexo的目录下，利用如下的命令，可以新建一个.md格式的文件。\n\n```\nhexo new \"My New Post\"\n反馈信息：INFO  Created: ~/hexo/source/_posts/My-New-Post.md\n\n```\n\n刷新刚才的`localhost:4000`，就能看到一篇新的博客出现了，用起来还是炒鸡方便的。创建之后再去编辑这个.md文件，写自己想写的内容就可以了。\n\n#### [](#4-__u751F_u6210_u9759_u6001_u7F51_u9875 \"4\\. 生成静态网页\")4\\. 生成静态网页\n\n下面的命令生成静态的网页，在将本地的内容部署到github上面去之前，一定要先执行这个步骤。\n\n```\nhexo generate\n   或者 hexo g\n\n```\n\n执行完之后，会在./public的目录下生成一系列的.html,.css文件。\n\n#### [](#5-__u90E8_u7F72_u5230Github \"5\\. 部署到Github\")5\\. 部署到Github\n\n在和github完成对接之前，需要去配置hexo自己的配置文件`_config.yml`。关于这个文件里面的一些内容，需要进行一些修改：\n\n```\n# Hexo Configuration\n## Docs: http://hexo.io/docs/configuration.html\n## Source: https://github.com/hexojs/hexo/\n\n# Site\ntitle: Xiaojuanmao's Blog # 网站的标题\nsubtitle: Life began in 1990 # 网站的副标题\ndescription: Coding Life # 显示在网页最下面的描述，类似于tag\nauthor: Xiaoxiaoda\nemail: daque@hustunique.com\nlanguage: zh_CN\ntimezone:\n\n# Deployment\n## Docs: http://hexo.io/docs/deployment.html\ndeploy:\n  type: git #这里不要写github了，hexo3.0之后用git代替了github\n  repository: git@github.com:Xiaojuanmao/Xiaojuanmao.github.io.git # 填写自己的git仓库地址，之前创建好了的\n  branch: master\n\n```\n\n更改完配置文件之后保存，通过下面的命令部署到github上：\n\n```\nhexo generate 或者 hexo g  #生成静态网页\nhexo deploy 或者 hexo d #部署到github\n上面两个命令可以和并为 hexo d -g\n\n```\n\n**Note**\n部署的过程中可能会出现如下的问题：\n\n```\nERROR Deployer not found: github\n\n```\n\n遇到这个不要慌，是hexo升级到3.0之后用git代替了github，所以需要再输入下面的命令，安装git的deployer\n\n```\nnpm install hexo-deployer-git --save\n\n```\n\n安装之后就可以将静态的网页部署到github的远程仓库上面。","source":"_posts/Github-Hexo搭建个人博客.md","raw":"---\ntitle: Github+Hexo搭建个人博客\ndate: 2017-02-23 00:52:12\ntags: hexo\n\n---\n\n# Ubuntu上结合Github用Hexo搭建博客\n\n### [](#u7B80_u4ECB \"简介\")简介\n在搭建博客的过程中会涉及到下面这些东西：\n\n1.  Hexo\n2.  Git\n3.  Github Pages\n4.  Npm\n5.  Nodejs\n\n**[Hexo](https://github.com/hexojs/hexo)**\n\n```\n一款基于Node.js的简单、快速、强大的静态博客框架\n\n```\n\n<!--more-->\n\n**Hexo搭建博客和github有什么关系**\n\n那Hexo就是一个博客框架，关Github什么事情呢，这还被你说对了，还真不怎么和github相关，用hexo弄一个博客出来很简单。当然你也可以选择用wordpress来结合hexo，只是这里选择用github pages服务，那又说到了一个东西:**github pages**。\n\n**[Github Pages](https://pages.github.com/)**\n\n上面是网址，可以自己进去看看，简单的说就是github提供的一种用来展示托管在自己github仓库上的静态网页。github pages也有自己的一套框架，只用github pages也可以搭建自己的博客。\n\n**[Npm](https://www.npmjs.com/)**\n\n一个NodeJs包管理和分发工具，全称为Node Package Manager。和Ruby的gem，Python的pypi类似。通过npm能快速的部署hexo框架，毕竟hexo基于nodejs。\n\n**[Node.js](https://nodejs.org/en/)**\n\nNode是一个Javascript运行环境(runtime)。实际上它是对Google V8引擎进行了封装。V8引 擎执行Javascript的速度非常快，性能非常好。Node对一些特殊用例进行了优化，提供了替代的API，使得V8在非浏览器环境下运行得更好。\n\n### [](#u5B89_u88C5 \"安装\")安装\n\n#### [](#1-__u5B89_u88C5Node-js \"1\\. 安装Node.js\")1\\. 安装Node.js\n\n在Ubuntu下面部署很容易的= =,在终端输入：\n\n```\nsudo apt-get install --yes nodejs\n\n```\n\nNodejs的部署工作就完成了。其他的Linux发行版可以参照下面的教程[Installing Node.js via package manager](https://github.com/nodejs/node-v0.x-archive/wiki/Installing-Node.js-via-package-manager)\n\n也可以在Node的官网上直接[下载](https://nodejs.org/en/download/)安装。\n\n安装好之后，在终端输入nodejs即可进入到nodejs的交互模式中。\n\n**Note**\n需要注意一个问题就是，在hexo中的nodejs文件在运行时使用的是`node xxx/js`这样的形式，而在Ubuntu下面直接运行`node xxx.js`会失败，报错为`/usr/bin/env: node: No such file or directory`，网上有些说是和node的版本有关，实际上是因为NodeJs在Ubuntu上默认安装之后，需要`nodejs xxx.js`这样用，解决方法为创建如下软链接，保证可以运行`node xxx.js`:\n\n```\nln -s /usr/bin/nodejs /usr/bin/node\n\n```\n\n#### [](#2-__u5B89_u88C5npm \"2\\. 安装npm\")2\\. 安装npm\n\n在终端输入：\n\n```\nsudo apt-get install npm\n\n```\n\n#### [](#3-__u5B89_u88C5hexo \"3\\. 安装hexo\")3\\. 安装hexo\n\n终端输入：\n\n```\nnpm install hexo-cli -g\n\n```\n\n在这里可能会报错，由于没有root权限导致无法安装hexo，`sudo su`root一下再安装一次就好了。\n\n到这里就完成了对Hexo的初步安装了，直接在终端输入`hexo`会出现相关的信息。\n\n#### [](#4-__u5B89_u88C5git \"4\\. 安装git\")4\\. 安装git\n\n首先安装git\n\n```\nsudo apt-get update\nsudo apt-get install git\n\n```\n\n设置用户信息\n\n```\n$ git config --global user.name \"Xiaojuanmao\"//用户名\n$ git config --global user.email  \"daque@hustunique.com\"//填写自己的邮箱\n\n```\n\n检查SSH keys\n\n```\n$ cd ~/. ssh\n\n```\n\n如果提示No such file or directory 说明你是第一次使用git。按照如下步骤处理SSH Keys，如果存在SSH Keys，则直接跳过下面分割线内的部分。\n\n* * *\n\n**配置SSH Keys**\n\n*   生成新的SSH Keys\n\n    ```\n    $ ssh-keygen -t rsa -C \"邮件地址@youremail.com\"\n\n    ```\n\n    会出现下面的提示：\n\n    ```\n    Generating public/private rsa key pair.\n    Enter file in which to save the key\n    (/Users/your_user_directory/.ssh/id_rsa):\n\n    ```\n\n    直接回车，存储在默认的目录下面。系统会提示输入密码，密码的作用是在向仓库提交代码的时候用到，可以防止其他人向自己的仓库提交代码。输入密码后，相关的会生成.ssh文件。\n\n*   添加新的SSH Keys到GitHub\n\n    通过下面的命令进入目录，该目录下存放着刚才生成的密钥文件\n\n    ```\n    $ cd ~/. ssh\n\n    ```\n\n    登陆github系统。点击右上角的 Account Settings—->SSH Public keys —-> add another public keys。打开刚才目录下面的`id_rsa.pub`文件，将文件内容复制到key文本框中就可以了。\n\n*   测试SSH\n    可以输入下面的命令，测试SSH是否设置成功\n\n    ```\n    ssh -T git@github.com\n\n    ```\n\n    如果出现下面的信息，则说明设置成功\n\n    ```\n    Hi XXX! You've successfully authenticated, but GitHub does not provide shell access.\n\n    ```\n\n    **Note**\n    也可能会报出错误：`Agent admitted failure to sign using the key.Permission denied (publickey).`这是由于没有将新建的ssh密钥加入，下面的命令可以解决：\n\n    ```\n    ssh-add   ~/.ssh/id_rsa\n\n    ```\n\n* * *\n\n### [](#u4F7F_u7528 \"使用\")使用\n\n#### [](#1-__u4F7F_u7528github_u521B_u5EFA_u535A_u5BA2_u4ED3_u5E93 \"1\\. 使用github创建博客仓库\")1\\. 使用github创建博客仓库\n在github上创建一个仓库，**仓库的名字和用户名必须对应**，如我的帐户名为`Xiaojuanmao`,则创建的仓库名称为`Xiaojuanmao.github.io`。这样存放在github上的远程仓库就准备好了，下面来用hexo来初始化本地的仓库内容。\n\n#### [](#2-_Hexo_u521D_u59CB_u5316 \"2\\. Hexo初始化\")2\\. Hexo初始化\n\n在主文件夹下创建一个hexo文件夹，进入文件夹，在终端输入如下的命令\n\n```\nhexo init\n\n```\n\n会给出这样的反馈：`INFO Copying data to ~/hexo INFO You are almost done! Don't forget to run 'npm install' before you start blogging with Hexo!`\n接着按照上面的提示，输入命令\n\n```\nnpm install\n\n```\n\n会自动在目录下面安装node_modules。接着在命令行中启动本地的服务器，可以用来预览个人博客的样子：\n\n```\nhexo server\n\n```\n\n反馈信息会提示已经在挂在了本地的服务器：`INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.`\n\n在浏览器中打开`http://0.0.0.0\"4000/`可以看到网页的整个框架已经生成了。有个默认的主题，如果觉得这个主题不好看，hexo还有好多主题可供更换。\n\n#### [](#3-__u6DFB_u52A0_u6587_u7AE0 \"3\\. 添加文章\")3\\. 添加文章\n\n打开命令行，进入到hexo的目录下，利用如下的命令，可以新建一个.md格式的文件。\n\n```\nhexo new \"My New Post\"\n反馈信息：INFO  Created: ~/hexo/source/_posts/My-New-Post.md\n\n```\n\n刷新刚才的`localhost:4000`，就能看到一篇新的博客出现了，用起来还是炒鸡方便的。创建之后再去编辑这个.md文件，写自己想写的内容就可以了。\n\n#### [](#4-__u751F_u6210_u9759_u6001_u7F51_u9875 \"4\\. 生成静态网页\")4\\. 生成静态网页\n\n下面的命令生成静态的网页，在将本地的内容部署到github上面去之前，一定要先执行这个步骤。\n\n```\nhexo generate\n   或者 hexo g\n\n```\n\n执行完之后，会在./public的目录下生成一系列的.html,.css文件。\n\n#### [](#5-__u90E8_u7F72_u5230Github \"5\\. 部署到Github\")5\\. 部署到Github\n\n在和github完成对接之前，需要去配置hexo自己的配置文件`_config.yml`。关于这个文件里面的一些内容，需要进行一些修改：\n\n```\n# Hexo Configuration\n## Docs: http://hexo.io/docs/configuration.html\n## Source: https://github.com/hexojs/hexo/\n\n# Site\ntitle: Xiaojuanmao's Blog # 网站的标题\nsubtitle: Life began in 1990 # 网站的副标题\ndescription: Coding Life # 显示在网页最下面的描述，类似于tag\nauthor: Xiaoxiaoda\nemail: daque@hustunique.com\nlanguage: zh_CN\ntimezone:\n\n# Deployment\n## Docs: http://hexo.io/docs/deployment.html\ndeploy:\n  type: git #这里不要写github了，hexo3.0之后用git代替了github\n  repository: git@github.com:Xiaojuanmao/Xiaojuanmao.github.io.git # 填写自己的git仓库地址，之前创建好了的\n  branch: master\n\n```\n\n更改完配置文件之后保存，通过下面的命令部署到github上：\n\n```\nhexo generate 或者 hexo g  #生成静态网页\nhexo deploy 或者 hexo d #部署到github\n上面两个命令可以和并为 hexo d -g\n\n```\n\n**Note**\n部署的过程中可能会出现如下的问题：\n\n```\nERROR Deployer not found: github\n\n```\n\n遇到这个不要慌，是hexo升级到3.0之后用git代替了github，所以需要再输入下面的命令，安装git的deployer\n\n```\nnpm install hexo-deployer-git --save\n\n```\n\n安装之后就可以将静态的网页部署到github的远程仓库上面。","slug":"Github-Hexo搭建个人博客","published":1,"updated":"2017-03-21T06:38:09.107Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0xtcup40000k2j9q4t8d7r5","content":"<h1 id=\"Ubuntu上结合Github用Hexo搭建博客\"><a href=\"#Ubuntu上结合Github用Hexo搭建博客\" class=\"headerlink\" title=\"Ubuntu上结合Github用Hexo搭建博客\"></a>Ubuntu上结合Github用Hexo搭建博客</h1><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a><a href=\"#u7B80_u4ECB\" title=\"简介\"></a>简介</h3><p>在搭建博客的过程中会涉及到下面这些东西：</p>\n<ol>\n<li>Hexo</li>\n<li>Git</li>\n<li>Github Pages</li>\n<li>Npm</li>\n<li>Nodejs</li>\n</ol>\n<p><strong><a href=\"https://github.com/hexojs/hexo\" target=\"_blank\" rel=\"external\">Hexo</a></strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">一款基于Node.js的简单、快速、强大的静态博客框架</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p><strong>Hexo搭建博客和github有什么关系</strong></p>\n<p>那Hexo就是一个博客框架，关Github什么事情呢，这还被你说对了，还真不怎么和github相关，用hexo弄一个博客出来很简单。当然你也可以选择用wordpress来结合hexo，只是这里选择用github pages服务，那又说到了一个东西:<strong>github pages</strong>。</p>\n<p><strong><a href=\"https://pages.github.com/\" target=\"_blank\" rel=\"external\">Github Pages</a></strong></p>\n<p>上面是网址，可以自己进去看看，简单的说就是github提供的一种用来展示托管在自己github仓库上的静态网页。github pages也有自己的一套框架，只用github pages也可以搭建自己的博客。</p>\n<p><strong><a href=\"https://www.npmjs.com/\" target=\"_blank\" rel=\"external\">Npm</a></strong></p>\n<p>一个NodeJs包管理和分发工具，全称为Node Package Manager。和Ruby的gem，Python的pypi类似。通过npm能快速的部署hexo框架，毕竟hexo基于nodejs。</p>\n<p><strong><a href=\"https://nodejs.org/en/\" target=\"_blank\" rel=\"external\">Node.js</a></strong></p>\n<p>Node是一个Javascript运行环境(runtime)。实际上它是对Google V8引擎进行了封装。V8引 擎执行Javascript的速度非常快，性能非常好。Node对一些特殊用例进行了优化，提供了替代的API，使得V8在非浏览器环境下运行得更好。</p>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a><a href=\"#u5B89_u88C5\" title=\"安装\"></a>安装</h3><h4 id=\"1-安装Node-js\"><a href=\"#1-安装Node-js\" class=\"headerlink\" title=\"1. 安装Node.js\"></a><a href=\"#1-__u5B89_u88C5Node-js\" title=\"1\\. 安装Node.js\"></a>1. 安装Node.js</h4><p>在Ubuntu下面部署很容易的= =,在终端输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install --yes nodejs</div></pre></td></tr></table></figure>\n<p>Nodejs的部署工作就完成了。其他的Linux发行版可以参照下面的教程<a href=\"https://github.com/nodejs/node-v0.x-archive/wiki/Installing-Node.js-via-package-manager\" target=\"_blank\" rel=\"external\">Installing Node.js via package manager</a></p>\n<p>也可以在Node的官网上直接<a href=\"https://nodejs.org/en/download/\" target=\"_blank\" rel=\"external\">下载</a>安装。</p>\n<p>安装好之后，在终端输入nodejs即可进入到nodejs的交互模式中。</p>\n<p><strong>Note</strong><br>需要注意一个问题就是，在hexo中的nodejs文件在运行时使用的是<code>node xxx/js</code>这样的形式，而在Ubuntu下面直接运行<code>node xxx.js</code>会失败，报错为<code>/usr/bin/env: node: No such file or directory</code>，网上有些说是和node的版本有关，实际上是因为NodeJs在Ubuntu上默认安装之后，需要<code>nodejs xxx.js</code>这样用，解决方法为创建如下软链接，保证可以运行<code>node xxx.js</code>:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ln -s /usr/bin/nodejs /usr/bin/node</div></pre></td></tr></table></figure>\n<h4 id=\"2-安装npm\"><a href=\"#2-安装npm\" class=\"headerlink\" title=\"2. 安装npm\"></a><a href=\"#2-__u5B89_u88C5npm\" title=\"2\\. 安装npm\"></a>2. 安装npm</h4><p>在终端输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install npm</div></pre></td></tr></table></figure>\n<h4 id=\"3-安装hexo\"><a href=\"#3-安装hexo\" class=\"headerlink\" title=\"3. 安装hexo\"></a><a href=\"#3-__u5B89_u88C5hexo\" title=\"3\\. 安装hexo\"></a>3. 安装hexo</h4><p>终端输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install hexo-cli -g</div></pre></td></tr></table></figure>\n<p>在这里可能会报错，由于没有root权限导致无法安装hexo，<code>sudo su</code>root一下再安装一次就好了。</p>\n<p>到这里就完成了对Hexo的初步安装了，直接在终端输入<code>hexo</code>会出现相关的信息。</p>\n<h4 id=\"4-安装git\"><a href=\"#4-安装git\" class=\"headerlink\" title=\"4. 安装git\"></a><a href=\"#4-__u5B89_u88C5git\" title=\"4\\. 安装git\"></a>4. 安装git</h4><p>首先安装git</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get update</div><div class=\"line\">sudo apt-get install git</div></pre></td></tr></table></figure>\n<p>设置用户信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git config --global user.name &quot;Xiaojuanmao&quot;//用户名</div><div class=\"line\">$ git config --global user.email  &quot;daque@hustunique.com&quot;//填写自己的邮箱</div></pre></td></tr></table></figure>\n<p>检查SSH keys</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ cd ~/. ssh</div></pre></td></tr></table></figure>\n<p>如果提示No such file or directory 说明你是第一次使用git。按照如下步骤处理SSH Keys，如果存在SSH Keys，则直接跳过下面分割线内的部分。</p>\n<hr>\n<p><strong>配置SSH Keys</strong></p>\n<ul>\n<li><p>生成新的SSH Keys</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ ssh-keygen -t rsa -C &quot;邮件地址@youremail.com&quot;</div></pre></td></tr></table></figure>\n<p>会出现下面的提示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Generating public/private rsa key pair.</div><div class=\"line\">Enter file in which to save the key</div><div class=\"line\">(/Users/your_user_directory/.ssh/id_rsa):</div></pre></td></tr></table></figure>\n<p>直接回车，存储在默认的目录下面。系统会提示输入密码，密码的作用是在向仓库提交代码的时候用到，可以防止其他人向自己的仓库提交代码。输入密码后，相关的会生成.ssh文件。</p>\n</li>\n<li><p>添加新的SSH Keys到GitHub</p>\n<p>通过下面的命令进入目录，该目录下存放着刚才生成的密钥文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ cd ~/. ssh</div></pre></td></tr></table></figure>\n<p>登陆github系统。点击右上角的 Account Settings—-&gt;SSH Public keys —-&gt; add another public keys。打开刚才目录下面的<code>id_rsa.pub</code>文件，将文件内容复制到key文本框中就可以了。</p>\n</li>\n<li><p>测试SSH<br>可以输入下面的命令，测试SSH是否设置成功</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ssh -T git@github.com</div></pre></td></tr></table></figure>\n<p>如果出现下面的信息，则说明设置成功</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Hi XXX! You&apos;ve successfully authenticated, but GitHub does not provide shell access.</div></pre></td></tr></table></figure>\n<p><strong>Note</strong><br>也可能会报出错误：<code>Agent admitted failure to sign using the key.Permission denied (publickey).</code>这是由于没有将新建的ssh密钥加入，下面的命令可以解决：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ssh-add   ~/.ssh/id_rsa</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<hr>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a><a href=\"#u4F7F_u7528\" title=\"使用\"></a>使用</h3><h4 id=\"1-使用github创建博客仓库\"><a href=\"#1-使用github创建博客仓库\" class=\"headerlink\" title=\"1. 使用github创建博客仓库\"></a><a href=\"#1-__u4F7F_u7528github_u521B_u5EFA_u535A_u5BA2_u4ED3_u5E93\" title=\"1\\. 使用github创建博客仓库\"></a>1. 使用github创建博客仓库</h4><p>在github上创建一个仓库，<strong>仓库的名字和用户名必须对应</strong>，如我的帐户名为<code>Xiaojuanmao</code>,则创建的仓库名称为<code>Xiaojuanmao.github.io</code>。这样存放在github上的远程仓库就准备好了，下面来用hexo来初始化本地的仓库内容。</p>\n<h4 id=\"2-Hexo初始化\"><a href=\"#2-Hexo初始化\" class=\"headerlink\" title=\"2. Hexo初始化\"></a><a href=\"#2-_Hexo_u521D_u59CB_u5316\" title=\"2\\. Hexo初始化\"></a>2. Hexo初始化</h4><p>在主文件夹下创建一个hexo文件夹，进入文件夹，在终端输入如下的命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo init</div></pre></td></tr></table></figure>\n<p>会给出这样的反馈：<code>INFO Copying data to ~/hexo INFO You are almost done! Don&#39;t forget to run &#39;npm install&#39; before you start blogging with Hexo!</code><br>接着按照上面的提示，输入命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install</div></pre></td></tr></table></figure>\n<p>会自动在目录下面安装node_modules。接着在命令行中启动本地的服务器，可以用来预览个人博客的样子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo server</div></pre></td></tr></table></figure>\n<p>反馈信息会提示已经在挂在了本地的服务器：<code>INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.</code></p>\n<p>在浏览器中打开<code>http://0.0.0.0&quot;4000/</code>可以看到网页的整个框架已经生成了。有个默认的主题，如果觉得这个主题不好看，hexo还有好多主题可供更换。</p>\n<h4 id=\"3-添加文章\"><a href=\"#3-添加文章\" class=\"headerlink\" title=\"3. 添加文章\"></a><a href=\"#3-__u6DFB_u52A0_u6587_u7AE0\" title=\"3\\. 添加文章\"></a>3. 添加文章</h4><p>打开命令行，进入到hexo的目录下，利用如下的命令，可以新建一个.md格式的文件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo new &quot;My New Post&quot;</div><div class=\"line\">反馈信息：INFO  Created: ~/hexo/source/_posts/My-New-Post.md</div></pre></td></tr></table></figure>\n<p>刷新刚才的<code>localhost:4000</code>，就能看到一篇新的博客出现了，用起来还是炒鸡方便的。创建之后再去编辑这个.md文件，写自己想写的内容就可以了。</p>\n<h4 id=\"4-生成静态网页\"><a href=\"#4-生成静态网页\" class=\"headerlink\" title=\"4. 生成静态网页\"></a><a href=\"#4-__u751F_u6210_u9759_u6001_u7F51_u9875\" title=\"4\\. 生成静态网页\"></a>4. 生成静态网页</h4><p>下面的命令生成静态的网页，在将本地的内容部署到github上面去之前，一定要先执行这个步骤。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo generate</div><div class=\"line\">   或者 hexo g</div></pre></td></tr></table></figure>\n<p>执行完之后，会在./public的目录下生成一系列的.html,.css文件。</p>\n<h4 id=\"5-部署到Github\"><a href=\"#5-部署到Github\" class=\"headerlink\" title=\"5. 部署到Github\"></a><a href=\"#5-__u90E8_u7F72_u5230Github\" title=\"5\\. 部署到Github\"></a>5. 部署到Github</h4><p>在和github完成对接之前，需要去配置hexo自己的配置文件<code>_config.yml</code>。关于这个文件里面的一些内容，需要进行一些修改：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Hexo Configuration</div><div class=\"line\">## Docs: http://hexo.io/docs/configuration.html</div><div class=\"line\">## Source: https://github.com/hexojs/hexo/</div><div class=\"line\"></div><div class=\"line\"># Site</div><div class=\"line\">title: Xiaojuanmao&apos;s Blog # 网站的标题</div><div class=\"line\">subtitle: Life began in 1990 # 网站的副标题</div><div class=\"line\">description: Coding Life # 显示在网页最下面的描述，类似于tag</div><div class=\"line\">author: Xiaoxiaoda</div><div class=\"line\">email: daque@hustunique.com</div><div class=\"line\">language: zh_CN</div><div class=\"line\">timezone:</div><div class=\"line\"></div><div class=\"line\"># Deployment</div><div class=\"line\">## Docs: http://hexo.io/docs/deployment.html</div><div class=\"line\">deploy:</div><div class=\"line\">  type: git #这里不要写github了，hexo3.0之后用git代替了github</div><div class=\"line\">  repository: git@github.com:Xiaojuanmao/Xiaojuanmao.github.io.git # 填写自己的git仓库地址，之前创建好了的</div><div class=\"line\">  branch: master</div></pre></td></tr></table></figure>\n<p>更改完配置文件之后保存，通过下面的命令部署到github上：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo generate 或者 hexo g  #生成静态网页</div><div class=\"line\">hexo deploy 或者 hexo d #部署到github</div><div class=\"line\">上面两个命令可以和并为 hexo d -g</div></pre></td></tr></table></figure>\n<p><strong>Note</strong><br>部署的过程中可能会出现如下的问题：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ERROR Deployer not found: github</div></pre></td></tr></table></figure>\n<p>遇到这个不要慌，是hexo升级到3.0之后用git代替了github，所以需要再输入下面的命令，安装git的deployer</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install hexo-deployer-git --save</div></pre></td></tr></table></figure>\n<p>安装之后就可以将静态的网页部署到github的远程仓库上面。</p>\n","excerpt":"<h1 id=\"Ubuntu上结合Github用Hexo搭建博客\"><a href=\"#Ubuntu上结合Github用Hexo搭建博客\" class=\"headerlink\" title=\"Ubuntu上结合Github用Hexo搭建博客\"></a>Ubuntu上结合Github用Hexo搭建博客</h1><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a><a href=\"#u7B80_u4ECB\" title=\"简介\"></a>简介</h3><p>在搭建博客的过程中会涉及到下面这些东西：</p>\n<ol>\n<li>Hexo</li>\n<li>Git</li>\n<li>Github Pages</li>\n<li>Npm</li>\n<li>Nodejs</li>\n</ol>\n<p><strong><a href=\"https://github.com/hexojs/hexo\">Hexo</a></strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">一款基于Node.js的简单、快速、强大的静态博客框架</div></pre></td></tr></table></figure>","more":"<p><strong>Hexo搭建博客和github有什么关系</strong></p>\n<p>那Hexo就是一个博客框架，关Github什么事情呢，这还被你说对了，还真不怎么和github相关，用hexo弄一个博客出来很简单。当然你也可以选择用wordpress来结合hexo，只是这里选择用github pages服务，那又说到了一个东西:<strong>github pages</strong>。</p>\n<p><strong><a href=\"https://pages.github.com/\">Github Pages</a></strong></p>\n<p>上面是网址，可以自己进去看看，简单的说就是github提供的一种用来展示托管在自己github仓库上的静态网页。github pages也有自己的一套框架，只用github pages也可以搭建自己的博客。</p>\n<p><strong><a href=\"https://www.npmjs.com/\">Npm</a></strong></p>\n<p>一个NodeJs包管理和分发工具，全称为Node Package Manager。和Ruby的gem，Python的pypi类似。通过npm能快速的部署hexo框架，毕竟hexo基于nodejs。</p>\n<p><strong><a href=\"https://nodejs.org/en/\">Node.js</a></strong></p>\n<p>Node是一个Javascript运行环境(runtime)。实际上它是对Google V8引擎进行了封装。V8引 擎执行Javascript的速度非常快，性能非常好。Node对一些特殊用例进行了优化，提供了替代的API，使得V8在非浏览器环境下运行得更好。</p>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a><a href=\"#u5B89_u88C5\" title=\"安装\"></a>安装</h3><h4 id=\"1-安装Node-js\"><a href=\"#1-安装Node-js\" class=\"headerlink\" title=\"1. 安装Node.js\"></a><a href=\"#1-__u5B89_u88C5Node-js\" title=\"1\\. 安装Node.js\"></a>1. 安装Node.js</h4><p>在Ubuntu下面部署很容易的= =,在终端输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install --yes nodejs</div></pre></td></tr></table></figure>\n<p>Nodejs的部署工作就完成了。其他的Linux发行版可以参照下面的教程<a href=\"https://github.com/nodejs/node-v0.x-archive/wiki/Installing-Node.js-via-package-manager\">Installing Node.js via package manager</a></p>\n<p>也可以在Node的官网上直接<a href=\"https://nodejs.org/en/download/\">下载</a>安装。</p>\n<p>安装好之后，在终端输入nodejs即可进入到nodejs的交互模式中。</p>\n<p><strong>Note</strong><br>需要注意一个问题就是，在hexo中的nodejs文件在运行时使用的是<code>node xxx/js</code>这样的形式，而在Ubuntu下面直接运行<code>node xxx.js</code>会失败，报错为<code>/usr/bin/env: node: No such file or directory</code>，网上有些说是和node的版本有关，实际上是因为NodeJs在Ubuntu上默认安装之后，需要<code>nodejs xxx.js</code>这样用，解决方法为创建如下软链接，保证可以运行<code>node xxx.js</code>:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ln -s /usr/bin/nodejs /usr/bin/node</div></pre></td></tr></table></figure>\n<h4 id=\"2-安装npm\"><a href=\"#2-安装npm\" class=\"headerlink\" title=\"2. 安装npm\"></a><a href=\"#2-__u5B89_u88C5npm\" title=\"2\\. 安装npm\"></a>2. 安装npm</h4><p>在终端输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install npm</div></pre></td></tr></table></figure>\n<h4 id=\"3-安装hexo\"><a href=\"#3-安装hexo\" class=\"headerlink\" title=\"3. 安装hexo\"></a><a href=\"#3-__u5B89_u88C5hexo\" title=\"3\\. 安装hexo\"></a>3. 安装hexo</h4><p>终端输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install hexo-cli -g</div></pre></td></tr></table></figure>\n<p>在这里可能会报错，由于没有root权限导致无法安装hexo，<code>sudo su</code>root一下再安装一次就好了。</p>\n<p>到这里就完成了对Hexo的初步安装了，直接在终端输入<code>hexo</code>会出现相关的信息。</p>\n<h4 id=\"4-安装git\"><a href=\"#4-安装git\" class=\"headerlink\" title=\"4. 安装git\"></a><a href=\"#4-__u5B89_u88C5git\" title=\"4\\. 安装git\"></a>4. 安装git</h4><p>首先安装git</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get update</div><div class=\"line\">sudo apt-get install git</div></pre></td></tr></table></figure>\n<p>设置用户信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git config --global user.name &quot;Xiaojuanmao&quot;//用户名</div><div class=\"line\">$ git config --global user.email  &quot;daque@hustunique.com&quot;//填写自己的邮箱</div></pre></td></tr></table></figure>\n<p>检查SSH keys</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ cd ~/. ssh</div></pre></td></tr></table></figure>\n<p>如果提示No such file or directory 说明你是第一次使用git。按照如下步骤处理SSH Keys，如果存在SSH Keys，则直接跳过下面分割线内的部分。</p>\n<hr>\n<p><strong>配置SSH Keys</strong></p>\n<ul>\n<li><p>生成新的SSH Keys</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ ssh-keygen -t rsa -C &quot;邮件地址@youremail.com&quot;</div></pre></td></tr></table></figure>\n<p>会出现下面的提示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Generating public/private rsa key pair.</div><div class=\"line\">Enter file in which to save the key</div><div class=\"line\">(/Users/your_user_directory/.ssh/id_rsa):</div></pre></td></tr></table></figure>\n<p>直接回车，存储在默认的目录下面。系统会提示输入密码，密码的作用是在向仓库提交代码的时候用到，可以防止其他人向自己的仓库提交代码。输入密码后，相关的会生成.ssh文件。</p>\n</li>\n<li><p>添加新的SSH Keys到GitHub</p>\n<p>通过下面的命令进入目录，该目录下存放着刚才生成的密钥文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ cd ~/. ssh</div></pre></td></tr></table></figure>\n<p>登陆github系统。点击右上角的 Account Settings—-&gt;SSH Public keys —-&gt; add another public keys。打开刚才目录下面的<code>id_rsa.pub</code>文件，将文件内容复制到key文本框中就可以了。</p>\n</li>\n<li><p>测试SSH<br>可以输入下面的命令，测试SSH是否设置成功</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ssh -T git@github.com</div></pre></td></tr></table></figure>\n<p>如果出现下面的信息，则说明设置成功</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Hi XXX! You&apos;ve successfully authenticated, but GitHub does not provide shell access.</div></pre></td></tr></table></figure>\n<p><strong>Note</strong><br>也可能会报出错误：<code>Agent admitted failure to sign using the key.Permission denied (publickey).</code>这是由于没有将新建的ssh密钥加入，下面的命令可以解决：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ssh-add   ~/.ssh/id_rsa</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<hr>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a><a href=\"#u4F7F_u7528\" title=\"使用\"></a>使用</h3><h4 id=\"1-使用github创建博客仓库\"><a href=\"#1-使用github创建博客仓库\" class=\"headerlink\" title=\"1. 使用github创建博客仓库\"></a><a href=\"#1-__u4F7F_u7528github_u521B_u5EFA_u535A_u5BA2_u4ED3_u5E93\" title=\"1\\. 使用github创建博客仓库\"></a>1. 使用github创建博客仓库</h4><p>在github上创建一个仓库，<strong>仓库的名字和用户名必须对应</strong>，如我的帐户名为<code>Xiaojuanmao</code>,则创建的仓库名称为<code>Xiaojuanmao.github.io</code>。这样存放在github上的远程仓库就准备好了，下面来用hexo来初始化本地的仓库内容。</p>\n<h4 id=\"2-Hexo初始化\"><a href=\"#2-Hexo初始化\" class=\"headerlink\" title=\"2. Hexo初始化\"></a><a href=\"#2-_Hexo_u521D_u59CB_u5316\" title=\"2\\. Hexo初始化\"></a>2. Hexo初始化</h4><p>在主文件夹下创建一个hexo文件夹，进入文件夹，在终端输入如下的命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo init</div></pre></td></tr></table></figure>\n<p>会给出这样的反馈：<code>INFO Copying data to ~/hexo INFO You are almost done! Don&#39;t forget to run &#39;npm install&#39; before you start blogging with Hexo!</code><br>接着按照上面的提示，输入命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install</div></pre></td></tr></table></figure>\n<p>会自动在目录下面安装node_modules。接着在命令行中启动本地的服务器，可以用来预览个人博客的样子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo server</div></pre></td></tr></table></figure>\n<p>反馈信息会提示已经在挂在了本地的服务器：<code>INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.</code></p>\n<p>在浏览器中打开<code>http://0.0.0.0&quot;4000/</code>可以看到网页的整个框架已经生成了。有个默认的主题，如果觉得这个主题不好看，hexo还有好多主题可供更换。</p>\n<h4 id=\"3-添加文章\"><a href=\"#3-添加文章\" class=\"headerlink\" title=\"3. 添加文章\"></a><a href=\"#3-__u6DFB_u52A0_u6587_u7AE0\" title=\"3\\. 添加文章\"></a>3. 添加文章</h4><p>打开命令行，进入到hexo的目录下，利用如下的命令，可以新建一个.md格式的文件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo new &quot;My New Post&quot;</div><div class=\"line\">反馈信息：INFO  Created: ~/hexo/source/_posts/My-New-Post.md</div></pre></td></tr></table></figure>\n<p>刷新刚才的<code>localhost:4000</code>，就能看到一篇新的博客出现了，用起来还是炒鸡方便的。创建之后再去编辑这个.md文件，写自己想写的内容就可以了。</p>\n<h4 id=\"4-生成静态网页\"><a href=\"#4-生成静态网页\" class=\"headerlink\" title=\"4. 生成静态网页\"></a><a href=\"#4-__u751F_u6210_u9759_u6001_u7F51_u9875\" title=\"4\\. 生成静态网页\"></a>4. 生成静态网页</h4><p>下面的命令生成静态的网页，在将本地的内容部署到github上面去之前，一定要先执行这个步骤。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo generate</div><div class=\"line\">   或者 hexo g</div></pre></td></tr></table></figure>\n<p>执行完之后，会在./public的目录下生成一系列的.html,.css文件。</p>\n<h4 id=\"5-部署到Github\"><a href=\"#5-部署到Github\" class=\"headerlink\" title=\"5. 部署到Github\"></a><a href=\"#5-__u90E8_u7F72_u5230Github\" title=\"5\\. 部署到Github\"></a>5. 部署到Github</h4><p>在和github完成对接之前，需要去配置hexo自己的配置文件<code>_config.yml</code>。关于这个文件里面的一些内容，需要进行一些修改：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Hexo Configuration</div><div class=\"line\">## Docs: http://hexo.io/docs/configuration.html</div><div class=\"line\">## Source: https://github.com/hexojs/hexo/</div><div class=\"line\"></div><div class=\"line\"># Site</div><div class=\"line\">title: Xiaojuanmao&apos;s Blog # 网站的标题</div><div class=\"line\">subtitle: Life began in 1990 # 网站的副标题</div><div class=\"line\">description: Coding Life # 显示在网页最下面的描述，类似于tag</div><div class=\"line\">author: Xiaoxiaoda</div><div class=\"line\">email: daque@hustunique.com</div><div class=\"line\">language: zh_CN</div><div class=\"line\">timezone:</div><div class=\"line\"></div><div class=\"line\"># Deployment</div><div class=\"line\">## Docs: http://hexo.io/docs/deployment.html</div><div class=\"line\">deploy:</div><div class=\"line\">  type: git #这里不要写github了，hexo3.0之后用git代替了github</div><div class=\"line\">  repository: git@github.com:Xiaojuanmao/Xiaojuanmao.github.io.git # 填写自己的git仓库地址，之前创建好了的</div><div class=\"line\">  branch: master</div></pre></td></tr></table></figure>\n<p>更改完配置文件之后保存，通过下面的命令部署到github上：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo generate 或者 hexo g  #生成静态网页</div><div class=\"line\">hexo deploy 或者 hexo d #部署到github</div><div class=\"line\">上面两个命令可以和并为 hexo d -g</div></pre></td></tr></table></figure>\n<p><strong>Note</strong><br>部署的过程中可能会出现如下的问题：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ERROR Deployer not found: github</div></pre></td></tr></table></figure>\n<p>遇到这个不要慌，是hexo升级到3.0之后用git代替了github，所以需要再输入下面的命令，安装git的deployer</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install hexo-deployer-git --save</div></pre></td></tr></table></figure>\n<p>安装之后就可以将静态的网页部署到github的远程仓库上面。</p>"},{"title":"React-Native笔记(一)","date":"2017-02-24T03:36:05.000Z","_content":"\n## React-Native笔记(一)\n创建项目 `react-native init projectname`\n\n手动运行packager，用于调试项目 `react-native start`\n\n查看日志 `adb locat *:S ReactNative:V ReactNativeJS:V`\n\n<!--more-->\n\n\n## 代码\n\n### import\n在index.android.js中，导入需要用到的组件,例如`Component`，`AppRegistry`，`View`等等\n```\n import React, { Component } from 'react';\n import { AppRegistry, StyleSheet, Text, View} from 'react-native';\n```\n\n### AppRegistry\n应用作为最大的一个Component，需要在最后通过`AppRegistry.registerComponent('AppName', () => AppName)`注册并运行\n\n### props(属性)\n常见基础组件有各种属性(props)，例如`Image`就有`source`和`style`等属性来控制图片地址和尺寸,下列代码中的name就是自定义的props\n\n```\nclass Greeting extends Component {\n  render() {\n    return (\n      <Text>Hello {this.props.name}!</Text>\n    );\n  }\n}\n\n```\n\n### state(状态)\n`props`由父组件指定，在生命周期中不会再改变，而`state`能够用于改变的数据。需要再`Constructor`中对`state`进行初始化，实例如下:\n\n```\nclass Blink extends Component {\n\tconstructor(props) {\n\t  super(props);\n\t  this.state = { showText: true};\n\n\t  setInterval(() => {\n\t  \tthis.setState({ showText: !this.state.showText});\n\t  }, 1000);\n\t}\n\n\n\trender() {\n\t\tlet display = this.state.showText ? this.props.text : ' ';\n\t\treturn (\n\t\t\t<Text>{display}</Text>\n\t\t);\n\t}\n}\n```\n\n### 样式\n所有核心组件都接受`style`属性，样式名称要求使用驼峰命名法。\n使用过程中建议用`StyleSheet.create`来集中定义组件样式，类似于`Android`中定义各种`style`一样。\n借鉴了`CSS`中层叠覆盖的做法，属性能够被覆盖\n\n```\nconst styles = StyleSheet.create({\n\tbigblue: {\n\t\tcolor: 'blue',\n\t\t    \t<View style={{\n   \t\t\tpadding: 10,\n    \t}}>\n\n    \t\t<TextInput\n    \t\t\tstyle={{height: 40}}\n    \t\t\tplaceholder=\"Type here to translate!\"\n    \t\t\tonChangeText={(text) => this.setState({text})} /> \n\n    \t\t<Text style={{padding: 10, fontSize: 42}} >\n    \t\t\t{this.state.text.spilt(' ').map((word) => word && 'woo').join(' ')}\n    \t\t</Text>\n    \t</View>\nfontWeight: 'bold',\n\t\tfontSize: 30,\n\t},\n\tred: {\n\t\tcolor: 'red',\n\t}\n})\n```\n\n\n### 控件尺寸\n\n**固定尺寸**\n在样式中设置`width`和`height`。\n```\n<View style={{width: 50, height: 50}} />\n```\n\n**弹性(flex)尺寸**\n在组件样式中使用`flex`来指定控件所占比例，`flex:1`指定组件撑满剩余空间，多个并列的`flex:1`平分剩余控件\n> 组件能够撑满剩余空间的前提是其父容器的尺寸不为零。如果父容器既没有固定的width和height，也没有设定flex，则父容器的尺寸为零。其子组件如果使用了flex，也是无法显示的。\n\n\n```\n<View style={{flex:1}}>\n    \t\t<View style={{flex:1, backgroundColor: 'powderblue'}} />\n    \t\t<View style={{flex:2, backgroundColor: 'skyblue'}} />\n    \t\t<View style={{flex:3, backgroundColor: 'steelblue'}} />\n    \t</View>\n```\n\n### Flexbox布局\n\n[布局属性文档](http://reactnative.cn/docs/0.41/layout-props.html)\n\n\n`Flexbox`规则用来指定某个组件的子元素布局。\n\n> React Native中的Flexbox的工作原理和web上的CSS基本一致，当然也存在少许差异。首先是默认值不同：flexDirection的默认值是column而不是row，而flex也只能指定一个数字值。\n\n**Flex Direction**\n`flexDirection`样式决定布局的**主轴**，子元素沿着**主轴**方向排列，默认为`column`方向,下面的三个`view`横向排列\n```\n<View style={{flex:1, flexDirection: 'row'}}>\n\t...\n</View>\n```\n\n**Justify Content**\n`justifyContent`决定子元素沿着**主轴**的排列方式。可选属性如下：\n\n| 名称 | 功能 |\n|--------|--------|\n|    默认    |    相邻无间距排列    |\n|    flex-start    |    同上    |\n|    center    |    从中间开始依次排列    |\n|    flex-end    |   从父布局尾端开始排列     |\n|    space-around    |    每个子布局周围距离一致    |\n|    space-between    |    子布局之间距离一致，和父布局无距离    |\n\n```\n<View style={{\n    \t\tflex:1,\n    \t\tflexDirection: 'row',\n    \t\tjustifyContent: 'flex-start',\n    \t}}>\n        ...\n    \t</View>\n```\n\n**Align Items**\n`alignItems`决定子元素**次轴**排列方式，**次轴**和**主轴**方向垂直。\n\n| 名称 | 功能 |\n|--------|--------|\n|    flex-start    |    次轴顶端排列    |\n|    center    |    次轴中间开始排列    |\n|    flex-end    |   次轴尾端开始排列     |\n|    stretch   |    每个子布局周围距离一致    |\n\n\n> 要使stretch选项生效的话，子元素在次轴方向上不能有固定的尺寸。\n\n\n### 处理文本输入\n使用`TextInput`来允许用户输入文本。\n\n`onChangeText`属性接受一个函数，在文本发生变化的时候调用该函数。\n`onSubmitEditting`属性会在文本被提交之后调用(用户按下软键盘上的提交按钮)。\n","source":"_posts/React-Native笔记-一.md","raw":"---\ntitle: React-Native笔记(一)\ndate: 2017-02-24 11:36:05\ntags: React-Native\n\n---\n\n## React-Native笔记(一)\n创建项目 `react-native init projectname`\n\n手动运行packager，用于调试项目 `react-native start`\n\n查看日志 `adb locat *:S ReactNative:V ReactNativeJS:V`\n\n<!--more-->\n\n\n## 代码\n\n### import\n在index.android.js中，导入需要用到的组件,例如`Component`，`AppRegistry`，`View`等等\n```\n import React, { Component } from 'react';\n import { AppRegistry, StyleSheet, Text, View} from 'react-native';\n```\n\n### AppRegistry\n应用作为最大的一个Component，需要在最后通过`AppRegistry.registerComponent('AppName', () => AppName)`注册并运行\n\n### props(属性)\n常见基础组件有各种属性(props)，例如`Image`就有`source`和`style`等属性来控制图片地址和尺寸,下列代码中的name就是自定义的props\n\n```\nclass Greeting extends Component {\n  render() {\n    return (\n      <Text>Hello {this.props.name}!</Text>\n    );\n  }\n}\n\n```\n\n### state(状态)\n`props`由父组件指定，在生命周期中不会再改变，而`state`能够用于改变的数据。需要再`Constructor`中对`state`进行初始化，实例如下:\n\n```\nclass Blink extends Component {\n\tconstructor(props) {\n\t  super(props);\n\t  this.state = { showText: true};\n\n\t  setInterval(() => {\n\t  \tthis.setState({ showText: !this.state.showText});\n\t  }, 1000);\n\t}\n\n\n\trender() {\n\t\tlet display = this.state.showText ? this.props.text : ' ';\n\t\treturn (\n\t\t\t<Text>{display}</Text>\n\t\t);\n\t}\n}\n```\n\n### 样式\n所有核心组件都接受`style`属性，样式名称要求使用驼峰命名法。\n使用过程中建议用`StyleSheet.create`来集中定义组件样式，类似于`Android`中定义各种`style`一样。\n借鉴了`CSS`中层叠覆盖的做法，属性能够被覆盖\n\n```\nconst styles = StyleSheet.create({\n\tbigblue: {\n\t\tcolor: 'blue',\n\t\t    \t<View style={{\n   \t\t\tpadding: 10,\n    \t}}>\n\n    \t\t<TextInput\n    \t\t\tstyle={{height: 40}}\n    \t\t\tplaceholder=\"Type here to translate!\"\n    \t\t\tonChangeText={(text) => this.setState({text})} /> \n\n    \t\t<Text style={{padding: 10, fontSize: 42}} >\n    \t\t\t{this.state.text.spilt(' ').map((word) => word && 'woo').join(' ')}\n    \t\t</Text>\n    \t</View>\nfontWeight: 'bold',\n\t\tfontSize: 30,\n\t},\n\tred: {\n\t\tcolor: 'red',\n\t}\n})\n```\n\n\n### 控件尺寸\n\n**固定尺寸**\n在样式中设置`width`和`height`。\n```\n<View style={{width: 50, height: 50}} />\n```\n\n**弹性(flex)尺寸**\n在组件样式中使用`flex`来指定控件所占比例，`flex:1`指定组件撑满剩余空间，多个并列的`flex:1`平分剩余控件\n> 组件能够撑满剩余空间的前提是其父容器的尺寸不为零。如果父容器既没有固定的width和height，也没有设定flex，则父容器的尺寸为零。其子组件如果使用了flex，也是无法显示的。\n\n\n```\n<View style={{flex:1}}>\n    \t\t<View style={{flex:1, backgroundColor: 'powderblue'}} />\n    \t\t<View style={{flex:2, backgroundColor: 'skyblue'}} />\n    \t\t<View style={{flex:3, backgroundColor: 'steelblue'}} />\n    \t</View>\n```\n\n### Flexbox布局\n\n[布局属性文档](http://reactnative.cn/docs/0.41/layout-props.html)\n\n\n`Flexbox`规则用来指定某个组件的子元素布局。\n\n> React Native中的Flexbox的工作原理和web上的CSS基本一致，当然也存在少许差异。首先是默认值不同：flexDirection的默认值是column而不是row，而flex也只能指定一个数字值。\n\n**Flex Direction**\n`flexDirection`样式决定布局的**主轴**，子元素沿着**主轴**方向排列，默认为`column`方向,下面的三个`view`横向排列\n```\n<View style={{flex:1, flexDirection: 'row'}}>\n\t...\n</View>\n```\n\n**Justify Content**\n`justifyContent`决定子元素沿着**主轴**的排列方式。可选属性如下：\n\n| 名称 | 功能 |\n|--------|--------|\n|    默认    |    相邻无间距排列    |\n|    flex-start    |    同上    |\n|    center    |    从中间开始依次排列    |\n|    flex-end    |   从父布局尾端开始排列     |\n|    space-around    |    每个子布局周围距离一致    |\n|    space-between    |    子布局之间距离一致，和父布局无距离    |\n\n```\n<View style={{\n    \t\tflex:1,\n    \t\tflexDirection: 'row',\n    \t\tjustifyContent: 'flex-start',\n    \t}}>\n        ...\n    \t</View>\n```\n\n**Align Items**\n`alignItems`决定子元素**次轴**排列方式，**次轴**和**主轴**方向垂直。\n\n| 名称 | 功能 |\n|--------|--------|\n|    flex-start    |    次轴顶端排列    |\n|    center    |    次轴中间开始排列    |\n|    flex-end    |   次轴尾端开始排列     |\n|    stretch   |    每个子布局周围距离一致    |\n\n\n> 要使stretch选项生效的话，子元素在次轴方向上不能有固定的尺寸。\n\n\n### 处理文本输入\n使用`TextInput`来允许用户输入文本。\n\n`onChangeText`属性接受一个函数，在文本发生变化的时候调用该函数。\n`onSubmitEditting`属性会在文本被提交之后调用(用户按下软键盘上的提交按钮)。\n","slug":"React-Native笔记-一","published":1,"updated":"2017-03-21T06:38:09.107Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0xtcup90002k2j9m6g10qx5","content":"<h2 id=\"React-Native笔记-一\"><a href=\"#React-Native笔记-一\" class=\"headerlink\" title=\"React-Native笔记(一)\"></a>React-Native笔记(一)</h2><p>创建项目 <code>react-native init projectname</code></p>\n<p>手动运行packager，用于调试项目 <code>react-native start</code></p>\n<p>查看日志 <code>adb locat *:S ReactNative:V ReactNativeJS:V</code></p>\n<a id=\"more\"></a>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><h3 id=\"import\"><a href=\"#import\" class=\"headerlink\" title=\"import\"></a>import</h3><p>在index.android.js中，导入需要用到的组件,例如<code>Component</code>，<code>AppRegistry</code>，<code>View</code>等等<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">import React, &#123; Component &#125; from &apos;react&apos;;</div><div class=\"line\">import &#123; AppRegistry, StyleSheet, Text, View&#125; from &apos;react-native&apos;;</div></pre></td></tr></table></figure></p>\n<h3 id=\"AppRegistry\"><a href=\"#AppRegistry\" class=\"headerlink\" title=\"AppRegistry\"></a>AppRegistry</h3><p>应用作为最大的一个Component，需要在最后通过<code>AppRegistry.registerComponent(&#39;AppName&#39;, () =&gt; AppName)</code>注册并运行</p>\n<h3 id=\"props-属性\"><a href=\"#props-属性\" class=\"headerlink\" title=\"props(属性)\"></a>props(属性)</h3><p>常见基础组件有各种属性(props)，例如<code>Image</code>就有<code>source</code>和<code>style</code>等属性来控制图片地址和尺寸,下列代码中的name就是自定义的props</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Greeting extends Component &#123;</div><div class=\"line\">  render() &#123;</div><div class=\"line\">    return (</div><div class=\"line\">      &lt;Text&gt;Hello &#123;this.props.name&#125;!&lt;/Text&gt;</div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"state-状态\"><a href=\"#state-状态\" class=\"headerlink\" title=\"state(状态)\"></a>state(状态)</h3><p><code>props</code>由父组件指定，在生命周期中不会再改变，而<code>state</code>能够用于改变的数据。需要再<code>Constructor</code>中对<code>state</code>进行初始化，实例如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Blink extends Component &#123;</div><div class=\"line\">\tconstructor(props) &#123;</div><div class=\"line\">\t  super(props);</div><div class=\"line\">\t  this.state = &#123; showText: true&#125;;</div><div class=\"line\"></div><div class=\"line\">\t  setInterval(() =&gt; &#123;</div><div class=\"line\">\t  \tthis.setState(&#123; showText: !this.state.showText&#125;);</div><div class=\"line\">\t  &#125;, 1000);</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\trender() &#123;</div><div class=\"line\">\t\tlet display = this.state.showText ? this.props.text : &apos; &apos;;</div><div class=\"line\">\t\treturn (</div><div class=\"line\">\t\t\t&lt;Text&gt;&#123;display&#125;&lt;/Text&gt;</div><div class=\"line\">\t\t);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"样式\"><a href=\"#样式\" class=\"headerlink\" title=\"样式\"></a>样式</h3><p>所有核心组件都接受<code>style</code>属性，样式名称要求使用驼峰命名法。<br>使用过程中建议用<code>StyleSheet.create</code>来集中定义组件样式，类似于<code>Android</code>中定义各种<code>style</code>一样。<br>借鉴了<code>CSS</code>中层叠覆盖的做法，属性能够被覆盖</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">const styles = StyleSheet.create(&#123;</div><div class=\"line\">\tbigblue: &#123;</div><div class=\"line\">\t\tcolor: &apos;blue&apos;,</div><div class=\"line\">\t\t    \t&lt;View style=&#123;&#123;</div><div class=\"line\">   \t\t\tpadding: 10,</div><div class=\"line\">    \t&#125;&#125;&gt;</div><div class=\"line\"></div><div class=\"line\">    \t\t&lt;TextInput</div><div class=\"line\">    \t\t\tstyle=&#123;&#123;height: 40&#125;&#125;</div><div class=\"line\">    \t\t\tplaceholder=&quot;Type here to translate!&quot;</div><div class=\"line\">    \t\t\tonChangeText=&#123;(text) =&gt; this.setState(&#123;text&#125;)&#125; /&gt; </div><div class=\"line\"></div><div class=\"line\">    \t\t&lt;Text style=&#123;&#123;padding: 10, fontSize: 42&#125;&#125; &gt;</div><div class=\"line\">    \t\t\t&#123;this.state.text.spilt(&apos; &apos;).map((word) =&gt; word &amp;&amp; &apos;woo&apos;).join(&apos; &apos;)&#125;</div><div class=\"line\">    \t\t&lt;/Text&gt;</div><div class=\"line\">    \t&lt;/View&gt;</div><div class=\"line\">fontWeight: &apos;bold&apos;,</div><div class=\"line\">\t\tfontSize: 30,</div><div class=\"line\">\t&#125;,</div><div class=\"line\">\tred: &#123;</div><div class=\"line\">\t\tcolor: &apos;red&apos;,</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h3 id=\"控件尺寸\"><a href=\"#控件尺寸\" class=\"headerlink\" title=\"控件尺寸\"></a>控件尺寸</h3><p><strong>固定尺寸</strong><br>在样式中设置<code>width</code>和<code>height</code>。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;View style=&#123;&#123;width: 50, height: 50&#125;&#125; /&gt;</div></pre></td></tr></table></figure></p>\n<p><strong>弹性(flex)尺寸</strong><br>在组件样式中使用<code>flex</code>来指定控件所占比例，<code>flex:1</code>指定组件撑满剩余空间，多个并列的<code>flex:1</code>平分剩余控件</p>\n<blockquote>\n<p>组件能够撑满剩余空间的前提是其父容器的尺寸不为零。如果父容器既没有固定的width和height，也没有设定flex，则父容器的尺寸为零。其子组件如果使用了flex，也是无法显示的。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;View style=&#123;&#123;flex:1&#125;&#125;&gt;</div><div class=\"line\">    \t\t&lt;View style=&#123;&#123;flex:1, backgroundColor: &apos;powderblue&apos;&#125;&#125; /&gt;</div><div class=\"line\">    \t\t&lt;View style=&#123;&#123;flex:2, backgroundColor: &apos;skyblue&apos;&#125;&#125; /&gt;</div><div class=\"line\">    \t\t&lt;View style=&#123;&#123;flex:3, backgroundColor: &apos;steelblue&apos;&#125;&#125; /&gt;</div><div class=\"line\">    \t&lt;/View&gt;</div></pre></td></tr></table></figure>\n<h3 id=\"Flexbox布局\"><a href=\"#Flexbox布局\" class=\"headerlink\" title=\"Flexbox布局\"></a>Flexbox布局</h3><p><a href=\"http://reactnative.cn/docs/0.41/layout-props.html\" target=\"_blank\" rel=\"external\">布局属性文档</a></p>\n<p><code>Flexbox</code>规则用来指定某个组件的子元素布局。</p>\n<blockquote>\n<p>React Native中的Flexbox的工作原理和web上的CSS基本一致，当然也存在少许差异。首先是默认值不同：flexDirection的默认值是column而不是row，而flex也只能指定一个数字值。</p>\n</blockquote>\n<p><strong>Flex Direction</strong><br><code>flexDirection</code>样式决定布局的<strong>主轴</strong>，子元素沿着<strong>主轴</strong>方向排列，默认为<code>column</code>方向,下面的三个<code>view</code>横向排列<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;View style=&#123;&#123;flex:1, flexDirection: &apos;row&apos;&#125;&#125;&gt;</div><div class=\"line\">\t...</div><div class=\"line\">&lt;/View&gt;</div></pre></td></tr></table></figure></p>\n<p><strong>Justify Content</strong><br><code>justifyContent</code>决定子元素沿着<strong>主轴</strong>的排列方式。可选属性如下：</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>默认</td>\n<td>相邻无间距排列</td>\n</tr>\n<tr>\n<td>flex-start</td>\n<td>同上</td>\n</tr>\n<tr>\n<td>center</td>\n<td>从中间开始依次排列</td>\n</tr>\n<tr>\n<td>flex-end</td>\n<td>从父布局尾端开始排列</td>\n</tr>\n<tr>\n<td>space-around</td>\n<td>每个子布局周围距离一致</td>\n</tr>\n<tr>\n<td>space-between</td>\n<td>子布局之间距离一致，和父布局无距离</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;View style=&#123;&#123;</div><div class=\"line\">    \t\tflex:1,</div><div class=\"line\">    \t\tflexDirection: &apos;row&apos;,</div><div class=\"line\">    \t\tjustifyContent: &apos;flex-start&apos;,</div><div class=\"line\">    \t&#125;&#125;&gt;</div><div class=\"line\">        ...</div><div class=\"line\">    \t&lt;/View&gt;</div></pre></td></tr></table></figure>\n<p><strong>Align Items</strong><br><code>alignItems</code>决定子元素<strong>次轴</strong>排列方式，<strong>次轴</strong>和<strong>主轴</strong>方向垂直。</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>flex-start</td>\n<td>次轴顶端排列</td>\n</tr>\n<tr>\n<td>center</td>\n<td>次轴中间开始排列</td>\n</tr>\n<tr>\n<td>flex-end</td>\n<td>次轴尾端开始排列</td>\n</tr>\n<tr>\n<td>stretch</td>\n<td>每个子布局周围距离一致</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>要使stretch选项生效的话，子元素在次轴方向上不能有固定的尺寸。</p>\n</blockquote>\n<h3 id=\"处理文本输入\"><a href=\"#处理文本输入\" class=\"headerlink\" title=\"处理文本输入\"></a>处理文本输入</h3><p>使用<code>TextInput</code>来允许用户输入文本。</p>\n<p><code>onChangeText</code>属性接受一个函数，在文本发生变化的时候调用该函数。<br><code>onSubmitEditting</code>属性会在文本被提交之后调用(用户按下软键盘上的提交按钮)。</p>\n","excerpt":"<h2 id=\"React-Native笔记-一\"><a href=\"#React-Native笔记-一\" class=\"headerlink\" title=\"React-Native笔记(一)\"></a>React-Native笔记(一)</h2><p>创建项目 <code>react-native init projectname</code></p>\n<p>手动运行packager，用于调试项目 <code>react-native start</code></p>\n<p>查看日志 <code>adb locat *:S ReactNative:V ReactNativeJS:V</code></p>","more":"<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><h3 id=\"import\"><a href=\"#import\" class=\"headerlink\" title=\"import\"></a>import</h3><p>在index.android.js中，导入需要用到的组件,例如<code>Component</code>，<code>AppRegistry</code>，<code>View</code>等等<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">import React, &#123; Component &#125; from &apos;react&apos;;</div><div class=\"line\">import &#123; AppRegistry, StyleSheet, Text, View&#125; from &apos;react-native&apos;;</div></pre></td></tr></table></figure></p>\n<h3 id=\"AppRegistry\"><a href=\"#AppRegistry\" class=\"headerlink\" title=\"AppRegistry\"></a>AppRegistry</h3><p>应用作为最大的一个Component，需要在最后通过<code>AppRegistry.registerComponent(&#39;AppName&#39;, () =&gt; AppName)</code>注册并运行</p>\n<h3 id=\"props-属性\"><a href=\"#props-属性\" class=\"headerlink\" title=\"props(属性)\"></a>props(属性)</h3><p>常见基础组件有各种属性(props)，例如<code>Image</code>就有<code>source</code>和<code>style</code>等属性来控制图片地址和尺寸,下列代码中的name就是自定义的props</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Greeting extends Component &#123;</div><div class=\"line\">  render() &#123;</div><div class=\"line\">    return (</div><div class=\"line\">      &lt;Text&gt;Hello &#123;this.props.name&#125;!&lt;/Text&gt;</div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"state-状态\"><a href=\"#state-状态\" class=\"headerlink\" title=\"state(状态)\"></a>state(状态)</h3><p><code>props</code>由父组件指定，在生命周期中不会再改变，而<code>state</code>能够用于改变的数据。需要再<code>Constructor</code>中对<code>state</code>进行初始化，实例如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Blink extends Component &#123;</div><div class=\"line\">\tconstructor(props) &#123;</div><div class=\"line\">\t  super(props);</div><div class=\"line\">\t  this.state = &#123; showText: true&#125;;</div><div class=\"line\"></div><div class=\"line\">\t  setInterval(() =&gt; &#123;</div><div class=\"line\">\t  \tthis.setState(&#123; showText: !this.state.showText&#125;);</div><div class=\"line\">\t  &#125;, 1000);</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\trender() &#123;</div><div class=\"line\">\t\tlet display = this.state.showText ? this.props.text : &apos; &apos;;</div><div class=\"line\">\t\treturn (</div><div class=\"line\">\t\t\t&lt;Text&gt;&#123;display&#125;&lt;/Text&gt;</div><div class=\"line\">\t\t);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"样式\"><a href=\"#样式\" class=\"headerlink\" title=\"样式\"></a>样式</h3><p>所有核心组件都接受<code>style</code>属性，样式名称要求使用驼峰命名法。<br>使用过程中建议用<code>StyleSheet.create</code>来集中定义组件样式，类似于<code>Android</code>中定义各种<code>style</code>一样。<br>借鉴了<code>CSS</code>中层叠覆盖的做法，属性能够被覆盖</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">const styles = StyleSheet.create(&#123;</div><div class=\"line\">\tbigblue: &#123;</div><div class=\"line\">\t\tcolor: &apos;blue&apos;,</div><div class=\"line\">\t\t    \t&lt;View style=&#123;&#123;</div><div class=\"line\">   \t\t\tpadding: 10,</div><div class=\"line\">    \t&#125;&#125;&gt;</div><div class=\"line\"></div><div class=\"line\">    \t\t&lt;TextInput</div><div class=\"line\">    \t\t\tstyle=&#123;&#123;height: 40&#125;&#125;</div><div class=\"line\">    \t\t\tplaceholder=&quot;Type here to translate!&quot;</div><div class=\"line\">    \t\t\tonChangeText=&#123;(text) =&gt; this.setState(&#123;text&#125;)&#125; /&gt; </div><div class=\"line\"></div><div class=\"line\">    \t\t&lt;Text style=&#123;&#123;padding: 10, fontSize: 42&#125;&#125; &gt;</div><div class=\"line\">    \t\t\t&#123;this.state.text.spilt(&apos; &apos;).map((word) =&gt; word &amp;&amp; &apos;woo&apos;).join(&apos; &apos;)&#125;</div><div class=\"line\">    \t\t&lt;/Text&gt;</div><div class=\"line\">    \t&lt;/View&gt;</div><div class=\"line\">fontWeight: &apos;bold&apos;,</div><div class=\"line\">\t\tfontSize: 30,</div><div class=\"line\">\t&#125;,</div><div class=\"line\">\tred: &#123;</div><div class=\"line\">\t\tcolor: &apos;red&apos;,</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h3 id=\"控件尺寸\"><a href=\"#控件尺寸\" class=\"headerlink\" title=\"控件尺寸\"></a>控件尺寸</h3><p><strong>固定尺寸</strong><br>在样式中设置<code>width</code>和<code>height</code>。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;View style=&#123;&#123;width: 50, height: 50&#125;&#125; /&gt;</div></pre></td></tr></table></figure></p>\n<p><strong>弹性(flex)尺寸</strong><br>在组件样式中使用<code>flex</code>来指定控件所占比例，<code>flex:1</code>指定组件撑满剩余空间，多个并列的<code>flex:1</code>平分剩余控件</p>\n<blockquote>\n<p>组件能够撑满剩余空间的前提是其父容器的尺寸不为零。如果父容器既没有固定的width和height，也没有设定flex，则父容器的尺寸为零。其子组件如果使用了flex，也是无法显示的。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;View style=&#123;&#123;flex:1&#125;&#125;&gt;</div><div class=\"line\">    \t\t&lt;View style=&#123;&#123;flex:1, backgroundColor: &apos;powderblue&apos;&#125;&#125; /&gt;</div><div class=\"line\">    \t\t&lt;View style=&#123;&#123;flex:2, backgroundColor: &apos;skyblue&apos;&#125;&#125; /&gt;</div><div class=\"line\">    \t\t&lt;View style=&#123;&#123;flex:3, backgroundColor: &apos;steelblue&apos;&#125;&#125; /&gt;</div><div class=\"line\">    \t&lt;/View&gt;</div></pre></td></tr></table></figure>\n<h3 id=\"Flexbox布局\"><a href=\"#Flexbox布局\" class=\"headerlink\" title=\"Flexbox布局\"></a>Flexbox布局</h3><p><a href=\"http://reactnative.cn/docs/0.41/layout-props.html\">布局属性文档</a></p>\n<p><code>Flexbox</code>规则用来指定某个组件的子元素布局。</p>\n<blockquote>\n<p>React Native中的Flexbox的工作原理和web上的CSS基本一致，当然也存在少许差异。首先是默认值不同：flexDirection的默认值是column而不是row，而flex也只能指定一个数字值。</p>\n</blockquote>\n<p><strong>Flex Direction</strong><br><code>flexDirection</code>样式决定布局的<strong>主轴</strong>，子元素沿着<strong>主轴</strong>方向排列，默认为<code>column</code>方向,下面的三个<code>view</code>横向排列<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;View style=&#123;&#123;flex:1, flexDirection: &apos;row&apos;&#125;&#125;&gt;</div><div class=\"line\">\t...</div><div class=\"line\">&lt;/View&gt;</div></pre></td></tr></table></figure></p>\n<p><strong>Justify Content</strong><br><code>justifyContent</code>决定子元素沿着<strong>主轴</strong>的排列方式。可选属性如下：</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>默认</td>\n<td>相邻无间距排列</td>\n</tr>\n<tr>\n<td>flex-start</td>\n<td>同上</td>\n</tr>\n<tr>\n<td>center</td>\n<td>从中间开始依次排列</td>\n</tr>\n<tr>\n<td>flex-end</td>\n<td>从父布局尾端开始排列</td>\n</tr>\n<tr>\n<td>space-around</td>\n<td>每个子布局周围距离一致</td>\n</tr>\n<tr>\n<td>space-between</td>\n<td>子布局之间距离一致，和父布局无距离</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;View style=&#123;&#123;</div><div class=\"line\">    \t\tflex:1,</div><div class=\"line\">    \t\tflexDirection: &apos;row&apos;,</div><div class=\"line\">    \t\tjustifyContent: &apos;flex-start&apos;,</div><div class=\"line\">    \t&#125;&#125;&gt;</div><div class=\"line\">        ...</div><div class=\"line\">    \t&lt;/View&gt;</div></pre></td></tr></table></figure>\n<p><strong>Align Items</strong><br><code>alignItems</code>决定子元素<strong>次轴</strong>排列方式，<strong>次轴</strong>和<strong>主轴</strong>方向垂直。</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>flex-start</td>\n<td>次轴顶端排列</td>\n</tr>\n<tr>\n<td>center</td>\n<td>次轴中间开始排列</td>\n</tr>\n<tr>\n<td>flex-end</td>\n<td>次轴尾端开始排列</td>\n</tr>\n<tr>\n<td>stretch</td>\n<td>每个子布局周围距离一致</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>要使stretch选项生效的话，子元素在次轴方向上不能有固定的尺寸。</p>\n</blockquote>\n<h3 id=\"处理文本输入\"><a href=\"#处理文本输入\" class=\"headerlink\" title=\"处理文本输入\"></a>处理文本输入</h3><p>使用<code>TextInput</code>来允许用户输入文本。</p>\n<p><code>onChangeText</code>属性接受一个函数，在文本发生变化的时候调用该函数。<br><code>onSubmitEditting</code>属性会在文本被提交之后调用(用户按下软键盘上的提交按钮)。</p>"},{"title":"React-Native笔记(三)","date":"2017-02-24T03:36:14.000Z","_content":"## React-Native笔记(三)\n\n### 网络\n`React Native`提供了和web标准一直的`Fetch API`来满足网络获取数据的需求。\n\n**发起网络请求**\n获取固定地址内容，不进行处理\n```\nfetch('https://www.baidu.com')\n```\n\n<!--more-->\n\n获取内容并对数据进行加工\n\n```\n fetch('http://bbs.reactnative.cn/api/category/3')\n            .then((response) => response.json())\n            .then((jsonData) => {\n                this.setState({\n                    title: jsonData.topics[0].title,\n                })\n            })\n            .catch((error) => {\n                console.warn(error);\n            })\n```\n\n### WebSocket支持\n对`websocket`支持，可以在单个TCP连接上提供全双工的通信通道。\n\n```\nvar ws = new WebSocket('ws://host.com/path');\n\nws.onopen = () => {\n  // 打开一个连接\n\n  ws.send('something'); // 发送一个消息\n};\n\nws.onmessage = (e) => {\n  // 接收到了一个消息\n  console.log(e.data);\n};\n\nws.onerror = (e) => {\n  // 发生了一个错误\n  console.log(e.message);\n};\n\nws.onclose = (e) => {\n  // 连接被关闭了\n  console.log(e.code, e.reason);\n};\n```\n\n### 页面跳转\n\n**场景(Scene)**\n各种组件组合在一起，形成了一个界面，也就是一个场景\n\n一个简单的场景如下：\n```\nMyScene.js\n\nimport React, { Component } from 'react';\nimport { View, Text } from 'react-native';\n\n/**\n * 导出当前组件\n */\n\nexport default class MyScene extends Component {\n    static defaultProps = {\n        title: 'MyScene',\n    };\n\n    render() {\n        return (\n            <View>\n                <Text>Hi ! My name is {this.props.title} </Text>\n            </View>\n        )\n    }\n}\n```\n\n**Navigator**\n官方首推`Navigator`来作为导航器组件，实现界面跳转,先渲染出一个`Navigator`组件，通过`Navigator`的`renderScene`属性来渲染其他的`Scene`。将之前的那个场景给渲染进来。\n\n**单个渲染**\n\n```\n <Navigator\n                initialRoute={{title: 'My Initial Scene', index: 0}}\n                renderScene={(route, navigator) => {\n                    return <MyScene title={route.title} />\n                }}\n            />\n```\n使用导航器经常会碰到“路由(route)”的概念。“路由”抽象自现实生活中的路牌，在RN中专指包含了场景信息的对象。\n```\n\n\n**实现跳转**\n场景之间的切换，`navigator`提供了两个主要的方法：\n* `push` 将`route`对象推入并渲染\n* `pop` 将`route`对象弹出导航栈\n\n**基本场景**\n```\nimport React, { Component, PropTypes } from 'react';\nimport { View, Text, TouchableHighlight } from 'react-native';\n\nexport default class MyScene extends Component {\n  static propTypes = {\n    title: PropTypes.string.isRequired,\n    onForward: PropTypes.func.isRequired,\n    onBack: PropTypes.func.isRequired,\n  }\n  render() {\n    return (\n      <View>\n        <Text>Current Scene: { this.props.title }</Text>\n        <TouchableHighlight onPress={this.props.onForward}>\n          <Text>点我进入下一场景</Text>\n        </TouchableHighlight>\n        <TouchableHighlight onPress={this.props.onBack}>\n          <Text>点我返回上一场景</Text>\n        </TouchableHighlight>    \n      </View>\n    )\n  }\n}\n```\n\n**导航器**\n\n```\nimport React, {Component} from 'react';\nimport {AppRegistry, Navigator, Text, View} from 'react-native';\n\nimport MyScene from './MyScene';\n\nclass AwesomeProject extends Component {\n\n    render() {\n        return (\n            <Navigator\n                initialRoute={{title: 'My Initial Scene', index: 0}}\n                renderScene={(route, navigator) => {\n                    return <MyScene title={route.title}\n\n                     onForward= { () => {\n                         const nextIndex = route.index + 1;\n                         navigator.push({\n                             title: 'Scene ' + nextIndex,\n                             index: nextIndex\n                         });\n                     }}\n\n                     onBack= { () => {\n                         if (route.index > 0) {\n                             navigator.pop();\n                         }\n                     }}\n\n                     />\n                }}\n            />\n        );\n    }\n\n}\n\nAppRegistry.registerComponent('AwesomeProject', () => AwesomeProject);\n```","source":"_posts/React-Native笔记-三.md","raw":"---\ntitle: React-Native笔记(三)\ndate: 2017-02-24 11:36:14\ntags: React-Native\n\n---\n## React-Native笔记(三)\n\n### 网络\n`React Native`提供了和web标准一直的`Fetch API`来满足网络获取数据的需求。\n\n**发起网络请求**\n获取固定地址内容，不进行处理\n```\nfetch('https://www.baidu.com')\n```\n\n<!--more-->\n\n获取内容并对数据进行加工\n\n```\n fetch('http://bbs.reactnative.cn/api/category/3')\n            .then((response) => response.json())\n            .then((jsonData) => {\n                this.setState({\n                    title: jsonData.topics[0].title,\n                })\n            })\n            .catch((error) => {\n                console.warn(error);\n            })\n```\n\n### WebSocket支持\n对`websocket`支持，可以在单个TCP连接上提供全双工的通信通道。\n\n```\nvar ws = new WebSocket('ws://host.com/path');\n\nws.onopen = () => {\n  // 打开一个连接\n\n  ws.send('something'); // 发送一个消息\n};\n\nws.onmessage = (e) => {\n  // 接收到了一个消息\n  console.log(e.data);\n};\n\nws.onerror = (e) => {\n  // 发生了一个错误\n  console.log(e.message);\n};\n\nws.onclose = (e) => {\n  // 连接被关闭了\n  console.log(e.code, e.reason);\n};\n```\n\n### 页面跳转\n\n**场景(Scene)**\n各种组件组合在一起，形成了一个界面，也就是一个场景\n\n一个简单的场景如下：\n```\nMyScene.js\n\nimport React, { Component } from 'react';\nimport { View, Text } from 'react-native';\n\n/**\n * 导出当前组件\n */\n\nexport default class MyScene extends Component {\n    static defaultProps = {\n        title: 'MyScene',\n    };\n\n    render() {\n        return (\n            <View>\n                <Text>Hi ! My name is {this.props.title} </Text>\n            </View>\n        )\n    }\n}\n```\n\n**Navigator**\n官方首推`Navigator`来作为导航器组件，实现界面跳转,先渲染出一个`Navigator`组件，通过`Navigator`的`renderScene`属性来渲染其他的`Scene`。将之前的那个场景给渲染进来。\n\n**单个渲染**\n\n```\n <Navigator\n                initialRoute={{title: 'My Initial Scene', index: 0}}\n                renderScene={(route, navigator) => {\n                    return <MyScene title={route.title} />\n                }}\n            />\n```\n使用导航器经常会碰到“路由(route)”的概念。“路由”抽象自现实生活中的路牌，在RN中专指包含了场景信息的对象。\n```\n\n\n**实现跳转**\n场景之间的切换，`navigator`提供了两个主要的方法：\n* `push` 将`route`对象推入并渲染\n* `pop` 将`route`对象弹出导航栈\n\n**基本场景**\n```\nimport React, { Component, PropTypes } from 'react';\nimport { View, Text, TouchableHighlight } from 'react-native';\n\nexport default class MyScene extends Component {\n  static propTypes = {\n    title: PropTypes.string.isRequired,\n    onForward: PropTypes.func.isRequired,\n    onBack: PropTypes.func.isRequired,\n  }\n  render() {\n    return (\n      <View>\n        <Text>Current Scene: { this.props.title }</Text>\n        <TouchableHighlight onPress={this.props.onForward}>\n          <Text>点我进入下一场景</Text>\n        </TouchableHighlight>\n        <TouchableHighlight onPress={this.props.onBack}>\n          <Text>点我返回上一场景</Text>\n        </TouchableHighlight>    \n      </View>\n    )\n  }\n}\n```\n\n**导航器**\n\n```\nimport React, {Component} from 'react';\nimport {AppRegistry, Navigator, Text, View} from 'react-native';\n\nimport MyScene from './MyScene';\n\nclass AwesomeProject extends Component {\n\n    render() {\n        return (\n            <Navigator\n                initialRoute={{title: 'My Initial Scene', index: 0}}\n                renderScene={(route, navigator) => {\n                    return <MyScene title={route.title}\n\n                     onForward= { () => {\n                         const nextIndex = route.index + 1;\n                         navigator.push({\n                             title: 'Scene ' + nextIndex,\n                             index: nextIndex\n                         });\n                     }}\n\n                     onBack= { () => {\n                         if (route.index > 0) {\n                             navigator.pop();\n                         }\n                     }}\n\n                     />\n                }}\n            />\n        );\n    }\n\n}\n\nAppRegistry.registerComponent('AwesomeProject', () => AwesomeProject);\n```","slug":"React-Native笔记-三","published":1,"updated":"2017-03-21T06:38:09.107Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0xtcupe0004k2j9vc1h6rbo","content":"<h2 id=\"React-Native笔记-三\"><a href=\"#React-Native笔记-三\" class=\"headerlink\" title=\"React-Native笔记(三)\"></a>React-Native笔记(三)</h2><h3 id=\"网络\"><a href=\"#网络\" class=\"headerlink\" title=\"网络\"></a>网络</h3><p><code>React Native</code>提供了和web标准一直的<code>Fetch API</code>来满足网络获取数据的需求。</p>\n<p><strong>发起网络请求</strong><br>获取固定地址内容，不进行处理<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">fetch(&apos;https://www.baidu.com&apos;)</div></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<p>获取内容并对数据进行加工</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">fetch(&apos;http://bbs.reactnative.cn/api/category/3&apos;)</div><div class=\"line\">           .then((response) =&gt; response.json())</div><div class=\"line\">           .then((jsonData) =&gt; &#123;</div><div class=\"line\">               this.setState(&#123;</div><div class=\"line\">                   title: jsonData.topics[0].title,</div><div class=\"line\">               &#125;)</div><div class=\"line\">           &#125;)</div><div class=\"line\">           .catch((error) =&gt; &#123;</div><div class=\"line\">               console.warn(error);</div><div class=\"line\">           &#125;)</div></pre></td></tr></table></figure>\n<h3 id=\"WebSocket支持\"><a href=\"#WebSocket支持\" class=\"headerlink\" title=\"WebSocket支持\"></a>WebSocket支持</h3><p>对<code>websocket</code>支持，可以在单个TCP连接上提供全双工的通信通道。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">var ws = new WebSocket(&apos;ws://host.com/path&apos;);</div><div class=\"line\"></div><div class=\"line\">ws.onopen = () =&gt; &#123;</div><div class=\"line\">  // 打开一个连接</div><div class=\"line\"></div><div class=\"line\">  ws.send(&apos;something&apos;); // 发送一个消息</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">ws.onmessage = (e) =&gt; &#123;</div><div class=\"line\">  // 接收到了一个消息</div><div class=\"line\">  console.log(e.data);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">ws.onerror = (e) =&gt; &#123;</div><div class=\"line\">  // 发生了一个错误</div><div class=\"line\">  console.log(e.message);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">ws.onclose = (e) =&gt; &#123;</div><div class=\"line\">  // 连接被关闭了</div><div class=\"line\">  console.log(e.code, e.reason);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"页面跳转\"><a href=\"#页面跳转\" class=\"headerlink\" title=\"页面跳转\"></a>页面跳转</h3><p><strong>场景(Scene)</strong><br>各种组件组合在一起，形成了一个界面，也就是一个场景</p>\n<p>一个简单的场景如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">MyScene.js</div><div class=\"line\"></div><div class=\"line\">import React, &#123; Component &#125; from &apos;react&apos;;</div><div class=\"line\">import &#123; View, Text &#125; from &apos;react-native&apos;;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\"> * 导出当前组件</div><div class=\"line\"> */</div><div class=\"line\"></div><div class=\"line\">export default class MyScene extends Component &#123;</div><div class=\"line\">    static defaultProps = &#123;</div><div class=\"line\">        title: &apos;MyScene&apos;,</div><div class=\"line\">    &#125;;</div><div class=\"line\"></div><div class=\"line\">    render() &#123;</div><div class=\"line\">        return (</div><div class=\"line\">            &lt;View&gt;</div><div class=\"line\">                &lt;Text&gt;Hi ! My name is &#123;this.props.title&#125; &lt;/Text&gt;</div><div class=\"line\">            &lt;/View&gt;</div><div class=\"line\">        )</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><strong>Navigator</strong><br>官方首推<code>Navigator</code>来作为导航器组件，实现界面跳转,先渲染出一个<code>Navigator</code>组件，通过<code>Navigator</code>的<code>renderScene</code>属性来渲染其他的<code>Scene</code>。将之前的那个场景给渲染进来。</p>\n<p><strong>单个渲染</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;Navigator</div><div class=\"line\">               initialRoute=&#123;&#123;title: &apos;My Initial Scene&apos;, index: 0&#125;&#125;</div><div class=\"line\">               renderScene=&#123;(route, navigator) =&gt; &#123;</div><div class=\"line\">                   return &lt;MyScene title=&#123;route.title&#125; /&gt;</div><div class=\"line\">               &#125;&#125;</div><div class=\"line\">           /&gt;</div></pre></td></tr></table></figure>\n<p>使用导航器经常会碰到“路由(route)”的概念。“路由”抽象自现实生活中的路牌，在RN中专指包含了场景信息的对象。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">**实现跳转**</div><div class=\"line\">场景之间的切换，`navigator`提供了两个主要的方法：</div><div class=\"line\">* `push` 将`route`对象推入并渲染</div><div class=\"line\">* `pop` 将`route`对象弹出导航栈</div><div class=\"line\"></div><div class=\"line\">**基本场景**</div></pre></td></tr></table></figure></p>\n<p>import React, { Component, PropTypes } from ‘react’;<br>import { View, Text, TouchableHighlight } from ‘react-native’;</p>\n<p>export default class MyScene extends Component {<br>  static propTypes = {<br>    title: PropTypes.string.isRequired,<br>    onForward: PropTypes.func.isRequired,<br>    onBack: PropTypes.func.isRequired,<br>  }<br>  render() {<br>    return (<br>      <view><br>        <text>Current Scene: { this.props.title }</text><br>        <touchablehighlight onpress=\"{this.props.onForward}\"><br>          <text>点我进入下一场景</text><br>        </touchablehighlight><br>        <touchablehighlight onpress=\"{this.props.onBack}\"><br>          <text>点我返回上一场景</text><br>        </touchablehighlight><br>      </view><br>    )<br>  }<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">**导航器**</div></pre></td></tr></table></figure></p>\n<p>import React, {Component} from ‘react’;<br>import {AppRegistry, Navigator, Text, View} from ‘react-native’;</p>\n<p>import MyScene from ‘./MyScene’;</p>\n<p>class AwesomeProject extends Component {</p>\n<pre><code>render() {\n    return (\n        &lt;Navigator\n            initialRoute={{title: 'My Initial Scene', index: 0}}\n            renderScene={(route, navigator) =&gt; {\n                return &lt;MyScene title={route.title}\n\n                 onForward= { () =&gt; {\n                     const nextIndex = route.index + 1;\n                     navigator.push({\n                         title: &apos;Scene &apos; + nextIndex,\n                         index: nextIndex\n                     });\n                 }}\n\n                 onBack= { () =&gt; {\n                     if (route.index &gt; 0) {\n                         navigator.pop();\n                     }\n                 }}\n\n                 /&gt;\n            }}\n        /&gt;\n    );\n}\n</code></pre><p>}</p>\n<p>AppRegistry.registerComponent(‘AwesomeProject’, () =&gt; AwesomeProject);<br>```</p>\n","excerpt":"<h2 id=\"React-Native笔记-三\"><a href=\"#React-Native笔记-三\" class=\"headerlink\" title=\"React-Native笔记(三)\"></a>React-Native笔记(三)</h2><h3 id=\"网络\"><a href=\"#网络\" class=\"headerlink\" title=\"网络\"></a>网络</h3><p><code>React Native</code>提供了和web标准一直的<code>Fetch API</code>来满足网络获取数据的需求。</p>\n<p><strong>发起网络请求</strong><br>获取固定地址内容，不进行处理<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">fetch(&apos;https://www.baidu.com&apos;)</div></pre></td></tr></table></figure></p>","more":"<p>获取内容并对数据进行加工</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">fetch(&apos;http://bbs.reactnative.cn/api/category/3&apos;)</div><div class=\"line\">           .then((response) =&gt; response.json())</div><div class=\"line\">           .then((jsonData) =&gt; &#123;</div><div class=\"line\">               this.setState(&#123;</div><div class=\"line\">                   title: jsonData.topics[0].title,</div><div class=\"line\">               &#125;)</div><div class=\"line\">           &#125;)</div><div class=\"line\">           .catch((error) =&gt; &#123;</div><div class=\"line\">               console.warn(error);</div><div class=\"line\">           &#125;)</div></pre></td></tr></table></figure>\n<h3 id=\"WebSocket支持\"><a href=\"#WebSocket支持\" class=\"headerlink\" title=\"WebSocket支持\"></a>WebSocket支持</h3><p>对<code>websocket</code>支持，可以在单个TCP连接上提供全双工的通信通道。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">var ws = new WebSocket(&apos;ws://host.com/path&apos;);</div><div class=\"line\"></div><div class=\"line\">ws.onopen = () =&gt; &#123;</div><div class=\"line\">  // 打开一个连接</div><div class=\"line\"></div><div class=\"line\">  ws.send(&apos;something&apos;); // 发送一个消息</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">ws.onmessage = (e) =&gt; &#123;</div><div class=\"line\">  // 接收到了一个消息</div><div class=\"line\">  console.log(e.data);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">ws.onerror = (e) =&gt; &#123;</div><div class=\"line\">  // 发生了一个错误</div><div class=\"line\">  console.log(e.message);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">ws.onclose = (e) =&gt; &#123;</div><div class=\"line\">  // 连接被关闭了</div><div class=\"line\">  console.log(e.code, e.reason);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"页面跳转\"><a href=\"#页面跳转\" class=\"headerlink\" title=\"页面跳转\"></a>页面跳转</h3><p><strong>场景(Scene)</strong><br>各种组件组合在一起，形成了一个界面，也就是一个场景</p>\n<p>一个简单的场景如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">MyScene.js</div><div class=\"line\"></div><div class=\"line\">import React, &#123; Component &#125; from &apos;react&apos;;</div><div class=\"line\">import &#123; View, Text &#125; from &apos;react-native&apos;;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\"> * 导出当前组件</div><div class=\"line\"> */</div><div class=\"line\"></div><div class=\"line\">export default class MyScene extends Component &#123;</div><div class=\"line\">    static defaultProps = &#123;</div><div class=\"line\">        title: &apos;MyScene&apos;,</div><div class=\"line\">    &#125;;</div><div class=\"line\"></div><div class=\"line\">    render() &#123;</div><div class=\"line\">        return (</div><div class=\"line\">            &lt;View&gt;</div><div class=\"line\">                &lt;Text&gt;Hi ! My name is &#123;this.props.title&#125; &lt;/Text&gt;</div><div class=\"line\">            &lt;/View&gt;</div><div class=\"line\">        )</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><strong>Navigator</strong><br>官方首推<code>Navigator</code>来作为导航器组件，实现界面跳转,先渲染出一个<code>Navigator</code>组件，通过<code>Navigator</code>的<code>renderScene</code>属性来渲染其他的<code>Scene</code>。将之前的那个场景给渲染进来。</p>\n<p><strong>单个渲染</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;Navigator</div><div class=\"line\">               initialRoute=&#123;&#123;title: &apos;My Initial Scene&apos;, index: 0&#125;&#125;</div><div class=\"line\">               renderScene=&#123;(route, navigator) =&gt; &#123;</div><div class=\"line\">                   return &lt;MyScene title=&#123;route.title&#125; /&gt;</div><div class=\"line\">               &#125;&#125;</div><div class=\"line\">           /&gt;</div></pre></td></tr></table></figure>\n<p>使用导航器经常会碰到“路由(route)”的概念。“路由”抽象自现实生活中的路牌，在RN中专指包含了场景信息的对象。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">**实现跳转**</div><div class=\"line\">场景之间的切换，`navigator`提供了两个主要的方法：</div><div class=\"line\">* `push` 将`route`对象推入并渲染</div><div class=\"line\">* `pop` 将`route`对象弹出导航栈</div><div class=\"line\"></div><div class=\"line\">**基本场景**</div></pre></td></tr></table></figure></p>\n<p>import React, { Component, PropTypes } from ‘react’;<br>import { View, Text, TouchableHighlight } from ‘react-native’;</p>\n<p>export default class MyScene extends Component {<br>  static propTypes = {<br>    title: PropTypes.string.isRequired,<br>    onForward: PropTypes.func.isRequired,<br>    onBack: PropTypes.func.isRequired,<br>  }<br>  render() {<br>    return (<br>      <View><br>        <Text>Current Scene: { this.props.title }</Text><br>        <TouchableHighlight onPress={this.props.onForward}><br>          <Text>点我进入下一场景</Text><br>        </TouchableHighlight><br>        <TouchableHighlight onPress={this.props.onBack}><br>          <Text>点我返回上一场景</Text><br>        </TouchableHighlight><br>      </View><br>    )<br>  }<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">**导航器**</div></pre></td></tr></table></figure></p>\n<p>import React, {Component} from ‘react’;<br>import {AppRegistry, Navigator, Text, View} from ‘react-native’;</p>\n<p>import MyScene from ‘./MyScene’;</p>\n<p>class AwesomeProject extends Component {</p>\n<pre><code>render() {\n    return (\n        &lt;Navigator\n            initialRoute={{title: 'My Initial Scene', index: 0}}\n            renderScene={(route, navigator) =&gt; {\n                return &lt;MyScene title={route.title}\n\n                 onForward= { () =&gt; {\n                     const nextIndex = route.index + 1;\n                     navigator.push({\n                         title: &apos;Scene &apos; + nextIndex,\n                         index: nextIndex\n                     });\n                 }}\n\n                 onBack= { () =&gt; {\n                     if (route.index &gt; 0) {\n                         navigator.pop();\n                     }\n                 }}\n\n                 /&gt;\n            }}\n        /&gt;\n    );\n}\n</code></pre><p>}</p>\n<p>AppRegistry.registerComponent(‘AwesomeProject’, () =&gt; AwesomeProject);<br>```</p>"},{"title":"React-Native笔记(二)","date":"2017-02-24T03:36:10.000Z","_content":"\n## React-Native笔记(二)\n\n### 图片\n\n**静态图片**\n引用图片只需要将图片文件放在项目文件夹中，指定路径引用\n\n```\n<Image source={require('./my-icon.png')} />\n```\n系统会从一个引用了图片的组件所在的根目录出发，去寻找这张图片。\n提供`@2x`,`@3x`来指明图片的精度。\n使用`my-icon.ios.png`以及`my-icon.android.png`来提供不同平台的图片。\n\n<!--more-->\n\n在`require()`里面的图片名字必须为静态字符串\n\n> 加入新的图片资源后，可能需要重启packager引入新的图片资源\n\n**原生与React Native**\n使用react native的时候也能够使用原生打包的资源文件\n\n```\n<Image source={{uri: 'app_icon'}} style={{width: 40, height: 40}} />\n```\n\n> 这一做法并没有任何安全检查。你需要自己确保图片在应用中确实存在，而且还需要指定尺寸。\n\n\n**网络图片**\n使用网络图片的时候需要指定图片的尺寸\n\n```\n// 正确\n<Image source={{uri: 'https://facebook.github.io/react/img/logo_og.png'}}\n       style={{width: 400, height: 400}} />\n\n// 错误\n<Image source={{uri: 'https://facebook.github.io/react/img/logo_og.png'}} />\n```\n\n### ScrollView\n`ScrollView`是一个通用的可滚动容器，支持竖直、水平滚动\n\n```\n    \t<ScrollView> \n\n    \t\t<Text style={{fontSize:32}}>Scroll me plz</Text>\n\n    \t\t<Text style={{fontSize:32}}>Scroll me plz</Text>\n\n    \t\t<Image source={require('./test.jpg')} />\n    \t</ScrollView>\n```\n\n**可点击组件**\n使用`Touchable`开头的一系列组件能够捕捉用户点击操作。\n`onPress`属性接受一个处理点击事件的函数，在点击操作开始并终止于组件的时候，相应的函数会被调用。\n`onLongPress`属性用来处理长按事件。\n\n```\n_onPressButton() {\n    console.log(\"You tapped the button!\");\n  }\n\n<TouchableHighlight onPress={this._onPressButton}>\n        <Text>Button</Text>\n      </TouchableHighlight>\n```\n\n可以通过使用不同组件提供给用户不同的触摸反馈:\n\n* `TouchableHighlight`会在用户手指按下的时候变暗\n* `TouchableNativeFeedback`会在Android上体现出原生的视觉效果\n* `TouchableOpacity`会在用户按下的时候改变透明度\n* `TouchableWithoutFeedback`没有任何反馈\n\n\n###ListView\n动态渲染屏幕上可见的元素\n`dataSource`属性，设定列表的数据源\n`renderRow`属性，诸葛解析数据源中的数据，染回一个设定好格式的组件来渲染\n\n```\nclass ListViewBasics extends Component {\n  // 初始化模拟数据\n  constructor(props) {\n    super(props);\n    const ds = new ListView.DataSource({rowHasChanged: (r1, r2) => r1 !== r2});\n    this.state = {\n      dataSource: ds.cloneWithRows([\n        'John', 'Joel', 'James', 'Jimmy', 'Jackson', 'Jillian', 'Julie', 'Devin'\n      ])\n    };\n  }\n  render() {\n    return (\n      <View style={{flex: 1, paddingTop: 22}}>\n        <ListView\n          dataSource={this.state.dataSource}\n          renderRow={(rowData) => <Text>{rowData}</Text>}\n        />\n      </View>\n    );\n  }\n}\n```","source":"_posts/React-Native笔记-二.md","raw":"---\ntitle: React-Native笔记(二)\ndate: 2017-02-24 11:36:10\ntags: React-Native\n\n---\n\n## React-Native笔记(二)\n\n### 图片\n\n**静态图片**\n引用图片只需要将图片文件放在项目文件夹中，指定路径引用\n\n```\n<Image source={require('./my-icon.png')} />\n```\n系统会从一个引用了图片的组件所在的根目录出发，去寻找这张图片。\n提供`@2x`,`@3x`来指明图片的精度。\n使用`my-icon.ios.png`以及`my-icon.android.png`来提供不同平台的图片。\n\n<!--more-->\n\n在`require()`里面的图片名字必须为静态字符串\n\n> 加入新的图片资源后，可能需要重启packager引入新的图片资源\n\n**原生与React Native**\n使用react native的时候也能够使用原生打包的资源文件\n\n```\n<Image source={{uri: 'app_icon'}} style={{width: 40, height: 40}} />\n```\n\n> 这一做法并没有任何安全检查。你需要自己确保图片在应用中确实存在，而且还需要指定尺寸。\n\n\n**网络图片**\n使用网络图片的时候需要指定图片的尺寸\n\n```\n// 正确\n<Image source={{uri: 'https://facebook.github.io/react/img/logo_og.png'}}\n       style={{width: 400, height: 400}} />\n\n// 错误\n<Image source={{uri: 'https://facebook.github.io/react/img/logo_og.png'}} />\n```\n\n### ScrollView\n`ScrollView`是一个通用的可滚动容器，支持竖直、水平滚动\n\n```\n    \t<ScrollView> \n\n    \t\t<Text style={{fontSize:32}}>Scroll me plz</Text>\n\n    \t\t<Text style={{fontSize:32}}>Scroll me plz</Text>\n\n    \t\t<Image source={require('./test.jpg')} />\n    \t</ScrollView>\n```\n\n**可点击组件**\n使用`Touchable`开头的一系列组件能够捕捉用户点击操作。\n`onPress`属性接受一个处理点击事件的函数，在点击操作开始并终止于组件的时候，相应的函数会被调用。\n`onLongPress`属性用来处理长按事件。\n\n```\n_onPressButton() {\n    console.log(\"You tapped the button!\");\n  }\n\n<TouchableHighlight onPress={this._onPressButton}>\n        <Text>Button</Text>\n      </TouchableHighlight>\n```\n\n可以通过使用不同组件提供给用户不同的触摸反馈:\n\n* `TouchableHighlight`会在用户手指按下的时候变暗\n* `TouchableNativeFeedback`会在Android上体现出原生的视觉效果\n* `TouchableOpacity`会在用户按下的时候改变透明度\n* `TouchableWithoutFeedback`没有任何反馈\n\n\n###ListView\n动态渲染屏幕上可见的元素\n`dataSource`属性，设定列表的数据源\n`renderRow`属性，诸葛解析数据源中的数据，染回一个设定好格式的组件来渲染\n\n```\nclass ListViewBasics extends Component {\n  // 初始化模拟数据\n  constructor(props) {\n    super(props);\n    const ds = new ListView.DataSource({rowHasChanged: (r1, r2) => r1 !== r2});\n    this.state = {\n      dataSource: ds.cloneWithRows([\n        'John', 'Joel', 'James', 'Jimmy', 'Jackson', 'Jillian', 'Julie', 'Devin'\n      ])\n    };\n  }\n  render() {\n    return (\n      <View style={{flex: 1, paddingTop: 22}}>\n        <ListView\n          dataSource={this.state.dataSource}\n          renderRow={(rowData) => <Text>{rowData}</Text>}\n        />\n      </View>\n    );\n  }\n}\n```","slug":"React-Native笔记-二","published":1,"updated":"2017-03-21T06:38:09.107Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0xtcupg0005k2j9qrv2albu","content":"<h2 id=\"React-Native笔记-二\"><a href=\"#React-Native笔记-二\" class=\"headerlink\" title=\"React-Native笔记(二)\"></a>React-Native笔记(二)</h2><h3 id=\"图片\"><a href=\"#图片\" class=\"headerlink\" title=\"图片\"></a>图片</h3><p><strong>静态图片</strong><br>引用图片只需要将图片文件放在项目文件夹中，指定路径引用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;Image source=&#123;require(&apos;./my-icon.png&apos;)&#125; /&gt;</div></pre></td></tr></table></figure>\n<p>系统会从一个引用了图片的组件所在的根目录出发，去寻找这张图片。<br>提供<code>@2x</code>,<code>@3x</code>来指明图片的精度。<br>使用<code>my-icon.ios.png</code>以及<code>my-icon.android.png</code>来提供不同平台的图片。</p>\n<a id=\"more\"></a>\n<p>在<code>require()</code>里面的图片名字必须为静态字符串</p>\n<blockquote>\n<p>加入新的图片资源后，可能需要重启packager引入新的图片资源</p>\n</blockquote>\n<p><strong>原生与React Native</strong><br>使用react native的时候也能够使用原生打包的资源文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;Image source=&#123;&#123;uri: &apos;app_icon&apos;&#125;&#125; style=&#123;&#123;width: 40, height: 40&#125;&#125; /&gt;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>这一做法并没有任何安全检查。你需要自己确保图片在应用中确实存在，而且还需要指定尺寸。</p>\n</blockquote>\n<p><strong>网络图片</strong><br>使用网络图片的时候需要指定图片的尺寸</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 正确</div><div class=\"line\">&lt;Image source=&#123;&#123;uri: &apos;https://facebook.github.io/react/img/logo_og.png&apos;&#125;&#125;</div><div class=\"line\">       style=&#123;&#123;width: 400, height: 400&#125;&#125; /&gt;</div><div class=\"line\"></div><div class=\"line\">// 错误</div><div class=\"line\">&lt;Image source=&#123;&#123;uri: &apos;https://facebook.github.io/react/img/logo_og.png&apos;&#125;&#125; /&gt;</div></pre></td></tr></table></figure>\n<h3 id=\"ScrollView\"><a href=\"#ScrollView\" class=\"headerlink\" title=\"ScrollView\"></a>ScrollView</h3><p><code>ScrollView</code>是一个通用的可滚动容器，支持竖直、水平滚动</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;ScrollView&gt; </div><div class=\"line\"></div><div class=\"line\">\t&lt;Text style=&#123;&#123;fontSize:32&#125;&#125;&gt;Scroll me plz&lt;/Text&gt;</div><div class=\"line\"></div><div class=\"line\">\t&lt;Text style=&#123;&#123;fontSize:32&#125;&#125;&gt;Scroll me plz&lt;/Text&gt;</div><div class=\"line\"></div><div class=\"line\">\t&lt;Image source=&#123;require(&apos;./test.jpg&apos;)&#125; /&gt;</div><div class=\"line\">&lt;/ScrollView&gt;</div></pre></td></tr></table></figure>\n<p><strong>可点击组件</strong><br>使用<code>Touchable</code>开头的一系列组件能够捕捉用户点击操作。<br><code>onPress</code>属性接受一个处理点击事件的函数，在点击操作开始并终止于组件的时候，相应的函数会被调用。<br><code>onLongPress</code>属性用来处理长按事件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">_onPressButton() &#123;</div><div class=\"line\">    console.log(&quot;You tapped the button!&quot;);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">&lt;TouchableHighlight onPress=&#123;this._onPressButton&#125;&gt;</div><div class=\"line\">        &lt;Text&gt;Button&lt;/Text&gt;</div><div class=\"line\">      &lt;/TouchableHighlight&gt;</div></pre></td></tr></table></figure>\n<p>可以通过使用不同组件提供给用户不同的触摸反馈:</p>\n<ul>\n<li><code>TouchableHighlight</code>会在用户手指按下的时候变暗</li>\n<li><code>TouchableNativeFeedback</code>会在Android上体现出原生的视觉效果</li>\n<li><code>TouchableOpacity</code>会在用户按下的时候改变透明度</li>\n<li><code>TouchableWithoutFeedback</code>没有任何反馈</li>\n</ul>\n<p>###ListView<br>动态渲染屏幕上可见的元素<br><code>dataSource</code>属性，设定列表的数据源<br><code>renderRow</code>属性，诸葛解析数据源中的数据，染回一个设定好格式的组件来渲染</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">class ListViewBasics extends Component &#123;</div><div class=\"line\">  // 初始化模拟数据</div><div class=\"line\">  constructor(props) &#123;</div><div class=\"line\">    super(props);</div><div class=\"line\">    const ds = new ListView.DataSource(&#123;rowHasChanged: (r1, r2) =&gt; r1 !== r2&#125;);</div><div class=\"line\">    this.state = &#123;</div><div class=\"line\">      dataSource: ds.cloneWithRows([</div><div class=\"line\">        &apos;John&apos;, &apos;Joel&apos;, &apos;James&apos;, &apos;Jimmy&apos;, &apos;Jackson&apos;, &apos;Jillian&apos;, &apos;Julie&apos;, &apos;Devin&apos;</div><div class=\"line\">      ])</div><div class=\"line\">    &#125;;</div><div class=\"line\">  &#125;</div><div class=\"line\">  render() &#123;</div><div class=\"line\">    return (</div><div class=\"line\">      &lt;View style=&#123;&#123;flex: 1, paddingTop: 22&#125;&#125;&gt;</div><div class=\"line\">        &lt;ListView</div><div class=\"line\">          dataSource=&#123;this.state.dataSource&#125;</div><div class=\"line\">          renderRow=&#123;(rowData) =&gt; &lt;Text&gt;&#123;rowData&#125;&lt;/Text&gt;&#125;</div><div class=\"line\">        /&gt;</div><div class=\"line\">      &lt;/View&gt;</div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","excerpt":"<h2 id=\"React-Native笔记-二\"><a href=\"#React-Native笔记-二\" class=\"headerlink\" title=\"React-Native笔记(二)\"></a>React-Native笔记(二)</h2><h3 id=\"图片\"><a href=\"#图片\" class=\"headerlink\" title=\"图片\"></a>图片</h3><p><strong>静态图片</strong><br>引用图片只需要将图片文件放在项目文件夹中，指定路径引用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;Image source=&#123;require(&apos;./my-icon.png&apos;)&#125; /&gt;</div></pre></td></tr></table></figure>\n<p>系统会从一个引用了图片的组件所在的根目录出发，去寻找这张图片。<br>提供<code>@2x</code>,<code>@3x</code>来指明图片的精度。<br>使用<code>my-icon.ios.png</code>以及<code>my-icon.android.png</code>来提供不同平台的图片。</p>","more":"<p>在<code>require()</code>里面的图片名字必须为静态字符串</p>\n<blockquote>\n<p>加入新的图片资源后，可能需要重启packager引入新的图片资源</p>\n</blockquote>\n<p><strong>原生与React Native</strong><br>使用react native的时候也能够使用原生打包的资源文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;Image source=&#123;&#123;uri: &apos;app_icon&apos;&#125;&#125; style=&#123;&#123;width: 40, height: 40&#125;&#125; /&gt;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>这一做法并没有任何安全检查。你需要自己确保图片在应用中确实存在，而且还需要指定尺寸。</p>\n</blockquote>\n<p><strong>网络图片</strong><br>使用网络图片的时候需要指定图片的尺寸</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 正确</div><div class=\"line\">&lt;Image source=&#123;&#123;uri: &apos;https://facebook.github.io/react/img/logo_og.png&apos;&#125;&#125;</div><div class=\"line\">       style=&#123;&#123;width: 400, height: 400&#125;&#125; /&gt;</div><div class=\"line\"></div><div class=\"line\">// 错误</div><div class=\"line\">&lt;Image source=&#123;&#123;uri: &apos;https://facebook.github.io/react/img/logo_og.png&apos;&#125;&#125; /&gt;</div></pre></td></tr></table></figure>\n<h3 id=\"ScrollView\"><a href=\"#ScrollView\" class=\"headerlink\" title=\"ScrollView\"></a>ScrollView</h3><p><code>ScrollView</code>是一个通用的可滚动容器，支持竖直、水平滚动</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;ScrollView&gt; </div><div class=\"line\"></div><div class=\"line\">\t&lt;Text style=&#123;&#123;fontSize:32&#125;&#125;&gt;Scroll me plz&lt;/Text&gt;</div><div class=\"line\"></div><div class=\"line\">\t&lt;Text style=&#123;&#123;fontSize:32&#125;&#125;&gt;Scroll me plz&lt;/Text&gt;</div><div class=\"line\"></div><div class=\"line\">\t&lt;Image source=&#123;require(&apos;./test.jpg&apos;)&#125; /&gt;</div><div class=\"line\">&lt;/ScrollView&gt;</div></pre></td></tr></table></figure>\n<p><strong>可点击组件</strong><br>使用<code>Touchable</code>开头的一系列组件能够捕捉用户点击操作。<br><code>onPress</code>属性接受一个处理点击事件的函数，在点击操作开始并终止于组件的时候，相应的函数会被调用。<br><code>onLongPress</code>属性用来处理长按事件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">_onPressButton() &#123;</div><div class=\"line\">    console.log(&quot;You tapped the button!&quot;);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">&lt;TouchableHighlight onPress=&#123;this._onPressButton&#125;&gt;</div><div class=\"line\">        &lt;Text&gt;Button&lt;/Text&gt;</div><div class=\"line\">      &lt;/TouchableHighlight&gt;</div></pre></td></tr></table></figure>\n<p>可以通过使用不同组件提供给用户不同的触摸反馈:</p>\n<ul>\n<li><code>TouchableHighlight</code>会在用户手指按下的时候变暗</li>\n<li><code>TouchableNativeFeedback</code>会在Android上体现出原生的视觉效果</li>\n<li><code>TouchableOpacity</code>会在用户按下的时候改变透明度</li>\n<li><code>TouchableWithoutFeedback</code>没有任何反馈</li>\n</ul>\n<p>###ListView<br>动态渲染屏幕上可见的元素<br><code>dataSource</code>属性，设定列表的数据源<br><code>renderRow</code>属性，诸葛解析数据源中的数据，染回一个设定好格式的组件来渲染</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">class ListViewBasics extends Component &#123;</div><div class=\"line\">  // 初始化模拟数据</div><div class=\"line\">  constructor(props) &#123;</div><div class=\"line\">    super(props);</div><div class=\"line\">    const ds = new ListView.DataSource(&#123;rowHasChanged: (r1, r2) =&gt; r1 !== r2&#125;);</div><div class=\"line\">    this.state = &#123;</div><div class=\"line\">      dataSource: ds.cloneWithRows([</div><div class=\"line\">        &apos;John&apos;, &apos;Joel&apos;, &apos;James&apos;, &apos;Jimmy&apos;, &apos;Jackson&apos;, &apos;Jillian&apos;, &apos;Julie&apos;, &apos;Devin&apos;</div><div class=\"line\">      ])</div><div class=\"line\">    &#125;;</div><div class=\"line\">  &#125;</div><div class=\"line\">  render() &#123;</div><div class=\"line\">    return (</div><div class=\"line\">      &lt;View style=&#123;&#123;flex: 1, paddingTop: 22&#125;&#125;&gt;</div><div class=\"line\">        &lt;ListView</div><div class=\"line\">          dataSource=&#123;this.state.dataSource&#125;</div><div class=\"line\">          renderRow=&#123;(rowData) =&gt; &lt;Text&gt;&#123;rowData&#125;&lt;/Text&gt;&#125;</div><div class=\"line\">        /&gt;</div><div class=\"line\">      &lt;/View&gt;</div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"Volley框架解析(一)整体介绍","date":"2017-02-26T02:04:01.000Z","_content":"\n## Volley框架解析(一)整体介绍\n\n感谢各位菊苣，[grumoon](https://github.com/grumoon \"grumoon\"),[huxian99](https://github.com/huxian99 \"huxian99\"),[trinea](https://github.com/trinea \"trinea\"),[郭霖juju](http://blog.csdn.net/guolin_blog \"郭霖juju\")的图片素材，以及详细的分析。\n\n其他菊苣关于Volley解析的链接如下：\n\n[codeKK—Volley源码解析](http://www.codekk.com/open-source-project-analysis/detail/Android/grumoon/Volley%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90)\n\n[郭霖juju—Android Volley完全解析(一)，初识Volley的基本用法](http://blog.csdn.net/guolin_blog/article/details/17482095/ \"郭霖juju\")\n\n<!--more-->\n\n***\n\n### [](#u9898_u5916_u8BDD_28_u53EF_u76F4_u63A5_u8DF3_u8FC7orz \"题外话(可直接跳过orz\")题外话(可直接跳过orz\n\n在Android路上的第一个涉及到网络的项目中，就用到了Volley，当时也就照着网上的方法用了用，用到后面发现满足不了需求之后，尝试着去自定义了一些request，自己去结合Volley来处理服务器返回的cookie。第一个项目已经过去时间比较长了，突然想到想深入的了解下Volley,于是就开始了Volley源码之旅…..本人比较笨，需要比其他人花更多的时间来消化，没办法orz。看了比较长的一段时间后，把自己边看边写的笔记拿出来和大家分享。\n\n### [](#1-_Volley_u7B80_u4ECB \"1\\. Volley简介\")1\\. Volley简介\n\n#### [](#1-1_Volley_u662F_u4EC0_u4E48 \"1.1 Volley是什么\")1.1 Volley是什么\n\nVolley是Google推出的Android异步网络请求框架和图片加载的框架。适合数据量小的,通信频繁的各种请求,官方已经封装好了各种API,而且还提供了很灵活的自定义请求接口,不仅使用起来方便,可扩展性也很强.\n![volley](https://raw.githubusercontent.com/android-cn/android-open-project-analysis/master/tool-lib/network/volley/image/volley.png)\n\n可以通过下面的几种途径获取到volley的代码：\n\n```\ngit clone https://android.googlesource.com/platform/frameworks/volley  \n\njar包下载地址： http://www.kwstu.com/ResourcesView/kwstu_201441183330928 \n\n```\n\n#### [](#1-2__u6574_u4F53_u6846_u67B6 \"1.2 整体框架\")1.2 整体框架\n\n这是从上面提到的菊苣那里拿来的一张图，十分感谢Orz,这张图大致的分析出了Volley中Request从开始到结束需要经历的一个流程，在后面会详细的分析request每一步的动向，这里先简单的做个介绍。\n![design](https://raw.githubusercontent.com/android-cn/android-open-project-analysis/master/tool-lib/network/volley/image/design.png)\n\n**最开始用到Volley发送请求的时候需要通过如下的几行代码(注意给应用添加网络访问的权限)**\n\n```\n//先新建一个请求队列(RequestQueue)\nRequestQueue mQueue = Volley.newRequestQueue(context); \n\n//新建一个request\nStringRequest stringRequest = new StringRequest(\"http://www.xxxxxxx.com\",\n                    new Response.Listener<String>() {\n                        @Override\n                        public void onResponse(String response) {\n                            Log.d(\"TAG\", response);\n                        }\n                    }, new Response.ErrorListener() {\n                        @Override\n                        public void onErrorResponse(VolleyError error) {\n                            Log.e(\"TAG\", error.getMessage(), error);\n                        }\n                    });\n\n//将request加入到队列(RequestQueue)当中\nmQueue.add(stringRequest); \n\n```\n\n做完上面的这些工作,如果不出问题，等着request返回结果就可以了。结合上面的图片，mQueue(**RequestQueue**)被创建之后，会启动新的工作线程(**dispatcher**)开始工作，mQueue里面有专门用来存放request的容器，只要没被stop,这些工作线程会不停的从容器中取出request进行处理,工作线程大致分为两类：\n\n1.  处理有缓存存在的request的dispatcher。该工作线程会涉及到从之前存储的有效缓存(**cache**)中读取数据并返回给调用者。\n2.  处理网络请求的request的dispatcher。该工作线程会涉及到从网络(**network**)获取有效的数据，并返回合适数据给调用者，并会根据request的设置来决定是否将请求结果缓存到本地。\n\n    在工作线程得到了请求响应结果response之后，会将response交给**ResponseDelivery**来处理并通过回调传递给调用者。\n\n    通过上面的介绍，应该能大致的了解volley中，一个request创建并加入到RequestQueue之后大致的一个走向。\n\n#### [](#1-3__u57FA_u7840_u7C7B_u7684_u7B80_u4ECB \"1.3 基础类的简介\")1.3 基础类的简介\n\n在Volley中一共有43个类(不知道当前阅读的是否为最新版本的，不过核心类差不了很远）,主要介绍一下核心类以及其在Volley中起的作用，后面会对核心类的每行代码进行展开分析。\n\n**Volley.java:** 从上面的用法`Volley.newRequestQueue`就能看出，Volley类是对外的接口，里面仅有4个重载了的`newRequestQueue()`函数，用来以各种不同的方式创建并启动一个RequestQueue。\n\n**RequestQueue.java:** 外界通过Volley中的接口来创建其实例，RequestQueue的作用就是存放所有add进来的Request(所有的Request不仅会存放在`mCurrentRequests`里面，其原型是一个HashSet。而且Request还会被分类存放在`mCacheQueue`和`mNetworkQueue`中，分类的标准是是否涉及到网络数据的获取),并且里面会有两类调度器`mDispatchers`和`mCacheDispatcher`来负责处理Request。前者用来处理涉及到网络的Request，后者用来处理直接从缓存中获取数据的Request。它俩获得了数据之后都会交给`mDelivery`(ResponseDelivery.java的实例)来传递回caller。\n\n**Request.java:** 请求类的基类，所有请求类都从该类继承。里面包含了请求方法(POST,GET等)，用户可自定义符合需求的Request，自由度很大。\n\n**NetworkDispatcher.java:** 处理网络请求的调度器，继承自`Thread`类，其中包含了用于存储涉及网络请求的`mQueue`，以及用于网络请求的接口类`mNetwork`(Network.java实例)。在被停止之前进行死循环，调度器会不停的从`mQueue`中取出request来处理，将结果通过`mCache`(Cache.java实例)写入本地缓存中，通过`mDelivery`(ResponseDelivery.java实例)将结果回传给caller。\n\n**CacheDispatcher.java:** 处理缓存请求的调度器，继承自`Thread`类，包含了用于存储涉及缓存请求的队列`mCacheQueue`，和上面的网络调度器工作原理类似。只是从缓存中取出数据再通过`mDelivery`返回给caller。\n\n**ResponseDelivery.java:** 一个用于将Response传递给调用者的回调接口，包含了两类回调方法，`postResponse(Request<?> request, Response<?> response, Runnable runnable)`和`postError(Request<?> request, VolleyError error)`。\n\n**Network.java:** 用于网络请求调用的接口，包含一个方法`performRequest()`。\n\n**BasicNetwork.java:** 继承了Network类，是Volley中默认使用的网络请求处理工具类。在该类里面会处理Request发送前的一系列工作，以及发送工作和发送后返回NetworkResponse的解析工作。里面真正实现网络请求的发送工作是利用了其中的`mHttpStack`(HttpStack.java实例)。\n\n**HttpStack.java:** 网络请求接口类，包含一个方法`performRequest(Request<?> request, Map<String, String> additionalHeaders)`。该方法和BasicNetwork类中实现的方法`performRequest(Request<?> request)`不同。前者在后者的方法中被调用，来实现真正的网络请求。\n\n**HurlStack.java:** 实现了HttpStack接口，在android版本在2.3之上的系统中，通过HttpURLConnection类实现网络请求。\n\n**HttpClientStack.java:** 实现了HttpStack接口，在android版本在2.3之下的系统中，通过HttpClient类实现网络请求。\n\n**Cache.java:** 读写缓存类的接口类，抽象出了一系列有关缓存读写的方法。\n\n**DiskBasedCache.java:** 继承并实现了Cache中的一系列方法，是Volley中默认使用的缓存读写工具类。\n\n**Response.java:** Volley自定义的bean类，Request通过上面实现了HttpStack接口的两种实现方法发出之后，会返回相应的`NetworkResponse`类实例，这个类是`org.apache.http`包里面的类，`NetworkResponse`实例返回后，解析出有用的信息，并组成Response实例。\n\n上面简单的介绍了Volley中的核心类，再盗用一张图orz，再次感谢上面的菊苣们。![design](https://raw.githubusercontent.com/android-cn/android-open-project-analysis/master/tool-lib/network/volley/image/Volley-run-flow-chart.png)\n\n上图清晰的画出了，请求从加入到队列，怎么被分步骤处理，分缓存和网络两条路径，先查询是否存在请求对应的缓存，如存在有效缓存则直接取出缓存数据返回给调用者，如不存在有效缓存则从网络获取数据，写入缓存并返回将结果返回给调用者。\n\n对Volley整体上的简单介绍就先到这里了，后面会将阅读源码时候的笔记整理之后再和大家分享。","source":"_posts/Volley框架解析-一-整体介绍.md","raw":"---\ntitle: Volley框架解析(一)整体介绍\ndate: 2017-02-26 10:04:01\ntags: volley\n\n---\n\n## Volley框架解析(一)整体介绍\n\n感谢各位菊苣，[grumoon](https://github.com/grumoon \"grumoon\"),[huxian99](https://github.com/huxian99 \"huxian99\"),[trinea](https://github.com/trinea \"trinea\"),[郭霖juju](http://blog.csdn.net/guolin_blog \"郭霖juju\")的图片素材，以及详细的分析。\n\n其他菊苣关于Volley解析的链接如下：\n\n[codeKK—Volley源码解析](http://www.codekk.com/open-source-project-analysis/detail/Android/grumoon/Volley%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90)\n\n[郭霖juju—Android Volley完全解析(一)，初识Volley的基本用法](http://blog.csdn.net/guolin_blog/article/details/17482095/ \"郭霖juju\")\n\n<!--more-->\n\n***\n\n### [](#u9898_u5916_u8BDD_28_u53EF_u76F4_u63A5_u8DF3_u8FC7orz \"题外话(可直接跳过orz\")题外话(可直接跳过orz\n\n在Android路上的第一个涉及到网络的项目中，就用到了Volley，当时也就照着网上的方法用了用，用到后面发现满足不了需求之后，尝试着去自定义了一些request，自己去结合Volley来处理服务器返回的cookie。第一个项目已经过去时间比较长了，突然想到想深入的了解下Volley,于是就开始了Volley源码之旅…..本人比较笨，需要比其他人花更多的时间来消化，没办法orz。看了比较长的一段时间后，把自己边看边写的笔记拿出来和大家分享。\n\n### [](#1-_Volley_u7B80_u4ECB \"1\\. Volley简介\")1\\. Volley简介\n\n#### [](#1-1_Volley_u662F_u4EC0_u4E48 \"1.1 Volley是什么\")1.1 Volley是什么\n\nVolley是Google推出的Android异步网络请求框架和图片加载的框架。适合数据量小的,通信频繁的各种请求,官方已经封装好了各种API,而且还提供了很灵活的自定义请求接口,不仅使用起来方便,可扩展性也很强.\n![volley](https://raw.githubusercontent.com/android-cn/android-open-project-analysis/master/tool-lib/network/volley/image/volley.png)\n\n可以通过下面的几种途径获取到volley的代码：\n\n```\ngit clone https://android.googlesource.com/platform/frameworks/volley  \n\njar包下载地址： http://www.kwstu.com/ResourcesView/kwstu_201441183330928 \n\n```\n\n#### [](#1-2__u6574_u4F53_u6846_u67B6 \"1.2 整体框架\")1.2 整体框架\n\n这是从上面提到的菊苣那里拿来的一张图，十分感谢Orz,这张图大致的分析出了Volley中Request从开始到结束需要经历的一个流程，在后面会详细的分析request每一步的动向，这里先简单的做个介绍。\n![design](https://raw.githubusercontent.com/android-cn/android-open-project-analysis/master/tool-lib/network/volley/image/design.png)\n\n**最开始用到Volley发送请求的时候需要通过如下的几行代码(注意给应用添加网络访问的权限)**\n\n```\n//先新建一个请求队列(RequestQueue)\nRequestQueue mQueue = Volley.newRequestQueue(context); \n\n//新建一个request\nStringRequest stringRequest = new StringRequest(\"http://www.xxxxxxx.com\",\n                    new Response.Listener<String>() {\n                        @Override\n                        public void onResponse(String response) {\n                            Log.d(\"TAG\", response);\n                        }\n                    }, new Response.ErrorListener() {\n                        @Override\n                        public void onErrorResponse(VolleyError error) {\n                            Log.e(\"TAG\", error.getMessage(), error);\n                        }\n                    });\n\n//将request加入到队列(RequestQueue)当中\nmQueue.add(stringRequest); \n\n```\n\n做完上面的这些工作,如果不出问题，等着request返回结果就可以了。结合上面的图片，mQueue(**RequestQueue**)被创建之后，会启动新的工作线程(**dispatcher**)开始工作，mQueue里面有专门用来存放request的容器，只要没被stop,这些工作线程会不停的从容器中取出request进行处理,工作线程大致分为两类：\n\n1.  处理有缓存存在的request的dispatcher。该工作线程会涉及到从之前存储的有效缓存(**cache**)中读取数据并返回给调用者。\n2.  处理网络请求的request的dispatcher。该工作线程会涉及到从网络(**network**)获取有效的数据，并返回合适数据给调用者，并会根据request的设置来决定是否将请求结果缓存到本地。\n\n    在工作线程得到了请求响应结果response之后，会将response交给**ResponseDelivery**来处理并通过回调传递给调用者。\n\n    通过上面的介绍，应该能大致的了解volley中，一个request创建并加入到RequestQueue之后大致的一个走向。\n\n#### [](#1-3__u57FA_u7840_u7C7B_u7684_u7B80_u4ECB \"1.3 基础类的简介\")1.3 基础类的简介\n\n在Volley中一共有43个类(不知道当前阅读的是否为最新版本的，不过核心类差不了很远）,主要介绍一下核心类以及其在Volley中起的作用，后面会对核心类的每行代码进行展开分析。\n\n**Volley.java:** 从上面的用法`Volley.newRequestQueue`就能看出，Volley类是对外的接口，里面仅有4个重载了的`newRequestQueue()`函数，用来以各种不同的方式创建并启动一个RequestQueue。\n\n**RequestQueue.java:** 外界通过Volley中的接口来创建其实例，RequestQueue的作用就是存放所有add进来的Request(所有的Request不仅会存放在`mCurrentRequests`里面，其原型是一个HashSet。而且Request还会被分类存放在`mCacheQueue`和`mNetworkQueue`中，分类的标准是是否涉及到网络数据的获取),并且里面会有两类调度器`mDispatchers`和`mCacheDispatcher`来负责处理Request。前者用来处理涉及到网络的Request，后者用来处理直接从缓存中获取数据的Request。它俩获得了数据之后都会交给`mDelivery`(ResponseDelivery.java的实例)来传递回caller。\n\n**Request.java:** 请求类的基类，所有请求类都从该类继承。里面包含了请求方法(POST,GET等)，用户可自定义符合需求的Request，自由度很大。\n\n**NetworkDispatcher.java:** 处理网络请求的调度器，继承自`Thread`类，其中包含了用于存储涉及网络请求的`mQueue`，以及用于网络请求的接口类`mNetwork`(Network.java实例)。在被停止之前进行死循环，调度器会不停的从`mQueue`中取出request来处理，将结果通过`mCache`(Cache.java实例)写入本地缓存中，通过`mDelivery`(ResponseDelivery.java实例)将结果回传给caller。\n\n**CacheDispatcher.java:** 处理缓存请求的调度器，继承自`Thread`类，包含了用于存储涉及缓存请求的队列`mCacheQueue`，和上面的网络调度器工作原理类似。只是从缓存中取出数据再通过`mDelivery`返回给caller。\n\n**ResponseDelivery.java:** 一个用于将Response传递给调用者的回调接口，包含了两类回调方法，`postResponse(Request<?> request, Response<?> response, Runnable runnable)`和`postError(Request<?> request, VolleyError error)`。\n\n**Network.java:** 用于网络请求调用的接口，包含一个方法`performRequest()`。\n\n**BasicNetwork.java:** 继承了Network类，是Volley中默认使用的网络请求处理工具类。在该类里面会处理Request发送前的一系列工作，以及发送工作和发送后返回NetworkResponse的解析工作。里面真正实现网络请求的发送工作是利用了其中的`mHttpStack`(HttpStack.java实例)。\n\n**HttpStack.java:** 网络请求接口类，包含一个方法`performRequest(Request<?> request, Map<String, String> additionalHeaders)`。该方法和BasicNetwork类中实现的方法`performRequest(Request<?> request)`不同。前者在后者的方法中被调用，来实现真正的网络请求。\n\n**HurlStack.java:** 实现了HttpStack接口，在android版本在2.3之上的系统中，通过HttpURLConnection类实现网络请求。\n\n**HttpClientStack.java:** 实现了HttpStack接口，在android版本在2.3之下的系统中，通过HttpClient类实现网络请求。\n\n**Cache.java:** 读写缓存类的接口类，抽象出了一系列有关缓存读写的方法。\n\n**DiskBasedCache.java:** 继承并实现了Cache中的一系列方法，是Volley中默认使用的缓存读写工具类。\n\n**Response.java:** Volley自定义的bean类，Request通过上面实现了HttpStack接口的两种实现方法发出之后，会返回相应的`NetworkResponse`类实例，这个类是`org.apache.http`包里面的类，`NetworkResponse`实例返回后，解析出有用的信息，并组成Response实例。\n\n上面简单的介绍了Volley中的核心类，再盗用一张图orz，再次感谢上面的菊苣们。![design](https://raw.githubusercontent.com/android-cn/android-open-project-analysis/master/tool-lib/network/volley/image/Volley-run-flow-chart.png)\n\n上图清晰的画出了，请求从加入到队列，怎么被分步骤处理，分缓存和网络两条路径，先查询是否存在请求对应的缓存，如存在有效缓存则直接取出缓存数据返回给调用者，如不存在有效缓存则从网络获取数据，写入缓存并返回将结果返回给调用者。\n\n对Volley整体上的简单介绍就先到这里了，后面会将阅读源码时候的笔记整理之后再和大家分享。","slug":"Volley框架解析-一-整体介绍","published":1,"updated":"2017-03-21T06:38:09.107Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0xtcupi0006k2j9rg6ec12s","content":"<h2 id=\"Volley框架解析-一-整体介绍\"><a href=\"#Volley框架解析-一-整体介绍\" class=\"headerlink\" title=\"Volley框架解析(一)整体介绍\"></a>Volley框架解析(一)整体介绍</h2><p>感谢各位菊苣，<a href=\"https://github.com/grumoon\" title=\"grumoon\" target=\"_blank\" rel=\"external\">grumoon</a>,<a href=\"https://github.com/huxian99\" title=\"huxian99\" target=\"_blank\" rel=\"external\">huxian99</a>,<a href=\"https://github.com/trinea\" title=\"trinea\" target=\"_blank\" rel=\"external\">trinea</a>,<a href=\"http://blog.csdn.net/guolin_blog\" title=\"郭霖juju\" target=\"_blank\" rel=\"external\">郭霖juju</a>的图片素材，以及详细的分析。</p>\n<p>其他菊苣关于Volley解析的链接如下：</p>\n<p><a href=\"http://www.codekk.com/open-source-project-analysis/detail/Android/grumoon/Volley%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90\" target=\"_blank\" rel=\"external\">codeKK—Volley源码解析</a></p>\n<p><a href=\"http://blog.csdn.net/guolin_blog/article/details/17482095/\" title=\"郭霖juju\" target=\"_blank\" rel=\"external\">郭霖juju—Android Volley完全解析(一)，初识Volley的基本用法</a></p>\n<a id=\"more\"></a>\n<hr>\n<h3 id=\"题外话-可直接跳过orz\"><a href=\"#题外话-可直接跳过orz\" class=\"headerlink\" title=\"题外话(可直接跳过orz\"></a><a href=\"#u9898_u5916_u8BDD_28_u53EF_u76F4_u63A5_u8DF3_u8FC7orz\" title=\"题外话(可直接跳过orz\"></a>题外话(可直接跳过orz</h3><p>在Android路上的第一个涉及到网络的项目中，就用到了Volley，当时也就照着网上的方法用了用，用到后面发现满足不了需求之后，尝试着去自定义了一些request，自己去结合Volley来处理服务器返回的cookie。第一个项目已经过去时间比较长了，突然想到想深入的了解下Volley,于是就开始了Volley源码之旅…..本人比较笨，需要比其他人花更多的时间来消化，没办法orz。看了比较长的一段时间后，把自己边看边写的笔记拿出来和大家分享。</p>\n<h3 id=\"1-Volley简介\"><a href=\"#1-Volley简介\" class=\"headerlink\" title=\"1. Volley简介\"></a><a href=\"#1-_Volley_u7B80_u4ECB\" title=\"1\\. Volley简介\"></a>1. Volley简介</h3><h4 id=\"1-1-Volley是什么\"><a href=\"#1-1-Volley是什么\" class=\"headerlink\" title=\"1.1 Volley是什么\"></a><a href=\"#1-1_Volley_u662F_u4EC0_u4E48\" title=\"1.1 Volley是什么\"></a>1.1 Volley是什么</h4><p>Volley是Google推出的Android异步网络请求框架和图片加载的框架。适合数据量小的,通信频繁的各种请求,官方已经封装好了各种API,而且还提供了很灵活的自定义请求接口,不仅使用起来方便,可扩展性也很强.<br><img src=\"https://raw.githubusercontent.com/android-cn/android-open-project-analysis/master/tool-lib/network/volley/image/volley.png\" alt=\"volley\"></p>\n<p>可以通过下面的几种途径获取到volley的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">git clone https://android.googlesource.com/platform/frameworks/volley  </div><div class=\"line\"></div><div class=\"line\">jar包下载地址： http://www.kwstu.com/ResourcesView/kwstu_201441183330928</div></pre></td></tr></table></figure>\n<h4 id=\"1-2-整体框架\"><a href=\"#1-2-整体框架\" class=\"headerlink\" title=\"1.2 整体框架\"></a><a href=\"#1-2__u6574_u4F53_u6846_u67B6\" title=\"1.2 整体框架\"></a>1.2 整体框架</h4><p>这是从上面提到的菊苣那里拿来的一张图，十分感谢Orz,这张图大致的分析出了Volley中Request从开始到结束需要经历的一个流程，在后面会详细的分析request每一步的动向，这里先简单的做个介绍。<br><img src=\"https://raw.githubusercontent.com/android-cn/android-open-project-analysis/master/tool-lib/network/volley/image/design.png\" alt=\"design\"></p>\n<p><strong>最开始用到Volley发送请求的时候需要通过如下的几行代码(注意给应用添加网络访问的权限)</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">//先新建一个请求队列(RequestQueue)</div><div class=\"line\">RequestQueue mQueue = Volley.newRequestQueue(context); </div><div class=\"line\"></div><div class=\"line\">//新建一个request</div><div class=\"line\">StringRequest stringRequest = new StringRequest(&quot;http://www.xxxxxxx.com&quot;,</div><div class=\"line\">                    new Response.Listener&lt;String&gt;() &#123;</div><div class=\"line\">                        @Override</div><div class=\"line\">                        public void onResponse(String response) &#123;</div><div class=\"line\">                            Log.d(&quot;TAG&quot;, response);</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;, new Response.ErrorListener() &#123;</div><div class=\"line\">                        @Override</div><div class=\"line\">                        public void onErrorResponse(VolleyError error) &#123;</div><div class=\"line\">                            Log.e(&quot;TAG&quot;, error.getMessage(), error);</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;);</div><div class=\"line\"></div><div class=\"line\">//将request加入到队列(RequestQueue)当中</div><div class=\"line\">mQueue.add(stringRequest);</div></pre></td></tr></table></figure>\n<p>做完上面的这些工作,如果不出问题，等着request返回结果就可以了。结合上面的图片，mQueue(<strong>RequestQueue</strong>)被创建之后，会启动新的工作线程(<strong>dispatcher</strong>)开始工作，mQueue里面有专门用来存放request的容器，只要没被stop,这些工作线程会不停的从容器中取出request进行处理,工作线程大致分为两类：</p>\n<ol>\n<li>处理有缓存存在的request的dispatcher。该工作线程会涉及到从之前存储的有效缓存(<strong>cache</strong>)中读取数据并返回给调用者。</li>\n<li><p>处理网络请求的request的dispatcher。该工作线程会涉及到从网络(<strong>network</strong>)获取有效的数据，并返回合适数据给调用者，并会根据request的设置来决定是否将请求结果缓存到本地。</p>\n<p>在工作线程得到了请求响应结果response之后，会将response交给<strong>ResponseDelivery</strong>来处理并通过回调传递给调用者。</p>\n<p>通过上面的介绍，应该能大致的了解volley中，一个request创建并加入到RequestQueue之后大致的一个走向。</p>\n</li>\n</ol>\n<h4 id=\"1-3-基础类的简介\"><a href=\"#1-3-基础类的简介\" class=\"headerlink\" title=\"1.3 基础类的简介\"></a><a href=\"#1-3__u57FA_u7840_u7C7B_u7684_u7B80_u4ECB\" title=\"1.3 基础类的简介\"></a>1.3 基础类的简介</h4><p>在Volley中一共有43个类(不知道当前阅读的是否为最新版本的，不过核心类差不了很远）,主要介绍一下核心类以及其在Volley中起的作用，后面会对核心类的每行代码进行展开分析。</p>\n<p><strong>Volley.java:</strong> 从上面的用法<code>Volley.newRequestQueue</code>就能看出，Volley类是对外的接口，里面仅有4个重载了的<code>newRequestQueue()</code>函数，用来以各种不同的方式创建并启动一个RequestQueue。</p>\n<p><strong>RequestQueue.java:</strong> 外界通过Volley中的接口来创建其实例，RequestQueue的作用就是存放所有add进来的Request(所有的Request不仅会存放在<code>mCurrentRequests</code>里面，其原型是一个HashSet。而且Request还会被分类存放在<code>mCacheQueue</code>和<code>mNetworkQueue</code>中，分类的标准是是否涉及到网络数据的获取),并且里面会有两类调度器<code>mDispatchers</code>和<code>mCacheDispatcher</code>来负责处理Request。前者用来处理涉及到网络的Request，后者用来处理直接从缓存中获取数据的Request。它俩获得了数据之后都会交给<code>mDelivery</code>(ResponseDelivery.java的实例)来传递回caller。</p>\n<p><strong>Request.java:</strong> 请求类的基类，所有请求类都从该类继承。里面包含了请求方法(POST,GET等)，用户可自定义符合需求的Request，自由度很大。</p>\n<p><strong>NetworkDispatcher.java:</strong> 处理网络请求的调度器，继承自<code>Thread</code>类，其中包含了用于存储涉及网络请求的<code>mQueue</code>，以及用于网络请求的接口类<code>mNetwork</code>(Network.java实例)。在被停止之前进行死循环，调度器会不停的从<code>mQueue</code>中取出request来处理，将结果通过<code>mCache</code>(Cache.java实例)写入本地缓存中，通过<code>mDelivery</code>(ResponseDelivery.java实例)将结果回传给caller。</p>\n<p><strong>CacheDispatcher.java:</strong> 处理缓存请求的调度器，继承自<code>Thread</code>类，包含了用于存储涉及缓存请求的队列<code>mCacheQueue</code>，和上面的网络调度器工作原理类似。只是从缓存中取出数据再通过<code>mDelivery</code>返回给caller。</p>\n<p><strong>ResponseDelivery.java:</strong> 一个用于将Response传递给调用者的回调接口，包含了两类回调方法，<code>postResponse(Request&lt;?&gt; request, Response&lt;?&gt; response, Runnable runnable)</code>和<code>postError(Request&lt;?&gt; request, VolleyError error)</code>。</p>\n<p><strong>Network.java:</strong> 用于网络请求调用的接口，包含一个方法<code>performRequest()</code>。</p>\n<p><strong>BasicNetwork.java:</strong> 继承了Network类，是Volley中默认使用的网络请求处理工具类。在该类里面会处理Request发送前的一系列工作，以及发送工作和发送后返回NetworkResponse的解析工作。里面真正实现网络请求的发送工作是利用了其中的<code>mHttpStack</code>(HttpStack.java实例)。</p>\n<p><strong>HttpStack.java:</strong> 网络请求接口类，包含一个方法<code>performRequest(Request&lt;?&gt; request, Map&lt;String, String&gt; additionalHeaders)</code>。该方法和BasicNetwork类中实现的方法<code>performRequest(Request&lt;?&gt; request)</code>不同。前者在后者的方法中被调用，来实现真正的网络请求。</p>\n<p><strong>HurlStack.java:</strong> 实现了HttpStack接口，在android版本在2.3之上的系统中，通过HttpURLConnection类实现网络请求。</p>\n<p><strong>HttpClientStack.java:</strong> 实现了HttpStack接口，在android版本在2.3之下的系统中，通过HttpClient类实现网络请求。</p>\n<p><strong>Cache.java:</strong> 读写缓存类的接口类，抽象出了一系列有关缓存读写的方法。</p>\n<p><strong>DiskBasedCache.java:</strong> 继承并实现了Cache中的一系列方法，是Volley中默认使用的缓存读写工具类。</p>\n<p><strong>Response.java:</strong> Volley自定义的bean类，Request通过上面实现了HttpStack接口的两种实现方法发出之后，会返回相应的<code>NetworkResponse</code>类实例，这个类是<code>org.apache.http</code>包里面的类，<code>NetworkResponse</code>实例返回后，解析出有用的信息，并组成Response实例。</p>\n<p>上面简单的介绍了Volley中的核心类，再盗用一张图orz，再次感谢上面的菊苣们。<img src=\"https://raw.githubusercontent.com/android-cn/android-open-project-analysis/master/tool-lib/network/volley/image/Volley-run-flow-chart.png\" alt=\"design\"></p>\n<p>上图清晰的画出了，请求从加入到队列，怎么被分步骤处理，分缓存和网络两条路径，先查询是否存在请求对应的缓存，如存在有效缓存则直接取出缓存数据返回给调用者，如不存在有效缓存则从网络获取数据，写入缓存并返回将结果返回给调用者。</p>\n<p>对Volley整体上的简单介绍就先到这里了，后面会将阅读源码时候的笔记整理之后再和大家分享。</p>\n","excerpt":"<h2 id=\"Volley框架解析-一-整体介绍\"><a href=\"#Volley框架解析-一-整体介绍\" class=\"headerlink\" title=\"Volley框架解析(一)整体介绍\"></a>Volley框架解析(一)整体介绍</h2><p>感谢各位菊苣，<a href=\"https://github.com/grumoon\" title=\"grumoon\">grumoon</a>,<a href=\"https://github.com/huxian99\" title=\"huxian99\">huxian99</a>,<a href=\"https://github.com/trinea\" title=\"trinea\">trinea</a>,<a href=\"http://blog.csdn.net/guolin_blog\" title=\"郭霖juju\">郭霖juju</a>的图片素材，以及详细的分析。</p>\n<p>其他菊苣关于Volley解析的链接如下：</p>\n<p><a href=\"http://www.codekk.com/open-source-project-analysis/detail/Android/grumoon/Volley%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90\">codeKK—Volley源码解析</a></p>\n<p><a href=\"http://blog.csdn.net/guolin_blog/article/details/17482095/\" title=\"郭霖juju\">郭霖juju—Android Volley完全解析(一)，初识Volley的基本用法</a></p>","more":"<hr>\n<h3 id=\"题外话-可直接跳过orz\"><a href=\"#题外话-可直接跳过orz\" class=\"headerlink\" title=\"题外话(可直接跳过orz\"></a><a href=\"#u9898_u5916_u8BDD_28_u53EF_u76F4_u63A5_u8DF3_u8FC7orz\" title=\"题外话(可直接跳过orz\"></a>题外话(可直接跳过orz</h3><p>在Android路上的第一个涉及到网络的项目中，就用到了Volley，当时也就照着网上的方法用了用，用到后面发现满足不了需求之后，尝试着去自定义了一些request，自己去结合Volley来处理服务器返回的cookie。第一个项目已经过去时间比较长了，突然想到想深入的了解下Volley,于是就开始了Volley源码之旅…..本人比较笨，需要比其他人花更多的时间来消化，没办法orz。看了比较长的一段时间后，把自己边看边写的笔记拿出来和大家分享。</p>\n<h3 id=\"1-Volley简介\"><a href=\"#1-Volley简介\" class=\"headerlink\" title=\"1. Volley简介\"></a><a href=\"#1-_Volley_u7B80_u4ECB\" title=\"1\\. Volley简介\"></a>1. Volley简介</h3><h4 id=\"1-1-Volley是什么\"><a href=\"#1-1-Volley是什么\" class=\"headerlink\" title=\"1.1 Volley是什么\"></a><a href=\"#1-1_Volley_u662F_u4EC0_u4E48\" title=\"1.1 Volley是什么\"></a>1.1 Volley是什么</h4><p>Volley是Google推出的Android异步网络请求框架和图片加载的框架。适合数据量小的,通信频繁的各种请求,官方已经封装好了各种API,而且还提供了很灵活的自定义请求接口,不仅使用起来方便,可扩展性也很强.<br><img src=\"https://raw.githubusercontent.com/android-cn/android-open-project-analysis/master/tool-lib/network/volley/image/volley.png\" alt=\"volley\"></p>\n<p>可以通过下面的几种途径获取到volley的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">git clone https://android.googlesource.com/platform/frameworks/volley  </div><div class=\"line\"></div><div class=\"line\">jar包下载地址： http://www.kwstu.com/ResourcesView/kwstu_201441183330928</div></pre></td></tr></table></figure>\n<h4 id=\"1-2-整体框架\"><a href=\"#1-2-整体框架\" class=\"headerlink\" title=\"1.2 整体框架\"></a><a href=\"#1-2__u6574_u4F53_u6846_u67B6\" title=\"1.2 整体框架\"></a>1.2 整体框架</h4><p>这是从上面提到的菊苣那里拿来的一张图，十分感谢Orz,这张图大致的分析出了Volley中Request从开始到结束需要经历的一个流程，在后面会详细的分析request每一步的动向，这里先简单的做个介绍。<br><img src=\"https://raw.githubusercontent.com/android-cn/android-open-project-analysis/master/tool-lib/network/volley/image/design.png\" alt=\"design\"></p>\n<p><strong>最开始用到Volley发送请求的时候需要通过如下的几行代码(注意给应用添加网络访问的权限)</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">//先新建一个请求队列(RequestQueue)</div><div class=\"line\">RequestQueue mQueue = Volley.newRequestQueue(context); </div><div class=\"line\"></div><div class=\"line\">//新建一个request</div><div class=\"line\">StringRequest stringRequest = new StringRequest(&quot;http://www.xxxxxxx.com&quot;,</div><div class=\"line\">                    new Response.Listener&lt;String&gt;() &#123;</div><div class=\"line\">                        @Override</div><div class=\"line\">                        public void onResponse(String response) &#123;</div><div class=\"line\">                            Log.d(&quot;TAG&quot;, response);</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;, new Response.ErrorListener() &#123;</div><div class=\"line\">                        @Override</div><div class=\"line\">                        public void onErrorResponse(VolleyError error) &#123;</div><div class=\"line\">                            Log.e(&quot;TAG&quot;, error.getMessage(), error);</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;);</div><div class=\"line\"></div><div class=\"line\">//将request加入到队列(RequestQueue)当中</div><div class=\"line\">mQueue.add(stringRequest);</div></pre></td></tr></table></figure>\n<p>做完上面的这些工作,如果不出问题，等着request返回结果就可以了。结合上面的图片，mQueue(<strong>RequestQueue</strong>)被创建之后，会启动新的工作线程(<strong>dispatcher</strong>)开始工作，mQueue里面有专门用来存放request的容器，只要没被stop,这些工作线程会不停的从容器中取出request进行处理,工作线程大致分为两类：</p>\n<ol>\n<li>处理有缓存存在的request的dispatcher。该工作线程会涉及到从之前存储的有效缓存(<strong>cache</strong>)中读取数据并返回给调用者。</li>\n<li><p>处理网络请求的request的dispatcher。该工作线程会涉及到从网络(<strong>network</strong>)获取有效的数据，并返回合适数据给调用者，并会根据request的设置来决定是否将请求结果缓存到本地。</p>\n<p>在工作线程得到了请求响应结果response之后，会将response交给<strong>ResponseDelivery</strong>来处理并通过回调传递给调用者。</p>\n<p>通过上面的介绍，应该能大致的了解volley中，一个request创建并加入到RequestQueue之后大致的一个走向。</p>\n</li>\n</ol>\n<h4 id=\"1-3-基础类的简介\"><a href=\"#1-3-基础类的简介\" class=\"headerlink\" title=\"1.3 基础类的简介\"></a><a href=\"#1-3__u57FA_u7840_u7C7B_u7684_u7B80_u4ECB\" title=\"1.3 基础类的简介\"></a>1.3 基础类的简介</h4><p>在Volley中一共有43个类(不知道当前阅读的是否为最新版本的，不过核心类差不了很远）,主要介绍一下核心类以及其在Volley中起的作用，后面会对核心类的每行代码进行展开分析。</p>\n<p><strong>Volley.java:</strong> 从上面的用法<code>Volley.newRequestQueue</code>就能看出，Volley类是对外的接口，里面仅有4个重载了的<code>newRequestQueue()</code>函数，用来以各种不同的方式创建并启动一个RequestQueue。</p>\n<p><strong>RequestQueue.java:</strong> 外界通过Volley中的接口来创建其实例，RequestQueue的作用就是存放所有add进来的Request(所有的Request不仅会存放在<code>mCurrentRequests</code>里面，其原型是一个HashSet。而且Request还会被分类存放在<code>mCacheQueue</code>和<code>mNetworkQueue</code>中，分类的标准是是否涉及到网络数据的获取),并且里面会有两类调度器<code>mDispatchers</code>和<code>mCacheDispatcher</code>来负责处理Request。前者用来处理涉及到网络的Request，后者用来处理直接从缓存中获取数据的Request。它俩获得了数据之后都会交给<code>mDelivery</code>(ResponseDelivery.java的实例)来传递回caller。</p>\n<p><strong>Request.java:</strong> 请求类的基类，所有请求类都从该类继承。里面包含了请求方法(POST,GET等)，用户可自定义符合需求的Request，自由度很大。</p>\n<p><strong>NetworkDispatcher.java:</strong> 处理网络请求的调度器，继承自<code>Thread</code>类，其中包含了用于存储涉及网络请求的<code>mQueue</code>，以及用于网络请求的接口类<code>mNetwork</code>(Network.java实例)。在被停止之前进行死循环，调度器会不停的从<code>mQueue</code>中取出request来处理，将结果通过<code>mCache</code>(Cache.java实例)写入本地缓存中，通过<code>mDelivery</code>(ResponseDelivery.java实例)将结果回传给caller。</p>\n<p><strong>CacheDispatcher.java:</strong> 处理缓存请求的调度器，继承自<code>Thread</code>类，包含了用于存储涉及缓存请求的队列<code>mCacheQueue</code>，和上面的网络调度器工作原理类似。只是从缓存中取出数据再通过<code>mDelivery</code>返回给caller。</p>\n<p><strong>ResponseDelivery.java:</strong> 一个用于将Response传递给调用者的回调接口，包含了两类回调方法，<code>postResponse(Request&lt;?&gt; request, Response&lt;?&gt; response, Runnable runnable)</code>和<code>postError(Request&lt;?&gt; request, VolleyError error)</code>。</p>\n<p><strong>Network.java:</strong> 用于网络请求调用的接口，包含一个方法<code>performRequest()</code>。</p>\n<p><strong>BasicNetwork.java:</strong> 继承了Network类，是Volley中默认使用的网络请求处理工具类。在该类里面会处理Request发送前的一系列工作，以及发送工作和发送后返回NetworkResponse的解析工作。里面真正实现网络请求的发送工作是利用了其中的<code>mHttpStack</code>(HttpStack.java实例)。</p>\n<p><strong>HttpStack.java:</strong> 网络请求接口类，包含一个方法<code>performRequest(Request&lt;?&gt; request, Map&lt;String, String&gt; additionalHeaders)</code>。该方法和BasicNetwork类中实现的方法<code>performRequest(Request&lt;?&gt; request)</code>不同。前者在后者的方法中被调用，来实现真正的网络请求。</p>\n<p><strong>HurlStack.java:</strong> 实现了HttpStack接口，在android版本在2.3之上的系统中，通过HttpURLConnection类实现网络请求。</p>\n<p><strong>HttpClientStack.java:</strong> 实现了HttpStack接口，在android版本在2.3之下的系统中，通过HttpClient类实现网络请求。</p>\n<p><strong>Cache.java:</strong> 读写缓存类的接口类，抽象出了一系列有关缓存读写的方法。</p>\n<p><strong>DiskBasedCache.java:</strong> 继承并实现了Cache中的一系列方法，是Volley中默认使用的缓存读写工具类。</p>\n<p><strong>Response.java:</strong> Volley自定义的bean类，Request通过上面实现了HttpStack接口的两种实现方法发出之后，会返回相应的<code>NetworkResponse</code>类实例，这个类是<code>org.apache.http</code>包里面的类，<code>NetworkResponse</code>实例返回后，解析出有用的信息，并组成Response实例。</p>\n<p>上面简单的介绍了Volley中的核心类，再盗用一张图orz，再次感谢上面的菊苣们。<img src=\"https://raw.githubusercontent.com/android-cn/android-open-project-analysis/master/tool-lib/network/volley/image/Volley-run-flow-chart.png\" alt=\"design\"></p>\n<p>上图清晰的画出了，请求从加入到队列，怎么被分步骤处理，分缓存和网络两条路径，先查询是否存在请求对应的缓存，如存在有效缓存则直接取出缓存数据返回给调用者，如不存在有效缓存则从网络获取数据，写入缓存并返回将结果返回给调用者。</p>\n<p>对Volley整体上的简单介绍就先到这里了，后面会将阅读源码时候的笔记整理之后再和大家分享。</p>"},{"title":"Volley框架解析(三)Dispatcher解析","date":"2017-03-01T15:53:47.000Z","_content":"\n## Volley框架解析(三)-----Dispatcher解析\n\n</header>\n\n<div class=\"article-entry\" itemprop=\"articleBody\">\n\n### [](#u9898_u5916_u8BDD_28_u53EF_u76F4_u63A5_u65E0_u89C6_uFF0C_u8DF3_u8FC7_7E \"题外话(可直接无视，跳过~\")题外话(可直接无视，跳过~\n\n在上一篇博客中结合volley源代码分析了`Volley.java`和`RequestQueue.java`这两个类，不知道代码全贴上去了，会不会看着很烦的嗯= =，当时看源代码的时候心里就有些不淡定，满屏幕看不懂的东西，但是个人觉得源代码和注释一起看才方便，一段代码一段解释会感觉有点摸不着头脑= =。前面的博客中一直提到了`Dispatcher`这种的东西，有`mNetworkDispatcher`和`mCacheDispatcher`之类的，这篇博客就开始进一步的介绍Volley中的Dispatcher。\n\n<!--more-->\n\n***\n\n<a id=\"more\"></a>\n\n### [](#1-__u7B80_u4ECB \"1\\. 简介\")1\\. 简介\n\n在Volley中涉及到了两类的Dispatcher,一类是涉及到缓存的`CacheDispatcher.java`，另外一类是用来处理网络方面request的`NetworkDispatcher.java`，最开始出现这两个Dispatcher是在`RequestQueue#start()`中，再来回顾一下start方法中的代码：\n\n```\npublic void start() {\n    stop();  // Make sure any currently running dispatchers are stopped.\n    // Create the cache dispatcher and start it.\n    mCacheDispatcher = new CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);\n    mCacheDispatcher.start();\n\n    // Create network dispatchers (and corresponding threads) up to the pool size.\n    for (int i = 0; i < mDispatchers.length; i++) {\n        NetworkDispatcher networkDispatcher = new NetworkDispatcher(mNetworkQueue, mNetwork,\n                mCache, mDelivery);\n        mDispatchers[i] = networkDispatcher;\n        networkDispatcher.start();\n    }\n}\n\n```\n\n先暂停了所有的dispatcher，然后又新建了dispatcher并start()。让dispatcher开始工作，实际上这些dispatcher继承了Thread类，是独立于主线程之外的工作线程，这样可以使RequestQueue中request的加入和处理同时进行。下面就结合CacheDispatcher和NetworkDispatcher两个类的代码来分析,Volley中是如何对request来进行调度和处理的。\n\n### [](#2-_CacheDispatcher-java \"2\\. CacheDispatcher.java\")2\\. CacheDispatcher.java\n\n```\npackage com.android.volley;\n\nimport android.os.Process;\n\nimport java.util.concurrent.BlockingQueue;\n\n/**\n * Provides a thread for performing cache triage on a queue of requests.\n * 提供一个用来处理涉及到缓存的requests的线程\n * \n * Requests added to the specified cache queue are resolved from cache.\n * Any deliverable response is posted back to the caller via a\n * {@link ResponseDelivery}.  Cache misses and responses that require\n * refresh are enqueued on the specified network queue for processing\n * by a {@link NetworkDispatcher}.\n * CacheDispatcher用来处理缓存队列里面(mCacheQueue)中的request\n * 任何符合delivery要求的response都会被通过ResponseDelivery的接口传递给caller\n * 有些cache丢失了或者是cache中的数据需要更新的，都将会交给NetworkDispatcher去处理\n * 交给NetworkDispatcher处理的方法就是直接放到mNetworkQueue中去\n * 因为NetworkDispatcher总是从mNetworkQueue中取出request来进行处理的\n */\n\npublic class CacheDispatcher extends Thread {\n\n    private static final boolean DEBUG = VolleyLog.DEBUG;\n\n    /** \n     * The queue of requests coming in for triage. \n     * 将要被处理的涉及到缓存的Request存放在这个阻塞队列里\n     * 等着咯，这个mCacheQueue和RequestQueue中的mCacheQueue指向的队列是同一个\n     * 也就是说整个Volley在运行的时候只有一个mCacheQueue\n     */\n    private final BlockingQueue<Request<?>> mCacheQueue;\n\n    /** \n     * The queue of requests going out to the network. \n     * 这个阻塞队里里面存着的可是要去进行网络访问的request\n     * 开始还不明白这里不应该是涉及到访问缓存的request\n     * 怎么有个这东西出来了，其实看到后面了就会发现，缓存里面有两个过期时间\n     * 在后面会介绍到Cache.java类，Cache.Entry类中涉及到了\n     * ttl 和 softTtl这两个long型的数据，用来标识缓存是否已经过期了\n     * 或者是否需要去检查是否要更新缓存的两个间隔时间\n     */\n    private final BlockingQueue<Request<?>> mNetworkQueue;\n\n    /** \n     * The cache to read from. \n     * 用于读写缓存的接口\n     * 这个接口也是在Volley中只有一个\n     * mCacheDispatcher和mNetworkDispatcher公用的\n     */\n    private final Cache mCache;\n\n    /** \n     * For posting responses. \n     * ResponseDelivery对象引用，用来将request的结果传递给caller\n     * 在NetworkDispatcher里面也有出现\n     * 这个也是从RequestQueue中传递过来的，公用\n     */\n    private final ResponseDelivery mDelivery;\n\n    /** \n     * Used for telling us to die. \n     * 直译 ： 用来告诉我们去死= = (shit)\n     * 然而 ： 这个变量用来标志这个dispatcher是否要继续工作下去\n     * 如果为true就结束本线程中的死循环\n     */\n    private volatile boolean mQuit = false;\n\n    /**\n     * Creates a new cache triage dispatcher thread.  You must call {@link #start()}\n     * in order to begin processing.\n     * 构造函数咯，创建一个存放需要访问缓存的request的调度线程\n     * 在创建之后需要将其用start()启动\n     * \n     * @param cacheQueue Queue of incoming requests for triage\n     * 存放request的缓存队列\n     * @param networkQueue Queue to post requests that require network to\n     * 存放涉及network的网络队列\n     * @param cache Cache interface to use for resolution\n     * 用来处理缓存读写问题的接口\n     * @param delivery Delivery interface to use for posting responses\n     * 用来反馈结果的接口\n     */\n    public CacheDispatcher(\n            BlockingQueue<Request<?>> cacheQueue, BlockingQueue<Request<?>> networkQueue,\n            Cache cache, ResponseDelivery delivery) {\n        mCacheQueue = cacheQueue;\n        mNetworkQueue = networkQueue;\n        mCache = cache;\n        mDelivery = delivery;\n    }\n\n    /**\n     * Forces this dispatcher to quit immediately.  If any requests are still in\n     * the queue, they are not guaranteed to be processed.\n     * 将标志位mQuit置为true,在每次死循环的最后会判断该标志位\n     */\n    public void quit() {\n        mQuit = true;\n        interrupt();\n    }\n\n    /**\n     * 前面提到了CacheDispatcher继承了Thread类\n     * 这里就重写了run()方法\n     * 当外面调用了mCacheDispatcher.start()之后\n     * run()里面的方法就开始执行了\n     */\n    @Override\n    public void run() {\n\n        if (DEBUG) VolleyLog.v(\"start new dispatcher\");\n        /**\n         * 给自己设置了线程的优先级\n         * THREAD_PRIORITY_BACKGROUND的优先级是0x0000000a(也就是10)\n         * 还有其他的很多种优先级，该优先级处于较高的位置\n         */\n        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);\n\n        /**\n         * Make a blocking call to initialize the cache.\n         * 在读写缓存之前做一些初始化工作，例如扫描缓存目录是否存在等\n         * 这个暂时先不用管里面的内容，等介绍到Cache.java的时候就会明白\n         */\n        mCache.initialize();\n\n        /**\n         * 从这里开始就进入了死循环的状态\n         * 除非出现了什么没有catch的exception\n         * 或者是mQuit标志位被置成了true\n         * 这个死循环将一直进行下去= =\n         * 总感觉有什么不妥的地方，感觉死循环怪怪的噢\n         */\n        while (true) {\n            /**\n             * 和NetworkDispatcher里面的流程没有什么太大的变化\n             * 还是一个死循环不停的从CacheQueue中取出Request\n             */\n            try {\n                /**\n                 * Get a request from the cache triage queue, blocking until\n                 * at least one is available.\n                 * 从缓存request队列里面取出等待处理的request\n                 * 如果没有可取出的request，则会在这里阻塞\n                 * 这个是PriorityBlockingQueue#take()函数的作用\n                 * \n                 */\n                final Request<?> request = mCacheQueue.take();\n\n                /**\n                 * 给每个request添加上一个打log的标志\n                 * 为了debug的需要\n                 */\n                request.addMarker(\"cache-queue-take\");\n\n                /**\n                 * If the request has been canceled, don't bother dispatching it.\n                 * 如果正在处理的这个请求被取消了\n                 * 中断对该request的处理，continue去处理下一个request的调度\n                 * 调用Request#finish()方法，传入的参数是为了debug方便，打出request调度进度的log\n                 */\n                if (request.isCanceled()) {\n                    request.finish(\"cache-discard-canceled\");\n                    continue;\n                }\n\n                /**\n                 * 在这里NetworkDispatcher和CacheDispatcher出现了一点差异\n                 * NetworkDispatcher.java在这一步就直接开始网络请求了\n                 * \n                 * 由于是CacheDispatcher.java，肯定是主要以Cahce为主的\n                 * CacheDispatcher在这里先看看有没有缓存\n                 * 如果没有缓存则马上将这个request加入到NetworkQueue中\n                 * (意思好像就是= =兄弟你排错队了)\n                 * 然后继续喊下一个request来被处理\n                 */\n                // Attempt to retrieve this item from cache.\n                Cache.Entry entry = mCache.get(request.getCacheKey());\n                if (entry == null) {\n                    request.addMarker(\"cache-miss\");\n                    // Cache miss; send off to the network dispatcher.\n                    mNetworkQueue.put(request);\n                    continue;\n                }\n\n                /**\n                 * 能到这一步的request不简单了\n                 * 肯定是被上面的mCache.get(cacheKey)查到了有缓存的(毕竟有靠山的伤不起)\n                 * 有缓存还不能太大意= =，万一缓存尼玛是个过期的就惨了= =\n                 * 先用entry.isExpired()函数检查一番\n                 * 过期了照样还是给我滚到NetworkQueue中去排队\n                 *\n                 * 继续喊下一个request来\n                 */\n                // If it is completely expired, just send it to the network.\n                if (entry.isExpired()) {\n                    request.addMarker(\"cache-hit-expired\");\n                    request.setCacheEntry(entry);\n                    mNetworkQueue.put(request);\n                    continue;\n                }\n\n                /**\n                 * 哎哟，能到这一步的request更加不简单了，不仅仅有缓存\n                 * 而且还是能用的缓存，没有过期的诶，这才是有真的靠山= =\n                 *\n                 * 将缓存的信息都拿出来，组成一个NetworkResponse\n                 * 就像是刚刚从网络上获取出来的一样，再形成一个Response.java对象\n                 * 但是不要着急把这个response直接传回caller，这个response还没确定是否需要refresh\n                 */\n\n                // We have a cache hit; parse its data for delivery back to the request.\n                request.addMarker(\"cache-hit\");\n\n                /**\n                 * 将一个由缓存中的数据创建的NetworkResponse.java对象\n                 * 通过Request#parseNetworkResponse()方法\n                 * 来解析成一个Response.java对象\n                 */\n                Response<?> response = request.parseNetworkResponse(\n                        new NetworkResponse(entry.data, entry.responseHeaders));\n\n                //为了方便debug，对request每一个时期的状态都需要添加不同的log信息\n                request.addMarker(\"cache-hit-parsed\");\n\n                if (!entry.refreshNeeded()) {\n                    // Completely unexpired cache hit. Just deliver the response.\n                    /**\n                     * 如果缓存不需要刷新的话，直接传回给caller\n                     */\n                    mDelivery.postResponse(request, response);\n                } else {\n                    // Soft-expired cache hit. We can deliver the cached response,\n                    // but we need to also send the request to the network for\n                    // refreshing.\n                    /**\n                     * 如果需要刷新的话，将这个response中的intermediate参数置为true\n                     * 然后再传递给caller，\n                     * 随后将请求发送到服务器进行刷新\n                     */\n                    request.addMarker(\"cache-hit-refresh-needed\");\n                    request.setCacheEntry(entry);\n\n                    /**\n                     * Mark the response as intermediate.\n                     * 将这个response标记成中间产物，也就不是最终的response\n                     * \n                     */\n                    response.intermediate = true;\n\n                    /** \n                     * Post the intermediate response back to the user and have\n                     * the delivery then forward the request along to the network.\n                     * poseResponse()方法中的Runnable是在response被传递给caller了之后\n                     * 再执行的，在ResponseDelivery.java中有注释\n                     * \n                     */\n                    mDelivery.postResponse(request, response, new Runnable() {\n                        @Override\n                        public void run() {\n                            try {\n                                //将request加入到网络请求队列中去\n                                mNetworkQueue.put(request);\n                            } catch (InterruptedException e) {\n                                // Not much we can do about this.\n                            }\n                        }\n                    });\n                }\n\n            } catch (InterruptedException e) {\n                //当cacheQueue中没有request之后就会捕捉到异常\n                // We may have been interrupted because it was time to quit.\n                if (mQuit) {\n                    return;\n                }\n                continue;\n            }\n        }\n    }\n}\n\n```\n\n### [](#3-_NetworkDispatcher-java \"3\\. NetworkDispatcher.java\")3\\. NetworkDispatcher.java\n\n```\npackage com.android.volley;\n\nimport android.annotation.TargetApi;\nimport android.net.TrafficStats;\nimport android.os.Build;\nimport android.os.Process;\nimport android.os.SystemClock;\n\nimport java.util.concurrent.BlockingQueue;\n\n/**\n * Provides a thread for performing network dispatch from a queue of requests.\n * 提供一个线程专门用来从请求队列(NetworkQueue)里面调度网络请求\n * \n * Requests added to the specified queue are processed from the network via a\n * specified {@link Network} interface. Responses are committed to cache, if\n * eligible, using a specified {@link Cache} interface. Valid responses and\n * errors are posted back to the caller via a {@link ResponseDelivery}.\n *\n * 被加入到RequestQueue中的request会被NetWork的接口进一步加工处理.\n * 如果从网络返回的response是符合条件的，则会被添加到缓存中去。\n * 有效的response将通过ResponseDelivery返回给调用者\n */\npublic class NetworkDispatcher extends Thread {\n    /** \n     * The queue of requests to service. \n     * 这个queue就是RequestQueue.java中的mNetworkQueue\n     */\n    private final BlockingQueue<Request<?>> mQueue;\n\n    /** \n     * The network interface for processing requests. \n     * 处理request的接口，其中的方法是performRequest()\n     */\n    private final Network mNetwork;     \n\n    /** \n     * The cache to write to. \n     * 处理缓存的接口\n     */\n    private final Cache mCache;\n\n    /** \n     * For posting responses and errors. \n     * 用来传递response和error的deliver.\n     */\n    private final ResponseDelivery mDelivery;\n\n    /** \n     * Used for telling us to die. 、\n     * 这里使用到了volatile变量\n     * 这个volatile类似于final之类的修饰词\n     * 是用来保证每次mQuit被读取的时候都是最新的\n     * 避免了读取的值和实际变量的值不同的情况\n     * 可以参考这篇博客，讲解的比较详细：\n     * http://www.cnblogs.com/aigongsi/archive/2012/04/01/2429166.html\n     */\n    private volatile boolean mQuit = false;\n\n    /**\n     * Creates a new network dispatcher thread.  You must call {@link #start()}\n     * in order to begin processing.\n     * 构造器，用于创建一个新的网络调度线程，必须要调用call来开始处理request\n     * \n     * @param queue Queue of incoming requests for triage\n     * 等待处理的request队列\n     * @param network Network interface to use for performing requests\n     * @param cache Cache interface to use for writing responses to cache\n     * @param delivery Delivery interface to use for posting responses\n     */\n    public NetworkDispatcher(BlockingQueue<Request<?>> queue,\n            Network network, Cache cache,\n            ResponseDelivery delivery) {\n        mQueue = queue;\n        mNetwork = network;\n        mCache = cache;\n        mDelivery = delivery;\n    }\n\n    /**\n     * Forces this dispatcher to quit immediately.  If any requests are still in\n     * the queue, they are not guaranteed to be processed.\n     * 强制调度器立刻退出，不再调度request。\n     * \n     */\n    public void quit() {\n        mQuit = true;\n        interrupt();\n    }\n\n    /**\n     * 这里涉及到了TrafficStats类，官方解释如下：\n     * Class that provides network traffic statistics. \n     * 这个类提供网络流量统计的服务。\n     * These statistics include bytes transmitted and received and network packets transmitted and received, \n     * over all interfaces, over the mobile interface, and on a per-UID basis.\n     * 这些被统计的流量包括传输的字节数和收到的字节数以及网络数据包\n     * These statistics may not be available on all platforms. \n     * If the statistics are not supported by this device, UNSUPPORTED will be returned.\n     * 这些数据并不是在所有的平台上都可以用\n     * 如果不可用，则会返回UNSPPORTED\n     * 貌似是每个request都统计一下网络流量= =\n     */\n    @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)\n    private void addTrafficStatsTag(Request<?> request) {\n        // Tag the request (if API >= 14)\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.ICE_CREAM_SANDWICH) {\n            TrafficStats.setThreadStatsTag(request.getTrafficStatsTag());\n        }\n    }\n\n    /**\n     * 由于NetworkDispatcher继承自Thread，重写了run()方法\n     * 里面的内容都会在另启动一个线程来执行\n     * 在CacheDispatcher中有很多相似的地方\n     */\n    @Override\n    public void run() {\n        /**\n         * 给自己设置了线程的优先级\n         * THREAD_PRIORITY_BACKGROUND的优先级是0x0000000a(也就是10)\n         * 还有其他的很多种优先级，该优先级处于较高的位置\n         */\n        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);\n\n        Request<?> request;\n\n        /**\n         * 进入了一个死循环状态\n         * 开始不停的工作\n         */\n        while (true) {\n\n            /**\n             * elapsedRealtime()函数返回的是线程从启动到现在的总时间\n             * 也包括线程睡眠时间在内\n             * 单看这一句看不出什么门道，结合在后面的异常处理时会用到startTimeMs\n             * 这里是记录一个request开始的时刻点，到后面再次调用elapsedRealtime()\n             * 两个变量相减得到了request花费了多长的时间\n             */\n            long startTimeMs = SystemClock.elapsedRealtime();\n            /**\n             * release previous request object to avoid leaking request object when mQueue is drained.\n             * 释放前面的一个Request对象，以免因为Request对象不停的申请而导致内存泄漏\n             */\n            request = null;\n\n            /**\n             * 尝试着从RequestQueue中取出一个Request，对其进行处理\n             * 可能会因为某些原因(可能是队列中没有元素了)会抛出异常\n             * 这个时候就捕捉异常并检验是否要退出了，需要退出则return\n             * 不需要退出则继续下一次循环，看有没有Request可以拿到\n             */\n            try {\n                // Take a request from the queue.\n                request = mQueue.take();\n            } catch (InterruptedException e) {\n                // We may have been interrupted because it was time to quit.\n                if (mQuit) {\n                    return;\n                }\n                continue;\n            }\n\n            /**\n             * 到这一步的时候，request应该是指向了一个Request\n             * 下面开始向服务器发送这个Request\n             */\n\n            try {\n                request.addMarker(\"network-queue-take\");\n\n                // If the request was cancelled already, do not perform the\n                // network request.\n                if (request.isCanceled()) {\n                    request.finish(\"network-discard-cancelled\");\n                    continue;\n                }\n\n                addTrafficStatsTag(request);\n\n                /**\n                 * Perform the network request.\n                 * 直接调用mNetwork的接口，发送request并获得NetworkResponse\n                 */\n                NetworkResponse networkResponse = mNetwork.performRequest(request);\n                request.addMarker(\"network-http-complete\");\n\n                // If the server returned 304 AND we delivered a response already,\n                // we're done -- don't deliver a second identical response.\n                if (networkResponse.notModified && request.hasHadResponseDelivered()) {\n                    request.finish(\"not-modified\");\n                    continue;\n                }\n\n                /**\n                 * Parse the response here on the worker thread.\n                 * 在工作线程上面直接解析结果\n                 * 并且封装成一个Response对象\n                 */\n                Response<?> response = request.parseNetworkResponse(networkResponse);\n                request.addMarker(\"network-parse-complete\");\n\n                /** Write to cache if applicable.\n                 *  如果符合要求，能写入缓存的话，就写到缓存里面\n                 */\n                // TODO: Only update cache metadata instead of entire record for 304s.\n\n                /**\n                 * 在这里看到作者的TODO了，还能改进的地方就是在出现了返回码是\n                 * 304的情况时，只更新缓存中的元数据(也就是response的主体)\n                 * 而不是整个cache的记录下来,有些重复的数据可以不用理会.\n                 */\n                if (request.shouldCache() && response.cacheEntry != null) {\n                    mCache.put(request.getCacheKey(), response.cacheEntry);\n                    request.addMarker(\"network-cache-written\");\n                }\n\n                /**\n                 * 将Request.java中的变量mResponseDelivered置成true\n                 * 标志着这个request的结果已经传回给了caller\n                 */\n\n                request.markDelivered();\n\n                /**\n                 * 通过ResponseDelivery的接口将包装好了的Response返回给调用者\n                 */\n                mDelivery.postResponse(request, response);\n\n            } catch (VolleyError volleyError) {\n                /**\n                 * 设置了request从队列中取出到服务器出现异常反应\n                 * 所花费的时间\n                 */\n                volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);\n\n                /**\n                 * 将网络请求的错误通过ResponseDelivery传递给调用者\n                 * 告诉它这.....不幸的一切\n                 */\n                parseAndDeliverNetworkError(request, volleyError);\n\n            } catch (Exception e) {\n                VolleyLog.e(e, \"Unhandled exception %s\", e.toString());\n                VolleyError volleyError = new VolleyError(e);\n                volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);\n                mDelivery.postError(request, volleyError);\n            }\n        }\n    }\n\n    private void parseAndDeliverNetworkError(Request<?> request, VolleyError error) {\n        error = request.parseNetworkError(error);\n        mDelivery.postError(request, error);\n    }\n}\n\n```\n\n当时看完了CacheDispatcher.java之后，再看NetworkDispatcher.java的时候，就会觉得这两个类非常的相似，run()函数里面的东西有些都差不多，都是进行一个死循环，从阻塞队列里面取出request，针对不同的情况做出不同的处理。\n\n从Volley.java暴露给外部的api开始，一直到现在，已经慢慢的了解了Volley中有一个RequestQueue对象，所有的request都在里面排着队等待被处理，RequestQueue里面还有一个CacheDispatcher和几个NetworkDispatcher,分别负责着不同种类的request。接下来要介绍的就是Volley中`Network.java`接口以及其默认实现类`BasicNetwork.java`,还有涉及缓存读写的接口`Cache.java`以及其默认实现类`DiskBasedCache.java`。","source":"_posts/Volley框架解析-三-Dispatcher解析.md","raw":"---\ntitle: Volley框架解析(三)Dispatcher解析\ndate: 2017-03-01 23:53:47\ntags: volley\n\n---\n\n## Volley框架解析(三)-----Dispatcher解析\n\n</header>\n\n<div class=\"article-entry\" itemprop=\"articleBody\">\n\n### [](#u9898_u5916_u8BDD_28_u53EF_u76F4_u63A5_u65E0_u89C6_uFF0C_u8DF3_u8FC7_7E \"题外话(可直接无视，跳过~\")题外话(可直接无视，跳过~\n\n在上一篇博客中结合volley源代码分析了`Volley.java`和`RequestQueue.java`这两个类，不知道代码全贴上去了，会不会看着很烦的嗯= =，当时看源代码的时候心里就有些不淡定，满屏幕看不懂的东西，但是个人觉得源代码和注释一起看才方便，一段代码一段解释会感觉有点摸不着头脑= =。前面的博客中一直提到了`Dispatcher`这种的东西，有`mNetworkDispatcher`和`mCacheDispatcher`之类的，这篇博客就开始进一步的介绍Volley中的Dispatcher。\n\n<!--more-->\n\n***\n\n<a id=\"more\"></a>\n\n### [](#1-__u7B80_u4ECB \"1\\. 简介\")1\\. 简介\n\n在Volley中涉及到了两类的Dispatcher,一类是涉及到缓存的`CacheDispatcher.java`，另外一类是用来处理网络方面request的`NetworkDispatcher.java`，最开始出现这两个Dispatcher是在`RequestQueue#start()`中，再来回顾一下start方法中的代码：\n\n```\npublic void start() {\n    stop();  // Make sure any currently running dispatchers are stopped.\n    // Create the cache dispatcher and start it.\n    mCacheDispatcher = new CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);\n    mCacheDispatcher.start();\n\n    // Create network dispatchers (and corresponding threads) up to the pool size.\n    for (int i = 0; i < mDispatchers.length; i++) {\n        NetworkDispatcher networkDispatcher = new NetworkDispatcher(mNetworkQueue, mNetwork,\n                mCache, mDelivery);\n        mDispatchers[i] = networkDispatcher;\n        networkDispatcher.start();\n    }\n}\n\n```\n\n先暂停了所有的dispatcher，然后又新建了dispatcher并start()。让dispatcher开始工作，实际上这些dispatcher继承了Thread类，是独立于主线程之外的工作线程，这样可以使RequestQueue中request的加入和处理同时进行。下面就结合CacheDispatcher和NetworkDispatcher两个类的代码来分析,Volley中是如何对request来进行调度和处理的。\n\n### [](#2-_CacheDispatcher-java \"2\\. CacheDispatcher.java\")2\\. CacheDispatcher.java\n\n```\npackage com.android.volley;\n\nimport android.os.Process;\n\nimport java.util.concurrent.BlockingQueue;\n\n/**\n * Provides a thread for performing cache triage on a queue of requests.\n * 提供一个用来处理涉及到缓存的requests的线程\n * \n * Requests added to the specified cache queue are resolved from cache.\n * Any deliverable response is posted back to the caller via a\n * {@link ResponseDelivery}.  Cache misses and responses that require\n * refresh are enqueued on the specified network queue for processing\n * by a {@link NetworkDispatcher}.\n * CacheDispatcher用来处理缓存队列里面(mCacheQueue)中的request\n * 任何符合delivery要求的response都会被通过ResponseDelivery的接口传递给caller\n * 有些cache丢失了或者是cache中的数据需要更新的，都将会交给NetworkDispatcher去处理\n * 交给NetworkDispatcher处理的方法就是直接放到mNetworkQueue中去\n * 因为NetworkDispatcher总是从mNetworkQueue中取出request来进行处理的\n */\n\npublic class CacheDispatcher extends Thread {\n\n    private static final boolean DEBUG = VolleyLog.DEBUG;\n\n    /** \n     * The queue of requests coming in for triage. \n     * 将要被处理的涉及到缓存的Request存放在这个阻塞队列里\n     * 等着咯，这个mCacheQueue和RequestQueue中的mCacheQueue指向的队列是同一个\n     * 也就是说整个Volley在运行的时候只有一个mCacheQueue\n     */\n    private final BlockingQueue<Request<?>> mCacheQueue;\n\n    /** \n     * The queue of requests going out to the network. \n     * 这个阻塞队里里面存着的可是要去进行网络访问的request\n     * 开始还不明白这里不应该是涉及到访问缓存的request\n     * 怎么有个这东西出来了，其实看到后面了就会发现，缓存里面有两个过期时间\n     * 在后面会介绍到Cache.java类，Cache.Entry类中涉及到了\n     * ttl 和 softTtl这两个long型的数据，用来标识缓存是否已经过期了\n     * 或者是否需要去检查是否要更新缓存的两个间隔时间\n     */\n    private final BlockingQueue<Request<?>> mNetworkQueue;\n\n    /** \n     * The cache to read from. \n     * 用于读写缓存的接口\n     * 这个接口也是在Volley中只有一个\n     * mCacheDispatcher和mNetworkDispatcher公用的\n     */\n    private final Cache mCache;\n\n    /** \n     * For posting responses. \n     * ResponseDelivery对象引用，用来将request的结果传递给caller\n     * 在NetworkDispatcher里面也有出现\n     * 这个也是从RequestQueue中传递过来的，公用\n     */\n    private final ResponseDelivery mDelivery;\n\n    /** \n     * Used for telling us to die. \n     * 直译 ： 用来告诉我们去死= = (shit)\n     * 然而 ： 这个变量用来标志这个dispatcher是否要继续工作下去\n     * 如果为true就结束本线程中的死循环\n     */\n    private volatile boolean mQuit = false;\n\n    /**\n     * Creates a new cache triage dispatcher thread.  You must call {@link #start()}\n     * in order to begin processing.\n     * 构造函数咯，创建一个存放需要访问缓存的request的调度线程\n     * 在创建之后需要将其用start()启动\n     * \n     * @param cacheQueue Queue of incoming requests for triage\n     * 存放request的缓存队列\n     * @param networkQueue Queue to post requests that require network to\n     * 存放涉及network的网络队列\n     * @param cache Cache interface to use for resolution\n     * 用来处理缓存读写问题的接口\n     * @param delivery Delivery interface to use for posting responses\n     * 用来反馈结果的接口\n     */\n    public CacheDispatcher(\n            BlockingQueue<Request<?>> cacheQueue, BlockingQueue<Request<?>> networkQueue,\n            Cache cache, ResponseDelivery delivery) {\n        mCacheQueue = cacheQueue;\n        mNetworkQueue = networkQueue;\n        mCache = cache;\n        mDelivery = delivery;\n    }\n\n    /**\n     * Forces this dispatcher to quit immediately.  If any requests are still in\n     * the queue, they are not guaranteed to be processed.\n     * 将标志位mQuit置为true,在每次死循环的最后会判断该标志位\n     */\n    public void quit() {\n        mQuit = true;\n        interrupt();\n    }\n\n    /**\n     * 前面提到了CacheDispatcher继承了Thread类\n     * 这里就重写了run()方法\n     * 当外面调用了mCacheDispatcher.start()之后\n     * run()里面的方法就开始执行了\n     */\n    @Override\n    public void run() {\n\n        if (DEBUG) VolleyLog.v(\"start new dispatcher\");\n        /**\n         * 给自己设置了线程的优先级\n         * THREAD_PRIORITY_BACKGROUND的优先级是0x0000000a(也就是10)\n         * 还有其他的很多种优先级，该优先级处于较高的位置\n         */\n        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);\n\n        /**\n         * Make a blocking call to initialize the cache.\n         * 在读写缓存之前做一些初始化工作，例如扫描缓存目录是否存在等\n         * 这个暂时先不用管里面的内容，等介绍到Cache.java的时候就会明白\n         */\n        mCache.initialize();\n\n        /**\n         * 从这里开始就进入了死循环的状态\n         * 除非出现了什么没有catch的exception\n         * 或者是mQuit标志位被置成了true\n         * 这个死循环将一直进行下去= =\n         * 总感觉有什么不妥的地方，感觉死循环怪怪的噢\n         */\n        while (true) {\n            /**\n             * 和NetworkDispatcher里面的流程没有什么太大的变化\n             * 还是一个死循环不停的从CacheQueue中取出Request\n             */\n            try {\n                /**\n                 * Get a request from the cache triage queue, blocking until\n                 * at least one is available.\n                 * 从缓存request队列里面取出等待处理的request\n                 * 如果没有可取出的request，则会在这里阻塞\n                 * 这个是PriorityBlockingQueue#take()函数的作用\n                 * \n                 */\n                final Request<?> request = mCacheQueue.take();\n\n                /**\n                 * 给每个request添加上一个打log的标志\n                 * 为了debug的需要\n                 */\n                request.addMarker(\"cache-queue-take\");\n\n                /**\n                 * If the request has been canceled, don't bother dispatching it.\n                 * 如果正在处理的这个请求被取消了\n                 * 中断对该request的处理，continue去处理下一个request的调度\n                 * 调用Request#finish()方法，传入的参数是为了debug方便，打出request调度进度的log\n                 */\n                if (request.isCanceled()) {\n                    request.finish(\"cache-discard-canceled\");\n                    continue;\n                }\n\n                /**\n                 * 在这里NetworkDispatcher和CacheDispatcher出现了一点差异\n                 * NetworkDispatcher.java在这一步就直接开始网络请求了\n                 * \n                 * 由于是CacheDispatcher.java，肯定是主要以Cahce为主的\n                 * CacheDispatcher在这里先看看有没有缓存\n                 * 如果没有缓存则马上将这个request加入到NetworkQueue中\n                 * (意思好像就是= =兄弟你排错队了)\n                 * 然后继续喊下一个request来被处理\n                 */\n                // Attempt to retrieve this item from cache.\n                Cache.Entry entry = mCache.get(request.getCacheKey());\n                if (entry == null) {\n                    request.addMarker(\"cache-miss\");\n                    // Cache miss; send off to the network dispatcher.\n                    mNetworkQueue.put(request);\n                    continue;\n                }\n\n                /**\n                 * 能到这一步的request不简单了\n                 * 肯定是被上面的mCache.get(cacheKey)查到了有缓存的(毕竟有靠山的伤不起)\n                 * 有缓存还不能太大意= =，万一缓存尼玛是个过期的就惨了= =\n                 * 先用entry.isExpired()函数检查一番\n                 * 过期了照样还是给我滚到NetworkQueue中去排队\n                 *\n                 * 继续喊下一个request来\n                 */\n                // If it is completely expired, just send it to the network.\n                if (entry.isExpired()) {\n                    request.addMarker(\"cache-hit-expired\");\n                    request.setCacheEntry(entry);\n                    mNetworkQueue.put(request);\n                    continue;\n                }\n\n                /**\n                 * 哎哟，能到这一步的request更加不简单了，不仅仅有缓存\n                 * 而且还是能用的缓存，没有过期的诶，这才是有真的靠山= =\n                 *\n                 * 将缓存的信息都拿出来，组成一个NetworkResponse\n                 * 就像是刚刚从网络上获取出来的一样，再形成一个Response.java对象\n                 * 但是不要着急把这个response直接传回caller，这个response还没确定是否需要refresh\n                 */\n\n                // We have a cache hit; parse its data for delivery back to the request.\n                request.addMarker(\"cache-hit\");\n\n                /**\n                 * 将一个由缓存中的数据创建的NetworkResponse.java对象\n                 * 通过Request#parseNetworkResponse()方法\n                 * 来解析成一个Response.java对象\n                 */\n                Response<?> response = request.parseNetworkResponse(\n                        new NetworkResponse(entry.data, entry.responseHeaders));\n\n                //为了方便debug，对request每一个时期的状态都需要添加不同的log信息\n                request.addMarker(\"cache-hit-parsed\");\n\n                if (!entry.refreshNeeded()) {\n                    // Completely unexpired cache hit. Just deliver the response.\n                    /**\n                     * 如果缓存不需要刷新的话，直接传回给caller\n                     */\n                    mDelivery.postResponse(request, response);\n                } else {\n                    // Soft-expired cache hit. We can deliver the cached response,\n                    // but we need to also send the request to the network for\n                    // refreshing.\n                    /**\n                     * 如果需要刷新的话，将这个response中的intermediate参数置为true\n                     * 然后再传递给caller，\n                     * 随后将请求发送到服务器进行刷新\n                     */\n                    request.addMarker(\"cache-hit-refresh-needed\");\n                    request.setCacheEntry(entry);\n\n                    /**\n                     * Mark the response as intermediate.\n                     * 将这个response标记成中间产物，也就不是最终的response\n                     * \n                     */\n                    response.intermediate = true;\n\n                    /** \n                     * Post the intermediate response back to the user and have\n                     * the delivery then forward the request along to the network.\n                     * poseResponse()方法中的Runnable是在response被传递给caller了之后\n                     * 再执行的，在ResponseDelivery.java中有注释\n                     * \n                     */\n                    mDelivery.postResponse(request, response, new Runnable() {\n                        @Override\n                        public void run() {\n                            try {\n                                //将request加入到网络请求队列中去\n                                mNetworkQueue.put(request);\n                            } catch (InterruptedException e) {\n                                // Not much we can do about this.\n                            }\n                        }\n                    });\n                }\n\n            } catch (InterruptedException e) {\n                //当cacheQueue中没有request之后就会捕捉到异常\n                // We may have been interrupted because it was time to quit.\n                if (mQuit) {\n                    return;\n                }\n                continue;\n            }\n        }\n    }\n}\n\n```\n\n### [](#3-_NetworkDispatcher-java \"3\\. NetworkDispatcher.java\")3\\. NetworkDispatcher.java\n\n```\npackage com.android.volley;\n\nimport android.annotation.TargetApi;\nimport android.net.TrafficStats;\nimport android.os.Build;\nimport android.os.Process;\nimport android.os.SystemClock;\n\nimport java.util.concurrent.BlockingQueue;\n\n/**\n * Provides a thread for performing network dispatch from a queue of requests.\n * 提供一个线程专门用来从请求队列(NetworkQueue)里面调度网络请求\n * \n * Requests added to the specified queue are processed from the network via a\n * specified {@link Network} interface. Responses are committed to cache, if\n * eligible, using a specified {@link Cache} interface. Valid responses and\n * errors are posted back to the caller via a {@link ResponseDelivery}.\n *\n * 被加入到RequestQueue中的request会被NetWork的接口进一步加工处理.\n * 如果从网络返回的response是符合条件的，则会被添加到缓存中去。\n * 有效的response将通过ResponseDelivery返回给调用者\n */\npublic class NetworkDispatcher extends Thread {\n    /** \n     * The queue of requests to service. \n     * 这个queue就是RequestQueue.java中的mNetworkQueue\n     */\n    private final BlockingQueue<Request<?>> mQueue;\n\n    /** \n     * The network interface for processing requests. \n     * 处理request的接口，其中的方法是performRequest()\n     */\n    private final Network mNetwork;     \n\n    /** \n     * The cache to write to. \n     * 处理缓存的接口\n     */\n    private final Cache mCache;\n\n    /** \n     * For posting responses and errors. \n     * 用来传递response和error的deliver.\n     */\n    private final ResponseDelivery mDelivery;\n\n    /** \n     * Used for telling us to die. 、\n     * 这里使用到了volatile变量\n     * 这个volatile类似于final之类的修饰词\n     * 是用来保证每次mQuit被读取的时候都是最新的\n     * 避免了读取的值和实际变量的值不同的情况\n     * 可以参考这篇博客，讲解的比较详细：\n     * http://www.cnblogs.com/aigongsi/archive/2012/04/01/2429166.html\n     */\n    private volatile boolean mQuit = false;\n\n    /**\n     * Creates a new network dispatcher thread.  You must call {@link #start()}\n     * in order to begin processing.\n     * 构造器，用于创建一个新的网络调度线程，必须要调用call来开始处理request\n     * \n     * @param queue Queue of incoming requests for triage\n     * 等待处理的request队列\n     * @param network Network interface to use for performing requests\n     * @param cache Cache interface to use for writing responses to cache\n     * @param delivery Delivery interface to use for posting responses\n     */\n    public NetworkDispatcher(BlockingQueue<Request<?>> queue,\n            Network network, Cache cache,\n            ResponseDelivery delivery) {\n        mQueue = queue;\n        mNetwork = network;\n        mCache = cache;\n        mDelivery = delivery;\n    }\n\n    /**\n     * Forces this dispatcher to quit immediately.  If any requests are still in\n     * the queue, they are not guaranteed to be processed.\n     * 强制调度器立刻退出，不再调度request。\n     * \n     */\n    public void quit() {\n        mQuit = true;\n        interrupt();\n    }\n\n    /**\n     * 这里涉及到了TrafficStats类，官方解释如下：\n     * Class that provides network traffic statistics. \n     * 这个类提供网络流量统计的服务。\n     * These statistics include bytes transmitted and received and network packets transmitted and received, \n     * over all interfaces, over the mobile interface, and on a per-UID basis.\n     * 这些被统计的流量包括传输的字节数和收到的字节数以及网络数据包\n     * These statistics may not be available on all platforms. \n     * If the statistics are not supported by this device, UNSUPPORTED will be returned.\n     * 这些数据并不是在所有的平台上都可以用\n     * 如果不可用，则会返回UNSPPORTED\n     * 貌似是每个request都统计一下网络流量= =\n     */\n    @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)\n    private void addTrafficStatsTag(Request<?> request) {\n        // Tag the request (if API >= 14)\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.ICE_CREAM_SANDWICH) {\n            TrafficStats.setThreadStatsTag(request.getTrafficStatsTag());\n        }\n    }\n\n    /**\n     * 由于NetworkDispatcher继承自Thread，重写了run()方法\n     * 里面的内容都会在另启动一个线程来执行\n     * 在CacheDispatcher中有很多相似的地方\n     */\n    @Override\n    public void run() {\n        /**\n         * 给自己设置了线程的优先级\n         * THREAD_PRIORITY_BACKGROUND的优先级是0x0000000a(也就是10)\n         * 还有其他的很多种优先级，该优先级处于较高的位置\n         */\n        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);\n\n        Request<?> request;\n\n        /**\n         * 进入了一个死循环状态\n         * 开始不停的工作\n         */\n        while (true) {\n\n            /**\n             * elapsedRealtime()函数返回的是线程从启动到现在的总时间\n             * 也包括线程睡眠时间在内\n             * 单看这一句看不出什么门道，结合在后面的异常处理时会用到startTimeMs\n             * 这里是记录一个request开始的时刻点，到后面再次调用elapsedRealtime()\n             * 两个变量相减得到了request花费了多长的时间\n             */\n            long startTimeMs = SystemClock.elapsedRealtime();\n            /**\n             * release previous request object to avoid leaking request object when mQueue is drained.\n             * 释放前面的一个Request对象，以免因为Request对象不停的申请而导致内存泄漏\n             */\n            request = null;\n\n            /**\n             * 尝试着从RequestQueue中取出一个Request，对其进行处理\n             * 可能会因为某些原因(可能是队列中没有元素了)会抛出异常\n             * 这个时候就捕捉异常并检验是否要退出了，需要退出则return\n             * 不需要退出则继续下一次循环，看有没有Request可以拿到\n             */\n            try {\n                // Take a request from the queue.\n                request = mQueue.take();\n            } catch (InterruptedException e) {\n                // We may have been interrupted because it was time to quit.\n                if (mQuit) {\n                    return;\n                }\n                continue;\n            }\n\n            /**\n             * 到这一步的时候，request应该是指向了一个Request\n             * 下面开始向服务器发送这个Request\n             */\n\n            try {\n                request.addMarker(\"network-queue-take\");\n\n                // If the request was cancelled already, do not perform the\n                // network request.\n                if (request.isCanceled()) {\n                    request.finish(\"network-discard-cancelled\");\n                    continue;\n                }\n\n                addTrafficStatsTag(request);\n\n                /**\n                 * Perform the network request.\n                 * 直接调用mNetwork的接口，发送request并获得NetworkResponse\n                 */\n                NetworkResponse networkResponse = mNetwork.performRequest(request);\n                request.addMarker(\"network-http-complete\");\n\n                // If the server returned 304 AND we delivered a response already,\n                // we're done -- don't deliver a second identical response.\n                if (networkResponse.notModified && request.hasHadResponseDelivered()) {\n                    request.finish(\"not-modified\");\n                    continue;\n                }\n\n                /**\n                 * Parse the response here on the worker thread.\n                 * 在工作线程上面直接解析结果\n                 * 并且封装成一个Response对象\n                 */\n                Response<?> response = request.parseNetworkResponse(networkResponse);\n                request.addMarker(\"network-parse-complete\");\n\n                /** Write to cache if applicable.\n                 *  如果符合要求，能写入缓存的话，就写到缓存里面\n                 */\n                // TODO: Only update cache metadata instead of entire record for 304s.\n\n                /**\n                 * 在这里看到作者的TODO了，还能改进的地方就是在出现了返回码是\n                 * 304的情况时，只更新缓存中的元数据(也就是response的主体)\n                 * 而不是整个cache的记录下来,有些重复的数据可以不用理会.\n                 */\n                if (request.shouldCache() && response.cacheEntry != null) {\n                    mCache.put(request.getCacheKey(), response.cacheEntry);\n                    request.addMarker(\"network-cache-written\");\n                }\n\n                /**\n                 * 将Request.java中的变量mResponseDelivered置成true\n                 * 标志着这个request的结果已经传回给了caller\n                 */\n\n                request.markDelivered();\n\n                /**\n                 * 通过ResponseDelivery的接口将包装好了的Response返回给调用者\n                 */\n                mDelivery.postResponse(request, response);\n\n            } catch (VolleyError volleyError) {\n                /**\n                 * 设置了request从队列中取出到服务器出现异常反应\n                 * 所花费的时间\n                 */\n                volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);\n\n                /**\n                 * 将网络请求的错误通过ResponseDelivery传递给调用者\n                 * 告诉它这.....不幸的一切\n                 */\n                parseAndDeliverNetworkError(request, volleyError);\n\n            } catch (Exception e) {\n                VolleyLog.e(e, \"Unhandled exception %s\", e.toString());\n                VolleyError volleyError = new VolleyError(e);\n                volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);\n                mDelivery.postError(request, volleyError);\n            }\n        }\n    }\n\n    private void parseAndDeliverNetworkError(Request<?> request, VolleyError error) {\n        error = request.parseNetworkError(error);\n        mDelivery.postError(request, error);\n    }\n}\n\n```\n\n当时看完了CacheDispatcher.java之后，再看NetworkDispatcher.java的时候，就会觉得这两个类非常的相似，run()函数里面的东西有些都差不多，都是进行一个死循环，从阻塞队列里面取出request，针对不同的情况做出不同的处理。\n\n从Volley.java暴露给外部的api开始，一直到现在，已经慢慢的了解了Volley中有一个RequestQueue对象，所有的request都在里面排着队等待被处理，RequestQueue里面还有一个CacheDispatcher和几个NetworkDispatcher,分别负责着不同种类的request。接下来要介绍的就是Volley中`Network.java`接口以及其默认实现类`BasicNetwork.java`,还有涉及缓存读写的接口`Cache.java`以及其默认实现类`DiskBasedCache.java`。","slug":"Volley框架解析-三-Dispatcher解析","published":1,"updated":"2017-03-21T06:38:09.107Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0xtcupj0009k2j9oxo3419m","content":"<h2 id=\"Volley框架解析-三-—–Dispatcher解析\"><a href=\"#Volley框架解析-三-—–Dispatcher解析\" class=\"headerlink\" title=\"Volley框架解析(三)—–Dispatcher解析\"></a>Volley框架解析(三)—–Dispatcher解析</h2><p></p>\n<div class=\"article-entry\" itemprop=\"articleBody\">\n\n<h3 id=\"题外话-可直接无视，跳过\"><a href=\"#题外话-可直接无视，跳过\" class=\"headerlink\" title=\"题外话(可直接无视，跳过~\"></a><a href=\"#u9898_u5916_u8BDD_28_u53EF_u76F4_u63A5_u65E0_u89C6_uFF0C_u8DF3_u8FC7_7E\" title=\"题外话(可直接无视，跳过~\"></a>题外话(可直接无视，跳过~</h3><p>在上一篇博客中结合volley源代码分析了<code>Volley.java</code>和<code>RequestQueue.java</code>这两个类，不知道代码全贴上去了，会不会看着很烦的嗯= =，当时看源代码的时候心里就有些不淡定，满屏幕看不懂的东西，但是个人觉得源代码和注释一起看才方便，一段代码一段解释会感觉有点摸不着头脑= =。前面的博客中一直提到了<code>Dispatcher</code>这种的东西，有<code>mNetworkDispatcher</code>和<code>mCacheDispatcher</code>之类的，这篇博客就开始进一步的介绍Volley中的Dispatcher。</p>\n<a id=\"more\"></a>\n<hr>\n<p><a id=\"more\"></a></p>\n<h3 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1. 简介\"></a><a href=\"#1-__u7B80_u4ECB\" title=\"1\\. 简介\"></a>1. 简介</h3><p>在Volley中涉及到了两类的Dispatcher,一类是涉及到缓存的<code>CacheDispatcher.java</code>，另外一类是用来处理网络方面request的<code>NetworkDispatcher.java</code>，最开始出现这两个Dispatcher是在<code>RequestQueue#start()</code>中，再来回顾一下start方法中的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void start() &#123;</div><div class=\"line\">    stop();  // Make sure any currently running dispatchers are stopped.</div><div class=\"line\">    // Create the cache dispatcher and start it.</div><div class=\"line\">    mCacheDispatcher = new CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);</div><div class=\"line\">    mCacheDispatcher.start();</div><div class=\"line\"></div><div class=\"line\">    // Create network dispatchers (and corresponding threads) up to the pool size.</div><div class=\"line\">    for (int i = 0; i &lt; mDispatchers.length; i++) &#123;</div><div class=\"line\">        NetworkDispatcher networkDispatcher = new NetworkDispatcher(mNetworkQueue, mNetwork,</div><div class=\"line\">                mCache, mDelivery);</div><div class=\"line\">        mDispatchers[i] = networkDispatcher;</div><div class=\"line\">        networkDispatcher.start();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>先暂停了所有的dispatcher，然后又新建了dispatcher并start()。让dispatcher开始工作，实际上这些dispatcher继承了Thread类，是独立于主线程之外的工作线程，这样可以使RequestQueue中request的加入和处理同时进行。下面就结合CacheDispatcher和NetworkDispatcher两个类的代码来分析,Volley中是如何对request来进行调度和处理的。</p>\n<h3 id=\"2-CacheDispatcher-java\"><a href=\"#2-CacheDispatcher-java\" class=\"headerlink\" title=\"2. CacheDispatcher.java\"></a><a href=\"#2-_CacheDispatcher-java\" title=\"2\\. CacheDispatcher.java\"></a>2. CacheDispatcher.java</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div><div class=\"line\">204</div><div class=\"line\">205</div><div class=\"line\">206</div><div class=\"line\">207</div><div class=\"line\">208</div><div class=\"line\">209</div><div class=\"line\">210</div><div class=\"line\">211</div><div class=\"line\">212</div><div class=\"line\">213</div><div class=\"line\">214</div><div class=\"line\">215</div><div class=\"line\">216</div><div class=\"line\">217</div><div class=\"line\">218</div><div class=\"line\">219</div><div class=\"line\">220</div><div class=\"line\">221</div><div class=\"line\">222</div><div class=\"line\">223</div><div class=\"line\">224</div><div class=\"line\">225</div><div class=\"line\">226</div><div class=\"line\">227</div><div class=\"line\">228</div><div class=\"line\">229</div><div class=\"line\">230</div><div class=\"line\">231</div><div class=\"line\">232</div><div class=\"line\">233</div><div class=\"line\">234</div><div class=\"line\">235</div><div class=\"line\">236</div><div class=\"line\">237</div><div class=\"line\">238</div><div class=\"line\">239</div><div class=\"line\">240</div><div class=\"line\">241</div><div class=\"line\">242</div><div class=\"line\">243</div><div class=\"line\">244</div><div class=\"line\">245</div><div class=\"line\">246</div><div class=\"line\">247</div><div class=\"line\">248</div><div class=\"line\">249</div><div class=\"line\">250</div><div class=\"line\">251</div><div class=\"line\">252</div><div class=\"line\">253</div><div class=\"line\">254</div><div class=\"line\">255</div><div class=\"line\">256</div><div class=\"line\">257</div><div class=\"line\">258</div><div class=\"line\">259</div><div class=\"line\">260</div><div class=\"line\">261</div><div class=\"line\">262</div><div class=\"line\">263</div><div class=\"line\">264</div><div class=\"line\">265</div><div class=\"line\">266</div><div class=\"line\">267</div><div class=\"line\">268</div><div class=\"line\">269</div><div class=\"line\">270</div><div class=\"line\">271</div><div class=\"line\">272</div><div class=\"line\">273</div><div class=\"line\">274</div><div class=\"line\">275</div><div class=\"line\">276</div><div class=\"line\">277</div><div class=\"line\">278</div><div class=\"line\">279</div><div class=\"line\">280</div><div class=\"line\">281</div><div class=\"line\">282</div></pre></td><td class=\"code\"><pre><div class=\"line\">package com.android.volley;</div><div class=\"line\"></div><div class=\"line\">import android.os.Process;</div><div class=\"line\"></div><div class=\"line\">import java.util.concurrent.BlockingQueue;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\"> * Provides a thread for performing cache triage on a queue of requests.</div><div class=\"line\"> * 提供一个用来处理涉及到缓存的requests的线程</div><div class=\"line\"> * </div><div class=\"line\"> * Requests added to the specified cache queue are resolved from cache.</div><div class=\"line\"> * Any deliverable response is posted back to the caller via a</div><div class=\"line\"> * &#123;@link ResponseDelivery&#125;.  Cache misses and responses that require</div><div class=\"line\"> * refresh are enqueued on the specified network queue for processing</div><div class=\"line\"> * by a &#123;@link NetworkDispatcher&#125;.</div><div class=\"line\"> * CacheDispatcher用来处理缓存队列里面(mCacheQueue)中的request</div><div class=\"line\"> * 任何符合delivery要求的response都会被通过ResponseDelivery的接口传递给caller</div><div class=\"line\"> * 有些cache丢失了或者是cache中的数据需要更新的，都将会交给NetworkDispatcher去处理</div><div class=\"line\"> * 交给NetworkDispatcher处理的方法就是直接放到mNetworkQueue中去</div><div class=\"line\"> * 因为NetworkDispatcher总是从mNetworkQueue中取出request来进行处理的</div><div class=\"line\"> */</div><div class=\"line\"></div><div class=\"line\">public class CacheDispatcher extends Thread &#123;</div><div class=\"line\"></div><div class=\"line\">    private static final boolean DEBUG = VolleyLog.DEBUG;</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * The queue of requests coming in for triage. </div><div class=\"line\">     * 将要被处理的涉及到缓存的Request存放在这个阻塞队列里</div><div class=\"line\">     * 等着咯，这个mCacheQueue和RequestQueue中的mCacheQueue指向的队列是同一个</div><div class=\"line\">     * 也就是说整个Volley在运行的时候只有一个mCacheQueue</div><div class=\"line\">     */</div><div class=\"line\">    private final BlockingQueue&lt;Request&lt;?&gt;&gt; mCacheQueue;</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * The queue of requests going out to the network. </div><div class=\"line\">     * 这个阻塞队里里面存着的可是要去进行网络访问的request</div><div class=\"line\">     * 开始还不明白这里不应该是涉及到访问缓存的request</div><div class=\"line\">     * 怎么有个这东西出来了，其实看到后面了就会发现，缓存里面有两个过期时间</div><div class=\"line\">     * 在后面会介绍到Cache.java类，Cache.Entry类中涉及到了</div><div class=\"line\">     * ttl 和 softTtl这两个long型的数据，用来标识缓存是否已经过期了</div><div class=\"line\">     * 或者是否需要去检查是否要更新缓存的两个间隔时间</div><div class=\"line\">     */</div><div class=\"line\">    private final BlockingQueue&lt;Request&lt;?&gt;&gt; mNetworkQueue;</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * The cache to read from. </div><div class=\"line\">     * 用于读写缓存的接口</div><div class=\"line\">     * 这个接口也是在Volley中只有一个</div><div class=\"line\">     * mCacheDispatcher和mNetworkDispatcher公用的</div><div class=\"line\">     */</div><div class=\"line\">    private final Cache mCache;</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * For posting responses. </div><div class=\"line\">     * ResponseDelivery对象引用，用来将request的结果传递给caller</div><div class=\"line\">     * 在NetworkDispatcher里面也有出现</div><div class=\"line\">     * 这个也是从RequestQueue中传递过来的，公用</div><div class=\"line\">     */</div><div class=\"line\">    private final ResponseDelivery mDelivery;</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * Used for telling us to die. </div><div class=\"line\">     * 直译 ： 用来告诉我们去死= = (shit)</div><div class=\"line\">     * 然而 ： 这个变量用来标志这个dispatcher是否要继续工作下去</div><div class=\"line\">     * 如果为true就结束本线程中的死循环</div><div class=\"line\">     */</div><div class=\"line\">    private volatile boolean mQuit = false;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Creates a new cache triage dispatcher thread.  You must call &#123;@link #start()&#125;</div><div class=\"line\">     * in order to begin processing.</div><div class=\"line\">     * 构造函数咯，创建一个存放需要访问缓存的request的调度线程</div><div class=\"line\">     * 在创建之后需要将其用start()启动</div><div class=\"line\">     * </div><div class=\"line\">     * @param cacheQueue Queue of incoming requests for triage</div><div class=\"line\">     * 存放request的缓存队列</div><div class=\"line\">     * @param networkQueue Queue to post requests that require network to</div><div class=\"line\">     * 存放涉及network的网络队列</div><div class=\"line\">     * @param cache Cache interface to use for resolution</div><div class=\"line\">     * 用来处理缓存读写问题的接口</div><div class=\"line\">     * @param delivery Delivery interface to use for posting responses</div><div class=\"line\">     * 用来反馈结果的接口</div><div class=\"line\">     */</div><div class=\"line\">    public CacheDispatcher(</div><div class=\"line\">            BlockingQueue&lt;Request&lt;?&gt;&gt; cacheQueue, BlockingQueue&lt;Request&lt;?&gt;&gt; networkQueue,</div><div class=\"line\">            Cache cache, ResponseDelivery delivery) &#123;</div><div class=\"line\">        mCacheQueue = cacheQueue;</div><div class=\"line\">        mNetworkQueue = networkQueue;</div><div class=\"line\">        mCache = cache;</div><div class=\"line\">        mDelivery = delivery;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Forces this dispatcher to quit immediately.  If any requests are still in</div><div class=\"line\">     * the queue, they are not guaranteed to be processed.</div><div class=\"line\">     * 将标志位mQuit置为true,在每次死循环的最后会判断该标志位</div><div class=\"line\">     */</div><div class=\"line\">    public void quit() &#123;</div><div class=\"line\">        mQuit = true;</div><div class=\"line\">        interrupt();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * 前面提到了CacheDispatcher继承了Thread类</div><div class=\"line\">     * 这里就重写了run()方法</div><div class=\"line\">     * 当外面调用了mCacheDispatcher.start()之后</div><div class=\"line\">     * run()里面的方法就开始执行了</div><div class=\"line\">     */</div><div class=\"line\">    @Override</div><div class=\"line\">    public void run() &#123;</div><div class=\"line\"></div><div class=\"line\">        if (DEBUG) VolleyLog.v(&quot;start new dispatcher&quot;);</div><div class=\"line\">        /**</div><div class=\"line\">         * 给自己设置了线程的优先级</div><div class=\"line\">         * THREAD_PRIORITY_BACKGROUND的优先级是0x0000000a(也就是10)</div><div class=\"line\">         * 还有其他的很多种优先级，该优先级处于较高的位置</div><div class=\"line\">         */</div><div class=\"line\">        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * Make a blocking call to initialize the cache.</div><div class=\"line\">         * 在读写缓存之前做一些初始化工作，例如扫描缓存目录是否存在等</div><div class=\"line\">         * 这个暂时先不用管里面的内容，等介绍到Cache.java的时候就会明白</div><div class=\"line\">         */</div><div class=\"line\">        mCache.initialize();</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * 从这里开始就进入了死循环的状态</div><div class=\"line\">         * 除非出现了什么没有catch的exception</div><div class=\"line\">         * 或者是mQuit标志位被置成了true</div><div class=\"line\">         * 这个死循环将一直进行下去= =</div><div class=\"line\">         * 总感觉有什么不妥的地方，感觉死循环怪怪的噢</div><div class=\"line\">         */</div><div class=\"line\">        while (true) &#123;</div><div class=\"line\">            /**</div><div class=\"line\">             * 和NetworkDispatcher里面的流程没有什么太大的变化</div><div class=\"line\">             * 还是一个死循环不停的从CacheQueue中取出Request</div><div class=\"line\">             */</div><div class=\"line\">            try &#123;</div><div class=\"line\">                /**</div><div class=\"line\">                 * Get a request from the cache triage queue, blocking until</div><div class=\"line\">                 * at least one is available.</div><div class=\"line\">                 * 从缓存request队列里面取出等待处理的request</div><div class=\"line\">                 * 如果没有可取出的request，则会在这里阻塞</div><div class=\"line\">                 * 这个是PriorityBlockingQueue#take()函数的作用</div><div class=\"line\">                 * </div><div class=\"line\">                 */</div><div class=\"line\">                final Request&lt;?&gt; request = mCacheQueue.take();</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * 给每个request添加上一个打log的标志</div><div class=\"line\">                 * 为了debug的需要</div><div class=\"line\">                 */</div><div class=\"line\">                request.addMarker(&quot;cache-queue-take&quot;);</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * If the request has been canceled, don&apos;t bother dispatching it.</div><div class=\"line\">                 * 如果正在处理的这个请求被取消了</div><div class=\"line\">                 * 中断对该request的处理，continue去处理下一个request的调度</div><div class=\"line\">                 * 调用Request#finish()方法，传入的参数是为了debug方便，打出request调度进度的log</div><div class=\"line\">                 */</div><div class=\"line\">                if (request.isCanceled()) &#123;</div><div class=\"line\">                    request.finish(&quot;cache-discard-canceled&quot;);</div><div class=\"line\">                    continue;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * 在这里NetworkDispatcher和CacheDispatcher出现了一点差异</div><div class=\"line\">                 * NetworkDispatcher.java在这一步就直接开始网络请求了</div><div class=\"line\">                 * </div><div class=\"line\">                 * 由于是CacheDispatcher.java，肯定是主要以Cahce为主的</div><div class=\"line\">                 * CacheDispatcher在这里先看看有没有缓存</div><div class=\"line\">                 * 如果没有缓存则马上将这个request加入到NetworkQueue中</div><div class=\"line\">                 * (意思好像就是= =兄弟你排错队了)</div><div class=\"line\">                 * 然后继续喊下一个request来被处理</div><div class=\"line\">                 */</div><div class=\"line\">                // Attempt to retrieve this item from cache.</div><div class=\"line\">                Cache.Entry entry = mCache.get(request.getCacheKey());</div><div class=\"line\">                if (entry == null) &#123;</div><div class=\"line\">                    request.addMarker(&quot;cache-miss&quot;);</div><div class=\"line\">                    // Cache miss; send off to the network dispatcher.</div><div class=\"line\">                    mNetworkQueue.put(request);</div><div class=\"line\">                    continue;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * 能到这一步的request不简单了</div><div class=\"line\">                 * 肯定是被上面的mCache.get(cacheKey)查到了有缓存的(毕竟有靠山的伤不起)</div><div class=\"line\">                 * 有缓存还不能太大意= =，万一缓存尼玛是个过期的就惨了= =</div><div class=\"line\">                 * 先用entry.isExpired()函数检查一番</div><div class=\"line\">                 * 过期了照样还是给我滚到NetworkQueue中去排队</div><div class=\"line\">                 *</div><div class=\"line\">                 * 继续喊下一个request来</div><div class=\"line\">                 */</div><div class=\"line\">                // If it is completely expired, just send it to the network.</div><div class=\"line\">                if (entry.isExpired()) &#123;</div><div class=\"line\">                    request.addMarker(&quot;cache-hit-expired&quot;);</div><div class=\"line\">                    request.setCacheEntry(entry);</div><div class=\"line\">                    mNetworkQueue.put(request);</div><div class=\"line\">                    continue;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * 哎哟，能到这一步的request更加不简单了，不仅仅有缓存</div><div class=\"line\">                 * 而且还是能用的缓存，没有过期的诶，这才是有真的靠山= =</div><div class=\"line\">                 *</div><div class=\"line\">                 * 将缓存的信息都拿出来，组成一个NetworkResponse</div><div class=\"line\">                 * 就像是刚刚从网络上获取出来的一样，再形成一个Response.java对象</div><div class=\"line\">                 * 但是不要着急把这个response直接传回caller，这个response还没确定是否需要refresh</div><div class=\"line\">                 */</div><div class=\"line\"></div><div class=\"line\">                // We have a cache hit; parse its data for delivery back to the request.</div><div class=\"line\">                request.addMarker(&quot;cache-hit&quot;);</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * 将一个由缓存中的数据创建的NetworkResponse.java对象</div><div class=\"line\">                 * 通过Request#parseNetworkResponse()方法</div><div class=\"line\">                 * 来解析成一个Response.java对象</div><div class=\"line\">                 */</div><div class=\"line\">                Response&lt;?&gt; response = request.parseNetworkResponse(</div><div class=\"line\">                        new NetworkResponse(entry.data, entry.responseHeaders));</div><div class=\"line\"></div><div class=\"line\">                //为了方便debug，对request每一个时期的状态都需要添加不同的log信息</div><div class=\"line\">                request.addMarker(&quot;cache-hit-parsed&quot;);</div><div class=\"line\"></div><div class=\"line\">                if (!entry.refreshNeeded()) &#123;</div><div class=\"line\">                    // Completely unexpired cache hit. Just deliver the response.</div><div class=\"line\">                    /**</div><div class=\"line\">                     * 如果缓存不需要刷新的话，直接传回给caller</div><div class=\"line\">                     */</div><div class=\"line\">                    mDelivery.postResponse(request, response);</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    // Soft-expired cache hit. We can deliver the cached response,</div><div class=\"line\">                    // but we need to also send the request to the network for</div><div class=\"line\">                    // refreshing.</div><div class=\"line\">                    /**</div><div class=\"line\">                     * 如果需要刷新的话，将这个response中的intermediate参数置为true</div><div class=\"line\">                     * 然后再传递给caller，</div><div class=\"line\">                     * 随后将请求发送到服务器进行刷新</div><div class=\"line\">                     */</div><div class=\"line\">                    request.addMarker(&quot;cache-hit-refresh-needed&quot;);</div><div class=\"line\">                    request.setCacheEntry(entry);</div><div class=\"line\"></div><div class=\"line\">                    /**</div><div class=\"line\">                     * Mark the response as intermediate.</div><div class=\"line\">                     * 将这个response标记成中间产物，也就不是最终的response</div><div class=\"line\">                     * </div><div class=\"line\">                     */</div><div class=\"line\">                    response.intermediate = true;</div><div class=\"line\"></div><div class=\"line\">                    /** </div><div class=\"line\">                     * Post the intermediate response back to the user and have</div><div class=\"line\">                     * the delivery then forward the request along to the network.</div><div class=\"line\">                     * poseResponse()方法中的Runnable是在response被传递给caller了之后</div><div class=\"line\">                     * 再执行的，在ResponseDelivery.java中有注释</div><div class=\"line\">                     * </div><div class=\"line\">                     */</div><div class=\"line\">                    mDelivery.postResponse(request, response, new Runnable() &#123;</div><div class=\"line\">                        @Override</div><div class=\"line\">                        public void run() &#123;</div><div class=\"line\">                            try &#123;</div><div class=\"line\">                                //将request加入到网络请求队列中去</div><div class=\"line\">                                mNetworkQueue.put(request);</div><div class=\"line\">                            &#125; catch (InterruptedException e) &#123;</div><div class=\"line\">                                // Not much we can do about this.</div><div class=\"line\">                            &#125;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;);</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">            &#125; catch (InterruptedException e) &#123;</div><div class=\"line\">                //当cacheQueue中没有request之后就会捕捉到异常</div><div class=\"line\">                // We may have been interrupted because it was time to quit.</div><div class=\"line\">                if (mQuit) &#123;</div><div class=\"line\">                    return;</div><div class=\"line\">                &#125;</div><div class=\"line\">                continue;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"3-NetworkDispatcher-java\"><a href=\"#3-NetworkDispatcher-java\" class=\"headerlink\" title=\"3. NetworkDispatcher.java\"></a><a href=\"#3-_NetworkDispatcher-java\" title=\"3\\. NetworkDispatcher.java\"></a>3. NetworkDispatcher.java</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div><div class=\"line\">204</div><div class=\"line\">205</div><div class=\"line\">206</div><div class=\"line\">207</div><div class=\"line\">208</div><div class=\"line\">209</div><div class=\"line\">210</div><div class=\"line\">211</div><div class=\"line\">212</div><div class=\"line\">213</div><div class=\"line\">214</div><div class=\"line\">215</div><div class=\"line\">216</div><div class=\"line\">217</div><div class=\"line\">218</div><div class=\"line\">219</div><div class=\"line\">220</div><div class=\"line\">221</div><div class=\"line\">222</div><div class=\"line\">223</div><div class=\"line\">224</div><div class=\"line\">225</div><div class=\"line\">226</div><div class=\"line\">227</div><div class=\"line\">228</div><div class=\"line\">229</div><div class=\"line\">230</div><div class=\"line\">231</div><div class=\"line\">232</div><div class=\"line\">233</div><div class=\"line\">234</div><div class=\"line\">235</div><div class=\"line\">236</div><div class=\"line\">237</div><div class=\"line\">238</div><div class=\"line\">239</div><div class=\"line\">240</div><div class=\"line\">241</div><div class=\"line\">242</div><div class=\"line\">243</div><div class=\"line\">244</div><div class=\"line\">245</div><div class=\"line\">246</div><div class=\"line\">247</div><div class=\"line\">248</div><div class=\"line\">249</div><div class=\"line\">250</div><div class=\"line\">251</div><div class=\"line\">252</div><div class=\"line\">253</div><div class=\"line\">254</div><div class=\"line\">255</div><div class=\"line\">256</div><div class=\"line\">257</div></pre></td><td class=\"code\"><pre><div class=\"line\">package com.android.volley;</div><div class=\"line\"></div><div class=\"line\">import android.annotation.TargetApi;</div><div class=\"line\">import android.net.TrafficStats;</div><div class=\"line\">import android.os.Build;</div><div class=\"line\">import android.os.Process;</div><div class=\"line\">import android.os.SystemClock;</div><div class=\"line\"></div><div class=\"line\">import java.util.concurrent.BlockingQueue;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\"> * Provides a thread for performing network dispatch from a queue of requests.</div><div class=\"line\"> * 提供一个线程专门用来从请求队列(NetworkQueue)里面调度网络请求</div><div class=\"line\"> * </div><div class=\"line\"> * Requests added to the specified queue are processed from the network via a</div><div class=\"line\"> * specified &#123;@link Network&#125; interface. Responses are committed to cache, if</div><div class=\"line\"> * eligible, using a specified &#123;@link Cache&#125; interface. Valid responses and</div><div class=\"line\"> * errors are posted back to the caller via a &#123;@link ResponseDelivery&#125;.</div><div class=\"line\"> *</div><div class=\"line\"> * 被加入到RequestQueue中的request会被NetWork的接口进一步加工处理.</div><div class=\"line\"> * 如果从网络返回的response是符合条件的，则会被添加到缓存中去。</div><div class=\"line\"> * 有效的response将通过ResponseDelivery返回给调用者</div><div class=\"line\"> */</div><div class=\"line\">public class NetworkDispatcher extends Thread &#123;</div><div class=\"line\">    /** </div><div class=\"line\">     * The queue of requests to service. </div><div class=\"line\">     * 这个queue就是RequestQueue.java中的mNetworkQueue</div><div class=\"line\">     */</div><div class=\"line\">    private final BlockingQueue&lt;Request&lt;?&gt;&gt; mQueue;</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * The network interface for processing requests. </div><div class=\"line\">     * 处理request的接口，其中的方法是performRequest()</div><div class=\"line\">     */</div><div class=\"line\">    private final Network mNetwork;     </div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * The cache to write to. </div><div class=\"line\">     * 处理缓存的接口</div><div class=\"line\">     */</div><div class=\"line\">    private final Cache mCache;</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * For posting responses and errors. </div><div class=\"line\">     * 用来传递response和error的deliver.</div><div class=\"line\">     */</div><div class=\"line\">    private final ResponseDelivery mDelivery;</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * Used for telling us to die. 、</div><div class=\"line\">     * 这里使用到了volatile变量</div><div class=\"line\">     * 这个volatile类似于final之类的修饰词</div><div class=\"line\">     * 是用来保证每次mQuit被读取的时候都是最新的</div><div class=\"line\">     * 避免了读取的值和实际变量的值不同的情况</div><div class=\"line\">     * 可以参考这篇博客，讲解的比较详细：</div><div class=\"line\">     * http://www.cnblogs.com/aigongsi/archive/2012/04/01/2429166.html</div><div class=\"line\">     */</div><div class=\"line\">    private volatile boolean mQuit = false;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Creates a new network dispatcher thread.  You must call &#123;@link #start()&#125;</div><div class=\"line\">     * in order to begin processing.</div><div class=\"line\">     * 构造器，用于创建一个新的网络调度线程，必须要调用call来开始处理request</div><div class=\"line\">     * </div><div class=\"line\">     * @param queue Queue of incoming requests for triage</div><div class=\"line\">     * 等待处理的request队列</div><div class=\"line\">     * @param network Network interface to use for performing requests</div><div class=\"line\">     * @param cache Cache interface to use for writing responses to cache</div><div class=\"line\">     * @param delivery Delivery interface to use for posting responses</div><div class=\"line\">     */</div><div class=\"line\">    public NetworkDispatcher(BlockingQueue&lt;Request&lt;?&gt;&gt; queue,</div><div class=\"line\">            Network network, Cache cache,</div><div class=\"line\">            ResponseDelivery delivery) &#123;</div><div class=\"line\">        mQueue = queue;</div><div class=\"line\">        mNetwork = network;</div><div class=\"line\">        mCache = cache;</div><div class=\"line\">        mDelivery = delivery;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Forces this dispatcher to quit immediately.  If any requests are still in</div><div class=\"line\">     * the queue, they are not guaranteed to be processed.</div><div class=\"line\">     * 强制调度器立刻退出，不再调度request。</div><div class=\"line\">     * </div><div class=\"line\">     */</div><div class=\"line\">    public void quit() &#123;</div><div class=\"line\">        mQuit = true;</div><div class=\"line\">        interrupt();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * 这里涉及到了TrafficStats类，官方解释如下：</div><div class=\"line\">     * Class that provides network traffic statistics. </div><div class=\"line\">     * 这个类提供网络流量统计的服务。</div><div class=\"line\">     * These statistics include bytes transmitted and received and network packets transmitted and received, </div><div class=\"line\">     * over all interfaces, over the mobile interface, and on a per-UID basis.</div><div class=\"line\">     * 这些被统计的流量包括传输的字节数和收到的字节数以及网络数据包</div><div class=\"line\">     * These statistics may not be available on all platforms. </div><div class=\"line\">     * If the statistics are not supported by this device, UNSUPPORTED will be returned.</div><div class=\"line\">     * 这些数据并不是在所有的平台上都可以用</div><div class=\"line\">     * 如果不可用，则会返回UNSPPORTED</div><div class=\"line\">     * 貌似是每个request都统计一下网络流量= =</div><div class=\"line\">     */</div><div class=\"line\">    @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)</div><div class=\"line\">    private void addTrafficStatsTag(Request&lt;?&gt; request) &#123;</div><div class=\"line\">        // Tag the request (if API &gt;= 14)</div><div class=\"line\">        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.ICE_CREAM_SANDWICH) &#123;</div><div class=\"line\">            TrafficStats.setThreadStatsTag(request.getTrafficStatsTag());</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * 由于NetworkDispatcher继承自Thread，重写了run()方法</div><div class=\"line\">     * 里面的内容都会在另启动一个线程来执行</div><div class=\"line\">     * 在CacheDispatcher中有很多相似的地方</div><div class=\"line\">     */</div><div class=\"line\">    @Override</div><div class=\"line\">    public void run() &#123;</div><div class=\"line\">        /**</div><div class=\"line\">         * 给自己设置了线程的优先级</div><div class=\"line\">         * THREAD_PRIORITY_BACKGROUND的优先级是0x0000000a(也就是10)</div><div class=\"line\">         * 还有其他的很多种优先级，该优先级处于较高的位置</div><div class=\"line\">         */</div><div class=\"line\">        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class=\"line\"></div><div class=\"line\">        Request&lt;?&gt; request;</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * 进入了一个死循环状态</div><div class=\"line\">         * 开始不停的工作</div><div class=\"line\">         */</div><div class=\"line\">        while (true) &#123;</div><div class=\"line\"></div><div class=\"line\">            /**</div><div class=\"line\">             * elapsedRealtime()函数返回的是线程从启动到现在的总时间</div><div class=\"line\">             * 也包括线程睡眠时间在内</div><div class=\"line\">             * 单看这一句看不出什么门道，结合在后面的异常处理时会用到startTimeMs</div><div class=\"line\">             * 这里是记录一个request开始的时刻点，到后面再次调用elapsedRealtime()</div><div class=\"line\">             * 两个变量相减得到了request花费了多长的时间</div><div class=\"line\">             */</div><div class=\"line\">            long startTimeMs = SystemClock.elapsedRealtime();</div><div class=\"line\">            /**</div><div class=\"line\">             * release previous request object to avoid leaking request object when mQueue is drained.</div><div class=\"line\">             * 释放前面的一个Request对象，以免因为Request对象不停的申请而导致内存泄漏</div><div class=\"line\">             */</div><div class=\"line\">            request = null;</div><div class=\"line\"></div><div class=\"line\">            /**</div><div class=\"line\">             * 尝试着从RequestQueue中取出一个Request，对其进行处理</div><div class=\"line\">             * 可能会因为某些原因(可能是队列中没有元素了)会抛出异常</div><div class=\"line\">             * 这个时候就捕捉异常并检验是否要退出了，需要退出则return</div><div class=\"line\">             * 不需要退出则继续下一次循环，看有没有Request可以拿到</div><div class=\"line\">             */</div><div class=\"line\">            try &#123;</div><div class=\"line\">                // Take a request from the queue.</div><div class=\"line\">                request = mQueue.take();</div><div class=\"line\">            &#125; catch (InterruptedException e) &#123;</div><div class=\"line\">                // We may have been interrupted because it was time to quit.</div><div class=\"line\">                if (mQuit) &#123;</div><div class=\"line\">                    return;</div><div class=\"line\">                &#125;</div><div class=\"line\">                continue;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            /**</div><div class=\"line\">             * 到这一步的时候，request应该是指向了一个Request</div><div class=\"line\">             * 下面开始向服务器发送这个Request</div><div class=\"line\">             */</div><div class=\"line\"></div><div class=\"line\">            try &#123;</div><div class=\"line\">                request.addMarker(&quot;network-queue-take&quot;);</div><div class=\"line\"></div><div class=\"line\">                // If the request was cancelled already, do not perform the</div><div class=\"line\">                // network request.</div><div class=\"line\">                if (request.isCanceled()) &#123;</div><div class=\"line\">                    request.finish(&quot;network-discard-cancelled&quot;);</div><div class=\"line\">                    continue;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                addTrafficStatsTag(request);</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * Perform the network request.</div><div class=\"line\">                 * 直接调用mNetwork的接口，发送request并获得NetworkResponse</div><div class=\"line\">                 */</div><div class=\"line\">                NetworkResponse networkResponse = mNetwork.performRequest(request);</div><div class=\"line\">                request.addMarker(&quot;network-http-complete&quot;);</div><div class=\"line\"></div><div class=\"line\">                // If the server returned 304 AND we delivered a response already,</div><div class=\"line\">                // we&apos;re done -- don&apos;t deliver a second identical response.</div><div class=\"line\">                if (networkResponse.notModified &amp;&amp; request.hasHadResponseDelivered()) &#123;</div><div class=\"line\">                    request.finish(&quot;not-modified&quot;);</div><div class=\"line\">                    continue;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * Parse the response here on the worker thread.</div><div class=\"line\">                 * 在工作线程上面直接解析结果</div><div class=\"line\">                 * 并且封装成一个Response对象</div><div class=\"line\">                 */</div><div class=\"line\">                Response&lt;?&gt; response = request.parseNetworkResponse(networkResponse);</div><div class=\"line\">                request.addMarker(&quot;network-parse-complete&quot;);</div><div class=\"line\"></div><div class=\"line\">                /** Write to cache if applicable.</div><div class=\"line\">                 *  如果符合要求，能写入缓存的话，就写到缓存里面</div><div class=\"line\">                 */</div><div class=\"line\">                // TODO: Only update cache metadata instead of entire record for 304s.</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * 在这里看到作者的TODO了，还能改进的地方就是在出现了返回码是</div><div class=\"line\">                 * 304的情况时，只更新缓存中的元数据(也就是response的主体)</div><div class=\"line\">                 * 而不是整个cache的记录下来,有些重复的数据可以不用理会.</div><div class=\"line\">                 */</div><div class=\"line\">                if (request.shouldCache() &amp;&amp; response.cacheEntry != null) &#123;</div><div class=\"line\">                    mCache.put(request.getCacheKey(), response.cacheEntry);</div><div class=\"line\">                    request.addMarker(&quot;network-cache-written&quot;);</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * 将Request.java中的变量mResponseDelivered置成true</div><div class=\"line\">                 * 标志着这个request的结果已经传回给了caller</div><div class=\"line\">                 */</div><div class=\"line\"></div><div class=\"line\">                request.markDelivered();</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * 通过ResponseDelivery的接口将包装好了的Response返回给调用者</div><div class=\"line\">                 */</div><div class=\"line\">                mDelivery.postResponse(request, response);</div><div class=\"line\"></div><div class=\"line\">            &#125; catch (VolleyError volleyError) &#123;</div><div class=\"line\">                /**</div><div class=\"line\">                 * 设置了request从队列中取出到服务器出现异常反应</div><div class=\"line\">                 * 所花费的时间</div><div class=\"line\">                 */</div><div class=\"line\">                volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * 将网络请求的错误通过ResponseDelivery传递给调用者</div><div class=\"line\">                 * 告诉它这.....不幸的一切</div><div class=\"line\">                 */</div><div class=\"line\">                parseAndDeliverNetworkError(request, volleyError);</div><div class=\"line\"></div><div class=\"line\">            &#125; catch (Exception e) &#123;</div><div class=\"line\">                VolleyLog.e(e, &quot;Unhandled exception %s&quot;, e.toString());</div><div class=\"line\">                VolleyError volleyError = new VolleyError(e);</div><div class=\"line\">                volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);</div><div class=\"line\">                mDelivery.postError(request, volleyError);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    private void parseAndDeliverNetworkError(Request&lt;?&gt; request, VolleyError error) &#123;</div><div class=\"line\">        error = request.parseNetworkError(error);</div><div class=\"line\">        mDelivery.postError(request, error);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当时看完了CacheDispatcher.java之后，再看NetworkDispatcher.java的时候，就会觉得这两个类非常的相似，run()函数里面的东西有些都差不多，都是进行一个死循环，从阻塞队列里面取出request，针对不同的情况做出不同的处理。</p>\n<p>从Volley.java暴露给外部的api开始，一直到现在，已经慢慢的了解了Volley中有一个RequestQueue对象，所有的request都在里面排着队等待被处理，RequestQueue里面还有一个CacheDispatcher和几个NetworkDispatcher,分别负责着不同种类的request。接下来要介绍的就是Volley中<code>Network.java</code>接口以及其默认实现类<code>BasicNetwork.java</code>,还有涉及缓存读写的接口<code>Cache.java</code>以及其默认实现类<code>DiskBasedCache.java</code>。</p>\n</div>","excerpt":"<h2 id=\"Volley框架解析-三-—–Dispatcher解析\"><a href=\"#Volley框架解析-三-—–Dispatcher解析\" class=\"headerlink\" title=\"Volley框架解析(三)—–Dispatcher解析\"></a>Volley框架解析(三)—–Dispatcher解析</h2><p></header></p>\n<div class=\"article-entry\" itemprop=\"articleBody\">\n\n<h3 id=\"题外话-可直接无视，跳过\"><a href=\"#题外话-可直接无视，跳过\" class=\"headerlink\" title=\"题外话(可直接无视，跳过~\"></a><a href=\"#u9898_u5916_u8BDD_28_u53EF_u76F4_u63A5_u65E0_u89C6_uFF0C_u8DF3_u8FC7_7E\" title=\"题外话(可直接无视，跳过~\"></a>题外话(可直接无视，跳过~</h3><p>在上一篇博客中结合volley源代码分析了<code>Volley.java</code>和<code>RequestQueue.java</code>这两个类，不知道代码全贴上去了，会不会看着很烦的嗯= =，当时看源代码的时候心里就有些不淡定，满屏幕看不懂的东西，但是个人觉得源代码和注释一起看才方便，一段代码一段解释会感觉有点摸不着头脑= =。前面的博客中一直提到了<code>Dispatcher</code>这种的东西，有<code>mNetworkDispatcher</code>和<code>mCacheDispatcher</code>之类的，这篇博客就开始进一步的介绍Volley中的Dispatcher。</p>","more":"<hr>\n<p><a id=\"more\"></a></p>\n<h3 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1. 简介\"></a><a href=\"#1-__u7B80_u4ECB\" title=\"1\\. 简介\"></a>1. 简介</h3><p>在Volley中涉及到了两类的Dispatcher,一类是涉及到缓存的<code>CacheDispatcher.java</code>，另外一类是用来处理网络方面request的<code>NetworkDispatcher.java</code>，最开始出现这两个Dispatcher是在<code>RequestQueue#start()</code>中，再来回顾一下start方法中的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void start() &#123;</div><div class=\"line\">    stop();  // Make sure any currently running dispatchers are stopped.</div><div class=\"line\">    // Create the cache dispatcher and start it.</div><div class=\"line\">    mCacheDispatcher = new CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);</div><div class=\"line\">    mCacheDispatcher.start();</div><div class=\"line\"></div><div class=\"line\">    // Create network dispatchers (and corresponding threads) up to the pool size.</div><div class=\"line\">    for (int i = 0; i &lt; mDispatchers.length; i++) &#123;</div><div class=\"line\">        NetworkDispatcher networkDispatcher = new NetworkDispatcher(mNetworkQueue, mNetwork,</div><div class=\"line\">                mCache, mDelivery);</div><div class=\"line\">        mDispatchers[i] = networkDispatcher;</div><div class=\"line\">        networkDispatcher.start();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>先暂停了所有的dispatcher，然后又新建了dispatcher并start()。让dispatcher开始工作，实际上这些dispatcher继承了Thread类，是独立于主线程之外的工作线程，这样可以使RequestQueue中request的加入和处理同时进行。下面就结合CacheDispatcher和NetworkDispatcher两个类的代码来分析,Volley中是如何对request来进行调度和处理的。</p>\n<h3 id=\"2-CacheDispatcher-java\"><a href=\"#2-CacheDispatcher-java\" class=\"headerlink\" title=\"2. CacheDispatcher.java\"></a><a href=\"#2-_CacheDispatcher-java\" title=\"2\\. CacheDispatcher.java\"></a>2. CacheDispatcher.java</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div><div class=\"line\">204</div><div class=\"line\">205</div><div class=\"line\">206</div><div class=\"line\">207</div><div class=\"line\">208</div><div class=\"line\">209</div><div class=\"line\">210</div><div class=\"line\">211</div><div class=\"line\">212</div><div class=\"line\">213</div><div class=\"line\">214</div><div class=\"line\">215</div><div class=\"line\">216</div><div class=\"line\">217</div><div class=\"line\">218</div><div class=\"line\">219</div><div class=\"line\">220</div><div class=\"line\">221</div><div class=\"line\">222</div><div class=\"line\">223</div><div class=\"line\">224</div><div class=\"line\">225</div><div class=\"line\">226</div><div class=\"line\">227</div><div class=\"line\">228</div><div class=\"line\">229</div><div class=\"line\">230</div><div class=\"line\">231</div><div class=\"line\">232</div><div class=\"line\">233</div><div class=\"line\">234</div><div class=\"line\">235</div><div class=\"line\">236</div><div class=\"line\">237</div><div class=\"line\">238</div><div class=\"line\">239</div><div class=\"line\">240</div><div class=\"line\">241</div><div class=\"line\">242</div><div class=\"line\">243</div><div class=\"line\">244</div><div class=\"line\">245</div><div class=\"line\">246</div><div class=\"line\">247</div><div class=\"line\">248</div><div class=\"line\">249</div><div class=\"line\">250</div><div class=\"line\">251</div><div class=\"line\">252</div><div class=\"line\">253</div><div class=\"line\">254</div><div class=\"line\">255</div><div class=\"line\">256</div><div class=\"line\">257</div><div class=\"line\">258</div><div class=\"line\">259</div><div class=\"line\">260</div><div class=\"line\">261</div><div class=\"line\">262</div><div class=\"line\">263</div><div class=\"line\">264</div><div class=\"line\">265</div><div class=\"line\">266</div><div class=\"line\">267</div><div class=\"line\">268</div><div class=\"line\">269</div><div class=\"line\">270</div><div class=\"line\">271</div><div class=\"line\">272</div><div class=\"line\">273</div><div class=\"line\">274</div><div class=\"line\">275</div><div class=\"line\">276</div><div class=\"line\">277</div><div class=\"line\">278</div><div class=\"line\">279</div><div class=\"line\">280</div><div class=\"line\">281</div><div class=\"line\">282</div></pre></td><td class=\"code\"><pre><div class=\"line\">package com.android.volley;</div><div class=\"line\"></div><div class=\"line\">import android.os.Process;</div><div class=\"line\"></div><div class=\"line\">import java.util.concurrent.BlockingQueue;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\"> * Provides a thread for performing cache triage on a queue of requests.</div><div class=\"line\"> * 提供一个用来处理涉及到缓存的requests的线程</div><div class=\"line\"> * </div><div class=\"line\"> * Requests added to the specified cache queue are resolved from cache.</div><div class=\"line\"> * Any deliverable response is posted back to the caller via a</div><div class=\"line\"> * &#123;@link ResponseDelivery&#125;.  Cache misses and responses that require</div><div class=\"line\"> * refresh are enqueued on the specified network queue for processing</div><div class=\"line\"> * by a &#123;@link NetworkDispatcher&#125;.</div><div class=\"line\"> * CacheDispatcher用来处理缓存队列里面(mCacheQueue)中的request</div><div class=\"line\"> * 任何符合delivery要求的response都会被通过ResponseDelivery的接口传递给caller</div><div class=\"line\"> * 有些cache丢失了或者是cache中的数据需要更新的，都将会交给NetworkDispatcher去处理</div><div class=\"line\"> * 交给NetworkDispatcher处理的方法就是直接放到mNetworkQueue中去</div><div class=\"line\"> * 因为NetworkDispatcher总是从mNetworkQueue中取出request来进行处理的</div><div class=\"line\"> */</div><div class=\"line\"></div><div class=\"line\">public class CacheDispatcher extends Thread &#123;</div><div class=\"line\"></div><div class=\"line\">    private static final boolean DEBUG = VolleyLog.DEBUG;</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * The queue of requests coming in for triage. </div><div class=\"line\">     * 将要被处理的涉及到缓存的Request存放在这个阻塞队列里</div><div class=\"line\">     * 等着咯，这个mCacheQueue和RequestQueue中的mCacheQueue指向的队列是同一个</div><div class=\"line\">     * 也就是说整个Volley在运行的时候只有一个mCacheQueue</div><div class=\"line\">     */</div><div class=\"line\">    private final BlockingQueue&lt;Request&lt;?&gt;&gt; mCacheQueue;</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * The queue of requests going out to the network. </div><div class=\"line\">     * 这个阻塞队里里面存着的可是要去进行网络访问的request</div><div class=\"line\">     * 开始还不明白这里不应该是涉及到访问缓存的request</div><div class=\"line\">     * 怎么有个这东西出来了，其实看到后面了就会发现，缓存里面有两个过期时间</div><div class=\"line\">     * 在后面会介绍到Cache.java类，Cache.Entry类中涉及到了</div><div class=\"line\">     * ttl 和 softTtl这两个long型的数据，用来标识缓存是否已经过期了</div><div class=\"line\">     * 或者是否需要去检查是否要更新缓存的两个间隔时间</div><div class=\"line\">     */</div><div class=\"line\">    private final BlockingQueue&lt;Request&lt;?&gt;&gt; mNetworkQueue;</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * The cache to read from. </div><div class=\"line\">     * 用于读写缓存的接口</div><div class=\"line\">     * 这个接口也是在Volley中只有一个</div><div class=\"line\">     * mCacheDispatcher和mNetworkDispatcher公用的</div><div class=\"line\">     */</div><div class=\"line\">    private final Cache mCache;</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * For posting responses. </div><div class=\"line\">     * ResponseDelivery对象引用，用来将request的结果传递给caller</div><div class=\"line\">     * 在NetworkDispatcher里面也有出现</div><div class=\"line\">     * 这个也是从RequestQueue中传递过来的，公用</div><div class=\"line\">     */</div><div class=\"line\">    private final ResponseDelivery mDelivery;</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * Used for telling us to die. </div><div class=\"line\">     * 直译 ： 用来告诉我们去死= = (shit)</div><div class=\"line\">     * 然而 ： 这个变量用来标志这个dispatcher是否要继续工作下去</div><div class=\"line\">     * 如果为true就结束本线程中的死循环</div><div class=\"line\">     */</div><div class=\"line\">    private volatile boolean mQuit = false;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Creates a new cache triage dispatcher thread.  You must call &#123;@link #start()&#125;</div><div class=\"line\">     * in order to begin processing.</div><div class=\"line\">     * 构造函数咯，创建一个存放需要访问缓存的request的调度线程</div><div class=\"line\">     * 在创建之后需要将其用start()启动</div><div class=\"line\">     * </div><div class=\"line\">     * @param cacheQueue Queue of incoming requests for triage</div><div class=\"line\">     * 存放request的缓存队列</div><div class=\"line\">     * @param networkQueue Queue to post requests that require network to</div><div class=\"line\">     * 存放涉及network的网络队列</div><div class=\"line\">     * @param cache Cache interface to use for resolution</div><div class=\"line\">     * 用来处理缓存读写问题的接口</div><div class=\"line\">     * @param delivery Delivery interface to use for posting responses</div><div class=\"line\">     * 用来反馈结果的接口</div><div class=\"line\">     */</div><div class=\"line\">    public CacheDispatcher(</div><div class=\"line\">            BlockingQueue&lt;Request&lt;?&gt;&gt; cacheQueue, BlockingQueue&lt;Request&lt;?&gt;&gt; networkQueue,</div><div class=\"line\">            Cache cache, ResponseDelivery delivery) &#123;</div><div class=\"line\">        mCacheQueue = cacheQueue;</div><div class=\"line\">        mNetworkQueue = networkQueue;</div><div class=\"line\">        mCache = cache;</div><div class=\"line\">        mDelivery = delivery;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Forces this dispatcher to quit immediately.  If any requests are still in</div><div class=\"line\">     * the queue, they are not guaranteed to be processed.</div><div class=\"line\">     * 将标志位mQuit置为true,在每次死循环的最后会判断该标志位</div><div class=\"line\">     */</div><div class=\"line\">    public void quit() &#123;</div><div class=\"line\">        mQuit = true;</div><div class=\"line\">        interrupt();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * 前面提到了CacheDispatcher继承了Thread类</div><div class=\"line\">     * 这里就重写了run()方法</div><div class=\"line\">     * 当外面调用了mCacheDispatcher.start()之后</div><div class=\"line\">     * run()里面的方法就开始执行了</div><div class=\"line\">     */</div><div class=\"line\">    @Override</div><div class=\"line\">    public void run() &#123;</div><div class=\"line\"></div><div class=\"line\">        if (DEBUG) VolleyLog.v(&quot;start new dispatcher&quot;);</div><div class=\"line\">        /**</div><div class=\"line\">         * 给自己设置了线程的优先级</div><div class=\"line\">         * THREAD_PRIORITY_BACKGROUND的优先级是0x0000000a(也就是10)</div><div class=\"line\">         * 还有其他的很多种优先级，该优先级处于较高的位置</div><div class=\"line\">         */</div><div class=\"line\">        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * Make a blocking call to initialize the cache.</div><div class=\"line\">         * 在读写缓存之前做一些初始化工作，例如扫描缓存目录是否存在等</div><div class=\"line\">         * 这个暂时先不用管里面的内容，等介绍到Cache.java的时候就会明白</div><div class=\"line\">         */</div><div class=\"line\">        mCache.initialize();</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * 从这里开始就进入了死循环的状态</div><div class=\"line\">         * 除非出现了什么没有catch的exception</div><div class=\"line\">         * 或者是mQuit标志位被置成了true</div><div class=\"line\">         * 这个死循环将一直进行下去= =</div><div class=\"line\">         * 总感觉有什么不妥的地方，感觉死循环怪怪的噢</div><div class=\"line\">         */</div><div class=\"line\">        while (true) &#123;</div><div class=\"line\">            /**</div><div class=\"line\">             * 和NetworkDispatcher里面的流程没有什么太大的变化</div><div class=\"line\">             * 还是一个死循环不停的从CacheQueue中取出Request</div><div class=\"line\">             */</div><div class=\"line\">            try &#123;</div><div class=\"line\">                /**</div><div class=\"line\">                 * Get a request from the cache triage queue, blocking until</div><div class=\"line\">                 * at least one is available.</div><div class=\"line\">                 * 从缓存request队列里面取出等待处理的request</div><div class=\"line\">                 * 如果没有可取出的request，则会在这里阻塞</div><div class=\"line\">                 * 这个是PriorityBlockingQueue#take()函数的作用</div><div class=\"line\">                 * </div><div class=\"line\">                 */</div><div class=\"line\">                final Request&lt;?&gt; request = mCacheQueue.take();</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * 给每个request添加上一个打log的标志</div><div class=\"line\">                 * 为了debug的需要</div><div class=\"line\">                 */</div><div class=\"line\">                request.addMarker(&quot;cache-queue-take&quot;);</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * If the request has been canceled, don&apos;t bother dispatching it.</div><div class=\"line\">                 * 如果正在处理的这个请求被取消了</div><div class=\"line\">                 * 中断对该request的处理，continue去处理下一个request的调度</div><div class=\"line\">                 * 调用Request#finish()方法，传入的参数是为了debug方便，打出request调度进度的log</div><div class=\"line\">                 */</div><div class=\"line\">                if (request.isCanceled()) &#123;</div><div class=\"line\">                    request.finish(&quot;cache-discard-canceled&quot;);</div><div class=\"line\">                    continue;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * 在这里NetworkDispatcher和CacheDispatcher出现了一点差异</div><div class=\"line\">                 * NetworkDispatcher.java在这一步就直接开始网络请求了</div><div class=\"line\">                 * </div><div class=\"line\">                 * 由于是CacheDispatcher.java，肯定是主要以Cahce为主的</div><div class=\"line\">                 * CacheDispatcher在这里先看看有没有缓存</div><div class=\"line\">                 * 如果没有缓存则马上将这个request加入到NetworkQueue中</div><div class=\"line\">                 * (意思好像就是= =兄弟你排错队了)</div><div class=\"line\">                 * 然后继续喊下一个request来被处理</div><div class=\"line\">                 */</div><div class=\"line\">                // Attempt to retrieve this item from cache.</div><div class=\"line\">                Cache.Entry entry = mCache.get(request.getCacheKey());</div><div class=\"line\">                if (entry == null) &#123;</div><div class=\"line\">                    request.addMarker(&quot;cache-miss&quot;);</div><div class=\"line\">                    // Cache miss; send off to the network dispatcher.</div><div class=\"line\">                    mNetworkQueue.put(request);</div><div class=\"line\">                    continue;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * 能到这一步的request不简单了</div><div class=\"line\">                 * 肯定是被上面的mCache.get(cacheKey)查到了有缓存的(毕竟有靠山的伤不起)</div><div class=\"line\">                 * 有缓存还不能太大意= =，万一缓存尼玛是个过期的就惨了= =</div><div class=\"line\">                 * 先用entry.isExpired()函数检查一番</div><div class=\"line\">                 * 过期了照样还是给我滚到NetworkQueue中去排队</div><div class=\"line\">                 *</div><div class=\"line\">                 * 继续喊下一个request来</div><div class=\"line\">                 */</div><div class=\"line\">                // If it is completely expired, just send it to the network.</div><div class=\"line\">                if (entry.isExpired()) &#123;</div><div class=\"line\">                    request.addMarker(&quot;cache-hit-expired&quot;);</div><div class=\"line\">                    request.setCacheEntry(entry);</div><div class=\"line\">                    mNetworkQueue.put(request);</div><div class=\"line\">                    continue;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * 哎哟，能到这一步的request更加不简单了，不仅仅有缓存</div><div class=\"line\">                 * 而且还是能用的缓存，没有过期的诶，这才是有真的靠山= =</div><div class=\"line\">                 *</div><div class=\"line\">                 * 将缓存的信息都拿出来，组成一个NetworkResponse</div><div class=\"line\">                 * 就像是刚刚从网络上获取出来的一样，再形成一个Response.java对象</div><div class=\"line\">                 * 但是不要着急把这个response直接传回caller，这个response还没确定是否需要refresh</div><div class=\"line\">                 */</div><div class=\"line\"></div><div class=\"line\">                // We have a cache hit; parse its data for delivery back to the request.</div><div class=\"line\">                request.addMarker(&quot;cache-hit&quot;);</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * 将一个由缓存中的数据创建的NetworkResponse.java对象</div><div class=\"line\">                 * 通过Request#parseNetworkResponse()方法</div><div class=\"line\">                 * 来解析成一个Response.java对象</div><div class=\"line\">                 */</div><div class=\"line\">                Response&lt;?&gt; response = request.parseNetworkResponse(</div><div class=\"line\">                        new NetworkResponse(entry.data, entry.responseHeaders));</div><div class=\"line\"></div><div class=\"line\">                //为了方便debug，对request每一个时期的状态都需要添加不同的log信息</div><div class=\"line\">                request.addMarker(&quot;cache-hit-parsed&quot;);</div><div class=\"line\"></div><div class=\"line\">                if (!entry.refreshNeeded()) &#123;</div><div class=\"line\">                    // Completely unexpired cache hit. Just deliver the response.</div><div class=\"line\">                    /**</div><div class=\"line\">                     * 如果缓存不需要刷新的话，直接传回给caller</div><div class=\"line\">                     */</div><div class=\"line\">                    mDelivery.postResponse(request, response);</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    // Soft-expired cache hit. We can deliver the cached response,</div><div class=\"line\">                    // but we need to also send the request to the network for</div><div class=\"line\">                    // refreshing.</div><div class=\"line\">                    /**</div><div class=\"line\">                     * 如果需要刷新的话，将这个response中的intermediate参数置为true</div><div class=\"line\">                     * 然后再传递给caller，</div><div class=\"line\">                     * 随后将请求发送到服务器进行刷新</div><div class=\"line\">                     */</div><div class=\"line\">                    request.addMarker(&quot;cache-hit-refresh-needed&quot;);</div><div class=\"line\">                    request.setCacheEntry(entry);</div><div class=\"line\"></div><div class=\"line\">                    /**</div><div class=\"line\">                     * Mark the response as intermediate.</div><div class=\"line\">                     * 将这个response标记成中间产物，也就不是最终的response</div><div class=\"line\">                     * </div><div class=\"line\">                     */</div><div class=\"line\">                    response.intermediate = true;</div><div class=\"line\"></div><div class=\"line\">                    /** </div><div class=\"line\">                     * Post the intermediate response back to the user and have</div><div class=\"line\">                     * the delivery then forward the request along to the network.</div><div class=\"line\">                     * poseResponse()方法中的Runnable是在response被传递给caller了之后</div><div class=\"line\">                     * 再执行的，在ResponseDelivery.java中有注释</div><div class=\"line\">                     * </div><div class=\"line\">                     */</div><div class=\"line\">                    mDelivery.postResponse(request, response, new Runnable() &#123;</div><div class=\"line\">                        @Override</div><div class=\"line\">                        public void run() &#123;</div><div class=\"line\">                            try &#123;</div><div class=\"line\">                                //将request加入到网络请求队列中去</div><div class=\"line\">                                mNetworkQueue.put(request);</div><div class=\"line\">                            &#125; catch (InterruptedException e) &#123;</div><div class=\"line\">                                // Not much we can do about this.</div><div class=\"line\">                            &#125;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;);</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">            &#125; catch (InterruptedException e) &#123;</div><div class=\"line\">                //当cacheQueue中没有request之后就会捕捉到异常</div><div class=\"line\">                // We may have been interrupted because it was time to quit.</div><div class=\"line\">                if (mQuit) &#123;</div><div class=\"line\">                    return;</div><div class=\"line\">                &#125;</div><div class=\"line\">                continue;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"3-NetworkDispatcher-java\"><a href=\"#3-NetworkDispatcher-java\" class=\"headerlink\" title=\"3. NetworkDispatcher.java\"></a><a href=\"#3-_NetworkDispatcher-java\" title=\"3\\. NetworkDispatcher.java\"></a>3. NetworkDispatcher.java</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div><div class=\"line\">204</div><div class=\"line\">205</div><div class=\"line\">206</div><div class=\"line\">207</div><div class=\"line\">208</div><div class=\"line\">209</div><div class=\"line\">210</div><div class=\"line\">211</div><div class=\"line\">212</div><div class=\"line\">213</div><div class=\"line\">214</div><div class=\"line\">215</div><div class=\"line\">216</div><div class=\"line\">217</div><div class=\"line\">218</div><div class=\"line\">219</div><div class=\"line\">220</div><div class=\"line\">221</div><div class=\"line\">222</div><div class=\"line\">223</div><div class=\"line\">224</div><div class=\"line\">225</div><div class=\"line\">226</div><div class=\"line\">227</div><div class=\"line\">228</div><div class=\"line\">229</div><div class=\"line\">230</div><div class=\"line\">231</div><div class=\"line\">232</div><div class=\"line\">233</div><div class=\"line\">234</div><div class=\"line\">235</div><div class=\"line\">236</div><div class=\"line\">237</div><div class=\"line\">238</div><div class=\"line\">239</div><div class=\"line\">240</div><div class=\"line\">241</div><div class=\"line\">242</div><div class=\"line\">243</div><div class=\"line\">244</div><div class=\"line\">245</div><div class=\"line\">246</div><div class=\"line\">247</div><div class=\"line\">248</div><div class=\"line\">249</div><div class=\"line\">250</div><div class=\"line\">251</div><div class=\"line\">252</div><div class=\"line\">253</div><div class=\"line\">254</div><div class=\"line\">255</div><div class=\"line\">256</div><div class=\"line\">257</div></pre></td><td class=\"code\"><pre><div class=\"line\">package com.android.volley;</div><div class=\"line\"></div><div class=\"line\">import android.annotation.TargetApi;</div><div class=\"line\">import android.net.TrafficStats;</div><div class=\"line\">import android.os.Build;</div><div class=\"line\">import android.os.Process;</div><div class=\"line\">import android.os.SystemClock;</div><div class=\"line\"></div><div class=\"line\">import java.util.concurrent.BlockingQueue;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\"> * Provides a thread for performing network dispatch from a queue of requests.</div><div class=\"line\"> * 提供一个线程专门用来从请求队列(NetworkQueue)里面调度网络请求</div><div class=\"line\"> * </div><div class=\"line\"> * Requests added to the specified queue are processed from the network via a</div><div class=\"line\"> * specified &#123;@link Network&#125; interface. Responses are committed to cache, if</div><div class=\"line\"> * eligible, using a specified &#123;@link Cache&#125; interface. Valid responses and</div><div class=\"line\"> * errors are posted back to the caller via a &#123;@link ResponseDelivery&#125;.</div><div class=\"line\"> *</div><div class=\"line\"> * 被加入到RequestQueue中的request会被NetWork的接口进一步加工处理.</div><div class=\"line\"> * 如果从网络返回的response是符合条件的，则会被添加到缓存中去。</div><div class=\"line\"> * 有效的response将通过ResponseDelivery返回给调用者</div><div class=\"line\"> */</div><div class=\"line\">public class NetworkDispatcher extends Thread &#123;</div><div class=\"line\">    /** </div><div class=\"line\">     * The queue of requests to service. </div><div class=\"line\">     * 这个queue就是RequestQueue.java中的mNetworkQueue</div><div class=\"line\">     */</div><div class=\"line\">    private final BlockingQueue&lt;Request&lt;?&gt;&gt; mQueue;</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * The network interface for processing requests. </div><div class=\"line\">     * 处理request的接口，其中的方法是performRequest()</div><div class=\"line\">     */</div><div class=\"line\">    private final Network mNetwork;     </div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * The cache to write to. </div><div class=\"line\">     * 处理缓存的接口</div><div class=\"line\">     */</div><div class=\"line\">    private final Cache mCache;</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * For posting responses and errors. </div><div class=\"line\">     * 用来传递response和error的deliver.</div><div class=\"line\">     */</div><div class=\"line\">    private final ResponseDelivery mDelivery;</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * Used for telling us to die. 、</div><div class=\"line\">     * 这里使用到了volatile变量</div><div class=\"line\">     * 这个volatile类似于final之类的修饰词</div><div class=\"line\">     * 是用来保证每次mQuit被读取的时候都是最新的</div><div class=\"line\">     * 避免了读取的值和实际变量的值不同的情况</div><div class=\"line\">     * 可以参考这篇博客，讲解的比较详细：</div><div class=\"line\">     * http://www.cnblogs.com/aigongsi/archive/2012/04/01/2429166.html</div><div class=\"line\">     */</div><div class=\"line\">    private volatile boolean mQuit = false;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Creates a new network dispatcher thread.  You must call &#123;@link #start()&#125;</div><div class=\"line\">     * in order to begin processing.</div><div class=\"line\">     * 构造器，用于创建一个新的网络调度线程，必须要调用call来开始处理request</div><div class=\"line\">     * </div><div class=\"line\">     * @param queue Queue of incoming requests for triage</div><div class=\"line\">     * 等待处理的request队列</div><div class=\"line\">     * @param network Network interface to use for performing requests</div><div class=\"line\">     * @param cache Cache interface to use for writing responses to cache</div><div class=\"line\">     * @param delivery Delivery interface to use for posting responses</div><div class=\"line\">     */</div><div class=\"line\">    public NetworkDispatcher(BlockingQueue&lt;Request&lt;?&gt;&gt; queue,</div><div class=\"line\">            Network network, Cache cache,</div><div class=\"line\">            ResponseDelivery delivery) &#123;</div><div class=\"line\">        mQueue = queue;</div><div class=\"line\">        mNetwork = network;</div><div class=\"line\">        mCache = cache;</div><div class=\"line\">        mDelivery = delivery;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Forces this dispatcher to quit immediately.  If any requests are still in</div><div class=\"line\">     * the queue, they are not guaranteed to be processed.</div><div class=\"line\">     * 强制调度器立刻退出，不再调度request。</div><div class=\"line\">     * </div><div class=\"line\">     */</div><div class=\"line\">    public void quit() &#123;</div><div class=\"line\">        mQuit = true;</div><div class=\"line\">        interrupt();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * 这里涉及到了TrafficStats类，官方解释如下：</div><div class=\"line\">     * Class that provides network traffic statistics. </div><div class=\"line\">     * 这个类提供网络流量统计的服务。</div><div class=\"line\">     * These statistics include bytes transmitted and received and network packets transmitted and received, </div><div class=\"line\">     * over all interfaces, over the mobile interface, and on a per-UID basis.</div><div class=\"line\">     * 这些被统计的流量包括传输的字节数和收到的字节数以及网络数据包</div><div class=\"line\">     * These statistics may not be available on all platforms. </div><div class=\"line\">     * If the statistics are not supported by this device, UNSUPPORTED will be returned.</div><div class=\"line\">     * 这些数据并不是在所有的平台上都可以用</div><div class=\"line\">     * 如果不可用，则会返回UNSPPORTED</div><div class=\"line\">     * 貌似是每个request都统计一下网络流量= =</div><div class=\"line\">     */</div><div class=\"line\">    @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)</div><div class=\"line\">    private void addTrafficStatsTag(Request&lt;?&gt; request) &#123;</div><div class=\"line\">        // Tag the request (if API &gt;= 14)</div><div class=\"line\">        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.ICE_CREAM_SANDWICH) &#123;</div><div class=\"line\">            TrafficStats.setThreadStatsTag(request.getTrafficStatsTag());</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * 由于NetworkDispatcher继承自Thread，重写了run()方法</div><div class=\"line\">     * 里面的内容都会在另启动一个线程来执行</div><div class=\"line\">     * 在CacheDispatcher中有很多相似的地方</div><div class=\"line\">     */</div><div class=\"line\">    @Override</div><div class=\"line\">    public void run() &#123;</div><div class=\"line\">        /**</div><div class=\"line\">         * 给自己设置了线程的优先级</div><div class=\"line\">         * THREAD_PRIORITY_BACKGROUND的优先级是0x0000000a(也就是10)</div><div class=\"line\">         * 还有其他的很多种优先级，该优先级处于较高的位置</div><div class=\"line\">         */</div><div class=\"line\">        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class=\"line\"></div><div class=\"line\">        Request&lt;?&gt; request;</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * 进入了一个死循环状态</div><div class=\"line\">         * 开始不停的工作</div><div class=\"line\">         */</div><div class=\"line\">        while (true) &#123;</div><div class=\"line\"></div><div class=\"line\">            /**</div><div class=\"line\">             * elapsedRealtime()函数返回的是线程从启动到现在的总时间</div><div class=\"line\">             * 也包括线程睡眠时间在内</div><div class=\"line\">             * 单看这一句看不出什么门道，结合在后面的异常处理时会用到startTimeMs</div><div class=\"line\">             * 这里是记录一个request开始的时刻点，到后面再次调用elapsedRealtime()</div><div class=\"line\">             * 两个变量相减得到了request花费了多长的时间</div><div class=\"line\">             */</div><div class=\"line\">            long startTimeMs = SystemClock.elapsedRealtime();</div><div class=\"line\">            /**</div><div class=\"line\">             * release previous request object to avoid leaking request object when mQueue is drained.</div><div class=\"line\">             * 释放前面的一个Request对象，以免因为Request对象不停的申请而导致内存泄漏</div><div class=\"line\">             */</div><div class=\"line\">            request = null;</div><div class=\"line\"></div><div class=\"line\">            /**</div><div class=\"line\">             * 尝试着从RequestQueue中取出一个Request，对其进行处理</div><div class=\"line\">             * 可能会因为某些原因(可能是队列中没有元素了)会抛出异常</div><div class=\"line\">             * 这个时候就捕捉异常并检验是否要退出了，需要退出则return</div><div class=\"line\">             * 不需要退出则继续下一次循环，看有没有Request可以拿到</div><div class=\"line\">             */</div><div class=\"line\">            try &#123;</div><div class=\"line\">                // Take a request from the queue.</div><div class=\"line\">                request = mQueue.take();</div><div class=\"line\">            &#125; catch (InterruptedException e) &#123;</div><div class=\"line\">                // We may have been interrupted because it was time to quit.</div><div class=\"line\">                if (mQuit) &#123;</div><div class=\"line\">                    return;</div><div class=\"line\">                &#125;</div><div class=\"line\">                continue;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            /**</div><div class=\"line\">             * 到这一步的时候，request应该是指向了一个Request</div><div class=\"line\">             * 下面开始向服务器发送这个Request</div><div class=\"line\">             */</div><div class=\"line\"></div><div class=\"line\">            try &#123;</div><div class=\"line\">                request.addMarker(&quot;network-queue-take&quot;);</div><div class=\"line\"></div><div class=\"line\">                // If the request was cancelled already, do not perform the</div><div class=\"line\">                // network request.</div><div class=\"line\">                if (request.isCanceled()) &#123;</div><div class=\"line\">                    request.finish(&quot;network-discard-cancelled&quot;);</div><div class=\"line\">                    continue;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                addTrafficStatsTag(request);</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * Perform the network request.</div><div class=\"line\">                 * 直接调用mNetwork的接口，发送request并获得NetworkResponse</div><div class=\"line\">                 */</div><div class=\"line\">                NetworkResponse networkResponse = mNetwork.performRequest(request);</div><div class=\"line\">                request.addMarker(&quot;network-http-complete&quot;);</div><div class=\"line\"></div><div class=\"line\">                // If the server returned 304 AND we delivered a response already,</div><div class=\"line\">                // we&apos;re done -- don&apos;t deliver a second identical response.</div><div class=\"line\">                if (networkResponse.notModified &amp;&amp; request.hasHadResponseDelivered()) &#123;</div><div class=\"line\">                    request.finish(&quot;not-modified&quot;);</div><div class=\"line\">                    continue;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * Parse the response here on the worker thread.</div><div class=\"line\">                 * 在工作线程上面直接解析结果</div><div class=\"line\">                 * 并且封装成一个Response对象</div><div class=\"line\">                 */</div><div class=\"line\">                Response&lt;?&gt; response = request.parseNetworkResponse(networkResponse);</div><div class=\"line\">                request.addMarker(&quot;network-parse-complete&quot;);</div><div class=\"line\"></div><div class=\"line\">                /** Write to cache if applicable.</div><div class=\"line\">                 *  如果符合要求，能写入缓存的话，就写到缓存里面</div><div class=\"line\">                 */</div><div class=\"line\">                // TODO: Only update cache metadata instead of entire record for 304s.</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * 在这里看到作者的TODO了，还能改进的地方就是在出现了返回码是</div><div class=\"line\">                 * 304的情况时，只更新缓存中的元数据(也就是response的主体)</div><div class=\"line\">                 * 而不是整个cache的记录下来,有些重复的数据可以不用理会.</div><div class=\"line\">                 */</div><div class=\"line\">                if (request.shouldCache() &amp;&amp; response.cacheEntry != null) &#123;</div><div class=\"line\">                    mCache.put(request.getCacheKey(), response.cacheEntry);</div><div class=\"line\">                    request.addMarker(&quot;network-cache-written&quot;);</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * 将Request.java中的变量mResponseDelivered置成true</div><div class=\"line\">                 * 标志着这个request的结果已经传回给了caller</div><div class=\"line\">                 */</div><div class=\"line\"></div><div class=\"line\">                request.markDelivered();</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * 通过ResponseDelivery的接口将包装好了的Response返回给调用者</div><div class=\"line\">                 */</div><div class=\"line\">                mDelivery.postResponse(request, response);</div><div class=\"line\"></div><div class=\"line\">            &#125; catch (VolleyError volleyError) &#123;</div><div class=\"line\">                /**</div><div class=\"line\">                 * 设置了request从队列中取出到服务器出现异常反应</div><div class=\"line\">                 * 所花费的时间</div><div class=\"line\">                 */</div><div class=\"line\">                volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * 将网络请求的错误通过ResponseDelivery传递给调用者</div><div class=\"line\">                 * 告诉它这.....不幸的一切</div><div class=\"line\">                 */</div><div class=\"line\">                parseAndDeliverNetworkError(request, volleyError);</div><div class=\"line\"></div><div class=\"line\">            &#125; catch (Exception e) &#123;</div><div class=\"line\">                VolleyLog.e(e, &quot;Unhandled exception %s&quot;, e.toString());</div><div class=\"line\">                VolleyError volleyError = new VolleyError(e);</div><div class=\"line\">                volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);</div><div class=\"line\">                mDelivery.postError(request, volleyError);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    private void parseAndDeliverNetworkError(Request&lt;?&gt; request, VolleyError error) &#123;</div><div class=\"line\">        error = request.parseNetworkError(error);</div><div class=\"line\">        mDelivery.postError(request, error);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当时看完了CacheDispatcher.java之后，再看NetworkDispatcher.java的时候，就会觉得这两个类非常的相似，run()函数里面的东西有些都差不多，都是进行一个死循环，从阻塞队列里面取出request，针对不同的情况做出不同的处理。</p>\n<p>从Volley.java暴露给外部的api开始，一直到现在，已经慢慢的了解了Volley中有一个RequestQueue对象，所有的request都在里面排着队等待被处理，RequestQueue里面还有一个CacheDispatcher和几个NetworkDispatcher,分别负责着不同种类的request。接下来要介绍的就是Volley中<code>Network.java</code>接口以及其默认实现类<code>BasicNetwork.java</code>,还有涉及缓存读写的接口<code>Cache.java</code>以及其默认实现类<code>DiskBasedCache.java</code>。</p>"},{"title":"Volley框架解析(二)Volley以及RequestQueue解析","date":"2017-02-28T08:43:26.000Z","_content":"\n## Volley框架解析(二)-----Volley及RequestQueue解析\n\n\n### [](#u9898_u5916_u8BDD_28_u53EF_u76F4_u63A5_u65E0_u89C6_u8DF3_u8FC7 \"题外话(可直接无视跳过\")题外话(可直接无视跳过\n\n是第一次比较完整的去阅读一个框架的源码，刚开始看的时候可以说是除了认识几个基本的`public, interface, final`等关键词之外，其他的一律不通orz，而且还不知道从哪里下手。后来磨蹭了好久还是慢慢的静下心来，对照着Java文档和Android文档查阅，刚开始都是陌生的，慢慢的在源码旁边打上注释，多看两遍就会get了。\n\n有些地方在一个.java文件里面是无法理解用处的，这样的先直接跳过不要纠结，看到对应用的地方就会恍然大悟了。还总结出了一个小技巧就是从框架暴露给外面的接口开始阅读，因为框架里面是一层一层往上的，底层是为了上层服务的，所以从接口开始阅读能很好的向下展开。\n\n前面一篇对Volley做了一个初步的介绍以及从整体上的一个解析，只是简单的描述了Request在Volley中是如何被处理的。从这篇博客开始将从最顶层一步一步的向下挖掘每一行代码，从最开始调用的地方`RequestQueue mQueue = Volley.newRequestQueue(mContext)`开始。\n\n<!--more-->\n\n***\n\n### [](#1-_Volley-java \"1\\. Volley.java\")1\\. Volley.java\n\nVolley.java是Volley整个框架对外暴露的接口，里面有四个重载的同名静态函数，方便直接使用。下面结合源代码来分析，主要是代码里面的注释。\n\n```\n\n    package com.android.volley.toolbox;\n\n\timport android.content.Context;\n\timport android.content.pm.PackageInfo;\n\timport android.content.pm.PackageManager.NameNotFoundException;\n\timport android.net.http.AndroidHttpClient;\n\timport android.os.Build;\n\n\timport com.android.volley.Network;\n\timport com.android.volley.RequestQueue;\n\n\timport java.io.File;\n\n\tpublic class Volley {\n\n\t    /** Default on-disk cache directory. */\n\t    private static final String DEFAULT_CACHE_DIR = \"volley\";\n\n\t    /**\n\t     * Creates a default instance of the worker pool and calls {@link RequestQueue#start()} on it.\n\t     * You may set a maximum size of the disk cache in bytes.\n\t     * 创建一个默认的线程池，并将其启动\n\t     * 还能通过构造函数来设置缓存的最大容量，默认的是5*1024*1024个字节\n\t     *\n\t     * @param context A {@link Context} to use for creating the cache dir.\n\t     * 用于创建缓存目录的context\n\t     * @param stack An {@link HttpStack} to use for the network, or null for default.\n\t     * HttpStack可以通过外面自定义之后传入，也可以不管直接用默认的\n\t     * @param maxDiskCacheBytes the maximum size of the disk cache, in bytes. Use -1 for default size.\n\t     * 最大缓存的字节数\n\t     * @return A started {@link RequestQueue} instance.\n\t     */\n\t    public static RequestQueue newRequestQueue(Context context, HttpStack stack, int maxDiskCacheBytes) {\n\n\t    \t//通过context，创建用于缓存文件的目录\n\t        File cacheDir = new File(context.getCacheDir(), DEFAULT_CACHE_DIR);\n\n\t        String userAgent = \"volley/0\";\n\n\t        try {\n\t            String packageName = context.getPackageName();\n\n\t            /**\n\t             * 关于PackageInfo，官方文档的解释如下：\n\t             * Overall information about the contents of a package.\n\t             * This corresponds to all of the information collected from AndroidManifest.xml.\n\t             * 该类作为Package信息的基类，还有很多子类例如：ApplicationInfo、 ComponentInfo等。\n\t             * 这些类包含了一些关于安装包的信息，icon,label等\n\t             */\n\t            PackageInfo info = context.getPackageManager().getPackageInfo(packageName, 0);\n\t            //获取到了Package的版本号\n\t            userAgent = packageName + \"/\" + info.versionCode;\n\n\t        } catch (NameNotFoundException e) {\n\t        }\n\n\t        /**\n\t         * HttpStack是一个用于网络请求的接口\n\t         * 如果传入的stack为空，则根据当前系统的版本号，来选择不同的实现了HttpStack(Volley自己的一个接口)的类对象\n\t         * 高于android2.3就用HurlStack(实现了HttpStack接口，基于HttpsURLConnection)\n\t         * 低于android2.3就用HttpClientStack(实现了HttpStack接口，基于HttpClient)\n\t         */\n\t        if (stack == null) {\n\t            if (Build.VERSION.SDK_INT >= 9) {\n\t                stack = new HurlStack();\n\t            } else {\n\t                // Prior to Gingerbread, HttpUrlConnection was unreliable.\n\t                // See: http://android-developers.blogspot.com/2011/09/androids-http-clients.html\n\t                stack = new HttpClientStack(AndroidHttpClient.newInstance(userAgent));\n\t            }\n\t        }\n\n\t        /**\n\t         * 创建了一个用于发送特定请求的Network类对象\n\t         * 该接口中有一个与HttpStack接口中同名的方法(performRequest)\n\t         * 但是参数的内容不同， 返回的类型也有所区别\n\t         * Network的返回类型是自定义的一个NetworkResponse类\n\t         * 而HttpStack返回的是HttpResponse\n\t         * (HttpResponse是java.apache.http中的一个类，里面包含了服务器返回的一些数据)\n\t         * \n\t         * 将stack传入到了已经实现了Network接口的一个BasicNetwork类中\n\t         * 在后面发送Request请求的时候会调用Network.performRequest()\n\t         * 然后在Network.performRequest()函数中会继续调用HttpStack.performRequest()\n\t         * 真正的网络请求发出是在HttpStack.performRequest()中进行的\n\t         */\n\n\t        Network network = new BasicNetwork(stack);\n\n\t        /**\n\t         * 创建一个RequestQueue引用\n\t         * RequestQueue是volley实现的一个请求调度队列\n\t         * 用来分发处理request\n\t         * 后面会分析RequestQueue.java\n\t         */\n\t        RequestQueue queue;\n\n\t        /**\n\t         * 根据是否设置了最大缓存字节数\n\t         * 来用不同的构造器生成RequestQueue对象\n\t         * 其中第一个构造参数为一个实现了Cache.java接口的默认缓存读写类DiskBasedCache.java\n\t         * 现在只需要知道它是用来专门处理缓存的就可以了，后面也会对源码做出分析\n\t         * 第二个参数是接口Network.java类的引用，在上面两排不远处可以看到BasicNetwork.java\n\t         * 它是用来实现网络请求的一个类。\n\t         */\n```\n\n简单的说，Volley.java的用处就只有一个，创建并启动一个RequestQueue对象，可以有四个构造器供我们选择，可以通过继承其接口衍生出自己的一套网络请求部分的实现(继承HttpStack接口),还可以定义缓存大小的限制。对于框架的使用者来说自由度还是很大的，不是固定死只能通过默认实现来使用Volley,提供接口能使框架的灵活性大大提升，在自己写代码的过程中也要注意这个问题。\n\n* * *\n\n###2. RequestQueue.java\nRequestQueue可以说是Volley中最核心的部分了，所有的request都要从这边进来，等待工作线程的调度，调度完成之后从里面的ResponseDelivery返回给caller。下面是RequestQueue.java的所有代码以及每行代码的用途，读了几遍才弄清楚了这个东西的作用，之前都迷糊的不行orz。\n\n```\n\n    package com.android.volley;\n\n\timport android.os.Handler;\n\timport android.os.Looper;\n\n\timport java.util.ArrayList;\n\timport java.util.HashMap;\n\timport java.util.HashSet;\n\timport java.util.LinkedList;\n\timport java.util.List;\n\timport java.util.Map;\n\timport java.util.Queue;\n\timport java.util.Set;\n\timport java.util.concurrent.PriorityBlockingQueue;\n\timport java.util.concurrent.atomic.AtomicInteger;\n\n\t/**\n\t * A request dispatch queue with a thread pool of dispatchers.\n\t * \n\t *\n\t * Calling {@link #add(Request)} will enqueue the given Request for dispatch,\n\t * resolving from either cache or network on a worker thread, and then delivering\n\t * a parsed response on the main thread.\n\t * 调用mQueue.add(Request)函数将一个request放入请求调度队列中排队，将在工作线程中，\n\t * 从网络或者缓存两个方面对request进行分类并处理，将response返回给主线程中。\n\t */\n\tpublic class RequestQueue {\n\n\t    /** \n\t     * Callback interface for completed requests. \n\t     * request完成之后的回掉接口\n\t     * 其中的T用到了java的泛型，是Request调用者所期待返回的数据类型\n\t     * 例如String或者是Integer\n\t     */\n\t    public static interface RequestFinishedListener {\n\t        /**\n\t         * Called when a request has finished processing. \n\t         * 当一个Request被处理完成时来调用\n\t         * = =其实从方法的名字来看也能看出来\n\t         */\n\t        public void onRequestFinished(Request request);\n\t    }\n\n\t    /**\n\t     * Used for generating monotonically-increasing sequence numbers for requests. \n\t     * 用来为request生成单调递增的有序数字，刚才是不知道这里是干什么用的= =\n\t     * 在这里纠结了一小段时间就继续看了下去，直到在add()函数里面看到了这个的用处\n\t     * 在request被add()进来的时候会给每个request发一个类似于排队的序号一样的数字，就是用这个类来实现的\n\t     * \n\t     * 官方的解释是：An int value that may be updated atomically. \n\t     * An AtomicInteger is used in applications such as atomically incremented counters, and cannot be used as a replacement for an Integer.\n\t     * However, this class does extend Number to allow uniform access by tools and utilities that deal with numerically-based classes.\n\t     * 这个类是在需要自动递增计数器的应用中使用的，但是不能作为一个Integer的替代品。\n\t     * 但是这个类确实是继承自Number类的，其允许处理数字的一些工具来统一访问= =。。\n\t     */\n\t    private AtomicInteger mSequenceGenerator = new AtomicInteger();\n\n\t    /**\n\t     * Staging area for requests that already have a duplicate request in flight.\n\t     * 用HashMap来形成一个筹备区域，这个筹备区域是为重复的request准备的。\n\t     * 每个对应的cacheKey都有一个Queue来存储，因为相同的请求有时不止一个。\n\t     * 这些重复的request已经有一个在被处理了，其他的不用重复处理，在这个HashMap里面等着拿结果就可以了\n\t     * \n\t     *     containsKey(cacheKey) indicates that there is a request in flight for the given cache\n\t     *          key.\n\t     *         用containsKey(String cacheKey)可以判定一个已经发送出去的请求是否有重复的请求。\n\t     *     \n\t     *     get(cacheKey) returns waiting requests for the given cache key. The in flight request\n\t     *          is not contained in that list. Is null if no requests are staged.\n\t     *         get()方法会返回一个queue，这个queue有可能是空的，也有可能里面存放着具有相同cacheKey的一系列request\n\t     * \n\t     */\n\t    private final Map>> mWaitingRequests =\n\t            new HashMap>>();\n\n\t    /**\n\t     * The set of all requests currently being processed by this RequestQueue. A Request\n\t     * will be in this set if it is waiting in any queue or currently being processed by\n\t     * any dispatcher.\n\t     *\n\t     * 一个容纳着所有request的HashSet。\n\t     * 如果一个request正在被调度或者正处于等待状态，该request就在这个集合之中。\n\t     * 这么说的话，RequestQueue里面主要存储request的集合就是这个了。\n\t     * 在外面调用add(Request request)的时候，也就是加入到了这个HashSet之中。\n\t     */\n\t    private final Set> mCurrentRequests = new HashSet>();\n\n\t    /** \n\t     * The cache triage queue. \n\t     * 运用到了优先队列\n\t     * 也就是里面的每个元素都会有一个优先级，优先级高的比优先级低的要先调度。\n\t     * 这个队列里面存放着需要访问缓存的一些Request，等待着调度器(dispatcher)的处理\n\t     * 后面慢慢的会介绍到dispatcher\n\t     */\n\t    private final PriorityBlockingQueue> mCacheQueue =\n\t        new PriorityBlockingQueue>();\n\n\t    /** \n\t     * The queue of requests that are actually going out to the network.\n\t     * 网络请求队列\n\t     * 要通过网络在服务器上请求数据的request\n\t     * 还包括一些缓存出了点小问题的request也会被加入到这里\n\t     * 在后面的代码中能够看到\n\t     */\n\t    private final PriorityBlockingQueue> mNetworkQueue =\n\t        new PriorityBlockingQueue>();\n\n\t    /** \n\t     * Number of network request dispatcher threads to start. \n\t     * 网络请求调度线程池中线程的默认数量。\n\t     */\n\t    private static final int DEFAULT_NETWORK_THREAD_POOL_SIZE = 4;\n\n\t    /** \n\t     * Cache interface for retrieving and storing responses. \n\t     * 缓存的接口，用来从缓存中取出response或者存储response到缓存中。\n\t     */\n\t    private final Cache mCache;\n\n\t    /** \n\t     * Network interface for performing requests. \n\t     * 网络接口，用来进行网络请求。\n\t     */\n\t    private final Network mNetwork;\n\n\t    /**\n\t     * Response delivery mechanism. \n\t     * 响应交付机制\n\t     * 请求最后的结果(Response.java实例)通过mDelivery中的方法传回\n\t     * 这个过程需要在工作线程中才能看到，也就是在介绍dispatcher里面能看到\n\t     */\n\t    private final ResponseDelivery mDelivery;\n\n\t    /**\n\t     * The network dispatchers. \n\t     * 网络调度线程池\n\t     * 因为是涉及到网络的一个框架，工作的效率不能低\n\t     * 多开几个网络调度器线程来一起工作\n\t     */\n\t    private NetworkDispatcher[] mDispatchers;\n\n\t    /** \n\t     * The cache dispatcher. \n\t     * 缓存调度线程(和上面的差不多吧= =，但是不是线程池了)\n\t     * 处理了涉及到缓存的request\n\t     */\n\t    private CacheDispatcher mCacheDispatcher;\n\n\t    /**\n\t     * 这个貌似是和listener差不多的用处\n\t     * 每个request结束之后，就会通知所有已经注册过的listener(所谓注册无非就是实现了RequestFinishedListener.java这个接口\n\t     * 然后再将自己传入，加入到这个ArrayList里面来)\n\t     * 在{@link #finish()}里面会用到这个ArrayList\n\t     */\n\t    private List mFinishedListeners =\n\t            new ArrayList();\n\n\t    /**\n\t     * Creates the worker pool. Processing will not begin until {@link #start()} is called.\n\t     * 创建工作线程，在start()调用之后开始不停的工作\n\t     *\n\t     * @param cache A Cache to use for persisting responses to disk\n\t     * 涉及到内存访问的接口\n\t     * @param network A Network interface for performing HTTP requests\n\t     * 用来进行HTTP请求的网络接口\n\t     * @param threadPoolSize Number of network dispatcher threads to create\n\t     * 网络请求线程池，里面放着很多个线程，可以同时处理多个需要网络访问的request\n\t     * @param delivery A ResponseDelivery interface for posting responses and errors\n\t     * 一个用来传递resposne和error的接口\n\t     */\n\t    public RequestQueue(Cache cache, Network network, int threadPoolSize,\n\t            ResponseDelivery delivery) {\n\t        mCache = cache;\n\t        mNetwork = network;\n\t        mDispatchers = new NetworkDispatcher[threadPoolSize];\n\t        mDelivery = delivery;\n\t    }\n\n\t    /**\n\t     * Creates the worker pool. Processing will not begin until {@link #start()} is called.\n\t     *\n\t     * @param cache A Cache to use for persisting responses to disk\n\t     * @param network A Network interface for performing HTTP requests\n\t     * @param threadPoolSize Number of network dispatcher threads to create\n\t     */\n\t    public RequestQueue(Cache cache, Network network, int threadPoolSize) {\n\t        this(cache, network, threadPoolSize,\n\t                new ExecutorDelivery(new Handler(Looper.getMainLooper())));\n\t    }\n\n\t    /**\n\t     * Creates the worker pool. Processing will not begin until {@link #start()} is called.\n\t     *\n\t     * @param cache A Cache to use for persisting responses to disk\n\t     * @param network A Network interface for performing HTTP requests\n\t     */\n\t    public RequestQueue(Cache cache, Network network) {\n\t        this(cache, network, DEFAULT_NETWORK_THREAD_POOL_SIZE);\n\t    }\n\n\t    /**\n\t     * Starts the dispatchers in this queue.\n\t     * 先将所有的调度线程都停止\n\t     * 再重新创建并启动\n\t     * 将mNetworkQueue和mCacheQueue传入到dispatcher中\n\t     * 方便从queue中取出request来进行处理\n\t     * 将mDelivery接口传入，方便将请求结果返回\n\t     * \n\t     * cacheDispatcher创建一个就够了，networkDispatcher创建了多个\n\t     * network花费时间比较长，需要开多个线程来工作\n\t     */\n\t    public void start() {\n\t        stop();  // Make sure any currently running dispatchers are stopped.\n\t        // Create the cache dispatcher and start it.\n\t        mCacheDispatcher = new CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);\n\t        mCacheDispatcher.start();\n\n\t        // Create network dispatchers (and corresponding threads) up to the pool size.\n\t        for (int i = 0; i < mDispatchers.length; i++) {\n\t            NetworkDispatcher networkDispatcher = new NetworkDispatcher(mNetworkQueue, mNetwork,\n\t                    mCache, mDelivery);\n\t            mDispatchers[i] = networkDispatcher;\n\t            networkDispatcher.start();\n\t        }\n\t    }\n\n\t    /**\n\t     * Stops the cache and network dispatchers.\n\t     * 将所有正在工作状态的dispatcher挨个退出\n\t     */\n\t    public void stop() {\n\t        if (mCacheDispatcher != null) {\n\t            mCacheDispatcher.quit();\n\t        }\n\t        for (int i = 0; i < mDispatchers.length; i++) {\n\t            if (mDispatchers[i] != null) {\n\t                mDispatchers[i].quit();\n\t            }\n\t        }\n\t    }\n\n\t    /**\n\t     * Gets a sequence number.\n\t     *\n\t     * incrementAndGet() : Atomically increments by one the current value.\n\t     * 自动向上涨一个单位然后返回当前值\n\t     * 在后面的{@link RequestQueue#add(Request)}函数中能看到这个的作用\n\t     * 用到了在前面提到过的AtomicInteger类\n\t     */\n\t    public int getSequenceNumber() {\n\t        return mSequenceGenerator.incrementAndGet();\n\t    }\n\n\t    /**\n\t     * Gets the {@link Cache} instance being used.\n\t     * 返回当前正在使用的cache引用\n\t     */\n\t    public Cache getCache() {\n\t        return mCache;\n\t    }\n\n\t    /**\n\t     * A simple predicate or filter interface for Requests, for use by\n\t     * {@link RequestQueue#cancelAll(RequestFilter)}.\n\t     * 一个request的过滤器\n\t     * 上面说是给cancelAll用的，应该是设置一个RequestFilter之后\n\t     * 将一类的request全都取消掉，至于具体的规则就需要重写里面的函数\n\t     * 定义规则了\n\t     */\n\t    public interface RequestFilter {\n\t        public boolean apply(Request request);\n\t    }\n\n\t    /**\n\t     * Cancels all requests in this queue for which the given filter applies.\n\t     * 从外面传入一个RequestFilter\n\t     * 按照传入的规则取消所有符合规则的request\n\t     * @param filter The filtering function to use\n\t     */\n\t    public void cancelAll(RequestFilter filter) {\n\t        synchronized (mCurrentRequests) {\n\t            for (Request request : mCurrentRequests) {\n\t                if (filter.apply(request)) {\n\t                    request.cancel();\n\t                }\n\t            }\n\t        }\n\t    }\n\n\t    /**\n\t     * Cancels all requests in this queue with the given tag. Tag must be non-null\n\t     * 依据request上面的tag来取消\n\t     * and equality is by identity.\n\t     */\n\t    public void cancelAll(final Object tag) {\n\t        if (tag == null) {\n\t            throw new IllegalArgumentException(\"Cannot cancelAll with a null tag\");\n\t        }\n\t        cancelAll(new RequestFilter() {\n\t            @Override\n\t            public boolean apply(Request request) {\n\t                return request.getTag() == tag;\n\t            }\n\t        });\n\t    }\n\n\t    /**\n\t     * Adds a Request to the dispatch queue.\n\t     * 将新的request加入到总的等待队列中去\n\t     * 一个request被处理之前都要待的地方\n\t     * mCurrentRequests里面存放着所有的request \n\t     *\n\t     * @param request The request to service\n\t     * 被传入的request，等待被处理\n\t     * @return The passed-in request\n\t     * 将加入的request返回回去\n\t     */\n\t    public  Request add(Request request) {\n\t        // Tag the request as belonging to this queue and add it to the set of current requests.\n\t        request.setRequestQueue(this);\n\n\t        /**\n\t         * 在向mCurrentRequest中添加request的时候\n\t         * 锁住不允许其他的线程进行访问操作\n\t         * 对于synchronized:可用来给对象和方法或者代码块加锁，\n\t         * 当它锁定一个方法或者一个代码块的时候，同一时刻最多只有一个线程执行这段代码。\n\t         * 当两个并发线程访问同一个对象object中的这个加锁同步代码块时，一个时间内只能有一个线程得到执行。\n\t         * 另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。\n\t         * \n\t         */\n\t        synchronized (mCurrentRequests) {\n\t            mCurrentRequests.add(request);\n\t        }\n\n\t        /**\n\t         * Process requests in the order they are added.\n\t         * 在加入到mCurrentQueue中排队的时候\n\t         * 就像我们排队一样会给我们一个对应的号码牌\n\t         * 只是这里用了getSequenceNumber()函数来自动的发放号码牌\n\t         */\n\t        request.setSequence(getSequenceNumber());\n\t        request.addMarker(\"add-to-queue\");\n\n\t        /** \n\t         * If the request is uncacheable, skip the cache queue and go straight to the network.\n\t         * 检查这个request是否是不可缓存的\n\t         * 也就是这个request所返回的response是否需要缓存下来\n\t         */\n\t        if (!request.shouldCache()) {\n\n\t            /**\n\t             * 如果不需要缓存的话\n\t             * 直接将这个request加入到网络队列中去\n\t             * 并且返回该request\n\t             */\n\t            mNetworkQueue.add(request);\n\t            return request;\n\t        }\n\n\t        /**\n\t         * Insert request into stage if there's already a request with the same cache key in flight.\n\t         * = =尼玛我这是什么记性，看见这个mWaittingRequests居然不认识了\n\t         * 向前翻到变量声明的地方，清清楚楚的写着专门存放重复请求的地方\n\t         * 根据需要缓存的request生成的特殊标记cacheKey\n\t         * 当然不涉及到缓存的request在上面几行代码被过滤处理了\n\t         */\n\t        synchronized (mWaitingRequests) {\n\n\t            /**\n\t             * 先获取到这个request的cacheKey\n\t             * 看看有没有和它相同的request已经处于天上飞的状态了\n\t             * (我觉得这里的in flight应该说的是已经发送过了的)\n\t             * 在后面会说明\n\t             */\n\t            String cacheKey = request.getCacheKey();\n\n\t            if (mWaitingRequests.containsKey(cacheKey)) {\n\n\t                /**\n\t                 * There is already a request in flight. Queue up.\n\t                 * 如果在等待的队列里面存在着cacheKey对应的一个Queue\n\t                 * 则说明在这个request之前，已经有相同的request发送出去过了\n\t                 * 那么现在需要做的就是将这个request加入到cacheKey对应的Queue存起来\n\t                 * 如果对应的Queue是null,就自己创建一个新的，再把request放入\n\t                 * \n\t                 * 这个request就不再会被放入到mCacheQueue中去了\n\t                 * 就是坐等数据的意思= =\n\t                 */\n\t                Queue> stagedRequests = mWaitingRequests.get(cacheKey);\n\t                if (stagedRequests == null) {\n\t                    stagedRequests = new LinkedList>();\n\t                }\n\t                stagedRequests.add(request);\n\t                mWaitingRequests.put(cacheKey, stagedRequests);\n\t                if (VolleyLog.DEBUG) {\n\t                    VolleyLog.v(\"Request for cacheKey=%s is in flight, putting on hold.\", cacheKey);\n\t                }\n\t            } else {\n\t                /**\n\t                 * Insert 'null' queue for this cacheKey, indicating there is now a request in flight.\n\t                 * 如果这个涉及到cache的request在它之前根本就没有和他相同的request\n\t                 * 直接以这个cacheKey为key，放一个null进去\n\t                 * 表示这是第一个么= =\n\t                 * 搞不懂为什么要这个样子设计，为什么不直接新建一个Queue进去呢\n\t                 */\n\t                mWaitingRequests.put(cacheKey, null);\n\t                mCacheQueue.add(request);\n\t            }\n\t            return request;\n\t        }\n\t    }\n\n\t    /**\n\t     * Called from {@link Request#finish(String)}, indicating that processing of the given request\n\t     * has finished.\n\t     * 从Request中的finish()方法调用开始，预示着给出的request已经结束\n\t     * Releases waiting requests for request.getCacheKey() if\n\t     *      request.shouldCache().\n\t     * 将处于mWaittingQueue中具有相同cacheKey的一组request全部释放\n\t     * 也就是把上面那些坐等数据的request全部取出来，response发送回去\n\t     */\n\t     void finish(Request request) {\n\t        // Remove from the set of requests currently being processed.\n\t        /**\n\t         * 将mCurrentRequests锁住\n\t         * 一个时间段内只有一个线程可以访问该对象\n\t         * 将已经结束的request从队列中移除\n\t         */\n\t        synchronized (mCurrentRequests) {\n\t            mCurrentRequests.remove(request);\n\t        }\n\n\t        /**\n\t         * 通知所有注册过的监听器\n\t         * 告诉它们，request已经finish了\n\t         */\n\t        synchronized (mFinishedListeners) {\n\t          for (RequestFinishedListener listener : mFinishedListeners) {\n\t            listener.onRequestFinished(request);\n\t          }\n\t        }\n\n\t        /**\n\t         * 如果该request涉及到需要缓存\n\t         * 则将mWaitingRequests中具有相同cacheKey的request\n\t         * 全部取出放入到缓存队列中等待CacheDispatcher的调度\n\t         */\n\t        if (request.shouldCache()) {\n\t            synchronized (mWaitingRequests) {\n\t                String cacheKey = request.getCacheKey();\n\t                Queue> waitingRequests = mWaitingRequests.remove(cacheKey);\n\t                if (waitingRequests != null) {\n\t                    if (VolleyLog.DEBUG) {\n\t                        VolleyLog.v(\"Releasing %d waiting requests for cacheKey=%s.\",\n\t                                waitingRequests.size(), cacheKey);\n\t                    }\n\t                    // Process all queued up requests. They won't be considered as in flight, but\n\t                    // that's not a problem as the cache has been primed by 'request'.\n\t                    mCacheQueue.addAll(waitingRequests);\n\t                }\n\t            }\n\t        }\n\t    }\n\n\t    /**\n\t     * 下面两个方法就是所谓注册监听器和取消注册的函数\n\t     */\n\t    public   void addRequestFinishedListener(RequestFinishedListener listener) {\n\t      synchronized (mFinishedListeners) {\n\t        mFinishedListeners.add(listener);\n\t      }\n\t    }\n\n\t    /**\n\t     * Remove a RequestFinishedListener. Has no effect if listener was not previously added.\n\t     */\n\t    public   void removeRequestFinishedListener(RequestFinishedListener listener) {\n\t      synchronized (mFinishedListeners) {\n\t        mFinishedListeners.remove(listener);\n\t      }\n\t    }\n\t}\n\n```\n\n上面介绍了Volley.java和RequestQueue.java两大类，Volley是对外的入口，而RequestQueue是Volley框架中最核心的部分了。如果注释上面有写错了或者有疑问的地方，还请各位直接指出在下一篇博客中将继续向下深入，结合源代码分析什么是Dispatcher。","source":"_posts/Volley框架解析-二-Volley以及RequestQueue解析.md","raw":"---\ntitle: Volley框架解析(二)Volley以及RequestQueue解析\ndate: 2017-02-28 16:43:26\ntags: volley\n\n---\n\n## Volley框架解析(二)-----Volley及RequestQueue解析\n\n\n### [](#u9898_u5916_u8BDD_28_u53EF_u76F4_u63A5_u65E0_u89C6_u8DF3_u8FC7 \"题外话(可直接无视跳过\")题外话(可直接无视跳过\n\n是第一次比较完整的去阅读一个框架的源码，刚开始看的时候可以说是除了认识几个基本的`public, interface, final`等关键词之外，其他的一律不通orz，而且还不知道从哪里下手。后来磨蹭了好久还是慢慢的静下心来，对照着Java文档和Android文档查阅，刚开始都是陌生的，慢慢的在源码旁边打上注释，多看两遍就会get了。\n\n有些地方在一个.java文件里面是无法理解用处的，这样的先直接跳过不要纠结，看到对应用的地方就会恍然大悟了。还总结出了一个小技巧就是从框架暴露给外面的接口开始阅读，因为框架里面是一层一层往上的，底层是为了上层服务的，所以从接口开始阅读能很好的向下展开。\n\n前面一篇对Volley做了一个初步的介绍以及从整体上的一个解析，只是简单的描述了Request在Volley中是如何被处理的。从这篇博客开始将从最顶层一步一步的向下挖掘每一行代码，从最开始调用的地方`RequestQueue mQueue = Volley.newRequestQueue(mContext)`开始。\n\n<!--more-->\n\n***\n\n### [](#1-_Volley-java \"1\\. Volley.java\")1\\. Volley.java\n\nVolley.java是Volley整个框架对外暴露的接口，里面有四个重载的同名静态函数，方便直接使用。下面结合源代码来分析，主要是代码里面的注释。\n\n```\n\n    package com.android.volley.toolbox;\n\n\timport android.content.Context;\n\timport android.content.pm.PackageInfo;\n\timport android.content.pm.PackageManager.NameNotFoundException;\n\timport android.net.http.AndroidHttpClient;\n\timport android.os.Build;\n\n\timport com.android.volley.Network;\n\timport com.android.volley.RequestQueue;\n\n\timport java.io.File;\n\n\tpublic class Volley {\n\n\t    /** Default on-disk cache directory. */\n\t    private static final String DEFAULT_CACHE_DIR = \"volley\";\n\n\t    /**\n\t     * Creates a default instance of the worker pool and calls {@link RequestQueue#start()} on it.\n\t     * You may set a maximum size of the disk cache in bytes.\n\t     * 创建一个默认的线程池，并将其启动\n\t     * 还能通过构造函数来设置缓存的最大容量，默认的是5*1024*1024个字节\n\t     *\n\t     * @param context A {@link Context} to use for creating the cache dir.\n\t     * 用于创建缓存目录的context\n\t     * @param stack An {@link HttpStack} to use for the network, or null for default.\n\t     * HttpStack可以通过外面自定义之后传入，也可以不管直接用默认的\n\t     * @param maxDiskCacheBytes the maximum size of the disk cache, in bytes. Use -1 for default size.\n\t     * 最大缓存的字节数\n\t     * @return A started {@link RequestQueue} instance.\n\t     */\n\t    public static RequestQueue newRequestQueue(Context context, HttpStack stack, int maxDiskCacheBytes) {\n\n\t    \t//通过context，创建用于缓存文件的目录\n\t        File cacheDir = new File(context.getCacheDir(), DEFAULT_CACHE_DIR);\n\n\t        String userAgent = \"volley/0\";\n\n\t        try {\n\t            String packageName = context.getPackageName();\n\n\t            /**\n\t             * 关于PackageInfo，官方文档的解释如下：\n\t             * Overall information about the contents of a package.\n\t             * This corresponds to all of the information collected from AndroidManifest.xml.\n\t             * 该类作为Package信息的基类，还有很多子类例如：ApplicationInfo、 ComponentInfo等。\n\t             * 这些类包含了一些关于安装包的信息，icon,label等\n\t             */\n\t            PackageInfo info = context.getPackageManager().getPackageInfo(packageName, 0);\n\t            //获取到了Package的版本号\n\t            userAgent = packageName + \"/\" + info.versionCode;\n\n\t        } catch (NameNotFoundException e) {\n\t        }\n\n\t        /**\n\t         * HttpStack是一个用于网络请求的接口\n\t         * 如果传入的stack为空，则根据当前系统的版本号，来选择不同的实现了HttpStack(Volley自己的一个接口)的类对象\n\t         * 高于android2.3就用HurlStack(实现了HttpStack接口，基于HttpsURLConnection)\n\t         * 低于android2.3就用HttpClientStack(实现了HttpStack接口，基于HttpClient)\n\t         */\n\t        if (stack == null) {\n\t            if (Build.VERSION.SDK_INT >= 9) {\n\t                stack = new HurlStack();\n\t            } else {\n\t                // Prior to Gingerbread, HttpUrlConnection was unreliable.\n\t                // See: http://android-developers.blogspot.com/2011/09/androids-http-clients.html\n\t                stack = new HttpClientStack(AndroidHttpClient.newInstance(userAgent));\n\t            }\n\t        }\n\n\t        /**\n\t         * 创建了一个用于发送特定请求的Network类对象\n\t         * 该接口中有一个与HttpStack接口中同名的方法(performRequest)\n\t         * 但是参数的内容不同， 返回的类型也有所区别\n\t         * Network的返回类型是自定义的一个NetworkResponse类\n\t         * 而HttpStack返回的是HttpResponse\n\t         * (HttpResponse是java.apache.http中的一个类，里面包含了服务器返回的一些数据)\n\t         * \n\t         * 将stack传入到了已经实现了Network接口的一个BasicNetwork类中\n\t         * 在后面发送Request请求的时候会调用Network.performRequest()\n\t         * 然后在Network.performRequest()函数中会继续调用HttpStack.performRequest()\n\t         * 真正的网络请求发出是在HttpStack.performRequest()中进行的\n\t         */\n\n\t        Network network = new BasicNetwork(stack);\n\n\t        /**\n\t         * 创建一个RequestQueue引用\n\t         * RequestQueue是volley实现的一个请求调度队列\n\t         * 用来分发处理request\n\t         * 后面会分析RequestQueue.java\n\t         */\n\t        RequestQueue queue;\n\n\t        /**\n\t         * 根据是否设置了最大缓存字节数\n\t         * 来用不同的构造器生成RequestQueue对象\n\t         * 其中第一个构造参数为一个实现了Cache.java接口的默认缓存读写类DiskBasedCache.java\n\t         * 现在只需要知道它是用来专门处理缓存的就可以了，后面也会对源码做出分析\n\t         * 第二个参数是接口Network.java类的引用，在上面两排不远处可以看到BasicNetwork.java\n\t         * 它是用来实现网络请求的一个类。\n\t         */\n```\n\n简单的说，Volley.java的用处就只有一个，创建并启动一个RequestQueue对象，可以有四个构造器供我们选择，可以通过继承其接口衍生出自己的一套网络请求部分的实现(继承HttpStack接口),还可以定义缓存大小的限制。对于框架的使用者来说自由度还是很大的，不是固定死只能通过默认实现来使用Volley,提供接口能使框架的灵活性大大提升，在自己写代码的过程中也要注意这个问题。\n\n* * *\n\n###2. RequestQueue.java\nRequestQueue可以说是Volley中最核心的部分了，所有的request都要从这边进来，等待工作线程的调度，调度完成之后从里面的ResponseDelivery返回给caller。下面是RequestQueue.java的所有代码以及每行代码的用途，读了几遍才弄清楚了这个东西的作用，之前都迷糊的不行orz。\n\n```\n\n    package com.android.volley;\n\n\timport android.os.Handler;\n\timport android.os.Looper;\n\n\timport java.util.ArrayList;\n\timport java.util.HashMap;\n\timport java.util.HashSet;\n\timport java.util.LinkedList;\n\timport java.util.List;\n\timport java.util.Map;\n\timport java.util.Queue;\n\timport java.util.Set;\n\timport java.util.concurrent.PriorityBlockingQueue;\n\timport java.util.concurrent.atomic.AtomicInteger;\n\n\t/**\n\t * A request dispatch queue with a thread pool of dispatchers.\n\t * \n\t *\n\t * Calling {@link #add(Request)} will enqueue the given Request for dispatch,\n\t * resolving from either cache or network on a worker thread, and then delivering\n\t * a parsed response on the main thread.\n\t * 调用mQueue.add(Request)函数将一个request放入请求调度队列中排队，将在工作线程中，\n\t * 从网络或者缓存两个方面对request进行分类并处理，将response返回给主线程中。\n\t */\n\tpublic class RequestQueue {\n\n\t    /** \n\t     * Callback interface for completed requests. \n\t     * request完成之后的回掉接口\n\t     * 其中的T用到了java的泛型，是Request调用者所期待返回的数据类型\n\t     * 例如String或者是Integer\n\t     */\n\t    public static interface RequestFinishedListener {\n\t        /**\n\t         * Called when a request has finished processing. \n\t         * 当一个Request被处理完成时来调用\n\t         * = =其实从方法的名字来看也能看出来\n\t         */\n\t        public void onRequestFinished(Request request);\n\t    }\n\n\t    /**\n\t     * Used for generating monotonically-increasing sequence numbers for requests. \n\t     * 用来为request生成单调递增的有序数字，刚才是不知道这里是干什么用的= =\n\t     * 在这里纠结了一小段时间就继续看了下去，直到在add()函数里面看到了这个的用处\n\t     * 在request被add()进来的时候会给每个request发一个类似于排队的序号一样的数字，就是用这个类来实现的\n\t     * \n\t     * 官方的解释是：An int value that may be updated atomically. \n\t     * An AtomicInteger is used in applications such as atomically incremented counters, and cannot be used as a replacement for an Integer.\n\t     * However, this class does extend Number to allow uniform access by tools and utilities that deal with numerically-based classes.\n\t     * 这个类是在需要自动递增计数器的应用中使用的，但是不能作为一个Integer的替代品。\n\t     * 但是这个类确实是继承自Number类的，其允许处理数字的一些工具来统一访问= =。。\n\t     */\n\t    private AtomicInteger mSequenceGenerator = new AtomicInteger();\n\n\t    /**\n\t     * Staging area for requests that already have a duplicate request in flight.\n\t     * 用HashMap来形成一个筹备区域，这个筹备区域是为重复的request准备的。\n\t     * 每个对应的cacheKey都有一个Queue来存储，因为相同的请求有时不止一个。\n\t     * 这些重复的request已经有一个在被处理了，其他的不用重复处理，在这个HashMap里面等着拿结果就可以了\n\t     * \n\t     *     containsKey(cacheKey) indicates that there is a request in flight for the given cache\n\t     *          key.\n\t     *         用containsKey(String cacheKey)可以判定一个已经发送出去的请求是否有重复的请求。\n\t     *     \n\t     *     get(cacheKey) returns waiting requests for the given cache key. The in flight request\n\t     *          is not contained in that list. Is null if no requests are staged.\n\t     *         get()方法会返回一个queue，这个queue有可能是空的，也有可能里面存放着具有相同cacheKey的一系列request\n\t     * \n\t     */\n\t    private final Map>> mWaitingRequests =\n\t            new HashMap>>();\n\n\t    /**\n\t     * The set of all requests currently being processed by this RequestQueue. A Request\n\t     * will be in this set if it is waiting in any queue or currently being processed by\n\t     * any dispatcher.\n\t     *\n\t     * 一个容纳着所有request的HashSet。\n\t     * 如果一个request正在被调度或者正处于等待状态，该request就在这个集合之中。\n\t     * 这么说的话，RequestQueue里面主要存储request的集合就是这个了。\n\t     * 在外面调用add(Request request)的时候，也就是加入到了这个HashSet之中。\n\t     */\n\t    private final Set> mCurrentRequests = new HashSet>();\n\n\t    /** \n\t     * The cache triage queue. \n\t     * 运用到了优先队列\n\t     * 也就是里面的每个元素都会有一个优先级，优先级高的比优先级低的要先调度。\n\t     * 这个队列里面存放着需要访问缓存的一些Request，等待着调度器(dispatcher)的处理\n\t     * 后面慢慢的会介绍到dispatcher\n\t     */\n\t    private final PriorityBlockingQueue> mCacheQueue =\n\t        new PriorityBlockingQueue>();\n\n\t    /** \n\t     * The queue of requests that are actually going out to the network.\n\t     * 网络请求队列\n\t     * 要通过网络在服务器上请求数据的request\n\t     * 还包括一些缓存出了点小问题的request也会被加入到这里\n\t     * 在后面的代码中能够看到\n\t     */\n\t    private final PriorityBlockingQueue> mNetworkQueue =\n\t        new PriorityBlockingQueue>();\n\n\t    /** \n\t     * Number of network request dispatcher threads to start. \n\t     * 网络请求调度线程池中线程的默认数量。\n\t     */\n\t    private static final int DEFAULT_NETWORK_THREAD_POOL_SIZE = 4;\n\n\t    /** \n\t     * Cache interface for retrieving and storing responses. \n\t     * 缓存的接口，用来从缓存中取出response或者存储response到缓存中。\n\t     */\n\t    private final Cache mCache;\n\n\t    /** \n\t     * Network interface for performing requests. \n\t     * 网络接口，用来进行网络请求。\n\t     */\n\t    private final Network mNetwork;\n\n\t    /**\n\t     * Response delivery mechanism. \n\t     * 响应交付机制\n\t     * 请求最后的结果(Response.java实例)通过mDelivery中的方法传回\n\t     * 这个过程需要在工作线程中才能看到，也就是在介绍dispatcher里面能看到\n\t     */\n\t    private final ResponseDelivery mDelivery;\n\n\t    /**\n\t     * The network dispatchers. \n\t     * 网络调度线程池\n\t     * 因为是涉及到网络的一个框架，工作的效率不能低\n\t     * 多开几个网络调度器线程来一起工作\n\t     */\n\t    private NetworkDispatcher[] mDispatchers;\n\n\t    /** \n\t     * The cache dispatcher. \n\t     * 缓存调度线程(和上面的差不多吧= =，但是不是线程池了)\n\t     * 处理了涉及到缓存的request\n\t     */\n\t    private CacheDispatcher mCacheDispatcher;\n\n\t    /**\n\t     * 这个貌似是和listener差不多的用处\n\t     * 每个request结束之后，就会通知所有已经注册过的listener(所谓注册无非就是实现了RequestFinishedListener.java这个接口\n\t     * 然后再将自己传入，加入到这个ArrayList里面来)\n\t     * 在{@link #finish()}里面会用到这个ArrayList\n\t     */\n\t    private List mFinishedListeners =\n\t            new ArrayList();\n\n\t    /**\n\t     * Creates the worker pool. Processing will not begin until {@link #start()} is called.\n\t     * 创建工作线程，在start()调用之后开始不停的工作\n\t     *\n\t     * @param cache A Cache to use for persisting responses to disk\n\t     * 涉及到内存访问的接口\n\t     * @param network A Network interface for performing HTTP requests\n\t     * 用来进行HTTP请求的网络接口\n\t     * @param threadPoolSize Number of network dispatcher threads to create\n\t     * 网络请求线程池，里面放着很多个线程，可以同时处理多个需要网络访问的request\n\t     * @param delivery A ResponseDelivery interface for posting responses and errors\n\t     * 一个用来传递resposne和error的接口\n\t     */\n\t    public RequestQueue(Cache cache, Network network, int threadPoolSize,\n\t            ResponseDelivery delivery) {\n\t        mCache = cache;\n\t        mNetwork = network;\n\t        mDispatchers = new NetworkDispatcher[threadPoolSize];\n\t        mDelivery = delivery;\n\t    }\n\n\t    /**\n\t     * Creates the worker pool. Processing will not begin until {@link #start()} is called.\n\t     *\n\t     * @param cache A Cache to use for persisting responses to disk\n\t     * @param network A Network interface for performing HTTP requests\n\t     * @param threadPoolSize Number of network dispatcher threads to create\n\t     */\n\t    public RequestQueue(Cache cache, Network network, int threadPoolSize) {\n\t        this(cache, network, threadPoolSize,\n\t                new ExecutorDelivery(new Handler(Looper.getMainLooper())));\n\t    }\n\n\t    /**\n\t     * Creates the worker pool. Processing will not begin until {@link #start()} is called.\n\t     *\n\t     * @param cache A Cache to use for persisting responses to disk\n\t     * @param network A Network interface for performing HTTP requests\n\t     */\n\t    public RequestQueue(Cache cache, Network network) {\n\t        this(cache, network, DEFAULT_NETWORK_THREAD_POOL_SIZE);\n\t    }\n\n\t    /**\n\t     * Starts the dispatchers in this queue.\n\t     * 先将所有的调度线程都停止\n\t     * 再重新创建并启动\n\t     * 将mNetworkQueue和mCacheQueue传入到dispatcher中\n\t     * 方便从queue中取出request来进行处理\n\t     * 将mDelivery接口传入，方便将请求结果返回\n\t     * \n\t     * cacheDispatcher创建一个就够了，networkDispatcher创建了多个\n\t     * network花费时间比较长，需要开多个线程来工作\n\t     */\n\t    public void start() {\n\t        stop();  // Make sure any currently running dispatchers are stopped.\n\t        // Create the cache dispatcher and start it.\n\t        mCacheDispatcher = new CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);\n\t        mCacheDispatcher.start();\n\n\t        // Create network dispatchers (and corresponding threads) up to the pool size.\n\t        for (int i = 0; i < mDispatchers.length; i++) {\n\t            NetworkDispatcher networkDispatcher = new NetworkDispatcher(mNetworkQueue, mNetwork,\n\t                    mCache, mDelivery);\n\t            mDispatchers[i] = networkDispatcher;\n\t            networkDispatcher.start();\n\t        }\n\t    }\n\n\t    /**\n\t     * Stops the cache and network dispatchers.\n\t     * 将所有正在工作状态的dispatcher挨个退出\n\t     */\n\t    public void stop() {\n\t        if (mCacheDispatcher != null) {\n\t            mCacheDispatcher.quit();\n\t        }\n\t        for (int i = 0; i < mDispatchers.length; i++) {\n\t            if (mDispatchers[i] != null) {\n\t                mDispatchers[i].quit();\n\t            }\n\t        }\n\t    }\n\n\t    /**\n\t     * Gets a sequence number.\n\t     *\n\t     * incrementAndGet() : Atomically increments by one the current value.\n\t     * 自动向上涨一个单位然后返回当前值\n\t     * 在后面的{@link RequestQueue#add(Request)}函数中能看到这个的作用\n\t     * 用到了在前面提到过的AtomicInteger类\n\t     */\n\t    public int getSequenceNumber() {\n\t        return mSequenceGenerator.incrementAndGet();\n\t    }\n\n\t    /**\n\t     * Gets the {@link Cache} instance being used.\n\t     * 返回当前正在使用的cache引用\n\t     */\n\t    public Cache getCache() {\n\t        return mCache;\n\t    }\n\n\t    /**\n\t     * A simple predicate or filter interface for Requests, for use by\n\t     * {@link RequestQueue#cancelAll(RequestFilter)}.\n\t     * 一个request的过滤器\n\t     * 上面说是给cancelAll用的，应该是设置一个RequestFilter之后\n\t     * 将一类的request全都取消掉，至于具体的规则就需要重写里面的函数\n\t     * 定义规则了\n\t     */\n\t    public interface RequestFilter {\n\t        public boolean apply(Request request);\n\t    }\n\n\t    /**\n\t     * Cancels all requests in this queue for which the given filter applies.\n\t     * 从外面传入一个RequestFilter\n\t     * 按照传入的规则取消所有符合规则的request\n\t     * @param filter The filtering function to use\n\t     */\n\t    public void cancelAll(RequestFilter filter) {\n\t        synchronized (mCurrentRequests) {\n\t            for (Request request : mCurrentRequests) {\n\t                if (filter.apply(request)) {\n\t                    request.cancel();\n\t                }\n\t            }\n\t        }\n\t    }\n\n\t    /**\n\t     * Cancels all requests in this queue with the given tag. Tag must be non-null\n\t     * 依据request上面的tag来取消\n\t     * and equality is by identity.\n\t     */\n\t    public void cancelAll(final Object tag) {\n\t        if (tag == null) {\n\t            throw new IllegalArgumentException(\"Cannot cancelAll with a null tag\");\n\t        }\n\t        cancelAll(new RequestFilter() {\n\t            @Override\n\t            public boolean apply(Request request) {\n\t                return request.getTag() == tag;\n\t            }\n\t        });\n\t    }\n\n\t    /**\n\t     * Adds a Request to the dispatch queue.\n\t     * 将新的request加入到总的等待队列中去\n\t     * 一个request被处理之前都要待的地方\n\t     * mCurrentRequests里面存放着所有的request \n\t     *\n\t     * @param request The request to service\n\t     * 被传入的request，等待被处理\n\t     * @return The passed-in request\n\t     * 将加入的request返回回去\n\t     */\n\t    public  Request add(Request request) {\n\t        // Tag the request as belonging to this queue and add it to the set of current requests.\n\t        request.setRequestQueue(this);\n\n\t        /**\n\t         * 在向mCurrentRequest中添加request的时候\n\t         * 锁住不允许其他的线程进行访问操作\n\t         * 对于synchronized:可用来给对象和方法或者代码块加锁，\n\t         * 当它锁定一个方法或者一个代码块的时候，同一时刻最多只有一个线程执行这段代码。\n\t         * 当两个并发线程访问同一个对象object中的这个加锁同步代码块时，一个时间内只能有一个线程得到执行。\n\t         * 另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。\n\t         * \n\t         */\n\t        synchronized (mCurrentRequests) {\n\t            mCurrentRequests.add(request);\n\t        }\n\n\t        /**\n\t         * Process requests in the order they are added.\n\t         * 在加入到mCurrentQueue中排队的时候\n\t         * 就像我们排队一样会给我们一个对应的号码牌\n\t         * 只是这里用了getSequenceNumber()函数来自动的发放号码牌\n\t         */\n\t        request.setSequence(getSequenceNumber());\n\t        request.addMarker(\"add-to-queue\");\n\n\t        /** \n\t         * If the request is uncacheable, skip the cache queue and go straight to the network.\n\t         * 检查这个request是否是不可缓存的\n\t         * 也就是这个request所返回的response是否需要缓存下来\n\t         */\n\t        if (!request.shouldCache()) {\n\n\t            /**\n\t             * 如果不需要缓存的话\n\t             * 直接将这个request加入到网络队列中去\n\t             * 并且返回该request\n\t             */\n\t            mNetworkQueue.add(request);\n\t            return request;\n\t        }\n\n\t        /**\n\t         * Insert request into stage if there's already a request with the same cache key in flight.\n\t         * = =尼玛我这是什么记性，看见这个mWaittingRequests居然不认识了\n\t         * 向前翻到变量声明的地方，清清楚楚的写着专门存放重复请求的地方\n\t         * 根据需要缓存的request生成的特殊标记cacheKey\n\t         * 当然不涉及到缓存的request在上面几行代码被过滤处理了\n\t         */\n\t        synchronized (mWaitingRequests) {\n\n\t            /**\n\t             * 先获取到这个request的cacheKey\n\t             * 看看有没有和它相同的request已经处于天上飞的状态了\n\t             * (我觉得这里的in flight应该说的是已经发送过了的)\n\t             * 在后面会说明\n\t             */\n\t            String cacheKey = request.getCacheKey();\n\n\t            if (mWaitingRequests.containsKey(cacheKey)) {\n\n\t                /**\n\t                 * There is already a request in flight. Queue up.\n\t                 * 如果在等待的队列里面存在着cacheKey对应的一个Queue\n\t                 * 则说明在这个request之前，已经有相同的request发送出去过了\n\t                 * 那么现在需要做的就是将这个request加入到cacheKey对应的Queue存起来\n\t                 * 如果对应的Queue是null,就自己创建一个新的，再把request放入\n\t                 * \n\t                 * 这个request就不再会被放入到mCacheQueue中去了\n\t                 * 就是坐等数据的意思= =\n\t                 */\n\t                Queue> stagedRequests = mWaitingRequests.get(cacheKey);\n\t                if (stagedRequests == null) {\n\t                    stagedRequests = new LinkedList>();\n\t                }\n\t                stagedRequests.add(request);\n\t                mWaitingRequests.put(cacheKey, stagedRequests);\n\t                if (VolleyLog.DEBUG) {\n\t                    VolleyLog.v(\"Request for cacheKey=%s is in flight, putting on hold.\", cacheKey);\n\t                }\n\t            } else {\n\t                /**\n\t                 * Insert 'null' queue for this cacheKey, indicating there is now a request in flight.\n\t                 * 如果这个涉及到cache的request在它之前根本就没有和他相同的request\n\t                 * 直接以这个cacheKey为key，放一个null进去\n\t                 * 表示这是第一个么= =\n\t                 * 搞不懂为什么要这个样子设计，为什么不直接新建一个Queue进去呢\n\t                 */\n\t                mWaitingRequests.put(cacheKey, null);\n\t                mCacheQueue.add(request);\n\t            }\n\t            return request;\n\t        }\n\t    }\n\n\t    /**\n\t     * Called from {@link Request#finish(String)}, indicating that processing of the given request\n\t     * has finished.\n\t     * 从Request中的finish()方法调用开始，预示着给出的request已经结束\n\t     * Releases waiting requests for request.getCacheKey() if\n\t     *      request.shouldCache().\n\t     * 将处于mWaittingQueue中具有相同cacheKey的一组request全部释放\n\t     * 也就是把上面那些坐等数据的request全部取出来，response发送回去\n\t     */\n\t     void finish(Request request) {\n\t        // Remove from the set of requests currently being processed.\n\t        /**\n\t         * 将mCurrentRequests锁住\n\t         * 一个时间段内只有一个线程可以访问该对象\n\t         * 将已经结束的request从队列中移除\n\t         */\n\t        synchronized (mCurrentRequests) {\n\t            mCurrentRequests.remove(request);\n\t        }\n\n\t        /**\n\t         * 通知所有注册过的监听器\n\t         * 告诉它们，request已经finish了\n\t         */\n\t        synchronized (mFinishedListeners) {\n\t          for (RequestFinishedListener listener : mFinishedListeners) {\n\t            listener.onRequestFinished(request);\n\t          }\n\t        }\n\n\t        /**\n\t         * 如果该request涉及到需要缓存\n\t         * 则将mWaitingRequests中具有相同cacheKey的request\n\t         * 全部取出放入到缓存队列中等待CacheDispatcher的调度\n\t         */\n\t        if (request.shouldCache()) {\n\t            synchronized (mWaitingRequests) {\n\t                String cacheKey = request.getCacheKey();\n\t                Queue> waitingRequests = mWaitingRequests.remove(cacheKey);\n\t                if (waitingRequests != null) {\n\t                    if (VolleyLog.DEBUG) {\n\t                        VolleyLog.v(\"Releasing %d waiting requests for cacheKey=%s.\",\n\t                                waitingRequests.size(), cacheKey);\n\t                    }\n\t                    // Process all queued up requests. They won't be considered as in flight, but\n\t                    // that's not a problem as the cache has been primed by 'request'.\n\t                    mCacheQueue.addAll(waitingRequests);\n\t                }\n\t            }\n\t        }\n\t    }\n\n\t    /**\n\t     * 下面两个方法就是所谓注册监听器和取消注册的函数\n\t     */\n\t    public   void addRequestFinishedListener(RequestFinishedListener listener) {\n\t      synchronized (mFinishedListeners) {\n\t        mFinishedListeners.add(listener);\n\t      }\n\t    }\n\n\t    /**\n\t     * Remove a RequestFinishedListener. Has no effect if listener was not previously added.\n\t     */\n\t    public   void removeRequestFinishedListener(RequestFinishedListener listener) {\n\t      synchronized (mFinishedListeners) {\n\t        mFinishedListeners.remove(listener);\n\t      }\n\t    }\n\t}\n\n```\n\n上面介绍了Volley.java和RequestQueue.java两大类，Volley是对外的入口，而RequestQueue是Volley框架中最核心的部分了。如果注释上面有写错了或者有疑问的地方，还请各位直接指出在下一篇博客中将继续向下深入，结合源代码分析什么是Dispatcher。","slug":"Volley框架解析-二-Volley以及RequestQueue解析","published":1,"updated":"2017-03-21T06:38:09.107Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0xtcupn000ak2j97hwwjm7n","content":"<h2 id=\"Volley框架解析-二-—–Volley及RequestQueue解析\"><a href=\"#Volley框架解析-二-—–Volley及RequestQueue解析\" class=\"headerlink\" title=\"Volley框架解析(二)—–Volley及RequestQueue解析\"></a>Volley框架解析(二)—–Volley及RequestQueue解析</h2><h3 id=\"题外话-可直接无视跳过\"><a href=\"#题外话-可直接无视跳过\" class=\"headerlink\" title=\"题外话(可直接无视跳过\"></a><a href=\"#u9898_u5916_u8BDD_28_u53EF_u76F4_u63A5_u65E0_u89C6_u8DF3_u8FC7\" title=\"题外话(可直接无视跳过\"></a>题外话(可直接无视跳过</h3><p>是第一次比较完整的去阅读一个框架的源码，刚开始看的时候可以说是除了认识几个基本的<code>public, interface, final</code>等关键词之外，其他的一律不通orz，而且还不知道从哪里下手。后来磨蹭了好久还是慢慢的静下心来，对照着Java文档和Android文档查阅，刚开始都是陌生的，慢慢的在源码旁边打上注释，多看两遍就会get了。</p>\n<p>有些地方在一个.java文件里面是无法理解用处的，这样的先直接跳过不要纠结，看到对应用的地方就会恍然大悟了。还总结出了一个小技巧就是从框架暴露给外面的接口开始阅读，因为框架里面是一层一层往上的，底层是为了上层服务的，所以从接口开始阅读能很好的向下展开。</p>\n<p>前面一篇对Volley做了一个初步的介绍以及从整体上的一个解析，只是简单的描述了Request在Volley中是如何被处理的。从这篇博客开始将从最顶层一步一步的向下挖掘每一行代码，从最开始调用的地方<code>RequestQueue mQueue = Volley.newRequestQueue(mContext)</code>开始。</p>\n<a id=\"more\"></a>\n<hr>\n<h3 id=\"1-Volley-java\"><a href=\"#1-Volley-java\" class=\"headerlink\" title=\"1. Volley.java\"></a><a href=\"#1-_Volley-java\" title=\"1\\. Volley.java\"></a>1. Volley.java</h3><p>Volley.java是Volley整个框架对外暴露的接口，里面有四个重载的同名静态函数，方便直接使用。下面结合源代码来分析，主要是代码里面的注释。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">   package com.android.volley.toolbox;</div><div class=\"line\"></div><div class=\"line\">import android.content.Context;</div><div class=\"line\">import android.content.pm.PackageInfo;</div><div class=\"line\">import android.content.pm.PackageManager.NameNotFoundException;</div><div class=\"line\">import android.net.http.AndroidHttpClient;</div><div class=\"line\">import android.os.Build;</div><div class=\"line\"></div><div class=\"line\">import com.android.volley.Network;</div><div class=\"line\">import com.android.volley.RequestQueue;</div><div class=\"line\"></div><div class=\"line\">import java.io.File;</div><div class=\"line\"></div><div class=\"line\">public class Volley &#123;</div><div class=\"line\"></div><div class=\"line\">    /** Default on-disk cache directory. */</div><div class=\"line\">    private static final String DEFAULT_CACHE_DIR = &quot;volley&quot;;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Creates a default instance of the worker pool and calls &#123;@link RequestQueue#start()&#125; on it.</div><div class=\"line\">     * You may set a maximum size of the disk cache in bytes.</div><div class=\"line\">     * 创建一个默认的线程池，并将其启动</div><div class=\"line\">     * 还能通过构造函数来设置缓存的最大容量，默认的是5*1024*1024个字节</div><div class=\"line\">     *</div><div class=\"line\">     * @param context A &#123;@link Context&#125; to use for creating the cache dir.</div><div class=\"line\">     * 用于创建缓存目录的context</div><div class=\"line\">     * @param stack An &#123;@link HttpStack&#125; to use for the network, or null for default.</div><div class=\"line\">     * HttpStack可以通过外面自定义之后传入，也可以不管直接用默认的</div><div class=\"line\">     * @param maxDiskCacheBytes the maximum size of the disk cache, in bytes. Use -1 for default size.</div><div class=\"line\">     * 最大缓存的字节数</div><div class=\"line\">     * @return A started &#123;@link RequestQueue&#125; instance.</div><div class=\"line\">     */</div><div class=\"line\">    public static RequestQueue newRequestQueue(Context context, HttpStack stack, int maxDiskCacheBytes) &#123;</div><div class=\"line\"></div><div class=\"line\">    \t//通过context，创建用于缓存文件的目录</div><div class=\"line\">        File cacheDir = new File(context.getCacheDir(), DEFAULT_CACHE_DIR);</div><div class=\"line\"></div><div class=\"line\">        String userAgent = &quot;volley/0&quot;;</div><div class=\"line\"></div><div class=\"line\">        try &#123;</div><div class=\"line\">            String packageName = context.getPackageName();</div><div class=\"line\"></div><div class=\"line\">            /**</div><div class=\"line\">             * 关于PackageInfo，官方文档的解释如下：</div><div class=\"line\">             * Overall information about the contents of a package.</div><div class=\"line\">             * This corresponds to all of the information collected from AndroidManifest.xml.</div><div class=\"line\">             * 该类作为Package信息的基类，还有很多子类例如：ApplicationInfo、 ComponentInfo等。</div><div class=\"line\">             * 这些类包含了一些关于安装包的信息，icon,label等</div><div class=\"line\">             */</div><div class=\"line\">            PackageInfo info = context.getPackageManager().getPackageInfo(packageName, 0);</div><div class=\"line\">            //获取到了Package的版本号</div><div class=\"line\">            userAgent = packageName + &quot;/&quot; + info.versionCode;</div><div class=\"line\"></div><div class=\"line\">        &#125; catch (NameNotFoundException e) &#123;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * HttpStack是一个用于网络请求的接口</div><div class=\"line\">         * 如果传入的stack为空，则根据当前系统的版本号，来选择不同的实现了HttpStack(Volley自己的一个接口)的类对象</div><div class=\"line\">         * 高于android2.3就用HurlStack(实现了HttpStack接口，基于HttpsURLConnection)</div><div class=\"line\">         * 低于android2.3就用HttpClientStack(实现了HttpStack接口，基于HttpClient)</div><div class=\"line\">         */</div><div class=\"line\">        if (stack == null) &#123;</div><div class=\"line\">            if (Build.VERSION.SDK_INT &gt;= 9) &#123;</div><div class=\"line\">                stack = new HurlStack();</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                // Prior to Gingerbread, HttpUrlConnection was unreliable.</div><div class=\"line\">                // See: http://android-developers.blogspot.com/2011/09/androids-http-clients.html</div><div class=\"line\">                stack = new HttpClientStack(AndroidHttpClient.newInstance(userAgent));</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * 创建了一个用于发送特定请求的Network类对象</div><div class=\"line\">         * 该接口中有一个与HttpStack接口中同名的方法(performRequest)</div><div class=\"line\">         * 但是参数的内容不同， 返回的类型也有所区别</div><div class=\"line\">         * Network的返回类型是自定义的一个NetworkResponse类</div><div class=\"line\">         * 而HttpStack返回的是HttpResponse</div><div class=\"line\">         * (HttpResponse是java.apache.http中的一个类，里面包含了服务器返回的一些数据)</div><div class=\"line\">         * </div><div class=\"line\">         * 将stack传入到了已经实现了Network接口的一个BasicNetwork类中</div><div class=\"line\">         * 在后面发送Request请求的时候会调用Network.performRequest()</div><div class=\"line\">         * 然后在Network.performRequest()函数中会继续调用HttpStack.performRequest()</div><div class=\"line\">         * 真正的网络请求发出是在HttpStack.performRequest()中进行的</div><div class=\"line\">         */</div><div class=\"line\"></div><div class=\"line\">        Network network = new BasicNetwork(stack);</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * 创建一个RequestQueue引用</div><div class=\"line\">         * RequestQueue是volley实现的一个请求调度队列</div><div class=\"line\">         * 用来分发处理request</div><div class=\"line\">         * 后面会分析RequestQueue.java</div><div class=\"line\">         */</div><div class=\"line\">        RequestQueue queue;</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * 根据是否设置了最大缓存字节数</div><div class=\"line\">         * 来用不同的构造器生成RequestQueue对象</div><div class=\"line\">         * 其中第一个构造参数为一个实现了Cache.java接口的默认缓存读写类DiskBasedCache.java</div><div class=\"line\">         * 现在只需要知道它是用来专门处理缓存的就可以了，后面也会对源码做出分析</div><div class=\"line\">         * 第二个参数是接口Network.java类的引用，在上面两排不远处可以看到BasicNetwork.java</div><div class=\"line\">         * 它是用来实现网络请求的一个类。</div><div class=\"line\">         */</div></pre></td></tr></table></figure>\n<p>简单的说，Volley.java的用处就只有一个，创建并启动一个RequestQueue对象，可以有四个构造器供我们选择，可以通过继承其接口衍生出自己的一套网络请求部分的实现(继承HttpStack接口),还可以定义缓存大小的限制。对于框架的使用者来说自由度还是很大的，不是固定死只能通过默认实现来使用Volley,提供接口能使框架的灵活性大大提升，在自己写代码的过程中也要注意这个问题。</p>\n<hr>\n<p>###2. RequestQueue.java<br>RequestQueue可以说是Volley中最核心的部分了，所有的request都要从这边进来，等待工作线程的调度，调度完成之后从里面的ResponseDelivery返回给caller。下面是RequestQueue.java的所有代码以及每行代码的用途，读了几遍才弄清楚了这个东西的作用，之前都迷糊的不行orz。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div><div class=\"line\">204</div><div class=\"line\">205</div><div class=\"line\">206</div><div class=\"line\">207</div><div class=\"line\">208</div><div class=\"line\">209</div><div class=\"line\">210</div><div class=\"line\">211</div><div class=\"line\">212</div><div class=\"line\">213</div><div class=\"line\">214</div><div class=\"line\">215</div><div class=\"line\">216</div><div class=\"line\">217</div><div class=\"line\">218</div><div class=\"line\">219</div><div class=\"line\">220</div><div class=\"line\">221</div><div class=\"line\">222</div><div class=\"line\">223</div><div class=\"line\">224</div><div class=\"line\">225</div><div class=\"line\">226</div><div class=\"line\">227</div><div class=\"line\">228</div><div class=\"line\">229</div><div class=\"line\">230</div><div class=\"line\">231</div><div class=\"line\">232</div><div class=\"line\">233</div><div class=\"line\">234</div><div class=\"line\">235</div><div class=\"line\">236</div><div class=\"line\">237</div><div class=\"line\">238</div><div class=\"line\">239</div><div class=\"line\">240</div><div class=\"line\">241</div><div class=\"line\">242</div><div class=\"line\">243</div><div class=\"line\">244</div><div class=\"line\">245</div><div class=\"line\">246</div><div class=\"line\">247</div><div class=\"line\">248</div><div class=\"line\">249</div><div class=\"line\">250</div><div class=\"line\">251</div><div class=\"line\">252</div><div class=\"line\">253</div><div class=\"line\">254</div><div class=\"line\">255</div><div class=\"line\">256</div><div class=\"line\">257</div><div class=\"line\">258</div><div class=\"line\">259</div><div class=\"line\">260</div><div class=\"line\">261</div><div class=\"line\">262</div><div class=\"line\">263</div><div class=\"line\">264</div><div class=\"line\">265</div><div class=\"line\">266</div><div class=\"line\">267</div><div class=\"line\">268</div><div class=\"line\">269</div><div class=\"line\">270</div><div class=\"line\">271</div><div class=\"line\">272</div><div class=\"line\">273</div><div class=\"line\">274</div><div class=\"line\">275</div><div class=\"line\">276</div><div class=\"line\">277</div><div class=\"line\">278</div><div class=\"line\">279</div><div class=\"line\">280</div><div class=\"line\">281</div><div class=\"line\">282</div><div class=\"line\">283</div><div class=\"line\">284</div><div class=\"line\">285</div><div class=\"line\">286</div><div class=\"line\">287</div><div class=\"line\">288</div><div class=\"line\">289</div><div class=\"line\">290</div><div class=\"line\">291</div><div class=\"line\">292</div><div class=\"line\">293</div><div class=\"line\">294</div><div class=\"line\">295</div><div class=\"line\">296</div><div class=\"line\">297</div><div class=\"line\">298</div><div class=\"line\">299</div><div class=\"line\">300</div><div class=\"line\">301</div><div class=\"line\">302</div><div class=\"line\">303</div><div class=\"line\">304</div><div class=\"line\">305</div><div class=\"line\">306</div><div class=\"line\">307</div><div class=\"line\">308</div><div class=\"line\">309</div><div class=\"line\">310</div><div class=\"line\">311</div><div class=\"line\">312</div><div class=\"line\">313</div><div class=\"line\">314</div><div class=\"line\">315</div><div class=\"line\">316</div><div class=\"line\">317</div><div class=\"line\">318</div><div class=\"line\">319</div><div class=\"line\">320</div><div class=\"line\">321</div><div class=\"line\">322</div><div class=\"line\">323</div><div class=\"line\">324</div><div class=\"line\">325</div><div class=\"line\">326</div><div class=\"line\">327</div><div class=\"line\">328</div><div class=\"line\">329</div><div class=\"line\">330</div><div class=\"line\">331</div><div class=\"line\">332</div><div class=\"line\">333</div><div class=\"line\">334</div><div class=\"line\">335</div><div class=\"line\">336</div><div class=\"line\">337</div><div class=\"line\">338</div><div class=\"line\">339</div><div class=\"line\">340</div><div class=\"line\">341</div><div class=\"line\">342</div><div class=\"line\">343</div><div class=\"line\">344</div><div class=\"line\">345</div><div class=\"line\">346</div><div class=\"line\">347</div><div class=\"line\">348</div><div class=\"line\">349</div><div class=\"line\">350</div><div class=\"line\">351</div><div class=\"line\">352</div><div class=\"line\">353</div><div class=\"line\">354</div><div class=\"line\">355</div><div class=\"line\">356</div><div class=\"line\">357</div><div class=\"line\">358</div><div class=\"line\">359</div><div class=\"line\">360</div><div class=\"line\">361</div><div class=\"line\">362</div><div class=\"line\">363</div><div class=\"line\">364</div><div class=\"line\">365</div><div class=\"line\">366</div><div class=\"line\">367</div><div class=\"line\">368</div><div class=\"line\">369</div><div class=\"line\">370</div><div class=\"line\">371</div><div class=\"line\">372</div><div class=\"line\">373</div><div class=\"line\">374</div><div class=\"line\">375</div><div class=\"line\">376</div><div class=\"line\">377</div><div class=\"line\">378</div><div class=\"line\">379</div><div class=\"line\">380</div><div class=\"line\">381</div><div class=\"line\">382</div><div class=\"line\">383</div><div class=\"line\">384</div><div class=\"line\">385</div><div class=\"line\">386</div><div class=\"line\">387</div><div class=\"line\">388</div><div class=\"line\">389</div><div class=\"line\">390</div><div class=\"line\">391</div><div class=\"line\">392</div><div class=\"line\">393</div><div class=\"line\">394</div><div class=\"line\">395</div><div class=\"line\">396</div><div class=\"line\">397</div><div class=\"line\">398</div><div class=\"line\">399</div><div class=\"line\">400</div><div class=\"line\">401</div><div class=\"line\">402</div><div class=\"line\">403</div><div class=\"line\">404</div><div class=\"line\">405</div><div class=\"line\">406</div><div class=\"line\">407</div><div class=\"line\">408</div><div class=\"line\">409</div><div class=\"line\">410</div><div class=\"line\">411</div><div class=\"line\">412</div><div class=\"line\">413</div><div class=\"line\">414</div><div class=\"line\">415</div><div class=\"line\">416</div><div class=\"line\">417</div><div class=\"line\">418</div><div class=\"line\">419</div><div class=\"line\">420</div><div class=\"line\">421</div><div class=\"line\">422</div><div class=\"line\">423</div><div class=\"line\">424</div><div class=\"line\">425</div><div class=\"line\">426</div><div class=\"line\">427</div><div class=\"line\">428</div><div class=\"line\">429</div><div class=\"line\">430</div><div class=\"line\">431</div><div class=\"line\">432</div><div class=\"line\">433</div><div class=\"line\">434</div><div class=\"line\">435</div><div class=\"line\">436</div><div class=\"line\">437</div><div class=\"line\">438</div><div class=\"line\">439</div><div class=\"line\">440</div><div class=\"line\">441</div><div class=\"line\">442</div><div class=\"line\">443</div><div class=\"line\">444</div><div class=\"line\">445</div><div class=\"line\">446</div><div class=\"line\">447</div><div class=\"line\">448</div><div class=\"line\">449</div><div class=\"line\">450</div><div class=\"line\">451</div><div class=\"line\">452</div><div class=\"line\">453</div><div class=\"line\">454</div><div class=\"line\">455</div><div class=\"line\">456</div><div class=\"line\">457</div><div class=\"line\">458</div><div class=\"line\">459</div><div class=\"line\">460</div><div class=\"line\">461</div><div class=\"line\">462</div><div class=\"line\">463</div><div class=\"line\">464</div><div class=\"line\">465</div><div class=\"line\">466</div><div class=\"line\">467</div><div class=\"line\">468</div><div class=\"line\">469</div><div class=\"line\">470</div><div class=\"line\">471</div><div class=\"line\">472</div><div class=\"line\">473</div><div class=\"line\">474</div><div class=\"line\">475</div><div class=\"line\">476</div><div class=\"line\">477</div><div class=\"line\">478</div><div class=\"line\">479</div><div class=\"line\">480</div><div class=\"line\">481</div><div class=\"line\">482</div><div class=\"line\">483</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">   package com.android.volley;</div><div class=\"line\"></div><div class=\"line\">import android.os.Handler;</div><div class=\"line\">import android.os.Looper;</div><div class=\"line\"></div><div class=\"line\">import java.util.ArrayList;</div><div class=\"line\">import java.util.HashMap;</div><div class=\"line\">import java.util.HashSet;</div><div class=\"line\">import java.util.LinkedList;</div><div class=\"line\">import java.util.List;</div><div class=\"line\">import java.util.Map;</div><div class=\"line\">import java.util.Queue;</div><div class=\"line\">import java.util.Set;</div><div class=\"line\">import java.util.concurrent.PriorityBlockingQueue;</div><div class=\"line\">import java.util.concurrent.atomic.AtomicInteger;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\"> * A request dispatch queue with a thread pool of dispatchers.</div><div class=\"line\"> * </div><div class=\"line\"> *</div><div class=\"line\"> * Calling &#123;@link #add(Request)&#125; will enqueue the given Request for dispatch,</div><div class=\"line\"> * resolving from either cache or network on a worker thread, and then delivering</div><div class=\"line\"> * a parsed response on the main thread.</div><div class=\"line\"> * 调用mQueue.add(Request)函数将一个request放入请求调度队列中排队，将在工作线程中，</div><div class=\"line\"> * 从网络或者缓存两个方面对request进行分类并处理，将response返回给主线程中。</div><div class=\"line\"> */</div><div class=\"line\">public class RequestQueue &#123;</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * Callback interface for completed requests. </div><div class=\"line\">     * request完成之后的回掉接口</div><div class=\"line\">     * 其中的T用到了java的泛型，是Request调用者所期待返回的数据类型</div><div class=\"line\">     * 例如String或者是Integer</div><div class=\"line\">     */</div><div class=\"line\">    public static interface RequestFinishedListener &#123;</div><div class=\"line\">        /**</div><div class=\"line\">         * Called when a request has finished processing. </div><div class=\"line\">         * 当一个Request被处理完成时来调用</div><div class=\"line\">         * = =其实从方法的名字来看也能看出来</div><div class=\"line\">         */</div><div class=\"line\">        public void onRequestFinished(Request request);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Used for generating monotonically-increasing sequence numbers for requests. </div><div class=\"line\">     * 用来为request生成单调递增的有序数字，刚才是不知道这里是干什么用的= =</div><div class=\"line\">     * 在这里纠结了一小段时间就继续看了下去，直到在add()函数里面看到了这个的用处</div><div class=\"line\">     * 在request被add()进来的时候会给每个request发一个类似于排队的序号一样的数字，就是用这个类来实现的</div><div class=\"line\">     * </div><div class=\"line\">     * 官方的解释是：An int value that may be updated atomically. </div><div class=\"line\">     * An AtomicInteger is used in applications such as atomically incremented counters, and cannot be used as a replacement for an Integer.</div><div class=\"line\">     * However, this class does extend Number to allow uniform access by tools and utilities that deal with numerically-based classes.</div><div class=\"line\">     * 这个类是在需要自动递增计数器的应用中使用的，但是不能作为一个Integer的替代品。</div><div class=\"line\">     * 但是这个类确实是继承自Number类的，其允许处理数字的一些工具来统一访问= =。。</div><div class=\"line\">     */</div><div class=\"line\">    private AtomicInteger mSequenceGenerator = new AtomicInteger();</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Staging area for requests that already have a duplicate request in flight.</div><div class=\"line\">     * 用HashMap来形成一个筹备区域，这个筹备区域是为重复的request准备的。</div><div class=\"line\">     * 每个对应的cacheKey都有一个Queue来存储，因为相同的请求有时不止一个。</div><div class=\"line\">     * 这些重复的request已经有一个在被处理了，其他的不用重复处理，在这个HashMap里面等着拿结果就可以了</div><div class=\"line\">     * </div><div class=\"line\">     *     containsKey(cacheKey) indicates that there is a request in flight for the given cache</div><div class=\"line\">     *          key.</div><div class=\"line\">     *         用containsKey(String cacheKey)可以判定一个已经发送出去的请求是否有重复的请求。</div><div class=\"line\">     *     </div><div class=\"line\">     *     get(cacheKey) returns waiting requests for the given cache key. The in flight request</div><div class=\"line\">     *          is not contained in that list. Is null if no requests are staged.</div><div class=\"line\">     *         get()方法会返回一个queue，这个queue有可能是空的，也有可能里面存放着具有相同cacheKey的一系列request</div><div class=\"line\">     * </div><div class=\"line\">     */</div><div class=\"line\">    private final Map&gt;&gt; mWaitingRequests =</div><div class=\"line\">            new HashMap&gt;&gt;();</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * The set of all requests currently being processed by this RequestQueue. A Request</div><div class=\"line\">     * will be in this set if it is waiting in any queue or currently being processed by</div><div class=\"line\">     * any dispatcher.</div><div class=\"line\">     *</div><div class=\"line\">     * 一个容纳着所有request的HashSet。</div><div class=\"line\">     * 如果一个request正在被调度或者正处于等待状态，该request就在这个集合之中。</div><div class=\"line\">     * 这么说的话，RequestQueue里面主要存储request的集合就是这个了。</div><div class=\"line\">     * 在外面调用add(Request request)的时候，也就是加入到了这个HashSet之中。</div><div class=\"line\">     */</div><div class=\"line\">    private final Set&gt; mCurrentRequests = new HashSet&gt;();</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * The cache triage queue. </div><div class=\"line\">     * 运用到了优先队列</div><div class=\"line\">     * 也就是里面的每个元素都会有一个优先级，优先级高的比优先级低的要先调度。</div><div class=\"line\">     * 这个队列里面存放着需要访问缓存的一些Request，等待着调度器(dispatcher)的处理</div><div class=\"line\">     * 后面慢慢的会介绍到dispatcher</div><div class=\"line\">     */</div><div class=\"line\">    private final PriorityBlockingQueue&gt; mCacheQueue =</div><div class=\"line\">        new PriorityBlockingQueue&gt;();</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * The queue of requests that are actually going out to the network.</div><div class=\"line\">     * 网络请求队列</div><div class=\"line\">     * 要通过网络在服务器上请求数据的request</div><div class=\"line\">     * 还包括一些缓存出了点小问题的request也会被加入到这里</div><div class=\"line\">     * 在后面的代码中能够看到</div><div class=\"line\">     */</div><div class=\"line\">    private final PriorityBlockingQueue&gt; mNetworkQueue =</div><div class=\"line\">        new PriorityBlockingQueue&gt;();</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * Number of network request dispatcher threads to start. </div><div class=\"line\">     * 网络请求调度线程池中线程的默认数量。</div><div class=\"line\">     */</div><div class=\"line\">    private static final int DEFAULT_NETWORK_THREAD_POOL_SIZE = 4;</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * Cache interface for retrieving and storing responses. </div><div class=\"line\">     * 缓存的接口，用来从缓存中取出response或者存储response到缓存中。</div><div class=\"line\">     */</div><div class=\"line\">    private final Cache mCache;</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * Network interface for performing requests. </div><div class=\"line\">     * 网络接口，用来进行网络请求。</div><div class=\"line\">     */</div><div class=\"line\">    private final Network mNetwork;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Response delivery mechanism. </div><div class=\"line\">     * 响应交付机制</div><div class=\"line\">     * 请求最后的结果(Response.java实例)通过mDelivery中的方法传回</div><div class=\"line\">     * 这个过程需要在工作线程中才能看到，也就是在介绍dispatcher里面能看到</div><div class=\"line\">     */</div><div class=\"line\">    private final ResponseDelivery mDelivery;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * The network dispatchers. </div><div class=\"line\">     * 网络调度线程池</div><div class=\"line\">     * 因为是涉及到网络的一个框架，工作的效率不能低</div><div class=\"line\">     * 多开几个网络调度器线程来一起工作</div><div class=\"line\">     */</div><div class=\"line\">    private NetworkDispatcher[] mDispatchers;</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * The cache dispatcher. </div><div class=\"line\">     * 缓存调度线程(和上面的差不多吧= =，但是不是线程池了)</div><div class=\"line\">     * 处理了涉及到缓存的request</div><div class=\"line\">     */</div><div class=\"line\">    private CacheDispatcher mCacheDispatcher;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * 这个貌似是和listener差不多的用处</div><div class=\"line\">     * 每个request结束之后，就会通知所有已经注册过的listener(所谓注册无非就是实现了RequestFinishedListener.java这个接口</div><div class=\"line\">     * 然后再将自己传入，加入到这个ArrayList里面来)</div><div class=\"line\">     * 在&#123;@link #finish()&#125;里面会用到这个ArrayList</div><div class=\"line\">     */</div><div class=\"line\">    private List mFinishedListeners =</div><div class=\"line\">            new ArrayList();</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Creates the worker pool. Processing will not begin until &#123;@link #start()&#125; is called.</div><div class=\"line\">     * 创建工作线程，在start()调用之后开始不停的工作</div><div class=\"line\">     *</div><div class=\"line\">     * @param cache A Cache to use for persisting responses to disk</div><div class=\"line\">     * 涉及到内存访问的接口</div><div class=\"line\">     * @param network A Network interface for performing HTTP requests</div><div class=\"line\">     * 用来进行HTTP请求的网络接口</div><div class=\"line\">     * @param threadPoolSize Number of network dispatcher threads to create</div><div class=\"line\">     * 网络请求线程池，里面放着很多个线程，可以同时处理多个需要网络访问的request</div><div class=\"line\">     * @param delivery A ResponseDelivery interface for posting responses and errors</div><div class=\"line\">     * 一个用来传递resposne和error的接口</div><div class=\"line\">     */</div><div class=\"line\">    public RequestQueue(Cache cache, Network network, int threadPoolSize,</div><div class=\"line\">            ResponseDelivery delivery) &#123;</div><div class=\"line\">        mCache = cache;</div><div class=\"line\">        mNetwork = network;</div><div class=\"line\">        mDispatchers = new NetworkDispatcher[threadPoolSize];</div><div class=\"line\">        mDelivery = delivery;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Creates the worker pool. Processing will not begin until &#123;@link #start()&#125; is called.</div><div class=\"line\">     *</div><div class=\"line\">     * @param cache A Cache to use for persisting responses to disk</div><div class=\"line\">     * @param network A Network interface for performing HTTP requests</div><div class=\"line\">     * @param threadPoolSize Number of network dispatcher threads to create</div><div class=\"line\">     */</div><div class=\"line\">    public RequestQueue(Cache cache, Network network, int threadPoolSize) &#123;</div><div class=\"line\">        this(cache, network, threadPoolSize,</div><div class=\"line\">                new ExecutorDelivery(new Handler(Looper.getMainLooper())));</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Creates the worker pool. Processing will not begin until &#123;@link #start()&#125; is called.</div><div class=\"line\">     *</div><div class=\"line\">     * @param cache A Cache to use for persisting responses to disk</div><div class=\"line\">     * @param network A Network interface for performing HTTP requests</div><div class=\"line\">     */</div><div class=\"line\">    public RequestQueue(Cache cache, Network network) &#123;</div><div class=\"line\">        this(cache, network, DEFAULT_NETWORK_THREAD_POOL_SIZE);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Starts the dispatchers in this queue.</div><div class=\"line\">     * 先将所有的调度线程都停止</div><div class=\"line\">     * 再重新创建并启动</div><div class=\"line\">     * 将mNetworkQueue和mCacheQueue传入到dispatcher中</div><div class=\"line\">     * 方便从queue中取出request来进行处理</div><div class=\"line\">     * 将mDelivery接口传入，方便将请求结果返回</div><div class=\"line\">     * </div><div class=\"line\">     * cacheDispatcher创建一个就够了，networkDispatcher创建了多个</div><div class=\"line\">     * network花费时间比较长，需要开多个线程来工作</div><div class=\"line\">     */</div><div class=\"line\">    public void start() &#123;</div><div class=\"line\">        stop();  // Make sure any currently running dispatchers are stopped.</div><div class=\"line\">        // Create the cache dispatcher and start it.</div><div class=\"line\">        mCacheDispatcher = new CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);</div><div class=\"line\">        mCacheDispatcher.start();</div><div class=\"line\"></div><div class=\"line\">        // Create network dispatchers (and corresponding threads) up to the pool size.</div><div class=\"line\">        for (int i = 0; i &lt; mDispatchers.length; i++) &#123;</div><div class=\"line\">            NetworkDispatcher networkDispatcher = new NetworkDispatcher(mNetworkQueue, mNetwork,</div><div class=\"line\">                    mCache, mDelivery);</div><div class=\"line\">            mDispatchers[i] = networkDispatcher;</div><div class=\"line\">            networkDispatcher.start();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Stops the cache and network dispatchers.</div><div class=\"line\">     * 将所有正在工作状态的dispatcher挨个退出</div><div class=\"line\">     */</div><div class=\"line\">    public void stop() &#123;</div><div class=\"line\">        if (mCacheDispatcher != null) &#123;</div><div class=\"line\">            mCacheDispatcher.quit();</div><div class=\"line\">        &#125;</div><div class=\"line\">        for (int i = 0; i &lt; mDispatchers.length; i++) &#123;</div><div class=\"line\">            if (mDispatchers[i] != null) &#123;</div><div class=\"line\">                mDispatchers[i].quit();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Gets a sequence number.</div><div class=\"line\">     *</div><div class=\"line\">     * incrementAndGet() : Atomically increments by one the current value.</div><div class=\"line\">     * 自动向上涨一个单位然后返回当前值</div><div class=\"line\">     * 在后面的&#123;@link RequestQueue#add(Request)&#125;函数中能看到这个的作用</div><div class=\"line\">     * 用到了在前面提到过的AtomicInteger类</div><div class=\"line\">     */</div><div class=\"line\">    public int getSequenceNumber() &#123;</div><div class=\"line\">        return mSequenceGenerator.incrementAndGet();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Gets the &#123;@link Cache&#125; instance being used.</div><div class=\"line\">     * 返回当前正在使用的cache引用</div><div class=\"line\">     */</div><div class=\"line\">    public Cache getCache() &#123;</div><div class=\"line\">        return mCache;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * A simple predicate or filter interface for Requests, for use by</div><div class=\"line\">     * &#123;@link RequestQueue#cancelAll(RequestFilter)&#125;.</div><div class=\"line\">     * 一个request的过滤器</div><div class=\"line\">     * 上面说是给cancelAll用的，应该是设置一个RequestFilter之后</div><div class=\"line\">     * 将一类的request全都取消掉，至于具体的规则就需要重写里面的函数</div><div class=\"line\">     * 定义规则了</div><div class=\"line\">     */</div><div class=\"line\">    public interface RequestFilter &#123;</div><div class=\"line\">        public boolean apply(Request request);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Cancels all requests in this queue for which the given filter applies.</div><div class=\"line\">     * 从外面传入一个RequestFilter</div><div class=\"line\">     * 按照传入的规则取消所有符合规则的request</div><div class=\"line\">     * @param filter The filtering function to use</div><div class=\"line\">     */</div><div class=\"line\">    public void cancelAll(RequestFilter filter) &#123;</div><div class=\"line\">        synchronized (mCurrentRequests) &#123;</div><div class=\"line\">            for (Request request : mCurrentRequests) &#123;</div><div class=\"line\">                if (filter.apply(request)) &#123;</div><div class=\"line\">                    request.cancel();</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Cancels all requests in this queue with the given tag. Tag must be non-null</div><div class=\"line\">     * 依据request上面的tag来取消</div><div class=\"line\">     * and equality is by identity.</div><div class=\"line\">     */</div><div class=\"line\">    public void cancelAll(final Object tag) &#123;</div><div class=\"line\">        if (tag == null) &#123;</div><div class=\"line\">            throw new IllegalArgumentException(&quot;Cannot cancelAll with a null tag&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        cancelAll(new RequestFilter() &#123;</div><div class=\"line\">            @Override</div><div class=\"line\">            public boolean apply(Request request) &#123;</div><div class=\"line\">                return request.getTag() == tag;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Adds a Request to the dispatch queue.</div><div class=\"line\">     * 将新的request加入到总的等待队列中去</div><div class=\"line\">     * 一个request被处理之前都要待的地方</div><div class=\"line\">     * mCurrentRequests里面存放着所有的request </div><div class=\"line\">     *</div><div class=\"line\">     * @param request The request to service</div><div class=\"line\">     * 被传入的request，等待被处理</div><div class=\"line\">     * @return The passed-in request</div><div class=\"line\">     * 将加入的request返回回去</div><div class=\"line\">     */</div><div class=\"line\">    public  Request add(Request request) &#123;</div><div class=\"line\">        // Tag the request as belonging to this queue and add it to the set of current requests.</div><div class=\"line\">        request.setRequestQueue(this);</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * 在向mCurrentRequest中添加request的时候</div><div class=\"line\">         * 锁住不允许其他的线程进行访问操作</div><div class=\"line\">         * 对于synchronized:可用来给对象和方法或者代码块加锁，</div><div class=\"line\">         * 当它锁定一个方法或者一个代码块的时候，同一时刻最多只有一个线程执行这段代码。</div><div class=\"line\">         * 当两个并发线程访问同一个对象object中的这个加锁同步代码块时，一个时间内只能有一个线程得到执行。</div><div class=\"line\">         * 另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。</div><div class=\"line\">         * </div><div class=\"line\">         */</div><div class=\"line\">        synchronized (mCurrentRequests) &#123;</div><div class=\"line\">            mCurrentRequests.add(request);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * Process requests in the order they are added.</div><div class=\"line\">         * 在加入到mCurrentQueue中排队的时候</div><div class=\"line\">         * 就像我们排队一样会给我们一个对应的号码牌</div><div class=\"line\">         * 只是这里用了getSequenceNumber()函数来自动的发放号码牌</div><div class=\"line\">         */</div><div class=\"line\">        request.setSequence(getSequenceNumber());</div><div class=\"line\">        request.addMarker(&quot;add-to-queue&quot;);</div><div class=\"line\"></div><div class=\"line\">        /** </div><div class=\"line\">         * If the request is uncacheable, skip the cache queue and go straight to the network.</div><div class=\"line\">         * 检查这个request是否是不可缓存的</div><div class=\"line\">         * 也就是这个request所返回的response是否需要缓存下来</div><div class=\"line\">         */</div><div class=\"line\">        if (!request.shouldCache()) &#123;</div><div class=\"line\"></div><div class=\"line\">            /**</div><div class=\"line\">             * 如果不需要缓存的话</div><div class=\"line\">             * 直接将这个request加入到网络队列中去</div><div class=\"line\">             * 并且返回该request</div><div class=\"line\">             */</div><div class=\"line\">            mNetworkQueue.add(request);</div><div class=\"line\">            return request;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * Insert request into stage if there&apos;s already a request with the same cache key in flight.</div><div class=\"line\">         * = =尼玛我这是什么记性，看见这个mWaittingRequests居然不认识了</div><div class=\"line\">         * 向前翻到变量声明的地方，清清楚楚的写着专门存放重复请求的地方</div><div class=\"line\">         * 根据需要缓存的request生成的特殊标记cacheKey</div><div class=\"line\">         * 当然不涉及到缓存的request在上面几行代码被过滤处理了</div><div class=\"line\">         */</div><div class=\"line\">        synchronized (mWaitingRequests) &#123;</div><div class=\"line\"></div><div class=\"line\">            /**</div><div class=\"line\">             * 先获取到这个request的cacheKey</div><div class=\"line\">             * 看看有没有和它相同的request已经处于天上飞的状态了</div><div class=\"line\">             * (我觉得这里的in flight应该说的是已经发送过了的)</div><div class=\"line\">             * 在后面会说明</div><div class=\"line\">             */</div><div class=\"line\">            String cacheKey = request.getCacheKey();</div><div class=\"line\"></div><div class=\"line\">            if (mWaitingRequests.containsKey(cacheKey)) &#123;</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * There is already a request in flight. Queue up.</div><div class=\"line\">                 * 如果在等待的队列里面存在着cacheKey对应的一个Queue</div><div class=\"line\">                 * 则说明在这个request之前，已经有相同的request发送出去过了</div><div class=\"line\">                 * 那么现在需要做的就是将这个request加入到cacheKey对应的Queue存起来</div><div class=\"line\">                 * 如果对应的Queue是null,就自己创建一个新的，再把request放入</div><div class=\"line\">                 * </div><div class=\"line\">                 * 这个request就不再会被放入到mCacheQueue中去了</div><div class=\"line\">                 * 就是坐等数据的意思= =</div><div class=\"line\">                 */</div><div class=\"line\">                Queue&gt; stagedRequests = mWaitingRequests.get(cacheKey);</div><div class=\"line\">                if (stagedRequests == null) &#123;</div><div class=\"line\">                    stagedRequests = new LinkedList&gt;();</div><div class=\"line\">                &#125;</div><div class=\"line\">                stagedRequests.add(request);</div><div class=\"line\">                mWaitingRequests.put(cacheKey, stagedRequests);</div><div class=\"line\">                if (VolleyLog.DEBUG) &#123;</div><div class=\"line\">                    VolleyLog.v(&quot;Request for cacheKey=%s is in flight, putting on hold.&quot;, cacheKey);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                /**</div><div class=\"line\">                 * Insert &apos;null&apos; queue for this cacheKey, indicating there is now a request in flight.</div><div class=\"line\">                 * 如果这个涉及到cache的request在它之前根本就没有和他相同的request</div><div class=\"line\">                 * 直接以这个cacheKey为key，放一个null进去</div><div class=\"line\">                 * 表示这是第一个么= =</div><div class=\"line\">                 * 搞不懂为什么要这个样子设计，为什么不直接新建一个Queue进去呢</div><div class=\"line\">                 */</div><div class=\"line\">                mWaitingRequests.put(cacheKey, null);</div><div class=\"line\">                mCacheQueue.add(request);</div><div class=\"line\">            &#125;</div><div class=\"line\">            return request;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Called from &#123;@link Request#finish(String)&#125;, indicating that processing of the given request</div><div class=\"line\">     * has finished.</div><div class=\"line\">     * 从Request中的finish()方法调用开始，预示着给出的request已经结束</div><div class=\"line\">     * Releases waiting requests for request.getCacheKey() if</div><div class=\"line\">     *      request.shouldCache().</div><div class=\"line\">     * 将处于mWaittingQueue中具有相同cacheKey的一组request全部释放</div><div class=\"line\">     * 也就是把上面那些坐等数据的request全部取出来，response发送回去</div><div class=\"line\">     */</div><div class=\"line\">     void finish(Request request) &#123;</div><div class=\"line\">        // Remove from the set of requests currently being processed.</div><div class=\"line\">        /**</div><div class=\"line\">         * 将mCurrentRequests锁住</div><div class=\"line\">         * 一个时间段内只有一个线程可以访问该对象</div><div class=\"line\">         * 将已经结束的request从队列中移除</div><div class=\"line\">         */</div><div class=\"line\">        synchronized (mCurrentRequests) &#123;</div><div class=\"line\">            mCurrentRequests.remove(request);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * 通知所有注册过的监听器</div><div class=\"line\">         * 告诉它们，request已经finish了</div><div class=\"line\">         */</div><div class=\"line\">        synchronized (mFinishedListeners) &#123;</div><div class=\"line\">          for (RequestFinishedListener listener : mFinishedListeners) &#123;</div><div class=\"line\">            listener.onRequestFinished(request);</div><div class=\"line\">          &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * 如果该request涉及到需要缓存</div><div class=\"line\">         * 则将mWaitingRequests中具有相同cacheKey的request</div><div class=\"line\">         * 全部取出放入到缓存队列中等待CacheDispatcher的调度</div><div class=\"line\">         */</div><div class=\"line\">        if (request.shouldCache()) &#123;</div><div class=\"line\">            synchronized (mWaitingRequests) &#123;</div><div class=\"line\">                String cacheKey = request.getCacheKey();</div><div class=\"line\">                Queue&gt; waitingRequests = mWaitingRequests.remove(cacheKey);</div><div class=\"line\">                if (waitingRequests != null) &#123;</div><div class=\"line\">                    if (VolleyLog.DEBUG) &#123;</div><div class=\"line\">                        VolleyLog.v(&quot;Releasing %d waiting requests for cacheKey=%s.&quot;,</div><div class=\"line\">                                waitingRequests.size(), cacheKey);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    // Process all queued up requests. They won&apos;t be considered as in flight, but</div><div class=\"line\">                    // that&apos;s not a problem as the cache has been primed by &apos;request&apos;.</div><div class=\"line\">                    mCacheQueue.addAll(waitingRequests);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * 下面两个方法就是所谓注册监听器和取消注册的函数</div><div class=\"line\">     */</div><div class=\"line\">    public   void addRequestFinishedListener(RequestFinishedListener listener) &#123;</div><div class=\"line\">      synchronized (mFinishedListeners) &#123;</div><div class=\"line\">        mFinishedListeners.add(listener);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Remove a RequestFinishedListener. Has no effect if listener was not previously added.</div><div class=\"line\">     */</div><div class=\"line\">    public   void removeRequestFinishedListener(RequestFinishedListener listener) &#123;</div><div class=\"line\">      synchronized (mFinishedListeners) &#123;</div><div class=\"line\">        mFinishedListeners.remove(listener);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面介绍了Volley.java和RequestQueue.java两大类，Volley是对外的入口，而RequestQueue是Volley框架中最核心的部分了。如果注释上面有写错了或者有疑问的地方，还请各位直接指出在下一篇博客中将继续向下深入，结合源代码分析什么是Dispatcher。</p>\n","excerpt":"<h2 id=\"Volley框架解析-二-—–Volley及RequestQueue解析\"><a href=\"#Volley框架解析-二-—–Volley及RequestQueue解析\" class=\"headerlink\" title=\"Volley框架解析(二)—–Volley及RequestQueue解析\"></a>Volley框架解析(二)—–Volley及RequestQueue解析</h2><h3 id=\"题外话-可直接无视跳过\"><a href=\"#题外话-可直接无视跳过\" class=\"headerlink\" title=\"题外话(可直接无视跳过\"></a><a href=\"#u9898_u5916_u8BDD_28_u53EF_u76F4_u63A5_u65E0_u89C6_u8DF3_u8FC7\" title=\"题外话(可直接无视跳过\"></a>题外话(可直接无视跳过</h3><p>是第一次比较完整的去阅读一个框架的源码，刚开始看的时候可以说是除了认识几个基本的<code>public, interface, final</code>等关键词之外，其他的一律不通orz，而且还不知道从哪里下手。后来磨蹭了好久还是慢慢的静下心来，对照着Java文档和Android文档查阅，刚开始都是陌生的，慢慢的在源码旁边打上注释，多看两遍就会get了。</p>\n<p>有些地方在一个.java文件里面是无法理解用处的，这样的先直接跳过不要纠结，看到对应用的地方就会恍然大悟了。还总结出了一个小技巧就是从框架暴露给外面的接口开始阅读，因为框架里面是一层一层往上的，底层是为了上层服务的，所以从接口开始阅读能很好的向下展开。</p>\n<p>前面一篇对Volley做了一个初步的介绍以及从整体上的一个解析，只是简单的描述了Request在Volley中是如何被处理的。从这篇博客开始将从最顶层一步一步的向下挖掘每一行代码，从最开始调用的地方<code>RequestQueue mQueue = Volley.newRequestQueue(mContext)</code>开始。</p>","more":"<hr>\n<h3 id=\"1-Volley-java\"><a href=\"#1-Volley-java\" class=\"headerlink\" title=\"1. Volley.java\"></a><a href=\"#1-_Volley-java\" title=\"1\\. Volley.java\"></a>1. Volley.java</h3><p>Volley.java是Volley整个框架对外暴露的接口，里面有四个重载的同名静态函数，方便直接使用。下面结合源代码来分析，主要是代码里面的注释。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">   package com.android.volley.toolbox;</div><div class=\"line\"></div><div class=\"line\">import android.content.Context;</div><div class=\"line\">import android.content.pm.PackageInfo;</div><div class=\"line\">import android.content.pm.PackageManager.NameNotFoundException;</div><div class=\"line\">import android.net.http.AndroidHttpClient;</div><div class=\"line\">import android.os.Build;</div><div class=\"line\"></div><div class=\"line\">import com.android.volley.Network;</div><div class=\"line\">import com.android.volley.RequestQueue;</div><div class=\"line\"></div><div class=\"line\">import java.io.File;</div><div class=\"line\"></div><div class=\"line\">public class Volley &#123;</div><div class=\"line\"></div><div class=\"line\">    /** Default on-disk cache directory. */</div><div class=\"line\">    private static final String DEFAULT_CACHE_DIR = &quot;volley&quot;;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Creates a default instance of the worker pool and calls &#123;@link RequestQueue#start()&#125; on it.</div><div class=\"line\">     * You may set a maximum size of the disk cache in bytes.</div><div class=\"line\">     * 创建一个默认的线程池，并将其启动</div><div class=\"line\">     * 还能通过构造函数来设置缓存的最大容量，默认的是5*1024*1024个字节</div><div class=\"line\">     *</div><div class=\"line\">     * @param context A &#123;@link Context&#125; to use for creating the cache dir.</div><div class=\"line\">     * 用于创建缓存目录的context</div><div class=\"line\">     * @param stack An &#123;@link HttpStack&#125; to use for the network, or null for default.</div><div class=\"line\">     * HttpStack可以通过外面自定义之后传入，也可以不管直接用默认的</div><div class=\"line\">     * @param maxDiskCacheBytes the maximum size of the disk cache, in bytes. Use -1 for default size.</div><div class=\"line\">     * 最大缓存的字节数</div><div class=\"line\">     * @return A started &#123;@link RequestQueue&#125; instance.</div><div class=\"line\">     */</div><div class=\"line\">    public static RequestQueue newRequestQueue(Context context, HttpStack stack, int maxDiskCacheBytes) &#123;</div><div class=\"line\"></div><div class=\"line\">    \t//通过context，创建用于缓存文件的目录</div><div class=\"line\">        File cacheDir = new File(context.getCacheDir(), DEFAULT_CACHE_DIR);</div><div class=\"line\"></div><div class=\"line\">        String userAgent = &quot;volley/0&quot;;</div><div class=\"line\"></div><div class=\"line\">        try &#123;</div><div class=\"line\">            String packageName = context.getPackageName();</div><div class=\"line\"></div><div class=\"line\">            /**</div><div class=\"line\">             * 关于PackageInfo，官方文档的解释如下：</div><div class=\"line\">             * Overall information about the contents of a package.</div><div class=\"line\">             * This corresponds to all of the information collected from AndroidManifest.xml.</div><div class=\"line\">             * 该类作为Package信息的基类，还有很多子类例如：ApplicationInfo、 ComponentInfo等。</div><div class=\"line\">             * 这些类包含了一些关于安装包的信息，icon,label等</div><div class=\"line\">             */</div><div class=\"line\">            PackageInfo info = context.getPackageManager().getPackageInfo(packageName, 0);</div><div class=\"line\">            //获取到了Package的版本号</div><div class=\"line\">            userAgent = packageName + &quot;/&quot; + info.versionCode;</div><div class=\"line\"></div><div class=\"line\">        &#125; catch (NameNotFoundException e) &#123;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * HttpStack是一个用于网络请求的接口</div><div class=\"line\">         * 如果传入的stack为空，则根据当前系统的版本号，来选择不同的实现了HttpStack(Volley自己的一个接口)的类对象</div><div class=\"line\">         * 高于android2.3就用HurlStack(实现了HttpStack接口，基于HttpsURLConnection)</div><div class=\"line\">         * 低于android2.3就用HttpClientStack(实现了HttpStack接口，基于HttpClient)</div><div class=\"line\">         */</div><div class=\"line\">        if (stack == null) &#123;</div><div class=\"line\">            if (Build.VERSION.SDK_INT &gt;= 9) &#123;</div><div class=\"line\">                stack = new HurlStack();</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                // Prior to Gingerbread, HttpUrlConnection was unreliable.</div><div class=\"line\">                // See: http://android-developers.blogspot.com/2011/09/androids-http-clients.html</div><div class=\"line\">                stack = new HttpClientStack(AndroidHttpClient.newInstance(userAgent));</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * 创建了一个用于发送特定请求的Network类对象</div><div class=\"line\">         * 该接口中有一个与HttpStack接口中同名的方法(performRequest)</div><div class=\"line\">         * 但是参数的内容不同， 返回的类型也有所区别</div><div class=\"line\">         * Network的返回类型是自定义的一个NetworkResponse类</div><div class=\"line\">         * 而HttpStack返回的是HttpResponse</div><div class=\"line\">         * (HttpResponse是java.apache.http中的一个类，里面包含了服务器返回的一些数据)</div><div class=\"line\">         * </div><div class=\"line\">         * 将stack传入到了已经实现了Network接口的一个BasicNetwork类中</div><div class=\"line\">         * 在后面发送Request请求的时候会调用Network.performRequest()</div><div class=\"line\">         * 然后在Network.performRequest()函数中会继续调用HttpStack.performRequest()</div><div class=\"line\">         * 真正的网络请求发出是在HttpStack.performRequest()中进行的</div><div class=\"line\">         */</div><div class=\"line\"></div><div class=\"line\">        Network network = new BasicNetwork(stack);</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * 创建一个RequestQueue引用</div><div class=\"line\">         * RequestQueue是volley实现的一个请求调度队列</div><div class=\"line\">         * 用来分发处理request</div><div class=\"line\">         * 后面会分析RequestQueue.java</div><div class=\"line\">         */</div><div class=\"line\">        RequestQueue queue;</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * 根据是否设置了最大缓存字节数</div><div class=\"line\">         * 来用不同的构造器生成RequestQueue对象</div><div class=\"line\">         * 其中第一个构造参数为一个实现了Cache.java接口的默认缓存读写类DiskBasedCache.java</div><div class=\"line\">         * 现在只需要知道它是用来专门处理缓存的就可以了，后面也会对源码做出分析</div><div class=\"line\">         * 第二个参数是接口Network.java类的引用，在上面两排不远处可以看到BasicNetwork.java</div><div class=\"line\">         * 它是用来实现网络请求的一个类。</div><div class=\"line\">         */</div></pre></td></tr></table></figure>\n<p>简单的说，Volley.java的用处就只有一个，创建并启动一个RequestQueue对象，可以有四个构造器供我们选择，可以通过继承其接口衍生出自己的一套网络请求部分的实现(继承HttpStack接口),还可以定义缓存大小的限制。对于框架的使用者来说自由度还是很大的，不是固定死只能通过默认实现来使用Volley,提供接口能使框架的灵活性大大提升，在自己写代码的过程中也要注意这个问题。</p>\n<hr>\n<p>###2. RequestQueue.java<br>RequestQueue可以说是Volley中最核心的部分了，所有的request都要从这边进来，等待工作线程的调度，调度完成之后从里面的ResponseDelivery返回给caller。下面是RequestQueue.java的所有代码以及每行代码的用途，读了几遍才弄清楚了这个东西的作用，之前都迷糊的不行orz。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div><div class=\"line\">204</div><div class=\"line\">205</div><div class=\"line\">206</div><div class=\"line\">207</div><div class=\"line\">208</div><div class=\"line\">209</div><div class=\"line\">210</div><div class=\"line\">211</div><div class=\"line\">212</div><div class=\"line\">213</div><div class=\"line\">214</div><div class=\"line\">215</div><div class=\"line\">216</div><div class=\"line\">217</div><div class=\"line\">218</div><div class=\"line\">219</div><div class=\"line\">220</div><div class=\"line\">221</div><div class=\"line\">222</div><div class=\"line\">223</div><div class=\"line\">224</div><div class=\"line\">225</div><div class=\"line\">226</div><div class=\"line\">227</div><div class=\"line\">228</div><div class=\"line\">229</div><div class=\"line\">230</div><div class=\"line\">231</div><div class=\"line\">232</div><div class=\"line\">233</div><div class=\"line\">234</div><div class=\"line\">235</div><div class=\"line\">236</div><div class=\"line\">237</div><div class=\"line\">238</div><div class=\"line\">239</div><div class=\"line\">240</div><div class=\"line\">241</div><div class=\"line\">242</div><div class=\"line\">243</div><div class=\"line\">244</div><div class=\"line\">245</div><div class=\"line\">246</div><div class=\"line\">247</div><div class=\"line\">248</div><div class=\"line\">249</div><div class=\"line\">250</div><div class=\"line\">251</div><div class=\"line\">252</div><div class=\"line\">253</div><div class=\"line\">254</div><div class=\"line\">255</div><div class=\"line\">256</div><div class=\"line\">257</div><div class=\"line\">258</div><div class=\"line\">259</div><div class=\"line\">260</div><div class=\"line\">261</div><div class=\"line\">262</div><div class=\"line\">263</div><div class=\"line\">264</div><div class=\"line\">265</div><div class=\"line\">266</div><div class=\"line\">267</div><div class=\"line\">268</div><div class=\"line\">269</div><div class=\"line\">270</div><div class=\"line\">271</div><div class=\"line\">272</div><div class=\"line\">273</div><div class=\"line\">274</div><div class=\"line\">275</div><div class=\"line\">276</div><div class=\"line\">277</div><div class=\"line\">278</div><div class=\"line\">279</div><div class=\"line\">280</div><div class=\"line\">281</div><div class=\"line\">282</div><div class=\"line\">283</div><div class=\"line\">284</div><div class=\"line\">285</div><div class=\"line\">286</div><div class=\"line\">287</div><div class=\"line\">288</div><div class=\"line\">289</div><div class=\"line\">290</div><div class=\"line\">291</div><div class=\"line\">292</div><div class=\"line\">293</div><div class=\"line\">294</div><div class=\"line\">295</div><div class=\"line\">296</div><div class=\"line\">297</div><div class=\"line\">298</div><div class=\"line\">299</div><div class=\"line\">300</div><div class=\"line\">301</div><div class=\"line\">302</div><div class=\"line\">303</div><div class=\"line\">304</div><div class=\"line\">305</div><div class=\"line\">306</div><div class=\"line\">307</div><div class=\"line\">308</div><div class=\"line\">309</div><div class=\"line\">310</div><div class=\"line\">311</div><div class=\"line\">312</div><div class=\"line\">313</div><div class=\"line\">314</div><div class=\"line\">315</div><div class=\"line\">316</div><div class=\"line\">317</div><div class=\"line\">318</div><div class=\"line\">319</div><div class=\"line\">320</div><div class=\"line\">321</div><div class=\"line\">322</div><div class=\"line\">323</div><div class=\"line\">324</div><div class=\"line\">325</div><div class=\"line\">326</div><div class=\"line\">327</div><div class=\"line\">328</div><div class=\"line\">329</div><div class=\"line\">330</div><div class=\"line\">331</div><div class=\"line\">332</div><div class=\"line\">333</div><div class=\"line\">334</div><div class=\"line\">335</div><div class=\"line\">336</div><div class=\"line\">337</div><div class=\"line\">338</div><div class=\"line\">339</div><div class=\"line\">340</div><div class=\"line\">341</div><div class=\"line\">342</div><div class=\"line\">343</div><div class=\"line\">344</div><div class=\"line\">345</div><div class=\"line\">346</div><div class=\"line\">347</div><div class=\"line\">348</div><div class=\"line\">349</div><div class=\"line\">350</div><div class=\"line\">351</div><div class=\"line\">352</div><div class=\"line\">353</div><div class=\"line\">354</div><div class=\"line\">355</div><div class=\"line\">356</div><div class=\"line\">357</div><div class=\"line\">358</div><div class=\"line\">359</div><div class=\"line\">360</div><div class=\"line\">361</div><div class=\"line\">362</div><div class=\"line\">363</div><div class=\"line\">364</div><div class=\"line\">365</div><div class=\"line\">366</div><div class=\"line\">367</div><div class=\"line\">368</div><div class=\"line\">369</div><div class=\"line\">370</div><div class=\"line\">371</div><div class=\"line\">372</div><div class=\"line\">373</div><div class=\"line\">374</div><div class=\"line\">375</div><div class=\"line\">376</div><div class=\"line\">377</div><div class=\"line\">378</div><div class=\"line\">379</div><div class=\"line\">380</div><div class=\"line\">381</div><div class=\"line\">382</div><div class=\"line\">383</div><div class=\"line\">384</div><div class=\"line\">385</div><div class=\"line\">386</div><div class=\"line\">387</div><div class=\"line\">388</div><div class=\"line\">389</div><div class=\"line\">390</div><div class=\"line\">391</div><div class=\"line\">392</div><div class=\"line\">393</div><div class=\"line\">394</div><div class=\"line\">395</div><div class=\"line\">396</div><div class=\"line\">397</div><div class=\"line\">398</div><div class=\"line\">399</div><div class=\"line\">400</div><div class=\"line\">401</div><div class=\"line\">402</div><div class=\"line\">403</div><div class=\"line\">404</div><div class=\"line\">405</div><div class=\"line\">406</div><div class=\"line\">407</div><div class=\"line\">408</div><div class=\"line\">409</div><div class=\"line\">410</div><div class=\"line\">411</div><div class=\"line\">412</div><div class=\"line\">413</div><div class=\"line\">414</div><div class=\"line\">415</div><div class=\"line\">416</div><div class=\"line\">417</div><div class=\"line\">418</div><div class=\"line\">419</div><div class=\"line\">420</div><div class=\"line\">421</div><div class=\"line\">422</div><div class=\"line\">423</div><div class=\"line\">424</div><div class=\"line\">425</div><div class=\"line\">426</div><div class=\"line\">427</div><div class=\"line\">428</div><div class=\"line\">429</div><div class=\"line\">430</div><div class=\"line\">431</div><div class=\"line\">432</div><div class=\"line\">433</div><div class=\"line\">434</div><div class=\"line\">435</div><div class=\"line\">436</div><div class=\"line\">437</div><div class=\"line\">438</div><div class=\"line\">439</div><div class=\"line\">440</div><div class=\"line\">441</div><div class=\"line\">442</div><div class=\"line\">443</div><div class=\"line\">444</div><div class=\"line\">445</div><div class=\"line\">446</div><div class=\"line\">447</div><div class=\"line\">448</div><div class=\"line\">449</div><div class=\"line\">450</div><div class=\"line\">451</div><div class=\"line\">452</div><div class=\"line\">453</div><div class=\"line\">454</div><div class=\"line\">455</div><div class=\"line\">456</div><div class=\"line\">457</div><div class=\"line\">458</div><div class=\"line\">459</div><div class=\"line\">460</div><div class=\"line\">461</div><div class=\"line\">462</div><div class=\"line\">463</div><div class=\"line\">464</div><div class=\"line\">465</div><div class=\"line\">466</div><div class=\"line\">467</div><div class=\"line\">468</div><div class=\"line\">469</div><div class=\"line\">470</div><div class=\"line\">471</div><div class=\"line\">472</div><div class=\"line\">473</div><div class=\"line\">474</div><div class=\"line\">475</div><div class=\"line\">476</div><div class=\"line\">477</div><div class=\"line\">478</div><div class=\"line\">479</div><div class=\"line\">480</div><div class=\"line\">481</div><div class=\"line\">482</div><div class=\"line\">483</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">   package com.android.volley;</div><div class=\"line\"></div><div class=\"line\">import android.os.Handler;</div><div class=\"line\">import android.os.Looper;</div><div class=\"line\"></div><div class=\"line\">import java.util.ArrayList;</div><div class=\"line\">import java.util.HashMap;</div><div class=\"line\">import java.util.HashSet;</div><div class=\"line\">import java.util.LinkedList;</div><div class=\"line\">import java.util.List;</div><div class=\"line\">import java.util.Map;</div><div class=\"line\">import java.util.Queue;</div><div class=\"line\">import java.util.Set;</div><div class=\"line\">import java.util.concurrent.PriorityBlockingQueue;</div><div class=\"line\">import java.util.concurrent.atomic.AtomicInteger;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\"> * A request dispatch queue with a thread pool of dispatchers.</div><div class=\"line\"> * </div><div class=\"line\"> *</div><div class=\"line\"> * Calling &#123;@link #add(Request)&#125; will enqueue the given Request for dispatch,</div><div class=\"line\"> * resolving from either cache or network on a worker thread, and then delivering</div><div class=\"line\"> * a parsed response on the main thread.</div><div class=\"line\"> * 调用mQueue.add(Request)函数将一个request放入请求调度队列中排队，将在工作线程中，</div><div class=\"line\"> * 从网络或者缓存两个方面对request进行分类并处理，将response返回给主线程中。</div><div class=\"line\"> */</div><div class=\"line\">public class RequestQueue &#123;</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * Callback interface for completed requests. </div><div class=\"line\">     * request完成之后的回掉接口</div><div class=\"line\">     * 其中的T用到了java的泛型，是Request调用者所期待返回的数据类型</div><div class=\"line\">     * 例如String或者是Integer</div><div class=\"line\">     */</div><div class=\"line\">    public static interface RequestFinishedListener &#123;</div><div class=\"line\">        /**</div><div class=\"line\">         * Called when a request has finished processing. </div><div class=\"line\">         * 当一个Request被处理完成时来调用</div><div class=\"line\">         * = =其实从方法的名字来看也能看出来</div><div class=\"line\">         */</div><div class=\"line\">        public void onRequestFinished(Request request);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Used for generating monotonically-increasing sequence numbers for requests. </div><div class=\"line\">     * 用来为request生成单调递增的有序数字，刚才是不知道这里是干什么用的= =</div><div class=\"line\">     * 在这里纠结了一小段时间就继续看了下去，直到在add()函数里面看到了这个的用处</div><div class=\"line\">     * 在request被add()进来的时候会给每个request发一个类似于排队的序号一样的数字，就是用这个类来实现的</div><div class=\"line\">     * </div><div class=\"line\">     * 官方的解释是：An int value that may be updated atomically. </div><div class=\"line\">     * An AtomicInteger is used in applications such as atomically incremented counters, and cannot be used as a replacement for an Integer.</div><div class=\"line\">     * However, this class does extend Number to allow uniform access by tools and utilities that deal with numerically-based classes.</div><div class=\"line\">     * 这个类是在需要自动递增计数器的应用中使用的，但是不能作为一个Integer的替代品。</div><div class=\"line\">     * 但是这个类确实是继承自Number类的，其允许处理数字的一些工具来统一访问= =。。</div><div class=\"line\">     */</div><div class=\"line\">    private AtomicInteger mSequenceGenerator = new AtomicInteger();</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Staging area for requests that already have a duplicate request in flight.</div><div class=\"line\">     * 用HashMap来形成一个筹备区域，这个筹备区域是为重复的request准备的。</div><div class=\"line\">     * 每个对应的cacheKey都有一个Queue来存储，因为相同的请求有时不止一个。</div><div class=\"line\">     * 这些重复的request已经有一个在被处理了，其他的不用重复处理，在这个HashMap里面等着拿结果就可以了</div><div class=\"line\">     * </div><div class=\"line\">     *     containsKey(cacheKey) indicates that there is a request in flight for the given cache</div><div class=\"line\">     *          key.</div><div class=\"line\">     *         用containsKey(String cacheKey)可以判定一个已经发送出去的请求是否有重复的请求。</div><div class=\"line\">     *     </div><div class=\"line\">     *     get(cacheKey) returns waiting requests for the given cache key. The in flight request</div><div class=\"line\">     *          is not contained in that list. Is null if no requests are staged.</div><div class=\"line\">     *         get()方法会返回一个queue，这个queue有可能是空的，也有可能里面存放着具有相同cacheKey的一系列request</div><div class=\"line\">     * </div><div class=\"line\">     */</div><div class=\"line\">    private final Map&gt;&gt; mWaitingRequests =</div><div class=\"line\">            new HashMap&gt;&gt;();</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * The set of all requests currently being processed by this RequestQueue. A Request</div><div class=\"line\">     * will be in this set if it is waiting in any queue or currently being processed by</div><div class=\"line\">     * any dispatcher.</div><div class=\"line\">     *</div><div class=\"line\">     * 一个容纳着所有request的HashSet。</div><div class=\"line\">     * 如果一个request正在被调度或者正处于等待状态，该request就在这个集合之中。</div><div class=\"line\">     * 这么说的话，RequestQueue里面主要存储request的集合就是这个了。</div><div class=\"line\">     * 在外面调用add(Request request)的时候，也就是加入到了这个HashSet之中。</div><div class=\"line\">     */</div><div class=\"line\">    private final Set&gt; mCurrentRequests = new HashSet&gt;();</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * The cache triage queue. </div><div class=\"line\">     * 运用到了优先队列</div><div class=\"line\">     * 也就是里面的每个元素都会有一个优先级，优先级高的比优先级低的要先调度。</div><div class=\"line\">     * 这个队列里面存放着需要访问缓存的一些Request，等待着调度器(dispatcher)的处理</div><div class=\"line\">     * 后面慢慢的会介绍到dispatcher</div><div class=\"line\">     */</div><div class=\"line\">    private final PriorityBlockingQueue&gt; mCacheQueue =</div><div class=\"line\">        new PriorityBlockingQueue&gt;();</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * The queue of requests that are actually going out to the network.</div><div class=\"line\">     * 网络请求队列</div><div class=\"line\">     * 要通过网络在服务器上请求数据的request</div><div class=\"line\">     * 还包括一些缓存出了点小问题的request也会被加入到这里</div><div class=\"line\">     * 在后面的代码中能够看到</div><div class=\"line\">     */</div><div class=\"line\">    private final PriorityBlockingQueue&gt; mNetworkQueue =</div><div class=\"line\">        new PriorityBlockingQueue&gt;();</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * Number of network request dispatcher threads to start. </div><div class=\"line\">     * 网络请求调度线程池中线程的默认数量。</div><div class=\"line\">     */</div><div class=\"line\">    private static final int DEFAULT_NETWORK_THREAD_POOL_SIZE = 4;</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * Cache interface for retrieving and storing responses. </div><div class=\"line\">     * 缓存的接口，用来从缓存中取出response或者存储response到缓存中。</div><div class=\"line\">     */</div><div class=\"line\">    private final Cache mCache;</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * Network interface for performing requests. </div><div class=\"line\">     * 网络接口，用来进行网络请求。</div><div class=\"line\">     */</div><div class=\"line\">    private final Network mNetwork;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Response delivery mechanism. </div><div class=\"line\">     * 响应交付机制</div><div class=\"line\">     * 请求最后的结果(Response.java实例)通过mDelivery中的方法传回</div><div class=\"line\">     * 这个过程需要在工作线程中才能看到，也就是在介绍dispatcher里面能看到</div><div class=\"line\">     */</div><div class=\"line\">    private final ResponseDelivery mDelivery;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * The network dispatchers. </div><div class=\"line\">     * 网络调度线程池</div><div class=\"line\">     * 因为是涉及到网络的一个框架，工作的效率不能低</div><div class=\"line\">     * 多开几个网络调度器线程来一起工作</div><div class=\"line\">     */</div><div class=\"line\">    private NetworkDispatcher[] mDispatchers;</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * The cache dispatcher. </div><div class=\"line\">     * 缓存调度线程(和上面的差不多吧= =，但是不是线程池了)</div><div class=\"line\">     * 处理了涉及到缓存的request</div><div class=\"line\">     */</div><div class=\"line\">    private CacheDispatcher mCacheDispatcher;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * 这个貌似是和listener差不多的用处</div><div class=\"line\">     * 每个request结束之后，就会通知所有已经注册过的listener(所谓注册无非就是实现了RequestFinishedListener.java这个接口</div><div class=\"line\">     * 然后再将自己传入，加入到这个ArrayList里面来)</div><div class=\"line\">     * 在&#123;@link #finish()&#125;里面会用到这个ArrayList</div><div class=\"line\">     */</div><div class=\"line\">    private List mFinishedListeners =</div><div class=\"line\">            new ArrayList();</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Creates the worker pool. Processing will not begin until &#123;@link #start()&#125; is called.</div><div class=\"line\">     * 创建工作线程，在start()调用之后开始不停的工作</div><div class=\"line\">     *</div><div class=\"line\">     * @param cache A Cache to use for persisting responses to disk</div><div class=\"line\">     * 涉及到内存访问的接口</div><div class=\"line\">     * @param network A Network interface for performing HTTP requests</div><div class=\"line\">     * 用来进行HTTP请求的网络接口</div><div class=\"line\">     * @param threadPoolSize Number of network dispatcher threads to create</div><div class=\"line\">     * 网络请求线程池，里面放着很多个线程，可以同时处理多个需要网络访问的request</div><div class=\"line\">     * @param delivery A ResponseDelivery interface for posting responses and errors</div><div class=\"line\">     * 一个用来传递resposne和error的接口</div><div class=\"line\">     */</div><div class=\"line\">    public RequestQueue(Cache cache, Network network, int threadPoolSize,</div><div class=\"line\">            ResponseDelivery delivery) &#123;</div><div class=\"line\">        mCache = cache;</div><div class=\"line\">        mNetwork = network;</div><div class=\"line\">        mDispatchers = new NetworkDispatcher[threadPoolSize];</div><div class=\"line\">        mDelivery = delivery;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Creates the worker pool. Processing will not begin until &#123;@link #start()&#125; is called.</div><div class=\"line\">     *</div><div class=\"line\">     * @param cache A Cache to use for persisting responses to disk</div><div class=\"line\">     * @param network A Network interface for performing HTTP requests</div><div class=\"line\">     * @param threadPoolSize Number of network dispatcher threads to create</div><div class=\"line\">     */</div><div class=\"line\">    public RequestQueue(Cache cache, Network network, int threadPoolSize) &#123;</div><div class=\"line\">        this(cache, network, threadPoolSize,</div><div class=\"line\">                new ExecutorDelivery(new Handler(Looper.getMainLooper())));</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Creates the worker pool. Processing will not begin until &#123;@link #start()&#125; is called.</div><div class=\"line\">     *</div><div class=\"line\">     * @param cache A Cache to use for persisting responses to disk</div><div class=\"line\">     * @param network A Network interface for performing HTTP requests</div><div class=\"line\">     */</div><div class=\"line\">    public RequestQueue(Cache cache, Network network) &#123;</div><div class=\"line\">        this(cache, network, DEFAULT_NETWORK_THREAD_POOL_SIZE);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Starts the dispatchers in this queue.</div><div class=\"line\">     * 先将所有的调度线程都停止</div><div class=\"line\">     * 再重新创建并启动</div><div class=\"line\">     * 将mNetworkQueue和mCacheQueue传入到dispatcher中</div><div class=\"line\">     * 方便从queue中取出request来进行处理</div><div class=\"line\">     * 将mDelivery接口传入，方便将请求结果返回</div><div class=\"line\">     * </div><div class=\"line\">     * cacheDispatcher创建一个就够了，networkDispatcher创建了多个</div><div class=\"line\">     * network花费时间比较长，需要开多个线程来工作</div><div class=\"line\">     */</div><div class=\"line\">    public void start() &#123;</div><div class=\"line\">        stop();  // Make sure any currently running dispatchers are stopped.</div><div class=\"line\">        // Create the cache dispatcher and start it.</div><div class=\"line\">        mCacheDispatcher = new CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);</div><div class=\"line\">        mCacheDispatcher.start();</div><div class=\"line\"></div><div class=\"line\">        // Create network dispatchers (and corresponding threads) up to the pool size.</div><div class=\"line\">        for (int i = 0; i &lt; mDispatchers.length; i++) &#123;</div><div class=\"line\">            NetworkDispatcher networkDispatcher = new NetworkDispatcher(mNetworkQueue, mNetwork,</div><div class=\"line\">                    mCache, mDelivery);</div><div class=\"line\">            mDispatchers[i] = networkDispatcher;</div><div class=\"line\">            networkDispatcher.start();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Stops the cache and network dispatchers.</div><div class=\"line\">     * 将所有正在工作状态的dispatcher挨个退出</div><div class=\"line\">     */</div><div class=\"line\">    public void stop() &#123;</div><div class=\"line\">        if (mCacheDispatcher != null) &#123;</div><div class=\"line\">            mCacheDispatcher.quit();</div><div class=\"line\">        &#125;</div><div class=\"line\">        for (int i = 0; i &lt; mDispatchers.length; i++) &#123;</div><div class=\"line\">            if (mDispatchers[i] != null) &#123;</div><div class=\"line\">                mDispatchers[i].quit();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Gets a sequence number.</div><div class=\"line\">     *</div><div class=\"line\">     * incrementAndGet() : Atomically increments by one the current value.</div><div class=\"line\">     * 自动向上涨一个单位然后返回当前值</div><div class=\"line\">     * 在后面的&#123;@link RequestQueue#add(Request)&#125;函数中能看到这个的作用</div><div class=\"line\">     * 用到了在前面提到过的AtomicInteger类</div><div class=\"line\">     */</div><div class=\"line\">    public int getSequenceNumber() &#123;</div><div class=\"line\">        return mSequenceGenerator.incrementAndGet();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Gets the &#123;@link Cache&#125; instance being used.</div><div class=\"line\">     * 返回当前正在使用的cache引用</div><div class=\"line\">     */</div><div class=\"line\">    public Cache getCache() &#123;</div><div class=\"line\">        return mCache;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * A simple predicate or filter interface for Requests, for use by</div><div class=\"line\">     * &#123;@link RequestQueue#cancelAll(RequestFilter)&#125;.</div><div class=\"line\">     * 一个request的过滤器</div><div class=\"line\">     * 上面说是给cancelAll用的，应该是设置一个RequestFilter之后</div><div class=\"line\">     * 将一类的request全都取消掉，至于具体的规则就需要重写里面的函数</div><div class=\"line\">     * 定义规则了</div><div class=\"line\">     */</div><div class=\"line\">    public interface RequestFilter &#123;</div><div class=\"line\">        public boolean apply(Request request);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Cancels all requests in this queue for which the given filter applies.</div><div class=\"line\">     * 从外面传入一个RequestFilter</div><div class=\"line\">     * 按照传入的规则取消所有符合规则的request</div><div class=\"line\">     * @param filter The filtering function to use</div><div class=\"line\">     */</div><div class=\"line\">    public void cancelAll(RequestFilter filter) &#123;</div><div class=\"line\">        synchronized (mCurrentRequests) &#123;</div><div class=\"line\">            for (Request request : mCurrentRequests) &#123;</div><div class=\"line\">                if (filter.apply(request)) &#123;</div><div class=\"line\">                    request.cancel();</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Cancels all requests in this queue with the given tag. Tag must be non-null</div><div class=\"line\">     * 依据request上面的tag来取消</div><div class=\"line\">     * and equality is by identity.</div><div class=\"line\">     */</div><div class=\"line\">    public void cancelAll(final Object tag) &#123;</div><div class=\"line\">        if (tag == null) &#123;</div><div class=\"line\">            throw new IllegalArgumentException(&quot;Cannot cancelAll with a null tag&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        cancelAll(new RequestFilter() &#123;</div><div class=\"line\">            @Override</div><div class=\"line\">            public boolean apply(Request request) &#123;</div><div class=\"line\">                return request.getTag() == tag;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Adds a Request to the dispatch queue.</div><div class=\"line\">     * 将新的request加入到总的等待队列中去</div><div class=\"line\">     * 一个request被处理之前都要待的地方</div><div class=\"line\">     * mCurrentRequests里面存放着所有的request </div><div class=\"line\">     *</div><div class=\"line\">     * @param request The request to service</div><div class=\"line\">     * 被传入的request，等待被处理</div><div class=\"line\">     * @return The passed-in request</div><div class=\"line\">     * 将加入的request返回回去</div><div class=\"line\">     */</div><div class=\"line\">    public  Request add(Request request) &#123;</div><div class=\"line\">        // Tag the request as belonging to this queue and add it to the set of current requests.</div><div class=\"line\">        request.setRequestQueue(this);</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * 在向mCurrentRequest中添加request的时候</div><div class=\"line\">         * 锁住不允许其他的线程进行访问操作</div><div class=\"line\">         * 对于synchronized:可用来给对象和方法或者代码块加锁，</div><div class=\"line\">         * 当它锁定一个方法或者一个代码块的时候，同一时刻最多只有一个线程执行这段代码。</div><div class=\"line\">         * 当两个并发线程访问同一个对象object中的这个加锁同步代码块时，一个时间内只能有一个线程得到执行。</div><div class=\"line\">         * 另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。</div><div class=\"line\">         * </div><div class=\"line\">         */</div><div class=\"line\">        synchronized (mCurrentRequests) &#123;</div><div class=\"line\">            mCurrentRequests.add(request);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * Process requests in the order they are added.</div><div class=\"line\">         * 在加入到mCurrentQueue中排队的时候</div><div class=\"line\">         * 就像我们排队一样会给我们一个对应的号码牌</div><div class=\"line\">         * 只是这里用了getSequenceNumber()函数来自动的发放号码牌</div><div class=\"line\">         */</div><div class=\"line\">        request.setSequence(getSequenceNumber());</div><div class=\"line\">        request.addMarker(&quot;add-to-queue&quot;);</div><div class=\"line\"></div><div class=\"line\">        /** </div><div class=\"line\">         * If the request is uncacheable, skip the cache queue and go straight to the network.</div><div class=\"line\">         * 检查这个request是否是不可缓存的</div><div class=\"line\">         * 也就是这个request所返回的response是否需要缓存下来</div><div class=\"line\">         */</div><div class=\"line\">        if (!request.shouldCache()) &#123;</div><div class=\"line\"></div><div class=\"line\">            /**</div><div class=\"line\">             * 如果不需要缓存的话</div><div class=\"line\">             * 直接将这个request加入到网络队列中去</div><div class=\"line\">             * 并且返回该request</div><div class=\"line\">             */</div><div class=\"line\">            mNetworkQueue.add(request);</div><div class=\"line\">            return request;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * Insert request into stage if there&apos;s already a request with the same cache key in flight.</div><div class=\"line\">         * = =尼玛我这是什么记性，看见这个mWaittingRequests居然不认识了</div><div class=\"line\">         * 向前翻到变量声明的地方，清清楚楚的写着专门存放重复请求的地方</div><div class=\"line\">         * 根据需要缓存的request生成的特殊标记cacheKey</div><div class=\"line\">         * 当然不涉及到缓存的request在上面几行代码被过滤处理了</div><div class=\"line\">         */</div><div class=\"line\">        synchronized (mWaitingRequests) &#123;</div><div class=\"line\"></div><div class=\"line\">            /**</div><div class=\"line\">             * 先获取到这个request的cacheKey</div><div class=\"line\">             * 看看有没有和它相同的request已经处于天上飞的状态了</div><div class=\"line\">             * (我觉得这里的in flight应该说的是已经发送过了的)</div><div class=\"line\">             * 在后面会说明</div><div class=\"line\">             */</div><div class=\"line\">            String cacheKey = request.getCacheKey();</div><div class=\"line\"></div><div class=\"line\">            if (mWaitingRequests.containsKey(cacheKey)) &#123;</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * There is already a request in flight. Queue up.</div><div class=\"line\">                 * 如果在等待的队列里面存在着cacheKey对应的一个Queue</div><div class=\"line\">                 * 则说明在这个request之前，已经有相同的request发送出去过了</div><div class=\"line\">                 * 那么现在需要做的就是将这个request加入到cacheKey对应的Queue存起来</div><div class=\"line\">                 * 如果对应的Queue是null,就自己创建一个新的，再把request放入</div><div class=\"line\">                 * </div><div class=\"line\">                 * 这个request就不再会被放入到mCacheQueue中去了</div><div class=\"line\">                 * 就是坐等数据的意思= =</div><div class=\"line\">                 */</div><div class=\"line\">                Queue&gt; stagedRequests = mWaitingRequests.get(cacheKey);</div><div class=\"line\">                if (stagedRequests == null) &#123;</div><div class=\"line\">                    stagedRequests = new LinkedList&gt;();</div><div class=\"line\">                &#125;</div><div class=\"line\">                stagedRequests.add(request);</div><div class=\"line\">                mWaitingRequests.put(cacheKey, stagedRequests);</div><div class=\"line\">                if (VolleyLog.DEBUG) &#123;</div><div class=\"line\">                    VolleyLog.v(&quot;Request for cacheKey=%s is in flight, putting on hold.&quot;, cacheKey);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                /**</div><div class=\"line\">                 * Insert &apos;null&apos; queue for this cacheKey, indicating there is now a request in flight.</div><div class=\"line\">                 * 如果这个涉及到cache的request在它之前根本就没有和他相同的request</div><div class=\"line\">                 * 直接以这个cacheKey为key，放一个null进去</div><div class=\"line\">                 * 表示这是第一个么= =</div><div class=\"line\">                 * 搞不懂为什么要这个样子设计，为什么不直接新建一个Queue进去呢</div><div class=\"line\">                 */</div><div class=\"line\">                mWaitingRequests.put(cacheKey, null);</div><div class=\"line\">                mCacheQueue.add(request);</div><div class=\"line\">            &#125;</div><div class=\"line\">            return request;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Called from &#123;@link Request#finish(String)&#125;, indicating that processing of the given request</div><div class=\"line\">     * has finished.</div><div class=\"line\">     * 从Request中的finish()方法调用开始，预示着给出的request已经结束</div><div class=\"line\">     * Releases waiting requests for request.getCacheKey() if</div><div class=\"line\">     *      request.shouldCache().</div><div class=\"line\">     * 将处于mWaittingQueue中具有相同cacheKey的一组request全部释放</div><div class=\"line\">     * 也就是把上面那些坐等数据的request全部取出来，response发送回去</div><div class=\"line\">     */</div><div class=\"line\">     void finish(Request request) &#123;</div><div class=\"line\">        // Remove from the set of requests currently being processed.</div><div class=\"line\">        /**</div><div class=\"line\">         * 将mCurrentRequests锁住</div><div class=\"line\">         * 一个时间段内只有一个线程可以访问该对象</div><div class=\"line\">         * 将已经结束的request从队列中移除</div><div class=\"line\">         */</div><div class=\"line\">        synchronized (mCurrentRequests) &#123;</div><div class=\"line\">            mCurrentRequests.remove(request);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * 通知所有注册过的监听器</div><div class=\"line\">         * 告诉它们，request已经finish了</div><div class=\"line\">         */</div><div class=\"line\">        synchronized (mFinishedListeners) &#123;</div><div class=\"line\">          for (RequestFinishedListener listener : mFinishedListeners) &#123;</div><div class=\"line\">            listener.onRequestFinished(request);</div><div class=\"line\">          &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * 如果该request涉及到需要缓存</div><div class=\"line\">         * 则将mWaitingRequests中具有相同cacheKey的request</div><div class=\"line\">         * 全部取出放入到缓存队列中等待CacheDispatcher的调度</div><div class=\"line\">         */</div><div class=\"line\">        if (request.shouldCache()) &#123;</div><div class=\"line\">            synchronized (mWaitingRequests) &#123;</div><div class=\"line\">                String cacheKey = request.getCacheKey();</div><div class=\"line\">                Queue&gt; waitingRequests = mWaitingRequests.remove(cacheKey);</div><div class=\"line\">                if (waitingRequests != null) &#123;</div><div class=\"line\">                    if (VolleyLog.DEBUG) &#123;</div><div class=\"line\">                        VolleyLog.v(&quot;Releasing %d waiting requests for cacheKey=%s.&quot;,</div><div class=\"line\">                                waitingRequests.size(), cacheKey);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    // Process all queued up requests. They won&apos;t be considered as in flight, but</div><div class=\"line\">                    // that&apos;s not a problem as the cache has been primed by &apos;request&apos;.</div><div class=\"line\">                    mCacheQueue.addAll(waitingRequests);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * 下面两个方法就是所谓注册监听器和取消注册的函数</div><div class=\"line\">     */</div><div class=\"line\">    public   void addRequestFinishedListener(RequestFinishedListener listener) &#123;</div><div class=\"line\">      synchronized (mFinishedListeners) &#123;</div><div class=\"line\">        mFinishedListeners.add(listener);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Remove a RequestFinishedListener. Has no effect if listener was not previously added.</div><div class=\"line\">     */</div><div class=\"line\">    public   void removeRequestFinishedListener(RequestFinishedListener listener) &#123;</div><div class=\"line\">      synchronized (mFinishedListeners) &#123;</div><div class=\"line\">        mFinishedListeners.remove(listener);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面介绍了Volley.java和RequestQueue.java两大类，Volley是对外的入口，而RequestQueue是Volley框架中最核心的部分了。如果注释上面有写错了或者有疑问的地方，还请各位直接指出在下一篇博客中将继续向下深入，结合源代码分析什么是Dispatcher。</p>"},{"title":"Volley框架解析-四-Network接口及其实现","date":"2017-03-20T15:34:06.000Z","_content":"\n## Volley框架解析(四)-----Network接口及其默认实现类解析\n\n### 1. 前言\n&#160;&#160;&#160;&#160;前面的三篇Volley框架解析文章已经从Volley对外暴露的接口Volley.java开始，向下慢慢深入到了RequestQueue.java，这个Volley中比较核心的类，然后又分析了Volley中负责主要request调度工作的两类Dispatcher，`NetworkDispatcher`以及`CacheDispatcher`。应该是将一个request从新建，到加入队列中等待处理，如何被处理以及返回结果或者error这一系列的流程理顺了。\n\n&#160;&#160;&#160;&#160;但是对于一些细节的问题还是不清楚，例如request究竟是如何发送出去，通过`NetworkResponse networkResponse = mNetwork.performRequest(request);`这么一句话就返回了结果(response)，这里面发生了些什么还不得而知，还有`Network#performRequest()`和`HttpStack#performRequest()`这两个函数之间有什么区别和联系等等。\n\n<!--more-->\n\n### [](#2-_Network-java \"2\\. Network.java\")2\\. Network.java\n\n&#160;&#160;&#160;&#160;最早接触到Network这个类是在`Volley.java`中的`newRequestQueue()`函数里面，`Network network = new BasicNetwork(stack);`创建了一个Network接口引用，并指向了一个Volley中的默认实现类的实例`BasicNetwork.java`，这个默认实现类也会在这篇博客的后面详细的解析。\n\n&#160;&#160;&#160;&#160;经过前面几篇博客的分析，`Volley.java`仅仅是持有而没有使用，仅将这个引用传递给了`NetworkDispatcher.java`中，只有在`NetworkDispatcher.java`类中用到了这个Network接口，在`NetowkrDispatcher.java`中存在着这么一行代码，\n\n```\nNetworkResponse networkResponse = mNetwork.performRequest(request);\n\n```\n\n&#160;&#160;&#160;&#160;仅仅用了一句话就将request发送出去了，并且还拿回来了一个`NetworkResponse.java`类对象。里面发生了什么= =，先进去Network.java里面看看：\n\n```\npackage com.android.volley;\n\n/**\n * An interface for performing requests.\n */\npublic interface Network {\n    /**\n     * Performs the specified request.\n     * 用来发送特定的请求\n     *\n     * @param request Request to process\n     * 即将被发送的request\n     *\n     * @return A {@link NetworkResponse} with data and caching metadata; will never be null\n     * 请求之后返回的response, 是volley自己构造出来的一个response\n     * 里面包含了返回的请求码等等。\n     *\n     * @throws VolleyError on errors\n     */\n    public NetworkResponse performRequest(Request<?> request) throws VolleyError;\n}\n\n```\n\n对，没有看错= =，就这么点东西，仅仅一个抽象方法而已，Network.java就是一个等待被实现的接口，想看真东西，还需要进去`Network network = new BasicNetwork(stack);`里面所提到的`BasicNetwork.java`看看。\n\n### [](#3-_BasicNetwork-java \"3\\. BasicNetwork.java\")3\\. BasicNetwork.java\n\n`Network.java`接口的默认实现类，该类里面会处理一些request发送前后的处理工作，主要是对请求返回的httpResponse处理，以及对请求失败进行retry或者抛出异常的处理。\n\n```\npackage com.android.volley.toolbox;\n\n/**\n * A network performing Volley requests over an {@link HttpStack}.\n * 一个用来执行Volley中request的类\n * 在HttpStack的基础之上\n * 因为主要还是调用HttpStack接口的performRequest\n * 在这个里面的performRequest主要还是做一些整理工作\n * 比如将｛@link HttpStack#performRequest()｝方法返回的HttpResponse\n * 解析成Volley自己实现的NetworkResponse.java\n */\n\npublic class BasicNetwork implements Network {\n\n    //是否允许打lo的boolean常变量\n    protected static final boolean DEBUG = VolleyLog.DEBUG;\n\n    /**\n     * 这是一个阀值，用来判断一个request是否请求响应过慢了= =\n     * 在后面的作用就是，如果响应时间超过了这个阀值\n     * 打出log说明这个request有些慢，为了更好的反应request当前状态\n     */\n    private static int SLOW_REQUEST_THRESHOLD_MS = 3000;\n\n    /**\n     * 默认ByteArrayPool的大小\n     * 现在只需要知道ByteArrayPool.java是Volley用来从输入流中读取数据并将其转换成字节数组的工具即可\n     * 在这篇博客后面会介绍，表担心~= =\n     */\n    private static int DEFAULT_POOL_SIZE = 4096;\n\n    /**\n     * 网络请求的真正接口\n     * 为什么这么说咧，BasicNetwork里面的performRequest()函数\n     * 调用了HttpStack里的performRequest()，真正的网络请求还是通过HttpStack里面的方法实现的\n     * 在Volley中实现了HttpStack接口的类有两个 HurlStack.java和HttpClientStack.java\n     * 针对了不同Android系统版本，用不同的方法实现了请求。\n     */\n    protected final HttpStack mHttpStack;\n\n    //表急，后面会介绍到的，现在知道是一个用于数据转换的工具类就好了\n    protected final ByteArrayPool mPool;\n\n    /**\n     * @param httpStack HTTP stack to be used\n     * 传入的HttpStack实现类引用\n     * 整个网络请求的较核心部分就在HttpStack实现类上面咯\n     */\n    public BasicNetwork(HttpStack httpStack) {\n        // If a pool isn't passed in, then build a small default pool that will give us a lot of\n        // benefit and not use too much memory.\n        this(httpStack, new ByteArrayPool(DEFAULT_POOL_SIZE));\n    }\n\n    /**\n     * @param httpStack HTTP stack to be used\n     * @param pool a buffer pool that improves GC performance in copy operations\n     * Volley接口分离的很明显，而且在构造函数里面也提供了很多种\n     * 可以定制出适合自己的ByteArrayPool衍生类\n     * 当然也可以自己来实现HttpStack的衍生类\n     */\n    public BasicNetwork(HttpStack httpStack, ByteArrayPool pool) {\n        mHttpStack = httpStack;\n        mPool = pool;\n    }\n\n    /**\n     * 这个方法重写的是Network的方法\n     * 在这个里面再调用HttpStack里面的performRequest方法\n     */\n    @Override\n    public NetworkResponse performRequest(Request<?> request) throws VolleyError {\n\n        /**\n         * Returns milliseconds since boot, including time spent in sleep.\n         * 为了方便计算每个request所用的时间\n         * 在处理每个request之前都记下此刻unix时间戳\n         */\n        long requestStart = SystemClock.elapsedRealtime();\n\n        /**\n         * 进入死循环= =\n         * 还没弄清楚为什么要死循环\n         */\n        while (true) {\n\n            /**\n             * 指向HttpResponse实例的引用\n             * 是调用HttpStack方法performRequest()之后返回的结果\n             */\n            HttpResponse httpResponse = null;\n\n            /**\n             * 返回的HttpResponse还需要经过处理\n             * 并不是返回回来就是能直接使用的数据\n             * 需要通过上面的ByteArrayPool将Entity转换成byte[]\n             * 这个就是指向解析后的byte[]的\n             */\n            byte[] responseContents = null;\n\n            //用来存放response里面header的信息，包含了状态码等\n            Map<String, String> responseHeaders = Collections.emptyMap();\n\n            try {\n                /**\n                 * Gather headers.\n                 * 设置header\n                 * 从缓存中收集上次相同request的信息\n                 */\n                Map<String, String> headers = new HashMap<String, String>();\n\n                /**\n                 * 将缓存的信息加入到headers中\n                 * headers会跟随request一起发送给服务器\n                 * 在函数的定义处会讲解\n                 */\n                addCacheHeaders(headers, request.getCacheEntry());\n\n                /**\n                 * 通过调用HttpStack接口的performRequest()方法\n                 * 获取服务器返回的HttpResponse\n                 */\n                httpResponse = mHttpStack.performRequest(request, headers);\n\n                /**\n                 * The first line of a Response message is the Status-Line, \n                 * consisting of the protocol version followed by a numeric status code and its associated textual phrase\n                 * with each element separated by SP characters. \n                 * No CR or LF is allowed except in the final CRLF sequence.\n                 * 请求返回的response第一行就是包含了状态码的一行\n                 */\n                StatusLine statusLine = httpResponse.getStatusLine();\n                int statusCode = statusLine.getStatusCode();\n\n                /**\n                 * 将头部解析成键值对的形式再返回\n                 */\n                responseHeaders = convertHeaders(httpResponse.getAllHeaders());\n\n                /**\n                 * Handle cache validation.\n                 * 处理缓存信息\n                 * 如果返回的状态码是304(HttpStatus.SC_NOT_MODIFIED)\n                 * 则进行如下的处理\n                 */\n                if (statusCode == HttpStatus.SC_NOT_MODIFIED) {\n\n                    /**\n                     * 如果缓存为空的话\n                     * 那就说明该请求的返回的response的body就是null\n                     * 直接构造一个NetworkResponse返回\n                     */\n                    Entry entry = request.getCacheEntry();\n                    if (entry == null) {\n                        return new NetworkResponse(HttpStatus.SC_NOT_MODIFIED, null,\n                                responseHeaders, true,\n                                SystemClock.elapsedRealtime() - requestStart);\n                    }\n\n                    // A HTTP 304 response does not have all header fields. We\n                    // have to use the header fields from the cache entry plus\n                    // the new ones from the response.\n                    // http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.5\n                    /**\n                     * 一个返回码为304的HttpResponse的header缺少一些信息\n                     * 需要我们将cache中的一些header信息加入到其中\n                     * 这样组成一个完整的NetworkResponse返回\n                     */\n                    entry.responseHeaders.putAll(responseHeaders);\n                    return new NetworkResponse(HttpStatus.SC_NOT_MODIFIED, entry.data,\n                            entry.responseHeaders, true,\n                            SystemClock.elapsedRealtime() - requestStart);\n                }\n\n                /**\n                 * Handle moved resources\n                 * 处理了重定向的问题\n                 * 并将request的mRedirectUrl设定成了新的url\n                 */\n                if (statusCode == HttpStatus.SC_MOVED_PERMANENTLY || statusCode == HttpStatus.SC_MOVED_TEMPORARILY) {\n                    String newUrl = responseHeaders.get(\"Location\");\n                    request.setRedirectUrl(newUrl);\n                }\n\n                /**\n                 * Some responses such as 204s do not have content.  We must check.\n                 * 204(无内容)服务器成功处理了请求，但没有返回任何内容。\n                 * \n                 */\n                if (httpResponse.getEntity() != null) {\n                    /**\n                     * 如果entity不为Null\n                     * 将其转换成byte数组\n                     * 利用之前提到过的ByteArrayPool.java类\n                     */\n                  responseContents = entityToBytes(httpResponse.getEntity());\n                } else {\n                  // Add 0 byte response as a way of honestly representing a\n                  // no-content request.\n                  responseContents = new byte[0];\n                }\n\n                /**\n                 * if the request is slow, log it.\n                 * 获取request已经占用的时间(requestLifetime)\n                 * 判断是否需要打出request的超时状态\n                 */\n                long requestLifetime = SystemClock.elapsedRealtime() - requestStart;\n                logSlowRequests(requestLifetime, request, responseContents, statusLine);\n\n                /**\n                 * 如果状态码位于200之下或者是299之上(200-299 用于表示请求成功)\n                 * 则抛出IOException异常= =为什么非要抛出这个异常\n                 * 在前面过滤掉了(304等情况)\n                 */\n                if (statusCode < 200 || statusCode > 299) {\n                    throw new IOException();\n                }\n\n                /**\n                 * 经过上面的层层过滤\n                 * 最后留下了200~299之间的请求成功response\n                 * 通过HttpResponse里面的信息构造出一个volley自己封装的NetworkResponse对象\n                 */\n                return new NetworkResponse(statusCode, responseContents, responseHeaders, false,\n                        SystemClock.elapsedRealtime() - requestStart);\n\n                /**\n                 * 抛出了异常之后，会用attemptREtryOnException()方法来尝试retry\n                 * 主要做的工作就是看是否还有retry的机会，如果有则不停通过这个死循环\n                 * 进行请求，直到请求成功或者请求的机会用完为止\n                 */\n            } catch (SocketTimeoutException e) {\n                attemptRetryOnException(\"socket\", request, new TimeoutError());\n            } catch (ConnectTimeoutException e) {·\n                attemptRetryOnException(\"connection\", request, new TimeoutError());\n            } catch (MalformedURLException e) {\n                throw new RuntimeException(\"Bad URL \" + request.getUrl(), e);\n            } catch (IOException e) {\n                /**\n                 * 状态码在0~200以及299之上的response\n                 * 处理的套路\n                 */\n                int statusCode = 0;\n                NetworkResponse networkResponse = null;\n                if (httpResponse != null) {\n                    statusCode = httpResponse.getStatusLine().getStatusCode();\n                } else {\n                    //如果状态码为0，则抛出NoConnectionError\n                    throw new NoConnectionError(e);\n                }\n                /**\n                 * 如果有重定向的情况发生\n                 * 用log打出\n                 */\n                if (statusCode == HttpStatus.SC_MOVED_PERMANENTLY || \n                        statusCode == HttpStatus.SC_MOVED_TEMPORARILY) {\n                    VolleyLog.e(\"Request at %s has been redirected to %s\", request.getOriginUrl(), request.getUrl());\n                } else {\n                    VolleyLog.e(\"Unexpected response code %d for %s\", statusCode, request.getUrl());\n                }\n\n                /**\n                 * 如果返回的content内容不为Null\n                 * 则构造出一个NetworkResponse\n                 * 否则抛出NetworkError\n                 */\n                if (responseContents != null) {\n\n                    networkResponse = new NetworkResponse(statusCode, responseContents,\n                            responseHeaders, false, SystemClock.elapsedRealtime() - requestStart);\n\n                    /**\n                     * 抛出了异常之后，会用attemptREtryOnException()方法来尝试retry\n                     * 主要做的工作就是看是否还有retry的机会，如果有则不停通过这个死循环\n                     * 进行请求，直到请求成功或者请求的机会用完为止\n                     */\n                    if (statusCode == HttpStatus.SC_UNAUTHORIZED ||\n                            statusCode == HttpStatus.SC_FORBIDDEN) {\n                        attemptRetryOnException(\"auth\",\n                                request, new AuthFailureError(networkResponse));\n                    } else if (statusCode == HttpStatus.SC_MOVED_PERMANENTLY || \n                                statusCode == HttpStatus.SC_MOVED_TEMPORARILY) {\n                        attemptRetryOnException(\"redirect\",\n                                request, new AuthFailureError(networkResponse));\n                    } else {\n                        // TODO: Only throw ServerError for 5xx status codes.\n                        throw new ServerError(networkResponse);\n                    }\n                } else {\n                    throw new NetworkError(networkResponse);\n                }\n            }\n        }\n    }\n\n    /**\n     * Logs requests that took over SLOW_REQUEST_THRESHOLD_MS to complete.\n     * 如果request用时超出了预先设定的阀值\n     * 则打出log用于debug时候的提示\n     */\n    private void logSlowRequests(long requestLifetime, Request<?> request,\n            byte[] responseContents, StatusLine statusLine) {\n        if (DEBUG || requestLifetime > SLOW_REQUEST_THRESHOLD_MS) {\n            VolleyLog.d(\"HTTP response for request=<%s> [lifetime=%d], [size=%s], \" +\n                    \"[rc=%d], [retryCount=%s]\", request, requestLifetime,\n                    responseContents != null ? responseContents.length : \"null\",\n                    statusLine.getStatusCode(), request.getRetryPolicy().getCurrentRetryCount());\n        }\n    }\n\n    /**\n     * Attempts to prepare the request for a retry. If there are no more attempts remaining in the\n     * request's retry policy, a timeout exception is thrown.\n     * 每次尝试都会使retry机会减少1，如果机会没有了，则抛出请求超时的exception\n     *\n     * @param request The request to use.\n     */\n    private static void attemptRetryOnException(String logPrefix, Request<?> request,\n            VolleyError exception) throws VolleyError {\n        RetryPolicy retryPolicy = request.getRetryPolicy();\n        int oldTimeout = request.getTimeoutMs();\n\n        try {\n            retryPolicy.retry(exception);\n        } catch (VolleyError e) {\n            request.addMarker(\n                    String.format(\"%s-timeout-giveup [timeout=%s]\", logPrefix, oldTimeout));\n            throw e;\n        }\n        request.addMarker(String.format(\"%s-retry [timeout=%s]\", logPrefix, oldTimeout));\n    }\n\n    /**\n     * 添加上缓存的header\n     * 如果有之前的缓存的信息\n     * 将里面的信息取出放入header中\n     * \n     * 这里面涉及到了一个条件请求\n     * 如果有缓存的话，header上面会带上一个If-Modified-Since关键字\n     * 服务器会先比较信息modified的时间，如果服务端的数据没有发生变化就返回304(也就是上面的 HttpStatus.SC_NOT_MODIFIED)\n     * 如果服务器的数据发生了变化，则会返回状态码200以及请求需要的数据(意思就是本地的数据需要刷新了，缓存不管用了)\n     */\n    private void addCacheHeaders(Map<String, String> headers, Cache.Entry entry) {\n        // If there's no cache entry, we're done.\n        if (entry == null) {\n            return;\n        }\n\n        if (entry.etag != null) {\n            headers.put(\"If-None-Match\", entry.etag);\n        }\n\n        if (entry.lastModified > 0) {\n            Date refTime = new Date(entry.lastModified);\n            headers.put(\"If-Modified-Since\", DateUtils.formatDate(refTime));\n        }\n    }\n\n    protected void logError(String what, String url, long start) {\n        long now = SystemClock.elapsedRealtime();\n        VolleyLog.v(\"HTTP ERROR(%s) %d ms to fetch %s\", what, (now - start), url);\n    }\n\n    /** \n     * Reads the contents of HttpEntity into a byte[].\n     * 从HttpEntity中读取数据，并通过ByteArrayPool将其转换成byte[]\n     * 暂时不用管太多= =，等后面介绍到ByteArrayPool.java的时候就会明白\n     */\n    private byte[] entityToBytes(HttpEntity entity) throws IOException, ServerError {\n\n        PoolingByteArrayOutputStream bytes =\n                new PoolingByteArrayOutputStream(mPool, (int) entity.getContentLength());\n\n        byte[] buffer = null;\n\n        try {\n            InputStream in = entity.getContent();\n            if (in == null) {\n                throw new ServerError();\n            }\n\n            /**\n             * 获取一个大小为1024的缓冲区\n             */\n            buffer = mPool.getBuf(1024);\n\n            int count;\n            //将content的内容通过流每次最大读出1024个byte, 全部读出并写入bytes\n            while ((count = in.read(buffer)) != -1) {\n                bytes.write(buffer, 0, count);\n            }\n            return bytes.toByteArray();\n        } finally {\n            try {\n                // Close the InputStream and release the resources by \"consuming the content\".\n                entity.consumeContent();\n            } catch (IOException e) {\n                // This can happen if there was an exception above that left the entity in\n                // an invalid state.\n                VolleyLog.v(\"Error occured when calling consumingContent\");\n            }\n            /**\n             * 在所有工作完成之后\n             * 需要将从mPool中拿出的buffer缓冲区回收\n             */\n            mPool.returnBuf(buffer);\n            bytes.close();\n        }\n    }\n\n    /**\n     * Converts Headers[] to Map<String, String>.\n     * 将返回的response里面的header[]\n     * 全部转换成Map里面的键值对形式\n     */\n    protected static Map<String, String> convertHeaders(Header[] headers) {\n        Map<String, String> result = new TreeMap<String, String>(String.CASE_INSENSITIVE_ORDER);\n        for (int i = 0; i < headers.length; i++) {\n            result.put(headers[i].getName(), headers[i].getValue());\n        }\n        return result;\n    }\n}\n\n```\n\n### [](#4-_ByteArrayPool-java \"4\\. ByteArrayPool.java\")4\\. ByteArrayPool.java\n\nByteArrayPool.java是用来将HttpResponse中Entity通过stream的形式转换成byte[],主要的作用是提供缓冲区，用来辅助流数据的读取，在使用完成之后需要将使用过的缓冲区还给ByteArrayPool，ByteArrayPool里会对这些byte[]进行简单的回收处理。\n\n```\n/**\n * 用来给外界提供byte[]作为缓冲区的一个工具类\n */\npublic class ByteArrayPool {\n    /**\n     * The buffer pool, arranged both by last use and by buffer size \n     */\n    private List<byte[]> mBuffersByLastUse = new LinkedList<byte[]>();\n    private List<byte[]> mBuffersBySize = new ArrayList<byte[]>(64);\n\n    /**\n     * The total size of the buffers in the pool\n     * 缓冲池的当前大小\n     */\n    private int mCurrentSize = 0;\n\n    /**\n     * The maximum aggregate size of the buffers in the pool. Old buffers are discarded to stay\n     * under this limit.\n     * 缓冲池当前的大小的阀值\n     * 超过了该值则会对缓冲池进行回收处理\n     */\n    private final int mSizeLimit;\n\n    /**\n     * Compares buffers by size\n     * 比较两个缓冲区的大小的规则\n     * 如果返回一个负数，则表示前一个数要小\n     * 如果返回0，则表示两个数字相等\n     * 如果返回一个正数，则表示后一个数要小\n     * \n     */\n    protected static final Comparator<byte[]> BUF_COMPARATOR = new Comparator<byte[]>() {\n        @Override\n        public int compare(byte[] lhs, byte[] rhs) {\n            return lhs.length - rhs.length;\n        }\n    };\n\n    /**\n     * @param sizeLimit the maximum size of the pool, in bytes\n     * 用来修改缓冲池的大小阀值\n     */\n    public ByteArrayPool(int sizeLimit) {\n        mSizeLimit = sizeLimit;\n    }\n\n    /**\n     * Returns a buffer from the pool if one is available in the requested size, or allocates a new\n     * one if a pooled one is not available.\n     * 从mBuffersBySize中调出一个缓冲区来\n     * 如果大小符合要求，则直接返回给调用者\n     * 如果没有符合要求的，直接创建一个新的byte[]返回\n     *\n     * @param len the minimum size, in bytes, of the requested buffer. The returned buffer may be\n     *        larger.\n     * @return a byte[] buffer is always returned.\n     */\n    public synchronized byte[] getBuf(int len) {\n        for (int i = 0; i < mBuffersBySize.size(); i++) {\n            byte[] buf = mBuffersBySize.get(i);\n            if (buf.length >= len) {\n                mCurrentSize -= buf.length;\n                mBuffersBySize.remove(i);\n                mBuffersByLastUse.remove(buf);\n                return buf;\n            }\n        }\n        return new byte[len];\n    }\n\n    /**\n     * Returns a buffer to the pool, throwing away old buffers if the pool would exceed its allotted\n     * size.\n     * \n     * @param buf the buffer to return to the pool.\n     */\n    public synchronized void returnBuf(byte[] buf) {\n\n        //如果buf为空或者超出了规定的大小，不管就行了，这种缓冲区用不着回收，因为= =根本就不符合要求嘛\n\n        if (buf == null || buf.length > mSizeLimit) {\n            return;\n        }\n\n        //如果buf符合要求，则将其加入到最近使用的队列中去\n\n        mBuffersByLastUse.add(buf);\n\n        /**\n         * 通过二分查找，比较规则为BUF_COMPARATOR，找出新进来的buf应该处于的位置\n         * 随后将buf插入到mBufferBySize的队列里面\n         */\n        int pos = Collections.binarySearch(mBuffersBySize, buf, BUF_COMPARATOR);\n        if (pos < 0) {\n            pos = -pos - 1;\n        }\n\n        mBuffersBySize.add(pos, buf);\n\n        //当前总缓冲区大小变大\n        mCurrentSize += buf.length;\n\n        //对整个缓冲池的大小做出调整\n        trim();\n    }\n\n    /**\n     * Removes buffers from the pool until it is under its size limit.\n     * 调整缓冲区的大小\n     * 直到mCurrentSize在限制大小之下\n     */\n    private synchronized void trim() {\n\n        while (mCurrentSize > mSizeLimit) {\n            byte[] buf = mBuffersByLastUse.remove(0);\n            mBuffersBySize.remove(buf);\n            mCurrentSize -= buf.length;\n        }\n    }\n\n}\n\n```\n\n### [](#5-_RetryPolicy-java \"5\\. RetryPolicy.java\")5\\. RetryPolicy.java\n\n在BasicNetwork.java这个类中，通过死循环加上try,catch的方式，不停的对一个request进行重复的处理，里面涉及到了`RetryPolicy.java`接口以及其默认实现类，这个接口是用来专门处理一个request在发送以及得到服务器响应返回结果的过程中出现的问题。通过有限次数的不断扩大request响应时间阀值，再次发送request的方式来达到一个retry的目的。和`Network.java`类似的，`RetryPolicy.java`也仅仅就是提供了抽象方法，想把具体的实现内容弄明白还需要去默认实现类`DefaultRetryPolicy.java`中去。\n\n```\npackage com.android.volley;\n\n/**\n * Retry policy for a request.\n * 该类用来管理request的调整及重新发送\n * 所谓调整就是将request响应时间(timeout)放宽\n */\npublic interface RetryPolicy {\n\n    /**\n     * Returns the current timeout (used for logging).\n     */\n    public int getCurrentTimeout();\n\n    /**\n     * Returns the current retry count (used for logging).\n     */\n    public int getCurrentRetryCount();\n\n    /**\n     * Prepares for the next retry by applying a backoff to the timeout.\n     * 为下一次request做好准备，通过不停地来放宽timeout时间限制\n     * 在DefaultRetryPolicy.java中好理解一些\n     * \n     * @param error The error code of the last attempt.\n     * @throws VolleyError In the event that the retry could not be performed (for example if we\n     * ran out of attempts), the passed in error is thrown.\n     */\n    public void retry(VolleyError error) throws VolleyError;\n}\n\n```\n\n### [](#6-_DefaultRetryPolicy-java \"6\\. DefaultRetryPolicy.java\")6\\. DefaultRetryPolicy.java\n\n`DefaultRetryPolicy.java`描述了对待Volley中涉及Network的request的策略方针，可以理解为重试策略方针，也就是对那些在网络请求失败的request处理方法。里面包含了retry的最大次数(`mMaxNumRetries`)，当前请求次数(`mCurrentRetryCount`)以及请求超时的时间阀值(`mCurrentTimeoutMs`)等。每个Request里面都包含了一个`RetryPolicy.java`实现类，在处理的时候可以通过`getRetryPolicy()`方法获得。\n\n```\npackage com.android.volley;\n\n/**\n * Default retry policy for requests.\n */\npublic class DefaultRetryPolicy implements RetryPolicy {\n    /** \n     * The current timeout in milliseconds. \n     * 请求超时的时间数\n     */\n    private int mCurrentTimeoutMs;\n\n    /** \n     * The current retry count.\n     * 当前请求的重试次数\n     */\n    private int mCurrentRetryCount;\n\n    /**\n     * The maximum number of attempts. \n     * 重复尝试的最大次数\n     **/\n    private final int mMaxNumRetries;\n\n    /**\n     * The backoff multiplier for the policy.\n     * 暂时不明白这个有什么用\n     * 根据后面的来看好像是一个用于放宽timeout时间限制的系数\n     * 这个系数越大每次retry的时候放宽的程度也就越大\n     */\n    private final float mBackoffMultiplier;\n\n    /** The default socket timeout in milliseconds */\n    public static final int DEFAULT_TIMEOUT_MS = 2500;\n\n    /** The default number of retries */\n    public static final int DEFAULT_MAX_RETRIES = 0;\n\n    /** The default backoff multiplier */\n    public static final float DEFAULT_BACKOFF_MULT = 1f;\n\n    /**\n     * Constructs a new retry policy using the default timeouts.\n     * 默认的构造器，2.5s的超时，\n     * 最大重试数为0，也就是request请求超时了就不要再自动重试了\n     */\n    public DefaultRetryPolicy() {\n        this(DEFAULT_TIMEOUT_MS, DEFAULT_MAX_RETRIES, DEFAULT_BACKOFF_MULT);\n    }\n\n    /**\n     * Constructs a new retry policy.\n     * @param initialTimeoutMs The initial timeout for the policy.\n     * @param maxNumRetries The maximum number of retries.\n     * @param backoffMultiplier Backoff multiplier for the policy.\n     */\n    public DefaultRetryPolicy(int initialTimeoutMs, int maxNumRetries, float backoffMultiplier) {\n        mCurrentTimeoutMs = initialTimeoutMs;\n        mMaxNumRetries = maxNumRetries;\n        mBackoffMultiplier = backoffMultiplier;\n    }\n\n    /**\n     * Returns the current timeout.\n     */\n    @Override\n    public int getCurrentTimeout() {\n        return mCurrentTimeoutMs;\n    }\n\n    /**\n     * Returns the current retry count.\n     */\n    @Override\n    public int getCurrentRetryCount() {\n        return mCurrentRetryCount;\n    }\n\n    /**\n     * Returns the backoff multiplier for the policy.\n     */\n    public float getBackoffMultiplier() {\n        return mBackoffMultiplier;\n    }\n\n    /**\n     * Prepares for the next retry by applying a backoff to the timeout.\n     * 该方法定义在RetryPolicy.java中。\n     * 为下一次重试request做准备，好像是通过延长服务器响应时间的限制 = =\n     * 每次对timeout的时间限制都放宽了mBackoffMultiplier个单位。让服务器多一点时间去响应\n     * \n     * @param error The error code of the last attempt.\n     * 最后一次request服务器给出的错误码\n     */\n    @Override\n    public void retry(VolleyError error) throws VolleyError {\n        mCurrentRetryCount++;\n        mCurrentTimeoutMs += (mCurrentTimeoutMs * mBackoffMultiplier);\n        if (!hasAttemptRemaining()) {\n            throw error;\n        }\n    }\n\n    /**\n     * Returns true if this policy has attempts remaining, false otherwise.\n     * 这个是用来判断是否还有retry机会的\n     */\n    protected boolean hasAttemptRemaining() {\n        return mCurrentRetryCount <= mMaxNumRetries;\n    }\n}\n\n```\n\n到这里对`Network.java`接口以及`RetryPolicy.java`接口的代码就分析完了，现在是清楚了在`NetworkDispatcher.java`调用了`mNetwork.performRequest()`之后发生了什么事情，还弄清楚了request在网络请求发送之后，出现了各种问题会怎么处理(重试策略)，但还不知道最核心的网络请求是如何发生的，也就是在`BasicNetwork.java`中的下面这行代码。\n\n```\nhttpResponse = mHttpStack.performRequest(request, headers);\n\n```\n\n这行代码就涉及到了后面的`HttpStack.java`接口及其两个实现类了。","source":"_posts/Volley框架解析-四-Network接口及其实现.md","raw":"---\ntitle: Volley框架解析-四-Network接口及其实现\ndate: 2017-03-20 23:34:06\ntags: volley\n\n---\n\n## Volley框架解析(四)-----Network接口及其默认实现类解析\n\n### 1. 前言\n&#160;&#160;&#160;&#160;前面的三篇Volley框架解析文章已经从Volley对外暴露的接口Volley.java开始，向下慢慢深入到了RequestQueue.java，这个Volley中比较核心的类，然后又分析了Volley中负责主要request调度工作的两类Dispatcher，`NetworkDispatcher`以及`CacheDispatcher`。应该是将一个request从新建，到加入队列中等待处理，如何被处理以及返回结果或者error这一系列的流程理顺了。\n\n&#160;&#160;&#160;&#160;但是对于一些细节的问题还是不清楚，例如request究竟是如何发送出去，通过`NetworkResponse networkResponse = mNetwork.performRequest(request);`这么一句话就返回了结果(response)，这里面发生了些什么还不得而知，还有`Network#performRequest()`和`HttpStack#performRequest()`这两个函数之间有什么区别和联系等等。\n\n<!--more-->\n\n### [](#2-_Network-java \"2\\. Network.java\")2\\. Network.java\n\n&#160;&#160;&#160;&#160;最早接触到Network这个类是在`Volley.java`中的`newRequestQueue()`函数里面，`Network network = new BasicNetwork(stack);`创建了一个Network接口引用，并指向了一个Volley中的默认实现类的实例`BasicNetwork.java`，这个默认实现类也会在这篇博客的后面详细的解析。\n\n&#160;&#160;&#160;&#160;经过前面几篇博客的分析，`Volley.java`仅仅是持有而没有使用，仅将这个引用传递给了`NetworkDispatcher.java`中，只有在`NetworkDispatcher.java`类中用到了这个Network接口，在`NetowkrDispatcher.java`中存在着这么一行代码，\n\n```\nNetworkResponse networkResponse = mNetwork.performRequest(request);\n\n```\n\n&#160;&#160;&#160;&#160;仅仅用了一句话就将request发送出去了，并且还拿回来了一个`NetworkResponse.java`类对象。里面发生了什么= =，先进去Network.java里面看看：\n\n```\npackage com.android.volley;\n\n/**\n * An interface for performing requests.\n */\npublic interface Network {\n    /**\n     * Performs the specified request.\n     * 用来发送特定的请求\n     *\n     * @param request Request to process\n     * 即将被发送的request\n     *\n     * @return A {@link NetworkResponse} with data and caching metadata; will never be null\n     * 请求之后返回的response, 是volley自己构造出来的一个response\n     * 里面包含了返回的请求码等等。\n     *\n     * @throws VolleyError on errors\n     */\n    public NetworkResponse performRequest(Request<?> request) throws VolleyError;\n}\n\n```\n\n对，没有看错= =，就这么点东西，仅仅一个抽象方法而已，Network.java就是一个等待被实现的接口，想看真东西，还需要进去`Network network = new BasicNetwork(stack);`里面所提到的`BasicNetwork.java`看看。\n\n### [](#3-_BasicNetwork-java \"3\\. BasicNetwork.java\")3\\. BasicNetwork.java\n\n`Network.java`接口的默认实现类，该类里面会处理一些request发送前后的处理工作，主要是对请求返回的httpResponse处理，以及对请求失败进行retry或者抛出异常的处理。\n\n```\npackage com.android.volley.toolbox;\n\n/**\n * A network performing Volley requests over an {@link HttpStack}.\n * 一个用来执行Volley中request的类\n * 在HttpStack的基础之上\n * 因为主要还是调用HttpStack接口的performRequest\n * 在这个里面的performRequest主要还是做一些整理工作\n * 比如将｛@link HttpStack#performRequest()｝方法返回的HttpResponse\n * 解析成Volley自己实现的NetworkResponse.java\n */\n\npublic class BasicNetwork implements Network {\n\n    //是否允许打lo的boolean常变量\n    protected static final boolean DEBUG = VolleyLog.DEBUG;\n\n    /**\n     * 这是一个阀值，用来判断一个request是否请求响应过慢了= =\n     * 在后面的作用就是，如果响应时间超过了这个阀值\n     * 打出log说明这个request有些慢，为了更好的反应request当前状态\n     */\n    private static int SLOW_REQUEST_THRESHOLD_MS = 3000;\n\n    /**\n     * 默认ByteArrayPool的大小\n     * 现在只需要知道ByteArrayPool.java是Volley用来从输入流中读取数据并将其转换成字节数组的工具即可\n     * 在这篇博客后面会介绍，表担心~= =\n     */\n    private static int DEFAULT_POOL_SIZE = 4096;\n\n    /**\n     * 网络请求的真正接口\n     * 为什么这么说咧，BasicNetwork里面的performRequest()函数\n     * 调用了HttpStack里的performRequest()，真正的网络请求还是通过HttpStack里面的方法实现的\n     * 在Volley中实现了HttpStack接口的类有两个 HurlStack.java和HttpClientStack.java\n     * 针对了不同Android系统版本，用不同的方法实现了请求。\n     */\n    protected final HttpStack mHttpStack;\n\n    //表急，后面会介绍到的，现在知道是一个用于数据转换的工具类就好了\n    protected final ByteArrayPool mPool;\n\n    /**\n     * @param httpStack HTTP stack to be used\n     * 传入的HttpStack实现类引用\n     * 整个网络请求的较核心部分就在HttpStack实现类上面咯\n     */\n    public BasicNetwork(HttpStack httpStack) {\n        // If a pool isn't passed in, then build a small default pool that will give us a lot of\n        // benefit and not use too much memory.\n        this(httpStack, new ByteArrayPool(DEFAULT_POOL_SIZE));\n    }\n\n    /**\n     * @param httpStack HTTP stack to be used\n     * @param pool a buffer pool that improves GC performance in copy operations\n     * Volley接口分离的很明显，而且在构造函数里面也提供了很多种\n     * 可以定制出适合自己的ByteArrayPool衍生类\n     * 当然也可以自己来实现HttpStack的衍生类\n     */\n    public BasicNetwork(HttpStack httpStack, ByteArrayPool pool) {\n        mHttpStack = httpStack;\n        mPool = pool;\n    }\n\n    /**\n     * 这个方法重写的是Network的方法\n     * 在这个里面再调用HttpStack里面的performRequest方法\n     */\n    @Override\n    public NetworkResponse performRequest(Request<?> request) throws VolleyError {\n\n        /**\n         * Returns milliseconds since boot, including time spent in sleep.\n         * 为了方便计算每个request所用的时间\n         * 在处理每个request之前都记下此刻unix时间戳\n         */\n        long requestStart = SystemClock.elapsedRealtime();\n\n        /**\n         * 进入死循环= =\n         * 还没弄清楚为什么要死循环\n         */\n        while (true) {\n\n            /**\n             * 指向HttpResponse实例的引用\n             * 是调用HttpStack方法performRequest()之后返回的结果\n             */\n            HttpResponse httpResponse = null;\n\n            /**\n             * 返回的HttpResponse还需要经过处理\n             * 并不是返回回来就是能直接使用的数据\n             * 需要通过上面的ByteArrayPool将Entity转换成byte[]\n             * 这个就是指向解析后的byte[]的\n             */\n            byte[] responseContents = null;\n\n            //用来存放response里面header的信息，包含了状态码等\n            Map<String, String> responseHeaders = Collections.emptyMap();\n\n            try {\n                /**\n                 * Gather headers.\n                 * 设置header\n                 * 从缓存中收集上次相同request的信息\n                 */\n                Map<String, String> headers = new HashMap<String, String>();\n\n                /**\n                 * 将缓存的信息加入到headers中\n                 * headers会跟随request一起发送给服务器\n                 * 在函数的定义处会讲解\n                 */\n                addCacheHeaders(headers, request.getCacheEntry());\n\n                /**\n                 * 通过调用HttpStack接口的performRequest()方法\n                 * 获取服务器返回的HttpResponse\n                 */\n                httpResponse = mHttpStack.performRequest(request, headers);\n\n                /**\n                 * The first line of a Response message is the Status-Line, \n                 * consisting of the protocol version followed by a numeric status code and its associated textual phrase\n                 * with each element separated by SP characters. \n                 * No CR or LF is allowed except in the final CRLF sequence.\n                 * 请求返回的response第一行就是包含了状态码的一行\n                 */\n                StatusLine statusLine = httpResponse.getStatusLine();\n                int statusCode = statusLine.getStatusCode();\n\n                /**\n                 * 将头部解析成键值对的形式再返回\n                 */\n                responseHeaders = convertHeaders(httpResponse.getAllHeaders());\n\n                /**\n                 * Handle cache validation.\n                 * 处理缓存信息\n                 * 如果返回的状态码是304(HttpStatus.SC_NOT_MODIFIED)\n                 * 则进行如下的处理\n                 */\n                if (statusCode == HttpStatus.SC_NOT_MODIFIED) {\n\n                    /**\n                     * 如果缓存为空的话\n                     * 那就说明该请求的返回的response的body就是null\n                     * 直接构造一个NetworkResponse返回\n                     */\n                    Entry entry = request.getCacheEntry();\n                    if (entry == null) {\n                        return new NetworkResponse(HttpStatus.SC_NOT_MODIFIED, null,\n                                responseHeaders, true,\n                                SystemClock.elapsedRealtime() - requestStart);\n                    }\n\n                    // A HTTP 304 response does not have all header fields. We\n                    // have to use the header fields from the cache entry plus\n                    // the new ones from the response.\n                    // http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.5\n                    /**\n                     * 一个返回码为304的HttpResponse的header缺少一些信息\n                     * 需要我们将cache中的一些header信息加入到其中\n                     * 这样组成一个完整的NetworkResponse返回\n                     */\n                    entry.responseHeaders.putAll(responseHeaders);\n                    return new NetworkResponse(HttpStatus.SC_NOT_MODIFIED, entry.data,\n                            entry.responseHeaders, true,\n                            SystemClock.elapsedRealtime() - requestStart);\n                }\n\n                /**\n                 * Handle moved resources\n                 * 处理了重定向的问题\n                 * 并将request的mRedirectUrl设定成了新的url\n                 */\n                if (statusCode == HttpStatus.SC_MOVED_PERMANENTLY || statusCode == HttpStatus.SC_MOVED_TEMPORARILY) {\n                    String newUrl = responseHeaders.get(\"Location\");\n                    request.setRedirectUrl(newUrl);\n                }\n\n                /**\n                 * Some responses such as 204s do not have content.  We must check.\n                 * 204(无内容)服务器成功处理了请求，但没有返回任何内容。\n                 * \n                 */\n                if (httpResponse.getEntity() != null) {\n                    /**\n                     * 如果entity不为Null\n                     * 将其转换成byte数组\n                     * 利用之前提到过的ByteArrayPool.java类\n                     */\n                  responseContents = entityToBytes(httpResponse.getEntity());\n                } else {\n                  // Add 0 byte response as a way of honestly representing a\n                  // no-content request.\n                  responseContents = new byte[0];\n                }\n\n                /**\n                 * if the request is slow, log it.\n                 * 获取request已经占用的时间(requestLifetime)\n                 * 判断是否需要打出request的超时状态\n                 */\n                long requestLifetime = SystemClock.elapsedRealtime() - requestStart;\n                logSlowRequests(requestLifetime, request, responseContents, statusLine);\n\n                /**\n                 * 如果状态码位于200之下或者是299之上(200-299 用于表示请求成功)\n                 * 则抛出IOException异常= =为什么非要抛出这个异常\n                 * 在前面过滤掉了(304等情况)\n                 */\n                if (statusCode < 200 || statusCode > 299) {\n                    throw new IOException();\n                }\n\n                /**\n                 * 经过上面的层层过滤\n                 * 最后留下了200~299之间的请求成功response\n                 * 通过HttpResponse里面的信息构造出一个volley自己封装的NetworkResponse对象\n                 */\n                return new NetworkResponse(statusCode, responseContents, responseHeaders, false,\n                        SystemClock.elapsedRealtime() - requestStart);\n\n                /**\n                 * 抛出了异常之后，会用attemptREtryOnException()方法来尝试retry\n                 * 主要做的工作就是看是否还有retry的机会，如果有则不停通过这个死循环\n                 * 进行请求，直到请求成功或者请求的机会用完为止\n                 */\n            } catch (SocketTimeoutException e) {\n                attemptRetryOnException(\"socket\", request, new TimeoutError());\n            } catch (ConnectTimeoutException e) {·\n                attemptRetryOnException(\"connection\", request, new TimeoutError());\n            } catch (MalformedURLException e) {\n                throw new RuntimeException(\"Bad URL \" + request.getUrl(), e);\n            } catch (IOException e) {\n                /**\n                 * 状态码在0~200以及299之上的response\n                 * 处理的套路\n                 */\n                int statusCode = 0;\n                NetworkResponse networkResponse = null;\n                if (httpResponse != null) {\n                    statusCode = httpResponse.getStatusLine().getStatusCode();\n                } else {\n                    //如果状态码为0，则抛出NoConnectionError\n                    throw new NoConnectionError(e);\n                }\n                /**\n                 * 如果有重定向的情况发生\n                 * 用log打出\n                 */\n                if (statusCode == HttpStatus.SC_MOVED_PERMANENTLY || \n                        statusCode == HttpStatus.SC_MOVED_TEMPORARILY) {\n                    VolleyLog.e(\"Request at %s has been redirected to %s\", request.getOriginUrl(), request.getUrl());\n                } else {\n                    VolleyLog.e(\"Unexpected response code %d for %s\", statusCode, request.getUrl());\n                }\n\n                /**\n                 * 如果返回的content内容不为Null\n                 * 则构造出一个NetworkResponse\n                 * 否则抛出NetworkError\n                 */\n                if (responseContents != null) {\n\n                    networkResponse = new NetworkResponse(statusCode, responseContents,\n                            responseHeaders, false, SystemClock.elapsedRealtime() - requestStart);\n\n                    /**\n                     * 抛出了异常之后，会用attemptREtryOnException()方法来尝试retry\n                     * 主要做的工作就是看是否还有retry的机会，如果有则不停通过这个死循环\n                     * 进行请求，直到请求成功或者请求的机会用完为止\n                     */\n                    if (statusCode == HttpStatus.SC_UNAUTHORIZED ||\n                            statusCode == HttpStatus.SC_FORBIDDEN) {\n                        attemptRetryOnException(\"auth\",\n                                request, new AuthFailureError(networkResponse));\n                    } else if (statusCode == HttpStatus.SC_MOVED_PERMANENTLY || \n                                statusCode == HttpStatus.SC_MOVED_TEMPORARILY) {\n                        attemptRetryOnException(\"redirect\",\n                                request, new AuthFailureError(networkResponse));\n                    } else {\n                        // TODO: Only throw ServerError for 5xx status codes.\n                        throw new ServerError(networkResponse);\n                    }\n                } else {\n                    throw new NetworkError(networkResponse);\n                }\n            }\n        }\n    }\n\n    /**\n     * Logs requests that took over SLOW_REQUEST_THRESHOLD_MS to complete.\n     * 如果request用时超出了预先设定的阀值\n     * 则打出log用于debug时候的提示\n     */\n    private void logSlowRequests(long requestLifetime, Request<?> request,\n            byte[] responseContents, StatusLine statusLine) {\n        if (DEBUG || requestLifetime > SLOW_REQUEST_THRESHOLD_MS) {\n            VolleyLog.d(\"HTTP response for request=<%s> [lifetime=%d], [size=%s], \" +\n                    \"[rc=%d], [retryCount=%s]\", request, requestLifetime,\n                    responseContents != null ? responseContents.length : \"null\",\n                    statusLine.getStatusCode(), request.getRetryPolicy().getCurrentRetryCount());\n        }\n    }\n\n    /**\n     * Attempts to prepare the request for a retry. If there are no more attempts remaining in the\n     * request's retry policy, a timeout exception is thrown.\n     * 每次尝试都会使retry机会减少1，如果机会没有了，则抛出请求超时的exception\n     *\n     * @param request The request to use.\n     */\n    private static void attemptRetryOnException(String logPrefix, Request<?> request,\n            VolleyError exception) throws VolleyError {\n        RetryPolicy retryPolicy = request.getRetryPolicy();\n        int oldTimeout = request.getTimeoutMs();\n\n        try {\n            retryPolicy.retry(exception);\n        } catch (VolleyError e) {\n            request.addMarker(\n                    String.format(\"%s-timeout-giveup [timeout=%s]\", logPrefix, oldTimeout));\n            throw e;\n        }\n        request.addMarker(String.format(\"%s-retry [timeout=%s]\", logPrefix, oldTimeout));\n    }\n\n    /**\n     * 添加上缓存的header\n     * 如果有之前的缓存的信息\n     * 将里面的信息取出放入header中\n     * \n     * 这里面涉及到了一个条件请求\n     * 如果有缓存的话，header上面会带上一个If-Modified-Since关键字\n     * 服务器会先比较信息modified的时间，如果服务端的数据没有发生变化就返回304(也就是上面的 HttpStatus.SC_NOT_MODIFIED)\n     * 如果服务器的数据发生了变化，则会返回状态码200以及请求需要的数据(意思就是本地的数据需要刷新了，缓存不管用了)\n     */\n    private void addCacheHeaders(Map<String, String> headers, Cache.Entry entry) {\n        // If there's no cache entry, we're done.\n        if (entry == null) {\n            return;\n        }\n\n        if (entry.etag != null) {\n            headers.put(\"If-None-Match\", entry.etag);\n        }\n\n        if (entry.lastModified > 0) {\n            Date refTime = new Date(entry.lastModified);\n            headers.put(\"If-Modified-Since\", DateUtils.formatDate(refTime));\n        }\n    }\n\n    protected void logError(String what, String url, long start) {\n        long now = SystemClock.elapsedRealtime();\n        VolleyLog.v(\"HTTP ERROR(%s) %d ms to fetch %s\", what, (now - start), url);\n    }\n\n    /** \n     * Reads the contents of HttpEntity into a byte[].\n     * 从HttpEntity中读取数据，并通过ByteArrayPool将其转换成byte[]\n     * 暂时不用管太多= =，等后面介绍到ByteArrayPool.java的时候就会明白\n     */\n    private byte[] entityToBytes(HttpEntity entity) throws IOException, ServerError {\n\n        PoolingByteArrayOutputStream bytes =\n                new PoolingByteArrayOutputStream(mPool, (int) entity.getContentLength());\n\n        byte[] buffer = null;\n\n        try {\n            InputStream in = entity.getContent();\n            if (in == null) {\n                throw new ServerError();\n            }\n\n            /**\n             * 获取一个大小为1024的缓冲区\n             */\n            buffer = mPool.getBuf(1024);\n\n            int count;\n            //将content的内容通过流每次最大读出1024个byte, 全部读出并写入bytes\n            while ((count = in.read(buffer)) != -1) {\n                bytes.write(buffer, 0, count);\n            }\n            return bytes.toByteArray();\n        } finally {\n            try {\n                // Close the InputStream and release the resources by \"consuming the content\".\n                entity.consumeContent();\n            } catch (IOException e) {\n                // This can happen if there was an exception above that left the entity in\n                // an invalid state.\n                VolleyLog.v(\"Error occured when calling consumingContent\");\n            }\n            /**\n             * 在所有工作完成之后\n             * 需要将从mPool中拿出的buffer缓冲区回收\n             */\n            mPool.returnBuf(buffer);\n            bytes.close();\n        }\n    }\n\n    /**\n     * Converts Headers[] to Map<String, String>.\n     * 将返回的response里面的header[]\n     * 全部转换成Map里面的键值对形式\n     */\n    protected static Map<String, String> convertHeaders(Header[] headers) {\n        Map<String, String> result = new TreeMap<String, String>(String.CASE_INSENSITIVE_ORDER);\n        for (int i = 0; i < headers.length; i++) {\n            result.put(headers[i].getName(), headers[i].getValue());\n        }\n        return result;\n    }\n}\n\n```\n\n### [](#4-_ByteArrayPool-java \"4\\. ByteArrayPool.java\")4\\. ByteArrayPool.java\n\nByteArrayPool.java是用来将HttpResponse中Entity通过stream的形式转换成byte[],主要的作用是提供缓冲区，用来辅助流数据的读取，在使用完成之后需要将使用过的缓冲区还给ByteArrayPool，ByteArrayPool里会对这些byte[]进行简单的回收处理。\n\n```\n/**\n * 用来给外界提供byte[]作为缓冲区的一个工具类\n */\npublic class ByteArrayPool {\n    /**\n     * The buffer pool, arranged both by last use and by buffer size \n     */\n    private List<byte[]> mBuffersByLastUse = new LinkedList<byte[]>();\n    private List<byte[]> mBuffersBySize = new ArrayList<byte[]>(64);\n\n    /**\n     * The total size of the buffers in the pool\n     * 缓冲池的当前大小\n     */\n    private int mCurrentSize = 0;\n\n    /**\n     * The maximum aggregate size of the buffers in the pool. Old buffers are discarded to stay\n     * under this limit.\n     * 缓冲池当前的大小的阀值\n     * 超过了该值则会对缓冲池进行回收处理\n     */\n    private final int mSizeLimit;\n\n    /**\n     * Compares buffers by size\n     * 比较两个缓冲区的大小的规则\n     * 如果返回一个负数，则表示前一个数要小\n     * 如果返回0，则表示两个数字相等\n     * 如果返回一个正数，则表示后一个数要小\n     * \n     */\n    protected static final Comparator<byte[]> BUF_COMPARATOR = new Comparator<byte[]>() {\n        @Override\n        public int compare(byte[] lhs, byte[] rhs) {\n            return lhs.length - rhs.length;\n        }\n    };\n\n    /**\n     * @param sizeLimit the maximum size of the pool, in bytes\n     * 用来修改缓冲池的大小阀值\n     */\n    public ByteArrayPool(int sizeLimit) {\n        mSizeLimit = sizeLimit;\n    }\n\n    /**\n     * Returns a buffer from the pool if one is available in the requested size, or allocates a new\n     * one if a pooled one is not available.\n     * 从mBuffersBySize中调出一个缓冲区来\n     * 如果大小符合要求，则直接返回给调用者\n     * 如果没有符合要求的，直接创建一个新的byte[]返回\n     *\n     * @param len the minimum size, in bytes, of the requested buffer. The returned buffer may be\n     *        larger.\n     * @return a byte[] buffer is always returned.\n     */\n    public synchronized byte[] getBuf(int len) {\n        for (int i = 0; i < mBuffersBySize.size(); i++) {\n            byte[] buf = mBuffersBySize.get(i);\n            if (buf.length >= len) {\n                mCurrentSize -= buf.length;\n                mBuffersBySize.remove(i);\n                mBuffersByLastUse.remove(buf);\n                return buf;\n            }\n        }\n        return new byte[len];\n    }\n\n    /**\n     * Returns a buffer to the pool, throwing away old buffers if the pool would exceed its allotted\n     * size.\n     * \n     * @param buf the buffer to return to the pool.\n     */\n    public synchronized void returnBuf(byte[] buf) {\n\n        //如果buf为空或者超出了规定的大小，不管就行了，这种缓冲区用不着回收，因为= =根本就不符合要求嘛\n\n        if (buf == null || buf.length > mSizeLimit) {\n            return;\n        }\n\n        //如果buf符合要求，则将其加入到最近使用的队列中去\n\n        mBuffersByLastUse.add(buf);\n\n        /**\n         * 通过二分查找，比较规则为BUF_COMPARATOR，找出新进来的buf应该处于的位置\n         * 随后将buf插入到mBufferBySize的队列里面\n         */\n        int pos = Collections.binarySearch(mBuffersBySize, buf, BUF_COMPARATOR);\n        if (pos < 0) {\n            pos = -pos - 1;\n        }\n\n        mBuffersBySize.add(pos, buf);\n\n        //当前总缓冲区大小变大\n        mCurrentSize += buf.length;\n\n        //对整个缓冲池的大小做出调整\n        trim();\n    }\n\n    /**\n     * Removes buffers from the pool until it is under its size limit.\n     * 调整缓冲区的大小\n     * 直到mCurrentSize在限制大小之下\n     */\n    private synchronized void trim() {\n\n        while (mCurrentSize > mSizeLimit) {\n            byte[] buf = mBuffersByLastUse.remove(0);\n            mBuffersBySize.remove(buf);\n            mCurrentSize -= buf.length;\n        }\n    }\n\n}\n\n```\n\n### [](#5-_RetryPolicy-java \"5\\. RetryPolicy.java\")5\\. RetryPolicy.java\n\n在BasicNetwork.java这个类中，通过死循环加上try,catch的方式，不停的对一个request进行重复的处理，里面涉及到了`RetryPolicy.java`接口以及其默认实现类，这个接口是用来专门处理一个request在发送以及得到服务器响应返回结果的过程中出现的问题。通过有限次数的不断扩大request响应时间阀值，再次发送request的方式来达到一个retry的目的。和`Network.java`类似的，`RetryPolicy.java`也仅仅就是提供了抽象方法，想把具体的实现内容弄明白还需要去默认实现类`DefaultRetryPolicy.java`中去。\n\n```\npackage com.android.volley;\n\n/**\n * Retry policy for a request.\n * 该类用来管理request的调整及重新发送\n * 所谓调整就是将request响应时间(timeout)放宽\n */\npublic interface RetryPolicy {\n\n    /**\n     * Returns the current timeout (used for logging).\n     */\n    public int getCurrentTimeout();\n\n    /**\n     * Returns the current retry count (used for logging).\n     */\n    public int getCurrentRetryCount();\n\n    /**\n     * Prepares for the next retry by applying a backoff to the timeout.\n     * 为下一次request做好准备，通过不停地来放宽timeout时间限制\n     * 在DefaultRetryPolicy.java中好理解一些\n     * \n     * @param error The error code of the last attempt.\n     * @throws VolleyError In the event that the retry could not be performed (for example if we\n     * ran out of attempts), the passed in error is thrown.\n     */\n    public void retry(VolleyError error) throws VolleyError;\n}\n\n```\n\n### [](#6-_DefaultRetryPolicy-java \"6\\. DefaultRetryPolicy.java\")6\\. DefaultRetryPolicy.java\n\n`DefaultRetryPolicy.java`描述了对待Volley中涉及Network的request的策略方针，可以理解为重试策略方针，也就是对那些在网络请求失败的request处理方法。里面包含了retry的最大次数(`mMaxNumRetries`)，当前请求次数(`mCurrentRetryCount`)以及请求超时的时间阀值(`mCurrentTimeoutMs`)等。每个Request里面都包含了一个`RetryPolicy.java`实现类，在处理的时候可以通过`getRetryPolicy()`方法获得。\n\n```\npackage com.android.volley;\n\n/**\n * Default retry policy for requests.\n */\npublic class DefaultRetryPolicy implements RetryPolicy {\n    /** \n     * The current timeout in milliseconds. \n     * 请求超时的时间数\n     */\n    private int mCurrentTimeoutMs;\n\n    /** \n     * The current retry count.\n     * 当前请求的重试次数\n     */\n    private int mCurrentRetryCount;\n\n    /**\n     * The maximum number of attempts. \n     * 重复尝试的最大次数\n     **/\n    private final int mMaxNumRetries;\n\n    /**\n     * The backoff multiplier for the policy.\n     * 暂时不明白这个有什么用\n     * 根据后面的来看好像是一个用于放宽timeout时间限制的系数\n     * 这个系数越大每次retry的时候放宽的程度也就越大\n     */\n    private final float mBackoffMultiplier;\n\n    /** The default socket timeout in milliseconds */\n    public static final int DEFAULT_TIMEOUT_MS = 2500;\n\n    /** The default number of retries */\n    public static final int DEFAULT_MAX_RETRIES = 0;\n\n    /** The default backoff multiplier */\n    public static final float DEFAULT_BACKOFF_MULT = 1f;\n\n    /**\n     * Constructs a new retry policy using the default timeouts.\n     * 默认的构造器，2.5s的超时，\n     * 最大重试数为0，也就是request请求超时了就不要再自动重试了\n     */\n    public DefaultRetryPolicy() {\n        this(DEFAULT_TIMEOUT_MS, DEFAULT_MAX_RETRIES, DEFAULT_BACKOFF_MULT);\n    }\n\n    /**\n     * Constructs a new retry policy.\n     * @param initialTimeoutMs The initial timeout for the policy.\n     * @param maxNumRetries The maximum number of retries.\n     * @param backoffMultiplier Backoff multiplier for the policy.\n     */\n    public DefaultRetryPolicy(int initialTimeoutMs, int maxNumRetries, float backoffMultiplier) {\n        mCurrentTimeoutMs = initialTimeoutMs;\n        mMaxNumRetries = maxNumRetries;\n        mBackoffMultiplier = backoffMultiplier;\n    }\n\n    /**\n     * Returns the current timeout.\n     */\n    @Override\n    public int getCurrentTimeout() {\n        return mCurrentTimeoutMs;\n    }\n\n    /**\n     * Returns the current retry count.\n     */\n    @Override\n    public int getCurrentRetryCount() {\n        return mCurrentRetryCount;\n    }\n\n    /**\n     * Returns the backoff multiplier for the policy.\n     */\n    public float getBackoffMultiplier() {\n        return mBackoffMultiplier;\n    }\n\n    /**\n     * Prepares for the next retry by applying a backoff to the timeout.\n     * 该方法定义在RetryPolicy.java中。\n     * 为下一次重试request做准备，好像是通过延长服务器响应时间的限制 = =\n     * 每次对timeout的时间限制都放宽了mBackoffMultiplier个单位。让服务器多一点时间去响应\n     * \n     * @param error The error code of the last attempt.\n     * 最后一次request服务器给出的错误码\n     */\n    @Override\n    public void retry(VolleyError error) throws VolleyError {\n        mCurrentRetryCount++;\n        mCurrentTimeoutMs += (mCurrentTimeoutMs * mBackoffMultiplier);\n        if (!hasAttemptRemaining()) {\n            throw error;\n        }\n    }\n\n    /**\n     * Returns true if this policy has attempts remaining, false otherwise.\n     * 这个是用来判断是否还有retry机会的\n     */\n    protected boolean hasAttemptRemaining() {\n        return mCurrentRetryCount <= mMaxNumRetries;\n    }\n}\n\n```\n\n到这里对`Network.java`接口以及`RetryPolicy.java`接口的代码就分析完了，现在是清楚了在`NetworkDispatcher.java`调用了`mNetwork.performRequest()`之后发生了什么事情，还弄清楚了request在网络请求发送之后，出现了各种问题会怎么处理(重试策略)，但还不知道最核心的网络请求是如何发生的，也就是在`BasicNetwork.java`中的下面这行代码。\n\n```\nhttpResponse = mHttpStack.performRequest(request, headers);\n\n```\n\n这行代码就涉及到了后面的`HttpStack.java`接口及其两个实现类了。","slug":"Volley框架解析-四-Network接口及其实现","published":1,"updated":"2017-03-21T06:38:09.107Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0xtcupr000ck2j9q0qv8opc","content":"<h2 id=\"Volley框架解析-四-—–Network接口及其默认实现类解析\"><a href=\"#Volley框架解析-四-—–Network接口及其默认实现类解析\" class=\"headerlink\" title=\"Volley框架解析(四)—–Network接口及其默认实现类解析\"></a>Volley框架解析(四)—–Network接口及其默认实现类解析</h2><h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h3><p>&#160;&#160;&#160;&#160;前面的三篇Volley框架解析文章已经从Volley对外暴露的接口Volley.java开始，向下慢慢深入到了RequestQueue.java，这个Volley中比较核心的类，然后又分析了Volley中负责主要request调度工作的两类Dispatcher，<code>NetworkDispatcher</code>以及<code>CacheDispatcher</code>。应该是将一个request从新建，到加入队列中等待处理，如何被处理以及返回结果或者error这一系列的流程理顺了。</p>\n<p>&#160;&#160;&#160;&#160;但是对于一些细节的问题还是不清楚，例如request究竟是如何发送出去，通过<code>NetworkResponse networkResponse = mNetwork.performRequest(request);</code>这么一句话就返回了结果(response)，这里面发生了些什么还不得而知，还有<code>Network#performRequest()</code>和<code>HttpStack#performRequest()</code>这两个函数之间有什么区别和联系等等。</p>\n<a id=\"more\"></a>\n<h3 id=\"2-Network-java\"><a href=\"#2-Network-java\" class=\"headerlink\" title=\"2. Network.java\"></a><a href=\"#2-_Network-java\" title=\"2\\. Network.java\"></a>2. Network.java</h3><p>&#160;&#160;&#160;&#160;最早接触到Network这个类是在<code>Volley.java</code>中的<code>newRequestQueue()</code>函数里面，<code>Network network = new BasicNetwork(stack);</code>创建了一个Network接口引用，并指向了一个Volley中的默认实现类的实例<code>BasicNetwork.java</code>，这个默认实现类也会在这篇博客的后面详细的解析。</p>\n<p>&#160;&#160;&#160;&#160;经过前面几篇博客的分析，<code>Volley.java</code>仅仅是持有而没有使用，仅将这个引用传递给了<code>NetworkDispatcher.java</code>中，只有在<code>NetworkDispatcher.java</code>类中用到了这个Network接口，在<code>NetowkrDispatcher.java</code>中存在着这么一行代码，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">NetworkResponse networkResponse = mNetwork.performRequest(request);</div></pre></td></tr></table></figure>\n<p>&#160;&#160;&#160;&#160;仅仅用了一句话就将request发送出去了，并且还拿回来了一个<code>NetworkResponse.java</code>类对象。里面发生了什么= =，先进去Network.java里面看看：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">package com.android.volley;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\"> * An interface for performing requests.</div><div class=\"line\"> */</div><div class=\"line\">public interface Network &#123;</div><div class=\"line\">    /**</div><div class=\"line\">     * Performs the specified request.</div><div class=\"line\">     * 用来发送特定的请求</div><div class=\"line\">     *</div><div class=\"line\">     * @param request Request to process</div><div class=\"line\">     * 即将被发送的request</div><div class=\"line\">     *</div><div class=\"line\">     * @return A &#123;@link NetworkResponse&#125; with data and caching metadata; will never be null</div><div class=\"line\">     * 请求之后返回的response, 是volley自己构造出来的一个response</div><div class=\"line\">     * 里面包含了返回的请求码等等。</div><div class=\"line\">     *</div><div class=\"line\">     * @throws VolleyError on errors</div><div class=\"line\">     */</div><div class=\"line\">    public NetworkResponse performRequest(Request&lt;?&gt; request) throws VolleyError;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>对，没有看错= =，就这么点东西，仅仅一个抽象方法而已，Network.java就是一个等待被实现的接口，想看真东西，还需要进去<code>Network network = new BasicNetwork(stack);</code>里面所提到的<code>BasicNetwork.java</code>看看。</p>\n<h3 id=\"3-BasicNetwork-java\"><a href=\"#3-BasicNetwork-java\" class=\"headerlink\" title=\"3. BasicNetwork.java\"></a><a href=\"#3-_BasicNetwork-java\" title=\"3\\. BasicNetwork.java\"></a>3. BasicNetwork.java</h3><p><code>Network.java</code>接口的默认实现类，该类里面会处理一些request发送前后的处理工作，主要是对请求返回的httpResponse处理，以及对请求失败进行retry或者抛出异常的处理。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div><div class=\"line\">204</div><div class=\"line\">205</div><div class=\"line\">206</div><div class=\"line\">207</div><div class=\"line\">208</div><div class=\"line\">209</div><div class=\"line\">210</div><div class=\"line\">211</div><div class=\"line\">212</div><div class=\"line\">213</div><div class=\"line\">214</div><div class=\"line\">215</div><div class=\"line\">216</div><div class=\"line\">217</div><div class=\"line\">218</div><div class=\"line\">219</div><div class=\"line\">220</div><div class=\"line\">221</div><div class=\"line\">222</div><div class=\"line\">223</div><div class=\"line\">224</div><div class=\"line\">225</div><div class=\"line\">226</div><div class=\"line\">227</div><div class=\"line\">228</div><div class=\"line\">229</div><div class=\"line\">230</div><div class=\"line\">231</div><div class=\"line\">232</div><div class=\"line\">233</div><div class=\"line\">234</div><div class=\"line\">235</div><div class=\"line\">236</div><div class=\"line\">237</div><div class=\"line\">238</div><div class=\"line\">239</div><div class=\"line\">240</div><div class=\"line\">241</div><div class=\"line\">242</div><div class=\"line\">243</div><div class=\"line\">244</div><div class=\"line\">245</div><div class=\"line\">246</div><div class=\"line\">247</div><div class=\"line\">248</div><div class=\"line\">249</div><div class=\"line\">250</div><div class=\"line\">251</div><div class=\"line\">252</div><div class=\"line\">253</div><div class=\"line\">254</div><div class=\"line\">255</div><div class=\"line\">256</div><div class=\"line\">257</div><div class=\"line\">258</div><div class=\"line\">259</div><div class=\"line\">260</div><div class=\"line\">261</div><div class=\"line\">262</div><div class=\"line\">263</div><div class=\"line\">264</div><div class=\"line\">265</div><div class=\"line\">266</div><div class=\"line\">267</div><div class=\"line\">268</div><div class=\"line\">269</div><div class=\"line\">270</div><div class=\"line\">271</div><div class=\"line\">272</div><div class=\"line\">273</div><div class=\"line\">274</div><div class=\"line\">275</div><div class=\"line\">276</div><div class=\"line\">277</div><div class=\"line\">278</div><div class=\"line\">279</div><div class=\"line\">280</div><div class=\"line\">281</div><div class=\"line\">282</div><div class=\"line\">283</div><div class=\"line\">284</div><div class=\"line\">285</div><div class=\"line\">286</div><div class=\"line\">287</div><div class=\"line\">288</div><div class=\"line\">289</div><div class=\"line\">290</div><div class=\"line\">291</div><div class=\"line\">292</div><div class=\"line\">293</div><div class=\"line\">294</div><div class=\"line\">295</div><div class=\"line\">296</div><div class=\"line\">297</div><div class=\"line\">298</div><div class=\"line\">299</div><div class=\"line\">300</div><div class=\"line\">301</div><div class=\"line\">302</div><div class=\"line\">303</div><div class=\"line\">304</div><div class=\"line\">305</div><div class=\"line\">306</div><div class=\"line\">307</div><div class=\"line\">308</div><div class=\"line\">309</div><div class=\"line\">310</div><div class=\"line\">311</div><div class=\"line\">312</div><div class=\"line\">313</div><div class=\"line\">314</div><div class=\"line\">315</div><div class=\"line\">316</div><div class=\"line\">317</div><div class=\"line\">318</div><div class=\"line\">319</div><div class=\"line\">320</div><div class=\"line\">321</div><div class=\"line\">322</div><div class=\"line\">323</div><div class=\"line\">324</div><div class=\"line\">325</div><div class=\"line\">326</div><div class=\"line\">327</div><div class=\"line\">328</div><div class=\"line\">329</div><div class=\"line\">330</div><div class=\"line\">331</div><div class=\"line\">332</div><div class=\"line\">333</div><div class=\"line\">334</div><div class=\"line\">335</div><div class=\"line\">336</div><div class=\"line\">337</div><div class=\"line\">338</div><div class=\"line\">339</div><div class=\"line\">340</div><div class=\"line\">341</div><div class=\"line\">342</div><div class=\"line\">343</div><div class=\"line\">344</div><div class=\"line\">345</div><div class=\"line\">346</div><div class=\"line\">347</div><div class=\"line\">348</div><div class=\"line\">349</div><div class=\"line\">350</div><div class=\"line\">351</div><div class=\"line\">352</div><div class=\"line\">353</div><div class=\"line\">354</div><div class=\"line\">355</div><div class=\"line\">356</div><div class=\"line\">357</div><div class=\"line\">358</div><div class=\"line\">359</div><div class=\"line\">360</div><div class=\"line\">361</div><div class=\"line\">362</div><div class=\"line\">363</div><div class=\"line\">364</div><div class=\"line\">365</div><div class=\"line\">366</div><div class=\"line\">367</div><div class=\"line\">368</div><div class=\"line\">369</div><div class=\"line\">370</div><div class=\"line\">371</div><div class=\"line\">372</div><div class=\"line\">373</div><div class=\"line\">374</div><div class=\"line\">375</div><div class=\"line\">376</div><div class=\"line\">377</div><div class=\"line\">378</div><div class=\"line\">379</div><div class=\"line\">380</div><div class=\"line\">381</div><div class=\"line\">382</div><div class=\"line\">383</div><div class=\"line\">384</div><div class=\"line\">385</div><div class=\"line\">386</div><div class=\"line\">387</div><div class=\"line\">388</div><div class=\"line\">389</div><div class=\"line\">390</div><div class=\"line\">391</div><div class=\"line\">392</div><div class=\"line\">393</div><div class=\"line\">394</div><div class=\"line\">395</div><div class=\"line\">396</div><div class=\"line\">397</div><div class=\"line\">398</div><div class=\"line\">399</div><div class=\"line\">400</div><div class=\"line\">401</div><div class=\"line\">402</div><div class=\"line\">403</div><div class=\"line\">404</div><div class=\"line\">405</div><div class=\"line\">406</div><div class=\"line\">407</div><div class=\"line\">408</div><div class=\"line\">409</div><div class=\"line\">410</div><div class=\"line\">411</div><div class=\"line\">412</div><div class=\"line\">413</div><div class=\"line\">414</div><div class=\"line\">415</div><div class=\"line\">416</div><div class=\"line\">417</div><div class=\"line\">418</div><div class=\"line\">419</div><div class=\"line\">420</div><div class=\"line\">421</div><div class=\"line\">422</div><div class=\"line\">423</div><div class=\"line\">424</div></pre></td><td class=\"code\"><pre><div class=\"line\">package com.android.volley.toolbox;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\"> * A network performing Volley requests over an &#123;@link HttpStack&#125;.</div><div class=\"line\"> * 一个用来执行Volley中request的类</div><div class=\"line\"> * 在HttpStack的基础之上</div><div class=\"line\"> * 因为主要还是调用HttpStack接口的performRequest</div><div class=\"line\"> * 在这个里面的performRequest主要还是做一些整理工作</div><div class=\"line\"> * 比如将｛@link HttpStack#performRequest()｝方法返回的HttpResponse</div><div class=\"line\"> * 解析成Volley自己实现的NetworkResponse.java</div><div class=\"line\"> */</div><div class=\"line\"></div><div class=\"line\">public class BasicNetwork implements Network &#123;</div><div class=\"line\"></div><div class=\"line\">    //是否允许打lo的boolean常变量</div><div class=\"line\">    protected static final boolean DEBUG = VolleyLog.DEBUG;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * 这是一个阀值，用来判断一个request是否请求响应过慢了= =</div><div class=\"line\">     * 在后面的作用就是，如果响应时间超过了这个阀值</div><div class=\"line\">     * 打出log说明这个request有些慢，为了更好的反应request当前状态</div><div class=\"line\">     */</div><div class=\"line\">    private static int SLOW_REQUEST_THRESHOLD_MS = 3000;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * 默认ByteArrayPool的大小</div><div class=\"line\">     * 现在只需要知道ByteArrayPool.java是Volley用来从输入流中读取数据并将其转换成字节数组的工具即可</div><div class=\"line\">     * 在这篇博客后面会介绍，表担心~= =</div><div class=\"line\">     */</div><div class=\"line\">    private static int DEFAULT_POOL_SIZE = 4096;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * 网络请求的真正接口</div><div class=\"line\">     * 为什么这么说咧，BasicNetwork里面的performRequest()函数</div><div class=\"line\">     * 调用了HttpStack里的performRequest()，真正的网络请求还是通过HttpStack里面的方法实现的</div><div class=\"line\">     * 在Volley中实现了HttpStack接口的类有两个 HurlStack.java和HttpClientStack.java</div><div class=\"line\">     * 针对了不同Android系统版本，用不同的方法实现了请求。</div><div class=\"line\">     */</div><div class=\"line\">    protected final HttpStack mHttpStack;</div><div class=\"line\"></div><div class=\"line\">    //表急，后面会介绍到的，现在知道是一个用于数据转换的工具类就好了</div><div class=\"line\">    protected final ByteArrayPool mPool;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * @param httpStack HTTP stack to be used</div><div class=\"line\">     * 传入的HttpStack实现类引用</div><div class=\"line\">     * 整个网络请求的较核心部分就在HttpStack实现类上面咯</div><div class=\"line\">     */</div><div class=\"line\">    public BasicNetwork(HttpStack httpStack) &#123;</div><div class=\"line\">        // If a pool isn&apos;t passed in, then build a small default pool that will give us a lot of</div><div class=\"line\">        // benefit and not use too much memory.</div><div class=\"line\">        this(httpStack, new ByteArrayPool(DEFAULT_POOL_SIZE));</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * @param httpStack HTTP stack to be used</div><div class=\"line\">     * @param pool a buffer pool that improves GC performance in copy operations</div><div class=\"line\">     * Volley接口分离的很明显，而且在构造函数里面也提供了很多种</div><div class=\"line\">     * 可以定制出适合自己的ByteArrayPool衍生类</div><div class=\"line\">     * 当然也可以自己来实现HttpStack的衍生类</div><div class=\"line\">     */</div><div class=\"line\">    public BasicNetwork(HttpStack httpStack, ByteArrayPool pool) &#123;</div><div class=\"line\">        mHttpStack = httpStack;</div><div class=\"line\">        mPool = pool;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * 这个方法重写的是Network的方法</div><div class=\"line\">     * 在这个里面再调用HttpStack里面的performRequest方法</div><div class=\"line\">     */</div><div class=\"line\">    @Override</div><div class=\"line\">    public NetworkResponse performRequest(Request&lt;?&gt; request) throws VolleyError &#123;</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * Returns milliseconds since boot, including time spent in sleep.</div><div class=\"line\">         * 为了方便计算每个request所用的时间</div><div class=\"line\">         * 在处理每个request之前都记下此刻unix时间戳</div><div class=\"line\">         */</div><div class=\"line\">        long requestStart = SystemClock.elapsedRealtime();</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * 进入死循环= =</div><div class=\"line\">         * 还没弄清楚为什么要死循环</div><div class=\"line\">         */</div><div class=\"line\">        while (true) &#123;</div><div class=\"line\"></div><div class=\"line\">            /**</div><div class=\"line\">             * 指向HttpResponse实例的引用</div><div class=\"line\">             * 是调用HttpStack方法performRequest()之后返回的结果</div><div class=\"line\">             */</div><div class=\"line\">            HttpResponse httpResponse = null;</div><div class=\"line\"></div><div class=\"line\">            /**</div><div class=\"line\">             * 返回的HttpResponse还需要经过处理</div><div class=\"line\">             * 并不是返回回来就是能直接使用的数据</div><div class=\"line\">             * 需要通过上面的ByteArrayPool将Entity转换成byte[]</div><div class=\"line\">             * 这个就是指向解析后的byte[]的</div><div class=\"line\">             */</div><div class=\"line\">            byte[] responseContents = null;</div><div class=\"line\"></div><div class=\"line\">            //用来存放response里面header的信息，包含了状态码等</div><div class=\"line\">            Map&lt;String, String&gt; responseHeaders = Collections.emptyMap();</div><div class=\"line\"></div><div class=\"line\">            try &#123;</div><div class=\"line\">                /**</div><div class=\"line\">                 * Gather headers.</div><div class=\"line\">                 * 设置header</div><div class=\"line\">                 * 从缓存中收集上次相同request的信息</div><div class=\"line\">                 */</div><div class=\"line\">                Map&lt;String, String&gt; headers = new HashMap&lt;String, String&gt;();</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * 将缓存的信息加入到headers中</div><div class=\"line\">                 * headers会跟随request一起发送给服务器</div><div class=\"line\">                 * 在函数的定义处会讲解</div><div class=\"line\">                 */</div><div class=\"line\">                addCacheHeaders(headers, request.getCacheEntry());</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * 通过调用HttpStack接口的performRequest()方法</div><div class=\"line\">                 * 获取服务器返回的HttpResponse</div><div class=\"line\">                 */</div><div class=\"line\">                httpResponse = mHttpStack.performRequest(request, headers);</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * The first line of a Response message is the Status-Line, </div><div class=\"line\">                 * consisting of the protocol version followed by a numeric status code and its associated textual phrase</div><div class=\"line\">                 * with each element separated by SP characters. </div><div class=\"line\">                 * No CR or LF is allowed except in the final CRLF sequence.</div><div class=\"line\">                 * 请求返回的response第一行就是包含了状态码的一行</div><div class=\"line\">                 */</div><div class=\"line\">                StatusLine statusLine = httpResponse.getStatusLine();</div><div class=\"line\">                int statusCode = statusLine.getStatusCode();</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * 将头部解析成键值对的形式再返回</div><div class=\"line\">                 */</div><div class=\"line\">                responseHeaders = convertHeaders(httpResponse.getAllHeaders());</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * Handle cache validation.</div><div class=\"line\">                 * 处理缓存信息</div><div class=\"line\">                 * 如果返回的状态码是304(HttpStatus.SC_NOT_MODIFIED)</div><div class=\"line\">                 * 则进行如下的处理</div><div class=\"line\">                 */</div><div class=\"line\">                if (statusCode == HttpStatus.SC_NOT_MODIFIED) &#123;</div><div class=\"line\"></div><div class=\"line\">                    /**</div><div class=\"line\">                     * 如果缓存为空的话</div><div class=\"line\">                     * 那就说明该请求的返回的response的body就是null</div><div class=\"line\">                     * 直接构造一个NetworkResponse返回</div><div class=\"line\">                     */</div><div class=\"line\">                    Entry entry = request.getCacheEntry();</div><div class=\"line\">                    if (entry == null) &#123;</div><div class=\"line\">                        return new NetworkResponse(HttpStatus.SC_NOT_MODIFIED, null,</div><div class=\"line\">                                responseHeaders, true,</div><div class=\"line\">                                SystemClock.elapsedRealtime() - requestStart);</div><div class=\"line\">                    &#125;</div><div class=\"line\"></div><div class=\"line\">                    // A HTTP 304 response does not have all header fields. We</div><div class=\"line\">                    // have to use the header fields from the cache entry plus</div><div class=\"line\">                    // the new ones from the response.</div><div class=\"line\">                    // http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.5</div><div class=\"line\">                    /**</div><div class=\"line\">                     * 一个返回码为304的HttpResponse的header缺少一些信息</div><div class=\"line\">                     * 需要我们将cache中的一些header信息加入到其中</div><div class=\"line\">                     * 这样组成一个完整的NetworkResponse返回</div><div class=\"line\">                     */</div><div class=\"line\">                    entry.responseHeaders.putAll(responseHeaders);</div><div class=\"line\">                    return new NetworkResponse(HttpStatus.SC_NOT_MODIFIED, entry.data,</div><div class=\"line\">                            entry.responseHeaders, true,</div><div class=\"line\">                            SystemClock.elapsedRealtime() - requestStart);</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * Handle moved resources</div><div class=\"line\">                 * 处理了重定向的问题</div><div class=\"line\">                 * 并将request的mRedirectUrl设定成了新的url</div><div class=\"line\">                 */</div><div class=\"line\">                if (statusCode == HttpStatus.SC_MOVED_PERMANENTLY || statusCode == HttpStatus.SC_MOVED_TEMPORARILY) &#123;</div><div class=\"line\">                    String newUrl = responseHeaders.get(&quot;Location&quot;);</div><div class=\"line\">                    request.setRedirectUrl(newUrl);</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * Some responses such as 204s do not have content.  We must check.</div><div class=\"line\">                 * 204(无内容)服务器成功处理了请求，但没有返回任何内容。</div><div class=\"line\">                 * </div><div class=\"line\">                 */</div><div class=\"line\">                if (httpResponse.getEntity() != null) &#123;</div><div class=\"line\">                    /**</div><div class=\"line\">                     * 如果entity不为Null</div><div class=\"line\">                     * 将其转换成byte数组</div><div class=\"line\">                     * 利用之前提到过的ByteArrayPool.java类</div><div class=\"line\">                     */</div><div class=\"line\">                  responseContents = entityToBytes(httpResponse.getEntity());</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                  // Add 0 byte response as a way of honestly representing a</div><div class=\"line\">                  // no-content request.</div><div class=\"line\">                  responseContents = new byte[0];</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * if the request is slow, log it.</div><div class=\"line\">                 * 获取request已经占用的时间(requestLifetime)</div><div class=\"line\">                 * 判断是否需要打出request的超时状态</div><div class=\"line\">                 */</div><div class=\"line\">                long requestLifetime = SystemClock.elapsedRealtime() - requestStart;</div><div class=\"line\">                logSlowRequests(requestLifetime, request, responseContents, statusLine);</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * 如果状态码位于200之下或者是299之上(200-299 用于表示请求成功)</div><div class=\"line\">                 * 则抛出IOException异常= =为什么非要抛出这个异常</div><div class=\"line\">                 * 在前面过滤掉了(304等情况)</div><div class=\"line\">                 */</div><div class=\"line\">                if (statusCode &lt; 200 || statusCode &gt; 299) &#123;</div><div class=\"line\">                    throw new IOException();</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * 经过上面的层层过滤</div><div class=\"line\">                 * 最后留下了200~299之间的请求成功response</div><div class=\"line\">                 * 通过HttpResponse里面的信息构造出一个volley自己封装的NetworkResponse对象</div><div class=\"line\">                 */</div><div class=\"line\">                return new NetworkResponse(statusCode, responseContents, responseHeaders, false,</div><div class=\"line\">                        SystemClock.elapsedRealtime() - requestStart);</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * 抛出了异常之后，会用attemptREtryOnException()方法来尝试retry</div><div class=\"line\">                 * 主要做的工作就是看是否还有retry的机会，如果有则不停通过这个死循环</div><div class=\"line\">                 * 进行请求，直到请求成功或者请求的机会用完为止</div><div class=\"line\">                 */</div><div class=\"line\">            &#125; catch (SocketTimeoutException e) &#123;</div><div class=\"line\">                attemptRetryOnException(&quot;socket&quot;, request, new TimeoutError());</div><div class=\"line\">            &#125; catch (ConnectTimeoutException e) &#123;·</div><div class=\"line\">                attemptRetryOnException(&quot;connection&quot;, request, new TimeoutError());</div><div class=\"line\">            &#125; catch (MalformedURLException e) &#123;</div><div class=\"line\">                throw new RuntimeException(&quot;Bad URL &quot; + request.getUrl(), e);</div><div class=\"line\">            &#125; catch (IOException e) &#123;</div><div class=\"line\">                /**</div><div class=\"line\">                 * 状态码在0~200以及299之上的response</div><div class=\"line\">                 * 处理的套路</div><div class=\"line\">                 */</div><div class=\"line\">                int statusCode = 0;</div><div class=\"line\">                NetworkResponse networkResponse = null;</div><div class=\"line\">                if (httpResponse != null) &#123;</div><div class=\"line\">                    statusCode = httpResponse.getStatusLine().getStatusCode();</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    //如果状态码为0，则抛出NoConnectionError</div><div class=\"line\">                    throw new NoConnectionError(e);</div><div class=\"line\">                &#125;</div><div class=\"line\">                /**</div><div class=\"line\">                 * 如果有重定向的情况发生</div><div class=\"line\">                 * 用log打出</div><div class=\"line\">                 */</div><div class=\"line\">                if (statusCode == HttpStatus.SC_MOVED_PERMANENTLY || </div><div class=\"line\">                        statusCode == HttpStatus.SC_MOVED_TEMPORARILY) &#123;</div><div class=\"line\">                    VolleyLog.e(&quot;Request at %s has been redirected to %s&quot;, request.getOriginUrl(), request.getUrl());</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    VolleyLog.e(&quot;Unexpected response code %d for %s&quot;, statusCode, request.getUrl());</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * 如果返回的content内容不为Null</div><div class=\"line\">                 * 则构造出一个NetworkResponse</div><div class=\"line\">                 * 否则抛出NetworkError</div><div class=\"line\">                 */</div><div class=\"line\">                if (responseContents != null) &#123;</div><div class=\"line\"></div><div class=\"line\">                    networkResponse = new NetworkResponse(statusCode, responseContents,</div><div class=\"line\">                            responseHeaders, false, SystemClock.elapsedRealtime() - requestStart);</div><div class=\"line\"></div><div class=\"line\">                    /**</div><div class=\"line\">                     * 抛出了异常之后，会用attemptREtryOnException()方法来尝试retry</div><div class=\"line\">                     * 主要做的工作就是看是否还有retry的机会，如果有则不停通过这个死循环</div><div class=\"line\">                     * 进行请求，直到请求成功或者请求的机会用完为止</div><div class=\"line\">                     */</div><div class=\"line\">                    if (statusCode == HttpStatus.SC_UNAUTHORIZED ||</div><div class=\"line\">                            statusCode == HttpStatus.SC_FORBIDDEN) &#123;</div><div class=\"line\">                        attemptRetryOnException(&quot;auth&quot;,</div><div class=\"line\">                                request, new AuthFailureError(networkResponse));</div><div class=\"line\">                    &#125; else if (statusCode == HttpStatus.SC_MOVED_PERMANENTLY || </div><div class=\"line\">                                statusCode == HttpStatus.SC_MOVED_TEMPORARILY) &#123;</div><div class=\"line\">                        attemptRetryOnException(&quot;redirect&quot;,</div><div class=\"line\">                                request, new AuthFailureError(networkResponse));</div><div class=\"line\">                    &#125; else &#123;</div><div class=\"line\">                        // TODO: Only throw ServerError for 5xx status codes.</div><div class=\"line\">                        throw new ServerError(networkResponse);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    throw new NetworkError(networkResponse);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Logs requests that took over SLOW_REQUEST_THRESHOLD_MS to complete.</div><div class=\"line\">     * 如果request用时超出了预先设定的阀值</div><div class=\"line\">     * 则打出log用于debug时候的提示</div><div class=\"line\">     */</div><div class=\"line\">    private void logSlowRequests(long requestLifetime, Request&lt;?&gt; request,</div><div class=\"line\">            byte[] responseContents, StatusLine statusLine) &#123;</div><div class=\"line\">        if (DEBUG || requestLifetime &gt; SLOW_REQUEST_THRESHOLD_MS) &#123;</div><div class=\"line\">            VolleyLog.d(&quot;HTTP response for request=&lt;%s&gt; [lifetime=%d], [size=%s], &quot; +</div><div class=\"line\">                    &quot;[rc=%d], [retryCount=%s]&quot;, request, requestLifetime,</div><div class=\"line\">                    responseContents != null ? responseContents.length : &quot;null&quot;,</div><div class=\"line\">                    statusLine.getStatusCode(), request.getRetryPolicy().getCurrentRetryCount());</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Attempts to prepare the request for a retry. If there are no more attempts remaining in the</div><div class=\"line\">     * request&apos;s retry policy, a timeout exception is thrown.</div><div class=\"line\">     * 每次尝试都会使retry机会减少1，如果机会没有了，则抛出请求超时的exception</div><div class=\"line\">     *</div><div class=\"line\">     * @param request The request to use.</div><div class=\"line\">     */</div><div class=\"line\">    private static void attemptRetryOnException(String logPrefix, Request&lt;?&gt; request,</div><div class=\"line\">            VolleyError exception) throws VolleyError &#123;</div><div class=\"line\">        RetryPolicy retryPolicy = request.getRetryPolicy();</div><div class=\"line\">        int oldTimeout = request.getTimeoutMs();</div><div class=\"line\"></div><div class=\"line\">        try &#123;</div><div class=\"line\">            retryPolicy.retry(exception);</div><div class=\"line\">        &#125; catch (VolleyError e) &#123;</div><div class=\"line\">            request.addMarker(</div><div class=\"line\">                    String.format(&quot;%s-timeout-giveup [timeout=%s]&quot;, logPrefix, oldTimeout));</div><div class=\"line\">            throw e;</div><div class=\"line\">        &#125;</div><div class=\"line\">        request.addMarker(String.format(&quot;%s-retry [timeout=%s]&quot;, logPrefix, oldTimeout));</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * 添加上缓存的header</div><div class=\"line\">     * 如果有之前的缓存的信息</div><div class=\"line\">     * 将里面的信息取出放入header中</div><div class=\"line\">     * </div><div class=\"line\">     * 这里面涉及到了一个条件请求</div><div class=\"line\">     * 如果有缓存的话，header上面会带上一个If-Modified-Since关键字</div><div class=\"line\">     * 服务器会先比较信息modified的时间，如果服务端的数据没有发生变化就返回304(也就是上面的 HttpStatus.SC_NOT_MODIFIED)</div><div class=\"line\">     * 如果服务器的数据发生了变化，则会返回状态码200以及请求需要的数据(意思就是本地的数据需要刷新了，缓存不管用了)</div><div class=\"line\">     */</div><div class=\"line\">    private void addCacheHeaders(Map&lt;String, String&gt; headers, Cache.Entry entry) &#123;</div><div class=\"line\">        // If there&apos;s no cache entry, we&apos;re done.</div><div class=\"line\">        if (entry == null) &#123;</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (entry.etag != null) &#123;</div><div class=\"line\">            headers.put(&quot;If-None-Match&quot;, entry.etag);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (entry.lastModified &gt; 0) &#123;</div><div class=\"line\">            Date refTime = new Date(entry.lastModified);</div><div class=\"line\">            headers.put(&quot;If-Modified-Since&quot;, DateUtils.formatDate(refTime));</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    protected void logError(String what, String url, long start) &#123;</div><div class=\"line\">        long now = SystemClock.elapsedRealtime();</div><div class=\"line\">        VolleyLog.v(&quot;HTTP ERROR(%s) %d ms to fetch %s&quot;, what, (now - start), url);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * Reads the contents of HttpEntity into a byte[].</div><div class=\"line\">     * 从HttpEntity中读取数据，并通过ByteArrayPool将其转换成byte[]</div><div class=\"line\">     * 暂时不用管太多= =，等后面介绍到ByteArrayPool.java的时候就会明白</div><div class=\"line\">     */</div><div class=\"line\">    private byte[] entityToBytes(HttpEntity entity) throws IOException, ServerError &#123;</div><div class=\"line\"></div><div class=\"line\">        PoolingByteArrayOutputStream bytes =</div><div class=\"line\">                new PoolingByteArrayOutputStream(mPool, (int) entity.getContentLength());</div><div class=\"line\"></div><div class=\"line\">        byte[] buffer = null;</div><div class=\"line\"></div><div class=\"line\">        try &#123;</div><div class=\"line\">            InputStream in = entity.getContent();</div><div class=\"line\">            if (in == null) &#123;</div><div class=\"line\">                throw new ServerError();</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            /**</div><div class=\"line\">             * 获取一个大小为1024的缓冲区</div><div class=\"line\">             */</div><div class=\"line\">            buffer = mPool.getBuf(1024);</div><div class=\"line\"></div><div class=\"line\">            int count;</div><div class=\"line\">            //将content的内容通过流每次最大读出1024个byte, 全部读出并写入bytes</div><div class=\"line\">            while ((count = in.read(buffer)) != -1) &#123;</div><div class=\"line\">                bytes.write(buffer, 0, count);</div><div class=\"line\">            &#125;</div><div class=\"line\">            return bytes.toByteArray();</div><div class=\"line\">        &#125; finally &#123;</div><div class=\"line\">            try &#123;</div><div class=\"line\">                // Close the InputStream and release the resources by &quot;consuming the content&quot;.</div><div class=\"line\">                entity.consumeContent();</div><div class=\"line\">            &#125; catch (IOException e) &#123;</div><div class=\"line\">                // This can happen if there was an exception above that left the entity in</div><div class=\"line\">                // an invalid state.</div><div class=\"line\">                VolleyLog.v(&quot;Error occured when calling consumingContent&quot;);</div><div class=\"line\">            &#125;</div><div class=\"line\">            /**</div><div class=\"line\">             * 在所有工作完成之后</div><div class=\"line\">             * 需要将从mPool中拿出的buffer缓冲区回收</div><div class=\"line\">             */</div><div class=\"line\">            mPool.returnBuf(buffer);</div><div class=\"line\">            bytes.close();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Converts Headers[] to Map&lt;String, String&gt;.</div><div class=\"line\">     * 将返回的response里面的header[]</div><div class=\"line\">     * 全部转换成Map里面的键值对形式</div><div class=\"line\">     */</div><div class=\"line\">    protected static Map&lt;String, String&gt; convertHeaders(Header[] headers) &#123;</div><div class=\"line\">        Map&lt;String, String&gt; result = new TreeMap&lt;String, String&gt;(String.CASE_INSENSITIVE_ORDER);</div><div class=\"line\">        for (int i = 0; i &lt; headers.length; i++) &#123;</div><div class=\"line\">            result.put(headers[i].getName(), headers[i].getValue());</div><div class=\"line\">        &#125;</div><div class=\"line\">        return result;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"4-ByteArrayPool-java\"><a href=\"#4-ByteArrayPool-java\" class=\"headerlink\" title=\"4. ByteArrayPool.java\"></a><a href=\"#4-_ByteArrayPool-java\" title=\"4\\. ByteArrayPool.java\"></a>4. ByteArrayPool.java</h3><p>ByteArrayPool.java是用来将HttpResponse中Entity通过stream的形式转换成byte[],主要的作用是提供缓冲区，用来辅助流数据的读取，在使用完成之后需要将使用过的缓冲区还给ByteArrayPool，ByteArrayPool里会对这些byte[]进行简单的回收处理。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * 用来给外界提供byte[]作为缓冲区的一个工具类</div><div class=\"line\"> */</div><div class=\"line\">public class ByteArrayPool &#123;</div><div class=\"line\">    /**</div><div class=\"line\">     * The buffer pool, arranged both by last use and by buffer size </div><div class=\"line\">     */</div><div class=\"line\">    private List&lt;byte[]&gt; mBuffersByLastUse = new LinkedList&lt;byte[]&gt;();</div><div class=\"line\">    private List&lt;byte[]&gt; mBuffersBySize = new ArrayList&lt;byte[]&gt;(64);</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * The total size of the buffers in the pool</div><div class=\"line\">     * 缓冲池的当前大小</div><div class=\"line\">     */</div><div class=\"line\">    private int mCurrentSize = 0;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * The maximum aggregate size of the buffers in the pool. Old buffers are discarded to stay</div><div class=\"line\">     * under this limit.</div><div class=\"line\">     * 缓冲池当前的大小的阀值</div><div class=\"line\">     * 超过了该值则会对缓冲池进行回收处理</div><div class=\"line\">     */</div><div class=\"line\">    private final int mSizeLimit;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Compares buffers by size</div><div class=\"line\">     * 比较两个缓冲区的大小的规则</div><div class=\"line\">     * 如果返回一个负数，则表示前一个数要小</div><div class=\"line\">     * 如果返回0，则表示两个数字相等</div><div class=\"line\">     * 如果返回一个正数，则表示后一个数要小</div><div class=\"line\">     * </div><div class=\"line\">     */</div><div class=\"line\">    protected static final Comparator&lt;byte[]&gt; BUF_COMPARATOR = new Comparator&lt;byte[]&gt;() &#123;</div><div class=\"line\">        @Override</div><div class=\"line\">        public int compare(byte[] lhs, byte[] rhs) &#123;</div><div class=\"line\">            return lhs.length - rhs.length;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * @param sizeLimit the maximum size of the pool, in bytes</div><div class=\"line\">     * 用来修改缓冲池的大小阀值</div><div class=\"line\">     */</div><div class=\"line\">    public ByteArrayPool(int sizeLimit) &#123;</div><div class=\"line\">        mSizeLimit = sizeLimit;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Returns a buffer from the pool if one is available in the requested size, or allocates a new</div><div class=\"line\">     * one if a pooled one is not available.</div><div class=\"line\">     * 从mBuffersBySize中调出一个缓冲区来</div><div class=\"line\">     * 如果大小符合要求，则直接返回给调用者</div><div class=\"line\">     * 如果没有符合要求的，直接创建一个新的byte[]返回</div><div class=\"line\">     *</div><div class=\"line\">     * @param len the minimum size, in bytes, of the requested buffer. The returned buffer may be</div><div class=\"line\">     *        larger.</div><div class=\"line\">     * @return a byte[] buffer is always returned.</div><div class=\"line\">     */</div><div class=\"line\">    public synchronized byte[] getBuf(int len) &#123;</div><div class=\"line\">        for (int i = 0; i &lt; mBuffersBySize.size(); i++) &#123;</div><div class=\"line\">            byte[] buf = mBuffersBySize.get(i);</div><div class=\"line\">            if (buf.length &gt;= len) &#123;</div><div class=\"line\">                mCurrentSize -= buf.length;</div><div class=\"line\">                mBuffersBySize.remove(i);</div><div class=\"line\">                mBuffersByLastUse.remove(buf);</div><div class=\"line\">                return buf;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return new byte[len];</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Returns a buffer to the pool, throwing away old buffers if the pool would exceed its allotted</div><div class=\"line\">     * size.</div><div class=\"line\">     * </div><div class=\"line\">     * @param buf the buffer to return to the pool.</div><div class=\"line\">     */</div><div class=\"line\">    public synchronized void returnBuf(byte[] buf) &#123;</div><div class=\"line\"></div><div class=\"line\">        //如果buf为空或者超出了规定的大小，不管就行了，这种缓冲区用不着回收，因为= =根本就不符合要求嘛</div><div class=\"line\"></div><div class=\"line\">        if (buf == null || buf.length &gt; mSizeLimit) &#123;</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        //如果buf符合要求，则将其加入到最近使用的队列中去</div><div class=\"line\"></div><div class=\"line\">        mBuffersByLastUse.add(buf);</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * 通过二分查找，比较规则为BUF_COMPARATOR，找出新进来的buf应该处于的位置</div><div class=\"line\">         * 随后将buf插入到mBufferBySize的队列里面</div><div class=\"line\">         */</div><div class=\"line\">        int pos = Collections.binarySearch(mBuffersBySize, buf, BUF_COMPARATOR);</div><div class=\"line\">        if (pos &lt; 0) &#123;</div><div class=\"line\">            pos = -pos - 1;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        mBuffersBySize.add(pos, buf);</div><div class=\"line\"></div><div class=\"line\">        //当前总缓冲区大小变大</div><div class=\"line\">        mCurrentSize += buf.length;</div><div class=\"line\"></div><div class=\"line\">        //对整个缓冲池的大小做出调整</div><div class=\"line\">        trim();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Removes buffers from the pool until it is under its size limit.</div><div class=\"line\">     * 调整缓冲区的大小</div><div class=\"line\">     * 直到mCurrentSize在限制大小之下</div><div class=\"line\">     */</div><div class=\"line\">    private synchronized void trim() &#123;</div><div class=\"line\"></div><div class=\"line\">        while (mCurrentSize &gt; mSizeLimit) &#123;</div><div class=\"line\">            byte[] buf = mBuffersByLastUse.remove(0);</div><div class=\"line\">            mBuffersBySize.remove(buf);</div><div class=\"line\">            mCurrentSize -= buf.length;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"5-RetryPolicy-java\"><a href=\"#5-RetryPolicy-java\" class=\"headerlink\" title=\"5. RetryPolicy.java\"></a><a href=\"#5-_RetryPolicy-java\" title=\"5\\. RetryPolicy.java\"></a>5. RetryPolicy.java</h3><p>在BasicNetwork.java这个类中，通过死循环加上try,catch的方式，不停的对一个request进行重复的处理，里面涉及到了<code>RetryPolicy.java</code>接口以及其默认实现类，这个接口是用来专门处理一个request在发送以及得到服务器响应返回结果的过程中出现的问题。通过有限次数的不断扩大request响应时间阀值，再次发送request的方式来达到一个retry的目的。和<code>Network.java</code>类似的，<code>RetryPolicy.java</code>也仅仅就是提供了抽象方法，想把具体的实现内容弄明白还需要去默认实现类<code>DefaultRetryPolicy.java</code>中去。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">package com.android.volley;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\"> * Retry policy for a request.</div><div class=\"line\"> * 该类用来管理request的调整及重新发送</div><div class=\"line\"> * 所谓调整就是将request响应时间(timeout)放宽</div><div class=\"line\"> */</div><div class=\"line\">public interface RetryPolicy &#123;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Returns the current timeout (used for logging).</div><div class=\"line\">     */</div><div class=\"line\">    public int getCurrentTimeout();</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Returns the current retry count (used for logging).</div><div class=\"line\">     */</div><div class=\"line\">    public int getCurrentRetryCount();</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Prepares for the next retry by applying a backoff to the timeout.</div><div class=\"line\">     * 为下一次request做好准备，通过不停地来放宽timeout时间限制</div><div class=\"line\">     * 在DefaultRetryPolicy.java中好理解一些</div><div class=\"line\">     * </div><div class=\"line\">     * @param error The error code of the last attempt.</div><div class=\"line\">     * @throws VolleyError In the event that the retry could not be performed (for example if we</div><div class=\"line\">     * ran out of attempts), the passed in error is thrown.</div><div class=\"line\">     */</div><div class=\"line\">    public void retry(VolleyError error) throws VolleyError;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"6-DefaultRetryPolicy-java\"><a href=\"#6-DefaultRetryPolicy-java\" class=\"headerlink\" title=\"6. DefaultRetryPolicy.java\"></a><a href=\"#6-_DefaultRetryPolicy-java\" title=\"6\\. DefaultRetryPolicy.java\"></a>6. DefaultRetryPolicy.java</h3><p><code>DefaultRetryPolicy.java</code>描述了对待Volley中涉及Network的request的策略方针，可以理解为重试策略方针，也就是对那些在网络请求失败的request处理方法。里面包含了retry的最大次数(<code>mMaxNumRetries</code>)，当前请求次数(<code>mCurrentRetryCount</code>)以及请求超时的时间阀值(<code>mCurrentTimeoutMs</code>)等。每个Request里面都包含了一个<code>RetryPolicy.java</code>实现类，在处理的时候可以通过<code>getRetryPolicy()</code>方法获得。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div></pre></td><td class=\"code\"><pre><div class=\"line\">package com.android.volley;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\"> * Default retry policy for requests.</div><div class=\"line\"> */</div><div class=\"line\">public class DefaultRetryPolicy implements RetryPolicy &#123;</div><div class=\"line\">    /** </div><div class=\"line\">     * The current timeout in milliseconds. </div><div class=\"line\">     * 请求超时的时间数</div><div class=\"line\">     */</div><div class=\"line\">    private int mCurrentTimeoutMs;</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * The current retry count.</div><div class=\"line\">     * 当前请求的重试次数</div><div class=\"line\">     */</div><div class=\"line\">    private int mCurrentRetryCount;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * The maximum number of attempts. </div><div class=\"line\">     * 重复尝试的最大次数</div><div class=\"line\">     **/</div><div class=\"line\">    private final int mMaxNumRetries;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * The backoff multiplier for the policy.</div><div class=\"line\">     * 暂时不明白这个有什么用</div><div class=\"line\">     * 根据后面的来看好像是一个用于放宽timeout时间限制的系数</div><div class=\"line\">     * 这个系数越大每次retry的时候放宽的程度也就越大</div><div class=\"line\">     */</div><div class=\"line\">    private final float mBackoffMultiplier;</div><div class=\"line\"></div><div class=\"line\">    /** The default socket timeout in milliseconds */</div><div class=\"line\">    public static final int DEFAULT_TIMEOUT_MS = 2500;</div><div class=\"line\"></div><div class=\"line\">    /** The default number of retries */</div><div class=\"line\">    public static final int DEFAULT_MAX_RETRIES = 0;</div><div class=\"line\"></div><div class=\"line\">    /** The default backoff multiplier */</div><div class=\"line\">    public static final float DEFAULT_BACKOFF_MULT = 1f;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Constructs a new retry policy using the default timeouts.</div><div class=\"line\">     * 默认的构造器，2.5s的超时，</div><div class=\"line\">     * 最大重试数为0，也就是request请求超时了就不要再自动重试了</div><div class=\"line\">     */</div><div class=\"line\">    public DefaultRetryPolicy() &#123;</div><div class=\"line\">        this(DEFAULT_TIMEOUT_MS, DEFAULT_MAX_RETRIES, DEFAULT_BACKOFF_MULT);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Constructs a new retry policy.</div><div class=\"line\">     * @param initialTimeoutMs The initial timeout for the policy.</div><div class=\"line\">     * @param maxNumRetries The maximum number of retries.</div><div class=\"line\">     * @param backoffMultiplier Backoff multiplier for the policy.</div><div class=\"line\">     */</div><div class=\"line\">    public DefaultRetryPolicy(int initialTimeoutMs, int maxNumRetries, float backoffMultiplier) &#123;</div><div class=\"line\">        mCurrentTimeoutMs = initialTimeoutMs;</div><div class=\"line\">        mMaxNumRetries = maxNumRetries;</div><div class=\"line\">        mBackoffMultiplier = backoffMultiplier;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Returns the current timeout.</div><div class=\"line\">     */</div><div class=\"line\">    @Override</div><div class=\"line\">    public int getCurrentTimeout() &#123;</div><div class=\"line\">        return mCurrentTimeoutMs;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Returns the current retry count.</div><div class=\"line\">     */</div><div class=\"line\">    @Override</div><div class=\"line\">    public int getCurrentRetryCount() &#123;</div><div class=\"line\">        return mCurrentRetryCount;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Returns the backoff multiplier for the policy.</div><div class=\"line\">     */</div><div class=\"line\">    public float getBackoffMultiplier() &#123;</div><div class=\"line\">        return mBackoffMultiplier;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Prepares for the next retry by applying a backoff to the timeout.</div><div class=\"line\">     * 该方法定义在RetryPolicy.java中。</div><div class=\"line\">     * 为下一次重试request做准备，好像是通过延长服务器响应时间的限制 = =</div><div class=\"line\">     * 每次对timeout的时间限制都放宽了mBackoffMultiplier个单位。让服务器多一点时间去响应</div><div class=\"line\">     * </div><div class=\"line\">     * @param error The error code of the last attempt.</div><div class=\"line\">     * 最后一次request服务器给出的错误码</div><div class=\"line\">     */</div><div class=\"line\">    @Override</div><div class=\"line\">    public void retry(VolleyError error) throws VolleyError &#123;</div><div class=\"line\">        mCurrentRetryCount++;</div><div class=\"line\">        mCurrentTimeoutMs += (mCurrentTimeoutMs * mBackoffMultiplier);</div><div class=\"line\">        if (!hasAttemptRemaining()) &#123;</div><div class=\"line\">            throw error;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Returns true if this policy has attempts remaining, false otherwise.</div><div class=\"line\">     * 这个是用来判断是否还有retry机会的</div><div class=\"line\">     */</div><div class=\"line\">    protected boolean hasAttemptRemaining() &#123;</div><div class=\"line\">        return mCurrentRetryCount &lt;= mMaxNumRetries;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>到这里对<code>Network.java</code>接口以及<code>RetryPolicy.java</code>接口的代码就分析完了，现在是清楚了在<code>NetworkDispatcher.java</code>调用了<code>mNetwork.performRequest()</code>之后发生了什么事情，还弄清楚了request在网络请求发送之后，出现了各种问题会怎么处理(重试策略)，但还不知道最核心的网络请求是如何发生的，也就是在<code>BasicNetwork.java</code>中的下面这行代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">httpResponse = mHttpStack.performRequest(request, headers);</div></pre></td></tr></table></figure>\n<p>这行代码就涉及到了后面的<code>HttpStack.java</code>接口及其两个实现类了。</p>\n","excerpt":"<h2 id=\"Volley框架解析-四-—–Network接口及其默认实现类解析\"><a href=\"#Volley框架解析-四-—–Network接口及其默认实现类解析\" class=\"headerlink\" title=\"Volley框架解析(四)—–Network接口及其默认实现类解析\"></a>Volley框架解析(四)—–Network接口及其默认实现类解析</h2><h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h3><p>&#160;&#160;&#160;&#160;前面的三篇Volley框架解析文章已经从Volley对外暴露的接口Volley.java开始，向下慢慢深入到了RequestQueue.java，这个Volley中比较核心的类，然后又分析了Volley中负责主要request调度工作的两类Dispatcher，<code>NetworkDispatcher</code>以及<code>CacheDispatcher</code>。应该是将一个request从新建，到加入队列中等待处理，如何被处理以及返回结果或者error这一系列的流程理顺了。</p>\n<p>&#160;&#160;&#160;&#160;但是对于一些细节的问题还是不清楚，例如request究竟是如何发送出去，通过<code>NetworkResponse networkResponse = mNetwork.performRequest(request);</code>这么一句话就返回了结果(response)，这里面发生了些什么还不得而知，还有<code>Network#performRequest()</code>和<code>HttpStack#performRequest()</code>这两个函数之间有什么区别和联系等等。</p>","more":"<h3 id=\"2-Network-java\"><a href=\"#2-Network-java\" class=\"headerlink\" title=\"2. Network.java\"></a><a href=\"#2-_Network-java\" title=\"2\\. Network.java\"></a>2. Network.java</h3><p>&#160;&#160;&#160;&#160;最早接触到Network这个类是在<code>Volley.java</code>中的<code>newRequestQueue()</code>函数里面，<code>Network network = new BasicNetwork(stack);</code>创建了一个Network接口引用，并指向了一个Volley中的默认实现类的实例<code>BasicNetwork.java</code>，这个默认实现类也会在这篇博客的后面详细的解析。</p>\n<p>&#160;&#160;&#160;&#160;经过前面几篇博客的分析，<code>Volley.java</code>仅仅是持有而没有使用，仅将这个引用传递给了<code>NetworkDispatcher.java</code>中，只有在<code>NetworkDispatcher.java</code>类中用到了这个Network接口，在<code>NetowkrDispatcher.java</code>中存在着这么一行代码，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">NetworkResponse networkResponse = mNetwork.performRequest(request);</div></pre></td></tr></table></figure>\n<p>&#160;&#160;&#160;&#160;仅仅用了一句话就将request发送出去了，并且还拿回来了一个<code>NetworkResponse.java</code>类对象。里面发生了什么= =，先进去Network.java里面看看：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">package com.android.volley;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\"> * An interface for performing requests.</div><div class=\"line\"> */</div><div class=\"line\">public interface Network &#123;</div><div class=\"line\">    /**</div><div class=\"line\">     * Performs the specified request.</div><div class=\"line\">     * 用来发送特定的请求</div><div class=\"line\">     *</div><div class=\"line\">     * @param request Request to process</div><div class=\"line\">     * 即将被发送的request</div><div class=\"line\">     *</div><div class=\"line\">     * @return A &#123;@link NetworkResponse&#125; with data and caching metadata; will never be null</div><div class=\"line\">     * 请求之后返回的response, 是volley自己构造出来的一个response</div><div class=\"line\">     * 里面包含了返回的请求码等等。</div><div class=\"line\">     *</div><div class=\"line\">     * @throws VolleyError on errors</div><div class=\"line\">     */</div><div class=\"line\">    public NetworkResponse performRequest(Request&lt;?&gt; request) throws VolleyError;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>对，没有看错= =，就这么点东西，仅仅一个抽象方法而已，Network.java就是一个等待被实现的接口，想看真东西，还需要进去<code>Network network = new BasicNetwork(stack);</code>里面所提到的<code>BasicNetwork.java</code>看看。</p>\n<h3 id=\"3-BasicNetwork-java\"><a href=\"#3-BasicNetwork-java\" class=\"headerlink\" title=\"3. BasicNetwork.java\"></a><a href=\"#3-_BasicNetwork-java\" title=\"3\\. BasicNetwork.java\"></a>3. BasicNetwork.java</h3><p><code>Network.java</code>接口的默认实现类，该类里面会处理一些request发送前后的处理工作，主要是对请求返回的httpResponse处理，以及对请求失败进行retry或者抛出异常的处理。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div><div class=\"line\">204</div><div class=\"line\">205</div><div class=\"line\">206</div><div class=\"line\">207</div><div class=\"line\">208</div><div class=\"line\">209</div><div class=\"line\">210</div><div class=\"line\">211</div><div class=\"line\">212</div><div class=\"line\">213</div><div class=\"line\">214</div><div class=\"line\">215</div><div class=\"line\">216</div><div class=\"line\">217</div><div class=\"line\">218</div><div class=\"line\">219</div><div class=\"line\">220</div><div class=\"line\">221</div><div class=\"line\">222</div><div class=\"line\">223</div><div class=\"line\">224</div><div class=\"line\">225</div><div class=\"line\">226</div><div class=\"line\">227</div><div class=\"line\">228</div><div class=\"line\">229</div><div class=\"line\">230</div><div class=\"line\">231</div><div class=\"line\">232</div><div class=\"line\">233</div><div class=\"line\">234</div><div class=\"line\">235</div><div class=\"line\">236</div><div class=\"line\">237</div><div class=\"line\">238</div><div class=\"line\">239</div><div class=\"line\">240</div><div class=\"line\">241</div><div class=\"line\">242</div><div class=\"line\">243</div><div class=\"line\">244</div><div class=\"line\">245</div><div class=\"line\">246</div><div class=\"line\">247</div><div class=\"line\">248</div><div class=\"line\">249</div><div class=\"line\">250</div><div class=\"line\">251</div><div class=\"line\">252</div><div class=\"line\">253</div><div class=\"line\">254</div><div class=\"line\">255</div><div class=\"line\">256</div><div class=\"line\">257</div><div class=\"line\">258</div><div class=\"line\">259</div><div class=\"line\">260</div><div class=\"line\">261</div><div class=\"line\">262</div><div class=\"line\">263</div><div class=\"line\">264</div><div class=\"line\">265</div><div class=\"line\">266</div><div class=\"line\">267</div><div class=\"line\">268</div><div class=\"line\">269</div><div class=\"line\">270</div><div class=\"line\">271</div><div class=\"line\">272</div><div class=\"line\">273</div><div class=\"line\">274</div><div class=\"line\">275</div><div class=\"line\">276</div><div class=\"line\">277</div><div class=\"line\">278</div><div class=\"line\">279</div><div class=\"line\">280</div><div class=\"line\">281</div><div class=\"line\">282</div><div class=\"line\">283</div><div class=\"line\">284</div><div class=\"line\">285</div><div class=\"line\">286</div><div class=\"line\">287</div><div class=\"line\">288</div><div class=\"line\">289</div><div class=\"line\">290</div><div class=\"line\">291</div><div class=\"line\">292</div><div class=\"line\">293</div><div class=\"line\">294</div><div class=\"line\">295</div><div class=\"line\">296</div><div class=\"line\">297</div><div class=\"line\">298</div><div class=\"line\">299</div><div class=\"line\">300</div><div class=\"line\">301</div><div class=\"line\">302</div><div class=\"line\">303</div><div class=\"line\">304</div><div class=\"line\">305</div><div class=\"line\">306</div><div class=\"line\">307</div><div class=\"line\">308</div><div class=\"line\">309</div><div class=\"line\">310</div><div class=\"line\">311</div><div class=\"line\">312</div><div class=\"line\">313</div><div class=\"line\">314</div><div class=\"line\">315</div><div class=\"line\">316</div><div class=\"line\">317</div><div class=\"line\">318</div><div class=\"line\">319</div><div class=\"line\">320</div><div class=\"line\">321</div><div class=\"line\">322</div><div class=\"line\">323</div><div class=\"line\">324</div><div class=\"line\">325</div><div class=\"line\">326</div><div class=\"line\">327</div><div class=\"line\">328</div><div class=\"line\">329</div><div class=\"line\">330</div><div class=\"line\">331</div><div class=\"line\">332</div><div class=\"line\">333</div><div class=\"line\">334</div><div class=\"line\">335</div><div class=\"line\">336</div><div class=\"line\">337</div><div class=\"line\">338</div><div class=\"line\">339</div><div class=\"line\">340</div><div class=\"line\">341</div><div class=\"line\">342</div><div class=\"line\">343</div><div class=\"line\">344</div><div class=\"line\">345</div><div class=\"line\">346</div><div class=\"line\">347</div><div class=\"line\">348</div><div class=\"line\">349</div><div class=\"line\">350</div><div class=\"line\">351</div><div class=\"line\">352</div><div class=\"line\">353</div><div class=\"line\">354</div><div class=\"line\">355</div><div class=\"line\">356</div><div class=\"line\">357</div><div class=\"line\">358</div><div class=\"line\">359</div><div class=\"line\">360</div><div class=\"line\">361</div><div class=\"line\">362</div><div class=\"line\">363</div><div class=\"line\">364</div><div class=\"line\">365</div><div class=\"line\">366</div><div class=\"line\">367</div><div class=\"line\">368</div><div class=\"line\">369</div><div class=\"line\">370</div><div class=\"line\">371</div><div class=\"line\">372</div><div class=\"line\">373</div><div class=\"line\">374</div><div class=\"line\">375</div><div class=\"line\">376</div><div class=\"line\">377</div><div class=\"line\">378</div><div class=\"line\">379</div><div class=\"line\">380</div><div class=\"line\">381</div><div class=\"line\">382</div><div class=\"line\">383</div><div class=\"line\">384</div><div class=\"line\">385</div><div class=\"line\">386</div><div class=\"line\">387</div><div class=\"line\">388</div><div class=\"line\">389</div><div class=\"line\">390</div><div class=\"line\">391</div><div class=\"line\">392</div><div class=\"line\">393</div><div class=\"line\">394</div><div class=\"line\">395</div><div class=\"line\">396</div><div class=\"line\">397</div><div class=\"line\">398</div><div class=\"line\">399</div><div class=\"line\">400</div><div class=\"line\">401</div><div class=\"line\">402</div><div class=\"line\">403</div><div class=\"line\">404</div><div class=\"line\">405</div><div class=\"line\">406</div><div class=\"line\">407</div><div class=\"line\">408</div><div class=\"line\">409</div><div class=\"line\">410</div><div class=\"line\">411</div><div class=\"line\">412</div><div class=\"line\">413</div><div class=\"line\">414</div><div class=\"line\">415</div><div class=\"line\">416</div><div class=\"line\">417</div><div class=\"line\">418</div><div class=\"line\">419</div><div class=\"line\">420</div><div class=\"line\">421</div><div class=\"line\">422</div><div class=\"line\">423</div><div class=\"line\">424</div></pre></td><td class=\"code\"><pre><div class=\"line\">package com.android.volley.toolbox;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\"> * A network performing Volley requests over an &#123;@link HttpStack&#125;.</div><div class=\"line\"> * 一个用来执行Volley中request的类</div><div class=\"line\"> * 在HttpStack的基础之上</div><div class=\"line\"> * 因为主要还是调用HttpStack接口的performRequest</div><div class=\"line\"> * 在这个里面的performRequest主要还是做一些整理工作</div><div class=\"line\"> * 比如将｛@link HttpStack#performRequest()｝方法返回的HttpResponse</div><div class=\"line\"> * 解析成Volley自己实现的NetworkResponse.java</div><div class=\"line\"> */</div><div class=\"line\"></div><div class=\"line\">public class BasicNetwork implements Network &#123;</div><div class=\"line\"></div><div class=\"line\">    //是否允许打lo的boolean常变量</div><div class=\"line\">    protected static final boolean DEBUG = VolleyLog.DEBUG;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * 这是一个阀值，用来判断一个request是否请求响应过慢了= =</div><div class=\"line\">     * 在后面的作用就是，如果响应时间超过了这个阀值</div><div class=\"line\">     * 打出log说明这个request有些慢，为了更好的反应request当前状态</div><div class=\"line\">     */</div><div class=\"line\">    private static int SLOW_REQUEST_THRESHOLD_MS = 3000;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * 默认ByteArrayPool的大小</div><div class=\"line\">     * 现在只需要知道ByteArrayPool.java是Volley用来从输入流中读取数据并将其转换成字节数组的工具即可</div><div class=\"line\">     * 在这篇博客后面会介绍，表担心~= =</div><div class=\"line\">     */</div><div class=\"line\">    private static int DEFAULT_POOL_SIZE = 4096;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * 网络请求的真正接口</div><div class=\"line\">     * 为什么这么说咧，BasicNetwork里面的performRequest()函数</div><div class=\"line\">     * 调用了HttpStack里的performRequest()，真正的网络请求还是通过HttpStack里面的方法实现的</div><div class=\"line\">     * 在Volley中实现了HttpStack接口的类有两个 HurlStack.java和HttpClientStack.java</div><div class=\"line\">     * 针对了不同Android系统版本，用不同的方法实现了请求。</div><div class=\"line\">     */</div><div class=\"line\">    protected final HttpStack mHttpStack;</div><div class=\"line\"></div><div class=\"line\">    //表急，后面会介绍到的，现在知道是一个用于数据转换的工具类就好了</div><div class=\"line\">    protected final ByteArrayPool mPool;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * @param httpStack HTTP stack to be used</div><div class=\"line\">     * 传入的HttpStack实现类引用</div><div class=\"line\">     * 整个网络请求的较核心部分就在HttpStack实现类上面咯</div><div class=\"line\">     */</div><div class=\"line\">    public BasicNetwork(HttpStack httpStack) &#123;</div><div class=\"line\">        // If a pool isn&apos;t passed in, then build a small default pool that will give us a lot of</div><div class=\"line\">        // benefit and not use too much memory.</div><div class=\"line\">        this(httpStack, new ByteArrayPool(DEFAULT_POOL_SIZE));</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * @param httpStack HTTP stack to be used</div><div class=\"line\">     * @param pool a buffer pool that improves GC performance in copy operations</div><div class=\"line\">     * Volley接口分离的很明显，而且在构造函数里面也提供了很多种</div><div class=\"line\">     * 可以定制出适合自己的ByteArrayPool衍生类</div><div class=\"line\">     * 当然也可以自己来实现HttpStack的衍生类</div><div class=\"line\">     */</div><div class=\"line\">    public BasicNetwork(HttpStack httpStack, ByteArrayPool pool) &#123;</div><div class=\"line\">        mHttpStack = httpStack;</div><div class=\"line\">        mPool = pool;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * 这个方法重写的是Network的方法</div><div class=\"line\">     * 在这个里面再调用HttpStack里面的performRequest方法</div><div class=\"line\">     */</div><div class=\"line\">    @Override</div><div class=\"line\">    public NetworkResponse performRequest(Request&lt;?&gt; request) throws VolleyError &#123;</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * Returns milliseconds since boot, including time spent in sleep.</div><div class=\"line\">         * 为了方便计算每个request所用的时间</div><div class=\"line\">         * 在处理每个request之前都记下此刻unix时间戳</div><div class=\"line\">         */</div><div class=\"line\">        long requestStart = SystemClock.elapsedRealtime();</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * 进入死循环= =</div><div class=\"line\">         * 还没弄清楚为什么要死循环</div><div class=\"line\">         */</div><div class=\"line\">        while (true) &#123;</div><div class=\"line\"></div><div class=\"line\">            /**</div><div class=\"line\">             * 指向HttpResponse实例的引用</div><div class=\"line\">             * 是调用HttpStack方法performRequest()之后返回的结果</div><div class=\"line\">             */</div><div class=\"line\">            HttpResponse httpResponse = null;</div><div class=\"line\"></div><div class=\"line\">            /**</div><div class=\"line\">             * 返回的HttpResponse还需要经过处理</div><div class=\"line\">             * 并不是返回回来就是能直接使用的数据</div><div class=\"line\">             * 需要通过上面的ByteArrayPool将Entity转换成byte[]</div><div class=\"line\">             * 这个就是指向解析后的byte[]的</div><div class=\"line\">             */</div><div class=\"line\">            byte[] responseContents = null;</div><div class=\"line\"></div><div class=\"line\">            //用来存放response里面header的信息，包含了状态码等</div><div class=\"line\">            Map&lt;String, String&gt; responseHeaders = Collections.emptyMap();</div><div class=\"line\"></div><div class=\"line\">            try &#123;</div><div class=\"line\">                /**</div><div class=\"line\">                 * Gather headers.</div><div class=\"line\">                 * 设置header</div><div class=\"line\">                 * 从缓存中收集上次相同request的信息</div><div class=\"line\">                 */</div><div class=\"line\">                Map&lt;String, String&gt; headers = new HashMap&lt;String, String&gt;();</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * 将缓存的信息加入到headers中</div><div class=\"line\">                 * headers会跟随request一起发送给服务器</div><div class=\"line\">                 * 在函数的定义处会讲解</div><div class=\"line\">                 */</div><div class=\"line\">                addCacheHeaders(headers, request.getCacheEntry());</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * 通过调用HttpStack接口的performRequest()方法</div><div class=\"line\">                 * 获取服务器返回的HttpResponse</div><div class=\"line\">                 */</div><div class=\"line\">                httpResponse = mHttpStack.performRequest(request, headers);</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * The first line of a Response message is the Status-Line, </div><div class=\"line\">                 * consisting of the protocol version followed by a numeric status code and its associated textual phrase</div><div class=\"line\">                 * with each element separated by SP characters. </div><div class=\"line\">                 * No CR or LF is allowed except in the final CRLF sequence.</div><div class=\"line\">                 * 请求返回的response第一行就是包含了状态码的一行</div><div class=\"line\">                 */</div><div class=\"line\">                StatusLine statusLine = httpResponse.getStatusLine();</div><div class=\"line\">                int statusCode = statusLine.getStatusCode();</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * 将头部解析成键值对的形式再返回</div><div class=\"line\">                 */</div><div class=\"line\">                responseHeaders = convertHeaders(httpResponse.getAllHeaders());</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * Handle cache validation.</div><div class=\"line\">                 * 处理缓存信息</div><div class=\"line\">                 * 如果返回的状态码是304(HttpStatus.SC_NOT_MODIFIED)</div><div class=\"line\">                 * 则进行如下的处理</div><div class=\"line\">                 */</div><div class=\"line\">                if (statusCode == HttpStatus.SC_NOT_MODIFIED) &#123;</div><div class=\"line\"></div><div class=\"line\">                    /**</div><div class=\"line\">                     * 如果缓存为空的话</div><div class=\"line\">                     * 那就说明该请求的返回的response的body就是null</div><div class=\"line\">                     * 直接构造一个NetworkResponse返回</div><div class=\"line\">                     */</div><div class=\"line\">                    Entry entry = request.getCacheEntry();</div><div class=\"line\">                    if (entry == null) &#123;</div><div class=\"line\">                        return new NetworkResponse(HttpStatus.SC_NOT_MODIFIED, null,</div><div class=\"line\">                                responseHeaders, true,</div><div class=\"line\">                                SystemClock.elapsedRealtime() - requestStart);</div><div class=\"line\">                    &#125;</div><div class=\"line\"></div><div class=\"line\">                    // A HTTP 304 response does not have all header fields. We</div><div class=\"line\">                    // have to use the header fields from the cache entry plus</div><div class=\"line\">                    // the new ones from the response.</div><div class=\"line\">                    // http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.5</div><div class=\"line\">                    /**</div><div class=\"line\">                     * 一个返回码为304的HttpResponse的header缺少一些信息</div><div class=\"line\">                     * 需要我们将cache中的一些header信息加入到其中</div><div class=\"line\">                     * 这样组成一个完整的NetworkResponse返回</div><div class=\"line\">                     */</div><div class=\"line\">                    entry.responseHeaders.putAll(responseHeaders);</div><div class=\"line\">                    return new NetworkResponse(HttpStatus.SC_NOT_MODIFIED, entry.data,</div><div class=\"line\">                            entry.responseHeaders, true,</div><div class=\"line\">                            SystemClock.elapsedRealtime() - requestStart);</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * Handle moved resources</div><div class=\"line\">                 * 处理了重定向的问题</div><div class=\"line\">                 * 并将request的mRedirectUrl设定成了新的url</div><div class=\"line\">                 */</div><div class=\"line\">                if (statusCode == HttpStatus.SC_MOVED_PERMANENTLY || statusCode == HttpStatus.SC_MOVED_TEMPORARILY) &#123;</div><div class=\"line\">                    String newUrl = responseHeaders.get(&quot;Location&quot;);</div><div class=\"line\">                    request.setRedirectUrl(newUrl);</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * Some responses such as 204s do not have content.  We must check.</div><div class=\"line\">                 * 204(无内容)服务器成功处理了请求，但没有返回任何内容。</div><div class=\"line\">                 * </div><div class=\"line\">                 */</div><div class=\"line\">                if (httpResponse.getEntity() != null) &#123;</div><div class=\"line\">                    /**</div><div class=\"line\">                     * 如果entity不为Null</div><div class=\"line\">                     * 将其转换成byte数组</div><div class=\"line\">                     * 利用之前提到过的ByteArrayPool.java类</div><div class=\"line\">                     */</div><div class=\"line\">                  responseContents = entityToBytes(httpResponse.getEntity());</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                  // Add 0 byte response as a way of honestly representing a</div><div class=\"line\">                  // no-content request.</div><div class=\"line\">                  responseContents = new byte[0];</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * if the request is slow, log it.</div><div class=\"line\">                 * 获取request已经占用的时间(requestLifetime)</div><div class=\"line\">                 * 判断是否需要打出request的超时状态</div><div class=\"line\">                 */</div><div class=\"line\">                long requestLifetime = SystemClock.elapsedRealtime() - requestStart;</div><div class=\"line\">                logSlowRequests(requestLifetime, request, responseContents, statusLine);</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * 如果状态码位于200之下或者是299之上(200-299 用于表示请求成功)</div><div class=\"line\">                 * 则抛出IOException异常= =为什么非要抛出这个异常</div><div class=\"line\">                 * 在前面过滤掉了(304等情况)</div><div class=\"line\">                 */</div><div class=\"line\">                if (statusCode &lt; 200 || statusCode &gt; 299) &#123;</div><div class=\"line\">                    throw new IOException();</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * 经过上面的层层过滤</div><div class=\"line\">                 * 最后留下了200~299之间的请求成功response</div><div class=\"line\">                 * 通过HttpResponse里面的信息构造出一个volley自己封装的NetworkResponse对象</div><div class=\"line\">                 */</div><div class=\"line\">                return new NetworkResponse(statusCode, responseContents, responseHeaders, false,</div><div class=\"line\">                        SystemClock.elapsedRealtime() - requestStart);</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * 抛出了异常之后，会用attemptREtryOnException()方法来尝试retry</div><div class=\"line\">                 * 主要做的工作就是看是否还有retry的机会，如果有则不停通过这个死循环</div><div class=\"line\">                 * 进行请求，直到请求成功或者请求的机会用完为止</div><div class=\"line\">                 */</div><div class=\"line\">            &#125; catch (SocketTimeoutException e) &#123;</div><div class=\"line\">                attemptRetryOnException(&quot;socket&quot;, request, new TimeoutError());</div><div class=\"line\">            &#125; catch (ConnectTimeoutException e) &#123;·</div><div class=\"line\">                attemptRetryOnException(&quot;connection&quot;, request, new TimeoutError());</div><div class=\"line\">            &#125; catch (MalformedURLException e) &#123;</div><div class=\"line\">                throw new RuntimeException(&quot;Bad URL &quot; + request.getUrl(), e);</div><div class=\"line\">            &#125; catch (IOException e) &#123;</div><div class=\"line\">                /**</div><div class=\"line\">                 * 状态码在0~200以及299之上的response</div><div class=\"line\">                 * 处理的套路</div><div class=\"line\">                 */</div><div class=\"line\">                int statusCode = 0;</div><div class=\"line\">                NetworkResponse networkResponse = null;</div><div class=\"line\">                if (httpResponse != null) &#123;</div><div class=\"line\">                    statusCode = httpResponse.getStatusLine().getStatusCode();</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    //如果状态码为0，则抛出NoConnectionError</div><div class=\"line\">                    throw new NoConnectionError(e);</div><div class=\"line\">                &#125;</div><div class=\"line\">                /**</div><div class=\"line\">                 * 如果有重定向的情况发生</div><div class=\"line\">                 * 用log打出</div><div class=\"line\">                 */</div><div class=\"line\">                if (statusCode == HttpStatus.SC_MOVED_PERMANENTLY || </div><div class=\"line\">                        statusCode == HttpStatus.SC_MOVED_TEMPORARILY) &#123;</div><div class=\"line\">                    VolleyLog.e(&quot;Request at %s has been redirected to %s&quot;, request.getOriginUrl(), request.getUrl());</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    VolleyLog.e(&quot;Unexpected response code %d for %s&quot;, statusCode, request.getUrl());</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * 如果返回的content内容不为Null</div><div class=\"line\">                 * 则构造出一个NetworkResponse</div><div class=\"line\">                 * 否则抛出NetworkError</div><div class=\"line\">                 */</div><div class=\"line\">                if (responseContents != null) &#123;</div><div class=\"line\"></div><div class=\"line\">                    networkResponse = new NetworkResponse(statusCode, responseContents,</div><div class=\"line\">                            responseHeaders, false, SystemClock.elapsedRealtime() - requestStart);</div><div class=\"line\"></div><div class=\"line\">                    /**</div><div class=\"line\">                     * 抛出了异常之后，会用attemptREtryOnException()方法来尝试retry</div><div class=\"line\">                     * 主要做的工作就是看是否还有retry的机会，如果有则不停通过这个死循环</div><div class=\"line\">                     * 进行请求，直到请求成功或者请求的机会用完为止</div><div class=\"line\">                     */</div><div class=\"line\">                    if (statusCode == HttpStatus.SC_UNAUTHORIZED ||</div><div class=\"line\">                            statusCode == HttpStatus.SC_FORBIDDEN) &#123;</div><div class=\"line\">                        attemptRetryOnException(&quot;auth&quot;,</div><div class=\"line\">                                request, new AuthFailureError(networkResponse));</div><div class=\"line\">                    &#125; else if (statusCode == HttpStatus.SC_MOVED_PERMANENTLY || </div><div class=\"line\">                                statusCode == HttpStatus.SC_MOVED_TEMPORARILY) &#123;</div><div class=\"line\">                        attemptRetryOnException(&quot;redirect&quot;,</div><div class=\"line\">                                request, new AuthFailureError(networkResponse));</div><div class=\"line\">                    &#125; else &#123;</div><div class=\"line\">                        // TODO: Only throw ServerError for 5xx status codes.</div><div class=\"line\">                        throw new ServerError(networkResponse);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    throw new NetworkError(networkResponse);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Logs requests that took over SLOW_REQUEST_THRESHOLD_MS to complete.</div><div class=\"line\">     * 如果request用时超出了预先设定的阀值</div><div class=\"line\">     * 则打出log用于debug时候的提示</div><div class=\"line\">     */</div><div class=\"line\">    private void logSlowRequests(long requestLifetime, Request&lt;?&gt; request,</div><div class=\"line\">            byte[] responseContents, StatusLine statusLine) &#123;</div><div class=\"line\">        if (DEBUG || requestLifetime &gt; SLOW_REQUEST_THRESHOLD_MS) &#123;</div><div class=\"line\">            VolleyLog.d(&quot;HTTP response for request=&lt;%s&gt; [lifetime=%d], [size=%s], &quot; +</div><div class=\"line\">                    &quot;[rc=%d], [retryCount=%s]&quot;, request, requestLifetime,</div><div class=\"line\">                    responseContents != null ? responseContents.length : &quot;null&quot;,</div><div class=\"line\">                    statusLine.getStatusCode(), request.getRetryPolicy().getCurrentRetryCount());</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Attempts to prepare the request for a retry. If there are no more attempts remaining in the</div><div class=\"line\">     * request&apos;s retry policy, a timeout exception is thrown.</div><div class=\"line\">     * 每次尝试都会使retry机会减少1，如果机会没有了，则抛出请求超时的exception</div><div class=\"line\">     *</div><div class=\"line\">     * @param request The request to use.</div><div class=\"line\">     */</div><div class=\"line\">    private static void attemptRetryOnException(String logPrefix, Request&lt;?&gt; request,</div><div class=\"line\">            VolleyError exception) throws VolleyError &#123;</div><div class=\"line\">        RetryPolicy retryPolicy = request.getRetryPolicy();</div><div class=\"line\">        int oldTimeout = request.getTimeoutMs();</div><div class=\"line\"></div><div class=\"line\">        try &#123;</div><div class=\"line\">            retryPolicy.retry(exception);</div><div class=\"line\">        &#125; catch (VolleyError e) &#123;</div><div class=\"line\">            request.addMarker(</div><div class=\"line\">                    String.format(&quot;%s-timeout-giveup [timeout=%s]&quot;, logPrefix, oldTimeout));</div><div class=\"line\">            throw e;</div><div class=\"line\">        &#125;</div><div class=\"line\">        request.addMarker(String.format(&quot;%s-retry [timeout=%s]&quot;, logPrefix, oldTimeout));</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * 添加上缓存的header</div><div class=\"line\">     * 如果有之前的缓存的信息</div><div class=\"line\">     * 将里面的信息取出放入header中</div><div class=\"line\">     * </div><div class=\"line\">     * 这里面涉及到了一个条件请求</div><div class=\"line\">     * 如果有缓存的话，header上面会带上一个If-Modified-Since关键字</div><div class=\"line\">     * 服务器会先比较信息modified的时间，如果服务端的数据没有发生变化就返回304(也就是上面的 HttpStatus.SC_NOT_MODIFIED)</div><div class=\"line\">     * 如果服务器的数据发生了变化，则会返回状态码200以及请求需要的数据(意思就是本地的数据需要刷新了，缓存不管用了)</div><div class=\"line\">     */</div><div class=\"line\">    private void addCacheHeaders(Map&lt;String, String&gt; headers, Cache.Entry entry) &#123;</div><div class=\"line\">        // If there&apos;s no cache entry, we&apos;re done.</div><div class=\"line\">        if (entry == null) &#123;</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (entry.etag != null) &#123;</div><div class=\"line\">            headers.put(&quot;If-None-Match&quot;, entry.etag);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (entry.lastModified &gt; 0) &#123;</div><div class=\"line\">            Date refTime = new Date(entry.lastModified);</div><div class=\"line\">            headers.put(&quot;If-Modified-Since&quot;, DateUtils.formatDate(refTime));</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    protected void logError(String what, String url, long start) &#123;</div><div class=\"line\">        long now = SystemClock.elapsedRealtime();</div><div class=\"line\">        VolleyLog.v(&quot;HTTP ERROR(%s) %d ms to fetch %s&quot;, what, (now - start), url);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * Reads the contents of HttpEntity into a byte[].</div><div class=\"line\">     * 从HttpEntity中读取数据，并通过ByteArrayPool将其转换成byte[]</div><div class=\"line\">     * 暂时不用管太多= =，等后面介绍到ByteArrayPool.java的时候就会明白</div><div class=\"line\">     */</div><div class=\"line\">    private byte[] entityToBytes(HttpEntity entity) throws IOException, ServerError &#123;</div><div class=\"line\"></div><div class=\"line\">        PoolingByteArrayOutputStream bytes =</div><div class=\"line\">                new PoolingByteArrayOutputStream(mPool, (int) entity.getContentLength());</div><div class=\"line\"></div><div class=\"line\">        byte[] buffer = null;</div><div class=\"line\"></div><div class=\"line\">        try &#123;</div><div class=\"line\">            InputStream in = entity.getContent();</div><div class=\"line\">            if (in == null) &#123;</div><div class=\"line\">                throw new ServerError();</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            /**</div><div class=\"line\">             * 获取一个大小为1024的缓冲区</div><div class=\"line\">             */</div><div class=\"line\">            buffer = mPool.getBuf(1024);</div><div class=\"line\"></div><div class=\"line\">            int count;</div><div class=\"line\">            //将content的内容通过流每次最大读出1024个byte, 全部读出并写入bytes</div><div class=\"line\">            while ((count = in.read(buffer)) != -1) &#123;</div><div class=\"line\">                bytes.write(buffer, 0, count);</div><div class=\"line\">            &#125;</div><div class=\"line\">            return bytes.toByteArray();</div><div class=\"line\">        &#125; finally &#123;</div><div class=\"line\">            try &#123;</div><div class=\"line\">                // Close the InputStream and release the resources by &quot;consuming the content&quot;.</div><div class=\"line\">                entity.consumeContent();</div><div class=\"line\">            &#125; catch (IOException e) &#123;</div><div class=\"line\">                // This can happen if there was an exception above that left the entity in</div><div class=\"line\">                // an invalid state.</div><div class=\"line\">                VolleyLog.v(&quot;Error occured when calling consumingContent&quot;);</div><div class=\"line\">            &#125;</div><div class=\"line\">            /**</div><div class=\"line\">             * 在所有工作完成之后</div><div class=\"line\">             * 需要将从mPool中拿出的buffer缓冲区回收</div><div class=\"line\">             */</div><div class=\"line\">            mPool.returnBuf(buffer);</div><div class=\"line\">            bytes.close();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Converts Headers[] to Map&lt;String, String&gt;.</div><div class=\"line\">     * 将返回的response里面的header[]</div><div class=\"line\">     * 全部转换成Map里面的键值对形式</div><div class=\"line\">     */</div><div class=\"line\">    protected static Map&lt;String, String&gt; convertHeaders(Header[] headers) &#123;</div><div class=\"line\">        Map&lt;String, String&gt; result = new TreeMap&lt;String, String&gt;(String.CASE_INSENSITIVE_ORDER);</div><div class=\"line\">        for (int i = 0; i &lt; headers.length; i++) &#123;</div><div class=\"line\">            result.put(headers[i].getName(), headers[i].getValue());</div><div class=\"line\">        &#125;</div><div class=\"line\">        return result;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"4-ByteArrayPool-java\"><a href=\"#4-ByteArrayPool-java\" class=\"headerlink\" title=\"4. ByteArrayPool.java\"></a><a href=\"#4-_ByteArrayPool-java\" title=\"4\\. ByteArrayPool.java\"></a>4. ByteArrayPool.java</h3><p>ByteArrayPool.java是用来将HttpResponse中Entity通过stream的形式转换成byte[],主要的作用是提供缓冲区，用来辅助流数据的读取，在使用完成之后需要将使用过的缓冲区还给ByteArrayPool，ByteArrayPool里会对这些byte[]进行简单的回收处理。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * 用来给外界提供byte[]作为缓冲区的一个工具类</div><div class=\"line\"> */</div><div class=\"line\">public class ByteArrayPool &#123;</div><div class=\"line\">    /**</div><div class=\"line\">     * The buffer pool, arranged both by last use and by buffer size </div><div class=\"line\">     */</div><div class=\"line\">    private List&lt;byte[]&gt; mBuffersByLastUse = new LinkedList&lt;byte[]&gt;();</div><div class=\"line\">    private List&lt;byte[]&gt; mBuffersBySize = new ArrayList&lt;byte[]&gt;(64);</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * The total size of the buffers in the pool</div><div class=\"line\">     * 缓冲池的当前大小</div><div class=\"line\">     */</div><div class=\"line\">    private int mCurrentSize = 0;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * The maximum aggregate size of the buffers in the pool. Old buffers are discarded to stay</div><div class=\"line\">     * under this limit.</div><div class=\"line\">     * 缓冲池当前的大小的阀值</div><div class=\"line\">     * 超过了该值则会对缓冲池进行回收处理</div><div class=\"line\">     */</div><div class=\"line\">    private final int mSizeLimit;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Compares buffers by size</div><div class=\"line\">     * 比较两个缓冲区的大小的规则</div><div class=\"line\">     * 如果返回一个负数，则表示前一个数要小</div><div class=\"line\">     * 如果返回0，则表示两个数字相等</div><div class=\"line\">     * 如果返回一个正数，则表示后一个数要小</div><div class=\"line\">     * </div><div class=\"line\">     */</div><div class=\"line\">    protected static final Comparator&lt;byte[]&gt; BUF_COMPARATOR = new Comparator&lt;byte[]&gt;() &#123;</div><div class=\"line\">        @Override</div><div class=\"line\">        public int compare(byte[] lhs, byte[] rhs) &#123;</div><div class=\"line\">            return lhs.length - rhs.length;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * @param sizeLimit the maximum size of the pool, in bytes</div><div class=\"line\">     * 用来修改缓冲池的大小阀值</div><div class=\"line\">     */</div><div class=\"line\">    public ByteArrayPool(int sizeLimit) &#123;</div><div class=\"line\">        mSizeLimit = sizeLimit;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Returns a buffer from the pool if one is available in the requested size, or allocates a new</div><div class=\"line\">     * one if a pooled one is not available.</div><div class=\"line\">     * 从mBuffersBySize中调出一个缓冲区来</div><div class=\"line\">     * 如果大小符合要求，则直接返回给调用者</div><div class=\"line\">     * 如果没有符合要求的，直接创建一个新的byte[]返回</div><div class=\"line\">     *</div><div class=\"line\">     * @param len the minimum size, in bytes, of the requested buffer. The returned buffer may be</div><div class=\"line\">     *        larger.</div><div class=\"line\">     * @return a byte[] buffer is always returned.</div><div class=\"line\">     */</div><div class=\"line\">    public synchronized byte[] getBuf(int len) &#123;</div><div class=\"line\">        for (int i = 0; i &lt; mBuffersBySize.size(); i++) &#123;</div><div class=\"line\">            byte[] buf = mBuffersBySize.get(i);</div><div class=\"line\">            if (buf.length &gt;= len) &#123;</div><div class=\"line\">                mCurrentSize -= buf.length;</div><div class=\"line\">                mBuffersBySize.remove(i);</div><div class=\"line\">                mBuffersByLastUse.remove(buf);</div><div class=\"line\">                return buf;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return new byte[len];</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Returns a buffer to the pool, throwing away old buffers if the pool would exceed its allotted</div><div class=\"line\">     * size.</div><div class=\"line\">     * </div><div class=\"line\">     * @param buf the buffer to return to the pool.</div><div class=\"line\">     */</div><div class=\"line\">    public synchronized void returnBuf(byte[] buf) &#123;</div><div class=\"line\"></div><div class=\"line\">        //如果buf为空或者超出了规定的大小，不管就行了，这种缓冲区用不着回收，因为= =根本就不符合要求嘛</div><div class=\"line\"></div><div class=\"line\">        if (buf == null || buf.length &gt; mSizeLimit) &#123;</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        //如果buf符合要求，则将其加入到最近使用的队列中去</div><div class=\"line\"></div><div class=\"line\">        mBuffersByLastUse.add(buf);</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * 通过二分查找，比较规则为BUF_COMPARATOR，找出新进来的buf应该处于的位置</div><div class=\"line\">         * 随后将buf插入到mBufferBySize的队列里面</div><div class=\"line\">         */</div><div class=\"line\">        int pos = Collections.binarySearch(mBuffersBySize, buf, BUF_COMPARATOR);</div><div class=\"line\">        if (pos &lt; 0) &#123;</div><div class=\"line\">            pos = -pos - 1;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        mBuffersBySize.add(pos, buf);</div><div class=\"line\"></div><div class=\"line\">        //当前总缓冲区大小变大</div><div class=\"line\">        mCurrentSize += buf.length;</div><div class=\"line\"></div><div class=\"line\">        //对整个缓冲池的大小做出调整</div><div class=\"line\">        trim();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Removes buffers from the pool until it is under its size limit.</div><div class=\"line\">     * 调整缓冲区的大小</div><div class=\"line\">     * 直到mCurrentSize在限制大小之下</div><div class=\"line\">     */</div><div class=\"line\">    private synchronized void trim() &#123;</div><div class=\"line\"></div><div class=\"line\">        while (mCurrentSize &gt; mSizeLimit) &#123;</div><div class=\"line\">            byte[] buf = mBuffersByLastUse.remove(0);</div><div class=\"line\">            mBuffersBySize.remove(buf);</div><div class=\"line\">            mCurrentSize -= buf.length;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"5-RetryPolicy-java\"><a href=\"#5-RetryPolicy-java\" class=\"headerlink\" title=\"5. RetryPolicy.java\"></a><a href=\"#5-_RetryPolicy-java\" title=\"5\\. RetryPolicy.java\"></a>5. RetryPolicy.java</h3><p>在BasicNetwork.java这个类中，通过死循环加上try,catch的方式，不停的对一个request进行重复的处理，里面涉及到了<code>RetryPolicy.java</code>接口以及其默认实现类，这个接口是用来专门处理一个request在发送以及得到服务器响应返回结果的过程中出现的问题。通过有限次数的不断扩大request响应时间阀值，再次发送request的方式来达到一个retry的目的。和<code>Network.java</code>类似的，<code>RetryPolicy.java</code>也仅仅就是提供了抽象方法，想把具体的实现内容弄明白还需要去默认实现类<code>DefaultRetryPolicy.java</code>中去。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">package com.android.volley;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\"> * Retry policy for a request.</div><div class=\"line\"> * 该类用来管理request的调整及重新发送</div><div class=\"line\"> * 所谓调整就是将request响应时间(timeout)放宽</div><div class=\"line\"> */</div><div class=\"line\">public interface RetryPolicy &#123;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Returns the current timeout (used for logging).</div><div class=\"line\">     */</div><div class=\"line\">    public int getCurrentTimeout();</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Returns the current retry count (used for logging).</div><div class=\"line\">     */</div><div class=\"line\">    public int getCurrentRetryCount();</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Prepares for the next retry by applying a backoff to the timeout.</div><div class=\"line\">     * 为下一次request做好准备，通过不停地来放宽timeout时间限制</div><div class=\"line\">     * 在DefaultRetryPolicy.java中好理解一些</div><div class=\"line\">     * </div><div class=\"line\">     * @param error The error code of the last attempt.</div><div class=\"line\">     * @throws VolleyError In the event that the retry could not be performed (for example if we</div><div class=\"line\">     * ran out of attempts), the passed in error is thrown.</div><div class=\"line\">     */</div><div class=\"line\">    public void retry(VolleyError error) throws VolleyError;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"6-DefaultRetryPolicy-java\"><a href=\"#6-DefaultRetryPolicy-java\" class=\"headerlink\" title=\"6. DefaultRetryPolicy.java\"></a><a href=\"#6-_DefaultRetryPolicy-java\" title=\"6\\. DefaultRetryPolicy.java\"></a>6. DefaultRetryPolicy.java</h3><p><code>DefaultRetryPolicy.java</code>描述了对待Volley中涉及Network的request的策略方针，可以理解为重试策略方针，也就是对那些在网络请求失败的request处理方法。里面包含了retry的最大次数(<code>mMaxNumRetries</code>)，当前请求次数(<code>mCurrentRetryCount</code>)以及请求超时的时间阀值(<code>mCurrentTimeoutMs</code>)等。每个Request里面都包含了一个<code>RetryPolicy.java</code>实现类，在处理的时候可以通过<code>getRetryPolicy()</code>方法获得。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div></pre></td><td class=\"code\"><pre><div class=\"line\">package com.android.volley;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\"> * Default retry policy for requests.</div><div class=\"line\"> */</div><div class=\"line\">public class DefaultRetryPolicy implements RetryPolicy &#123;</div><div class=\"line\">    /** </div><div class=\"line\">     * The current timeout in milliseconds. </div><div class=\"line\">     * 请求超时的时间数</div><div class=\"line\">     */</div><div class=\"line\">    private int mCurrentTimeoutMs;</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * The current retry count.</div><div class=\"line\">     * 当前请求的重试次数</div><div class=\"line\">     */</div><div class=\"line\">    private int mCurrentRetryCount;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * The maximum number of attempts. </div><div class=\"line\">     * 重复尝试的最大次数</div><div class=\"line\">     **/</div><div class=\"line\">    private final int mMaxNumRetries;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * The backoff multiplier for the policy.</div><div class=\"line\">     * 暂时不明白这个有什么用</div><div class=\"line\">     * 根据后面的来看好像是一个用于放宽timeout时间限制的系数</div><div class=\"line\">     * 这个系数越大每次retry的时候放宽的程度也就越大</div><div class=\"line\">     */</div><div class=\"line\">    private final float mBackoffMultiplier;</div><div class=\"line\"></div><div class=\"line\">    /** The default socket timeout in milliseconds */</div><div class=\"line\">    public static final int DEFAULT_TIMEOUT_MS = 2500;</div><div class=\"line\"></div><div class=\"line\">    /** The default number of retries */</div><div class=\"line\">    public static final int DEFAULT_MAX_RETRIES = 0;</div><div class=\"line\"></div><div class=\"line\">    /** The default backoff multiplier */</div><div class=\"line\">    public static final float DEFAULT_BACKOFF_MULT = 1f;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Constructs a new retry policy using the default timeouts.</div><div class=\"line\">     * 默认的构造器，2.5s的超时，</div><div class=\"line\">     * 最大重试数为0，也就是request请求超时了就不要再自动重试了</div><div class=\"line\">     */</div><div class=\"line\">    public DefaultRetryPolicy() &#123;</div><div class=\"line\">        this(DEFAULT_TIMEOUT_MS, DEFAULT_MAX_RETRIES, DEFAULT_BACKOFF_MULT);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Constructs a new retry policy.</div><div class=\"line\">     * @param initialTimeoutMs The initial timeout for the policy.</div><div class=\"line\">     * @param maxNumRetries The maximum number of retries.</div><div class=\"line\">     * @param backoffMultiplier Backoff multiplier for the policy.</div><div class=\"line\">     */</div><div class=\"line\">    public DefaultRetryPolicy(int initialTimeoutMs, int maxNumRetries, float backoffMultiplier) &#123;</div><div class=\"line\">        mCurrentTimeoutMs = initialTimeoutMs;</div><div class=\"line\">        mMaxNumRetries = maxNumRetries;</div><div class=\"line\">        mBackoffMultiplier = backoffMultiplier;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Returns the current timeout.</div><div class=\"line\">     */</div><div class=\"line\">    @Override</div><div class=\"line\">    public int getCurrentTimeout() &#123;</div><div class=\"line\">        return mCurrentTimeoutMs;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Returns the current retry count.</div><div class=\"line\">     */</div><div class=\"line\">    @Override</div><div class=\"line\">    public int getCurrentRetryCount() &#123;</div><div class=\"line\">        return mCurrentRetryCount;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Returns the backoff multiplier for the policy.</div><div class=\"line\">     */</div><div class=\"line\">    public float getBackoffMultiplier() &#123;</div><div class=\"line\">        return mBackoffMultiplier;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Prepares for the next retry by applying a backoff to the timeout.</div><div class=\"line\">     * 该方法定义在RetryPolicy.java中。</div><div class=\"line\">     * 为下一次重试request做准备，好像是通过延长服务器响应时间的限制 = =</div><div class=\"line\">     * 每次对timeout的时间限制都放宽了mBackoffMultiplier个单位。让服务器多一点时间去响应</div><div class=\"line\">     * </div><div class=\"line\">     * @param error The error code of the last attempt.</div><div class=\"line\">     * 最后一次request服务器给出的错误码</div><div class=\"line\">     */</div><div class=\"line\">    @Override</div><div class=\"line\">    public void retry(VolleyError error) throws VolleyError &#123;</div><div class=\"line\">        mCurrentRetryCount++;</div><div class=\"line\">        mCurrentTimeoutMs += (mCurrentTimeoutMs * mBackoffMultiplier);</div><div class=\"line\">        if (!hasAttemptRemaining()) &#123;</div><div class=\"line\">            throw error;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Returns true if this policy has attempts remaining, false otherwise.</div><div class=\"line\">     * 这个是用来判断是否还有retry机会的</div><div class=\"line\">     */</div><div class=\"line\">    protected boolean hasAttemptRemaining() &#123;</div><div class=\"line\">        return mCurrentRetryCount &lt;= mMaxNumRetries;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>到这里对<code>Network.java</code>接口以及<code>RetryPolicy.java</code>接口的代码就分析完了，现在是清楚了在<code>NetworkDispatcher.java</code>调用了<code>mNetwork.performRequest()</code>之后发生了什么事情，还弄清楚了request在网络请求发送之后，出现了各种问题会怎么处理(重试策略)，但还不知道最核心的网络请求是如何发生的，也就是在<code>BasicNetwork.java</code>中的下面这行代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">httpResponse = mHttpStack.performRequest(request, headers);</div></pre></td></tr></table></figure>\n<p>这行代码就涉及到了后面的<code>HttpStack.java</code>接口及其两个实现类了。</p>"},{"title":"关于字符编码","date":"2017-03-21T06:42:28.000Z","_content":"\n## 关于字符编码\n\n### 1. 字符集和字符编码\n\n&#160;&#160;&#160;&#160;各种文字和符号的总称为字符，多个字符集合为字符集，不同字符集包含字符个数不同，常见字符集有ASCII、ISO 8859、GB2312、BIG5、GB18030、Unicode等。\n\n&#160;&#160;&#160;&#160;编码和字符集不同，字符集在传输的过程中需要进行编码，编码方式有UTF-8、UTF-16等等，字符变吗就是以二进制的数字来对应字符集的字符。\n\n&#160;&#160;&#160;&#160;一般国家制定字符集和编码的时候都是同时进行的，平常说的GBK等有字符集和编码两层意思。\n\n> Unicode字符集有多种编码方式，如UTF-8、UTF-16等；ASCII只有一种；\n\n\n<!--more-->\n\n### 2. 内码\n&#160;&#160;&#160;&#160;内码指的是“将资讯编码后，透过某种方式储存在特定记忆装置时，装置内部的编码形式”。在不同的系统中，会有不同的内码。\n在以往的英文系统中，内码为ASCII。在繁体中文系统中，目前常用的内码为大五码（Big5）。在简体中文系统中，内码则为国标码（国家标准代码：现在强制要求使用GB18030标准；较旧计算机仍然使用GB2312）。而统一码（Unicode）则为另一常见内码。\n\n### 3. 字符编码分类\n\n#### 3.1 ASCII编码\n&#160;&#160;&#160;&#160;ASCII（American Standard Code for Information Interchange，美国信息互换标准代码）是基于拉丁字母的一套电脑编码系统。[字符编码表](http://zh.wikipedia.org/zh-cn/ASCII)\n\n- 单字节编码 ： 单字节字符串使用一个字节存放一个字符（SBCS,Single Byte Character System）。如：\"Bob123\"占6个字节。\n- 缺点 ： 只能显示26个字符、阿拉伯数字、英文标点\n\n#### 3.2 ANSI编码\n&#160;&#160;&#160;&#160;为了支持更多语言，通常使用0x800~xFF范围的两个字节来表示一个字符，例如“中”使用[0xD6,0xD0]这两个字节存储。不用国家制定了不同的标准，使用两个字节来表示一个字符的各种汉字延伸编码方式称为ANSI编码。简体中文系统下，ANSI编码代表GB2312编码。\n\n#### 3.3 Unicode编码\n&#160;&#160;&#160;&#160;为了国际间信息交流方便，制定了Unicode字符集，为每种语言中的字符设定了统一并唯一的数字编号。\n\n&#160;&#160;&#160;&#160;Unicode字符集简写为UCS(Unicode Character Set)。早期的unicodeUnicode标准有UCS-2、UCS-4的说法。UCS-2用两个字节编码，UCS-4用4个字节编码。\n\n### 4. 编码区别\n#### 4.1 GB2312、GBK、GB18030\n\n1. **GB2312**\n\tASCII码中127号之后的奇异符号们直接取消掉, 规定：一个小于127的字符的意义与原来相同，但两个大于127的字符连在一起时，表示一个汉字，前面的一个字节（称之为高字节）从0xA1用到0xF7，后面一个字节（低字节）从0xA1到0xFE，这样我们就可以组合出大约7000多个简体汉字了。这就是常说的\"全角\"字符，而原来在127号以下的那些就叫\"半角\"字符了。这种汉字方案叫做 \"GB2312\"。GB2312 是对 ASCII 的中文扩展。兼容ASCII。\n2. **GBK**\n\t不再要求低字节一定是127号之后的内码，只要第一个字节是大于127就固定表示这是一个汉字的开始，不管后面跟的是不是扩展字符集里的内容。对GB2312的扩展\n3. **GB18030**\n\t在GBK基础上扩展了少数民族的文字\n\n#### 4.2 UTF-8、UTF-16\n&#160;&#160;&#160;&#160;Unicode中所有字符都使用一个\"Unicode\"进行表示，采用双字节编码，和单字节编码的ASCII编码不兼容。UTF即UCS Transformation Format，即UCS转换(传输)格式。是将Unicode编码规则和计算机的实际编码对应起来的规则，流行的UTF有两种，UTF-8和UTF-16。\n\n1. **UTF-8**\n| UCS-2编码(16进制)  | UTF-8 字节流(二进制) |\n|--------|--------|\n|    0000 - 007F    |    0xxxxxxx    |\n|    0080 - 07FF    |    110xxxxx 10xxxxxx    |\n|    0800 - FFFF    |   1110xxxx 10xxxxxx 10xxxxxx      |\n\n&#160;&#160;&#160;&#160;例如“汉”字的Unicode编码是6C49。6C49在0800-FFFF之间，所以肯定要用3字节模板了：1110xxxx 10xxxxxx 10xxxxxx。将6C49写成二进制是：0110 110001 001001，用这个比特流依次代替模板中的x，得到：11100110 10110001 10001001，即E6 B1 89。\n\n&#160;&#160;&#160;&#160;UTF-16以16位为单元对UCS进行编码。对于小于0x10000的UCS码，UTF-16编码就等于UCS码对应的16位无符号整数。对于不小于0x10000的UCS码，定义了一个算法。不过由于实际使用的UCS2，或者UCS4的BMP必然小于0x10000，所以就目前而言，可以认为UTF-16和UCS-2基本相同。但UCS-2只是一个编码方案，UTF-16却要用于实际的传输，所以就不得不考虑字节序的问题。\n\n2. **UTF-16**\n\n&#160;&#160;&#160;&#160;UTF-16以16位为单元对UCS进行编码。对于小于0x10000的UCS码，UTF-16编码就等于UCS码对应的16位无符号整数。对于不小于0x10000的UCS码，定义了一个算法。不过由于实际使用的UCS2，或者UCS4的BMP必然小于0x10000，所以就目前而言，可以认为UTF-16和UCS-2基本相同。但UCS-2只是一个编码方案，UTF-16却要用于实际的传输，所以就不得不考虑字节序的问题。\n\n&#160;&#160;&#160;&#160;UTF-16不兼容ASCII。\n\n#### 5.1 UTF的字节序和BOM\n\n##### 5.1.1 字节序列\n&#160;&#160;&#160;&#160;UTF-8以字节为编码单元，而UTF-16两个字节编码单元，解释UTF-16文本前，先要弄清每个编码单元的字节序。Unicode规范中推荐的标记字节顺序的方法是BOM，也就是Byte Order Mark。\n\n&#160;&#160;&#160;&#160;在UCS编码中有一个叫做\"ZERO WIDTH NO-BREAK SPACE\"的字符，它的编码是FEFF。而FFFE在UCS中是不存在的字符，所以不应该出现在实际传输中。UCS规范建议我们在传输字节流前，先传输字符\"ZERO WIDTH NO-BREAK SPACE\"。这样如果接收者收到FEFF，就表明这个字节流是Big-Endian的；如果收到FFFE，就表明这个字节流是Little-Endian的。因此字符\"ZERO WIDTH NO-BREAK SPACE\"又被称作BOM。","source":"_posts/关于字符编码.md","raw":"---\ntitle: 关于字符编码\ndate: 2017-03-21 14:42:28\ntags: other\n\n---\n\n## 关于字符编码\n\n### 1. 字符集和字符编码\n\n&#160;&#160;&#160;&#160;各种文字和符号的总称为字符，多个字符集合为字符集，不同字符集包含字符个数不同，常见字符集有ASCII、ISO 8859、GB2312、BIG5、GB18030、Unicode等。\n\n&#160;&#160;&#160;&#160;编码和字符集不同，字符集在传输的过程中需要进行编码，编码方式有UTF-8、UTF-16等等，字符变吗就是以二进制的数字来对应字符集的字符。\n\n&#160;&#160;&#160;&#160;一般国家制定字符集和编码的时候都是同时进行的，平常说的GBK等有字符集和编码两层意思。\n\n> Unicode字符集有多种编码方式，如UTF-8、UTF-16等；ASCII只有一种；\n\n\n<!--more-->\n\n### 2. 内码\n&#160;&#160;&#160;&#160;内码指的是“将资讯编码后，透过某种方式储存在特定记忆装置时，装置内部的编码形式”。在不同的系统中，会有不同的内码。\n在以往的英文系统中，内码为ASCII。在繁体中文系统中，目前常用的内码为大五码（Big5）。在简体中文系统中，内码则为国标码（国家标准代码：现在强制要求使用GB18030标准；较旧计算机仍然使用GB2312）。而统一码（Unicode）则为另一常见内码。\n\n### 3. 字符编码分类\n\n#### 3.1 ASCII编码\n&#160;&#160;&#160;&#160;ASCII（American Standard Code for Information Interchange，美国信息互换标准代码）是基于拉丁字母的一套电脑编码系统。[字符编码表](http://zh.wikipedia.org/zh-cn/ASCII)\n\n- 单字节编码 ： 单字节字符串使用一个字节存放一个字符（SBCS,Single Byte Character System）。如：\"Bob123\"占6个字节。\n- 缺点 ： 只能显示26个字符、阿拉伯数字、英文标点\n\n#### 3.2 ANSI编码\n&#160;&#160;&#160;&#160;为了支持更多语言，通常使用0x800~xFF范围的两个字节来表示一个字符，例如“中”使用[0xD6,0xD0]这两个字节存储。不用国家制定了不同的标准，使用两个字节来表示一个字符的各种汉字延伸编码方式称为ANSI编码。简体中文系统下，ANSI编码代表GB2312编码。\n\n#### 3.3 Unicode编码\n&#160;&#160;&#160;&#160;为了国际间信息交流方便，制定了Unicode字符集，为每种语言中的字符设定了统一并唯一的数字编号。\n\n&#160;&#160;&#160;&#160;Unicode字符集简写为UCS(Unicode Character Set)。早期的unicodeUnicode标准有UCS-2、UCS-4的说法。UCS-2用两个字节编码，UCS-4用4个字节编码。\n\n### 4. 编码区别\n#### 4.1 GB2312、GBK、GB18030\n\n1. **GB2312**\n\tASCII码中127号之后的奇异符号们直接取消掉, 规定：一个小于127的字符的意义与原来相同，但两个大于127的字符连在一起时，表示一个汉字，前面的一个字节（称之为高字节）从0xA1用到0xF7，后面一个字节（低字节）从0xA1到0xFE，这样我们就可以组合出大约7000多个简体汉字了。这就是常说的\"全角\"字符，而原来在127号以下的那些就叫\"半角\"字符了。这种汉字方案叫做 \"GB2312\"。GB2312 是对 ASCII 的中文扩展。兼容ASCII。\n2. **GBK**\n\t不再要求低字节一定是127号之后的内码，只要第一个字节是大于127就固定表示这是一个汉字的开始，不管后面跟的是不是扩展字符集里的内容。对GB2312的扩展\n3. **GB18030**\n\t在GBK基础上扩展了少数民族的文字\n\n#### 4.2 UTF-8、UTF-16\n&#160;&#160;&#160;&#160;Unicode中所有字符都使用一个\"Unicode\"进行表示，采用双字节编码，和单字节编码的ASCII编码不兼容。UTF即UCS Transformation Format，即UCS转换(传输)格式。是将Unicode编码规则和计算机的实际编码对应起来的规则，流行的UTF有两种，UTF-8和UTF-16。\n\n1. **UTF-8**\n| UCS-2编码(16进制)  | UTF-8 字节流(二进制) |\n|--------|--------|\n|    0000 - 007F    |    0xxxxxxx    |\n|    0080 - 07FF    |    110xxxxx 10xxxxxx    |\n|    0800 - FFFF    |   1110xxxx 10xxxxxx 10xxxxxx      |\n\n&#160;&#160;&#160;&#160;例如“汉”字的Unicode编码是6C49。6C49在0800-FFFF之间，所以肯定要用3字节模板了：1110xxxx 10xxxxxx 10xxxxxx。将6C49写成二进制是：0110 110001 001001，用这个比特流依次代替模板中的x，得到：11100110 10110001 10001001，即E6 B1 89。\n\n&#160;&#160;&#160;&#160;UTF-16以16位为单元对UCS进行编码。对于小于0x10000的UCS码，UTF-16编码就等于UCS码对应的16位无符号整数。对于不小于0x10000的UCS码，定义了一个算法。不过由于实际使用的UCS2，或者UCS4的BMP必然小于0x10000，所以就目前而言，可以认为UTF-16和UCS-2基本相同。但UCS-2只是一个编码方案，UTF-16却要用于实际的传输，所以就不得不考虑字节序的问题。\n\n2. **UTF-16**\n\n&#160;&#160;&#160;&#160;UTF-16以16位为单元对UCS进行编码。对于小于0x10000的UCS码，UTF-16编码就等于UCS码对应的16位无符号整数。对于不小于0x10000的UCS码，定义了一个算法。不过由于实际使用的UCS2，或者UCS4的BMP必然小于0x10000，所以就目前而言，可以认为UTF-16和UCS-2基本相同。但UCS-2只是一个编码方案，UTF-16却要用于实际的传输，所以就不得不考虑字节序的问题。\n\n&#160;&#160;&#160;&#160;UTF-16不兼容ASCII。\n\n#### 5.1 UTF的字节序和BOM\n\n##### 5.1.1 字节序列\n&#160;&#160;&#160;&#160;UTF-8以字节为编码单元，而UTF-16两个字节编码单元，解释UTF-16文本前，先要弄清每个编码单元的字节序。Unicode规范中推荐的标记字节顺序的方法是BOM，也就是Byte Order Mark。\n\n&#160;&#160;&#160;&#160;在UCS编码中有一个叫做\"ZERO WIDTH NO-BREAK SPACE\"的字符，它的编码是FEFF。而FFFE在UCS中是不存在的字符，所以不应该出现在实际传输中。UCS规范建议我们在传输字节流前，先传输字符\"ZERO WIDTH NO-BREAK SPACE\"。这样如果接收者收到FEFF，就表明这个字节流是Big-Endian的；如果收到FFFE，就表明这个字节流是Little-Endian的。因此字符\"ZERO WIDTH NO-BREAK SPACE\"又被称作BOM。","slug":"关于字符编码","published":1,"updated":"2017-03-31T12:36:43.668Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0xtcups000ek2j9bpbp5v6y","content":"<h2 id=\"关于字符编码\"><a href=\"#关于字符编码\" class=\"headerlink\" title=\"关于字符编码\"></a>关于字符编码</h2><h3 id=\"1-字符集和字符编码\"><a href=\"#1-字符集和字符编码\" class=\"headerlink\" title=\"1. 字符集和字符编码\"></a>1. 字符集和字符编码</h3><p>&#160;&#160;&#160;&#160;各种文字和符号的总称为字符，多个字符集合为字符集，不同字符集包含字符个数不同，常见字符集有ASCII、ISO 8859、GB2312、BIG5、GB18030、Unicode等。</p>\n<p>&#160;&#160;&#160;&#160;编码和字符集不同，字符集在传输的过程中需要进行编码，编码方式有UTF-8、UTF-16等等，字符变吗就是以二进制的数字来对应字符集的字符。</p>\n<p>&#160;&#160;&#160;&#160;一般国家制定字符集和编码的时候都是同时进行的，平常说的GBK等有字符集和编码两层意思。</p>\n<blockquote>\n<p>Unicode字符集有多种编码方式，如UTF-8、UTF-16等；ASCII只有一种；</p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"2-内码\"><a href=\"#2-内码\" class=\"headerlink\" title=\"2. 内码\"></a>2. 内码</h3><p>&#160;&#160;&#160;&#160;内码指的是“将资讯编码后，透过某种方式储存在特定记忆装置时，装置内部的编码形式”。在不同的系统中，会有不同的内码。<br>在以往的英文系统中，内码为ASCII。在繁体中文系统中，目前常用的内码为大五码（Big5）。在简体中文系统中，内码则为国标码（国家标准代码：现在强制要求使用GB18030标准；较旧计算机仍然使用GB2312）。而统一码（Unicode）则为另一常见内码。</p>\n<h3 id=\"3-字符编码分类\"><a href=\"#3-字符编码分类\" class=\"headerlink\" title=\"3. 字符编码分类\"></a>3. 字符编码分类</h3><h4 id=\"3-1-ASCII编码\"><a href=\"#3-1-ASCII编码\" class=\"headerlink\" title=\"3.1 ASCII编码\"></a>3.1 ASCII编码</h4><p>&#160;&#160;&#160;&#160;ASCII（American Standard Code for Information Interchange，美国信息互换标准代码）是基于拉丁字母的一套电脑编码系统。<a href=\"http://zh.wikipedia.org/zh-cn/ASCII\" target=\"_blank\" rel=\"external\">字符编码表</a></p>\n<ul>\n<li>单字节编码 ： 单字节字符串使用一个字节存放一个字符（SBCS,Single Byte Character System）。如：”Bob123”占6个字节。</li>\n<li>缺点 ： 只能显示26个字符、阿拉伯数字、英文标点</li>\n</ul>\n<h4 id=\"3-2-ANSI编码\"><a href=\"#3-2-ANSI编码\" class=\"headerlink\" title=\"3.2 ANSI编码\"></a>3.2 ANSI编码</h4><p>&#160;&#160;&#160;&#160;为了支持更多语言，通常使用0x800~xFF范围的两个字节来表示一个字符，例如“中”使用[0xD6,0xD0]这两个字节存储。不用国家制定了不同的标准，使用两个字节来表示一个字符的各种汉字延伸编码方式称为ANSI编码。简体中文系统下，ANSI编码代表GB2312编码。</p>\n<h4 id=\"3-3-Unicode编码\"><a href=\"#3-3-Unicode编码\" class=\"headerlink\" title=\"3.3 Unicode编码\"></a>3.3 Unicode编码</h4><p>&#160;&#160;&#160;&#160;为了国际间信息交流方便，制定了Unicode字符集，为每种语言中的字符设定了统一并唯一的数字编号。</p>\n<p>&#160;&#160;&#160;&#160;Unicode字符集简写为UCS(Unicode Character Set)。早期的unicodeUnicode标准有UCS-2、UCS-4的说法。UCS-2用两个字节编码，UCS-4用4个字节编码。</p>\n<h3 id=\"4-编码区别\"><a href=\"#4-编码区别\" class=\"headerlink\" title=\"4. 编码区别\"></a>4. 编码区别</h3><h4 id=\"4-1-GB2312、GBK、GB18030\"><a href=\"#4-1-GB2312、GBK、GB18030\" class=\"headerlink\" title=\"4.1 GB2312、GBK、GB18030\"></a>4.1 GB2312、GBK、GB18030</h4><ol>\n<li><strong>GB2312</strong><br> ASCII码中127号之后的奇异符号们直接取消掉, 规定：一个小于127的字符的意义与原来相同，但两个大于127的字符连在一起时，表示一个汉字，前面的一个字节（称之为高字节）从0xA1用到0xF7，后面一个字节（低字节）从0xA1到0xFE，这样我们就可以组合出大约7000多个简体汉字了。这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。这种汉字方案叫做 “GB2312”。GB2312 是对 ASCII 的中文扩展。兼容ASCII。</li>\n<li><strong>GBK</strong><br> 不再要求低字节一定是127号之后的内码，只要第一个字节是大于127就固定表示这是一个汉字的开始，不管后面跟的是不是扩展字符集里的内容。对GB2312的扩展</li>\n<li><strong>GB18030</strong><br> 在GBK基础上扩展了少数民族的文字</li>\n</ol>\n<h4 id=\"4-2-UTF-8、UTF-16\"><a href=\"#4-2-UTF-8、UTF-16\" class=\"headerlink\" title=\"4.2 UTF-8、UTF-16\"></a>4.2 UTF-8、UTF-16</h4><p>&#160;&#160;&#160;&#160;Unicode中所有字符都使用一个”Unicode”进行表示，采用双字节编码，和单字节编码的ASCII编码不兼容。UTF即UCS Transformation Format，即UCS转换(传输)格式。是将Unicode编码规则和计算机的实际编码对应起来的规则，流行的UTF有两种，UTF-8和UTF-16。</p>\n<ol>\n<li><strong>UTF-8</strong><br>| UCS-2编码(16进制)  | UTF-8 字节流(二进制) |<br>|——–|——–|<br>|    0000 - 007F    |    0xxxxxxx    |<br>|    0080 - 07FF    |    110xxxxx 10xxxxxx    |<br>|    0800 - FFFF    |   1110xxxx 10xxxxxx 10xxxxxx      |</li>\n</ol>\n<p>&#160;&#160;&#160;&#160;例如“汉”字的Unicode编码是6C49。6C49在0800-FFFF之间，所以肯定要用3字节模板了：1110xxxx 10xxxxxx 10xxxxxx。将6C49写成二进制是：0110 110001 001001，用这个比特流依次代替模板中的x，得到：11100110 10110001 10001001，即E6 B1 89。</p>\n<p>&#160;&#160;&#160;&#160;UTF-16以16位为单元对UCS进行编码。对于小于0x10000的UCS码，UTF-16编码就等于UCS码对应的16位无符号整数。对于不小于0x10000的UCS码，定义了一个算法。不过由于实际使用的UCS2，或者UCS4的BMP必然小于0x10000，所以就目前而言，可以认为UTF-16和UCS-2基本相同。但UCS-2只是一个编码方案，UTF-16却要用于实际的传输，所以就不得不考虑字节序的问题。</p>\n<ol>\n<li><strong>UTF-16</strong></li>\n</ol>\n<p>&#160;&#160;&#160;&#160;UTF-16以16位为单元对UCS进行编码。对于小于0x10000的UCS码，UTF-16编码就等于UCS码对应的16位无符号整数。对于不小于0x10000的UCS码，定义了一个算法。不过由于实际使用的UCS2，或者UCS4的BMP必然小于0x10000，所以就目前而言，可以认为UTF-16和UCS-2基本相同。但UCS-2只是一个编码方案，UTF-16却要用于实际的传输，所以就不得不考虑字节序的问题。</p>\n<p>&#160;&#160;&#160;&#160;UTF-16不兼容ASCII。</p>\n<h4 id=\"5-1-UTF的字节序和BOM\"><a href=\"#5-1-UTF的字节序和BOM\" class=\"headerlink\" title=\"5.1 UTF的字节序和BOM\"></a>5.1 UTF的字节序和BOM</h4><h5 id=\"5-1-1-字节序列\"><a href=\"#5-1-1-字节序列\" class=\"headerlink\" title=\"5.1.1 字节序列\"></a>5.1.1 字节序列</h5><p>&#160;&#160;&#160;&#160;UTF-8以字节为编码单元，而UTF-16两个字节编码单元，解释UTF-16文本前，先要弄清每个编码单元的字节序。Unicode规范中推荐的标记字节顺序的方法是BOM，也就是Byte Order Mark。</p>\n<p>&#160;&#160;&#160;&#160;在UCS编码中有一个叫做”ZERO WIDTH NO-BREAK SPACE”的字符，它的编码是FEFF。而FFFE在UCS中是不存在的字符，所以不应该出现在实际传输中。UCS规范建议我们在传输字节流前，先传输字符”ZERO WIDTH NO-BREAK SPACE”。这样如果接收者收到FEFF，就表明这个字节流是Big-Endian的；如果收到FFFE，就表明这个字节流是Little-Endian的。因此字符”ZERO WIDTH NO-BREAK SPACE”又被称作BOM。</p>\n","excerpt":"<h2 id=\"关于字符编码\"><a href=\"#关于字符编码\" class=\"headerlink\" title=\"关于字符编码\"></a>关于字符编码</h2><h3 id=\"1-字符集和字符编码\"><a href=\"#1-字符集和字符编码\" class=\"headerlink\" title=\"1. 字符集和字符编码\"></a>1. 字符集和字符编码</h3><p>&#160;&#160;&#160;&#160;各种文字和符号的总称为字符，多个字符集合为字符集，不同字符集包含字符个数不同，常见字符集有ASCII、ISO 8859、GB2312、BIG5、GB18030、Unicode等。</p>\n<p>&#160;&#160;&#160;&#160;编码和字符集不同，字符集在传输的过程中需要进行编码，编码方式有UTF-8、UTF-16等等，字符变吗就是以二进制的数字来对应字符集的字符。</p>\n<p>&#160;&#160;&#160;&#160;一般国家制定字符集和编码的时候都是同时进行的，平常说的GBK等有字符集和编码两层意思。</p>\n<blockquote>\n<p>Unicode字符集有多种编码方式，如UTF-8、UTF-16等；ASCII只有一种；</p>\n</blockquote>","more":"<h3 id=\"2-内码\"><a href=\"#2-内码\" class=\"headerlink\" title=\"2. 内码\"></a>2. 内码</h3><p>&#160;&#160;&#160;&#160;内码指的是“将资讯编码后，透过某种方式储存在特定记忆装置时，装置内部的编码形式”。在不同的系统中，会有不同的内码。<br>在以往的英文系统中，内码为ASCII。在繁体中文系统中，目前常用的内码为大五码（Big5）。在简体中文系统中，内码则为国标码（国家标准代码：现在强制要求使用GB18030标准；较旧计算机仍然使用GB2312）。而统一码（Unicode）则为另一常见内码。</p>\n<h3 id=\"3-字符编码分类\"><a href=\"#3-字符编码分类\" class=\"headerlink\" title=\"3. 字符编码分类\"></a>3. 字符编码分类</h3><h4 id=\"3-1-ASCII编码\"><a href=\"#3-1-ASCII编码\" class=\"headerlink\" title=\"3.1 ASCII编码\"></a>3.1 ASCII编码</h4><p>&#160;&#160;&#160;&#160;ASCII（American Standard Code for Information Interchange，美国信息互换标准代码）是基于拉丁字母的一套电脑编码系统。<a href=\"http://zh.wikipedia.org/zh-cn/ASCII\">字符编码表</a></p>\n<ul>\n<li>单字节编码 ： 单字节字符串使用一个字节存放一个字符（SBCS,Single Byte Character System）。如：”Bob123”占6个字节。</li>\n<li>缺点 ： 只能显示26个字符、阿拉伯数字、英文标点</li>\n</ul>\n<h4 id=\"3-2-ANSI编码\"><a href=\"#3-2-ANSI编码\" class=\"headerlink\" title=\"3.2 ANSI编码\"></a>3.2 ANSI编码</h4><p>&#160;&#160;&#160;&#160;为了支持更多语言，通常使用0x800~xFF范围的两个字节来表示一个字符，例如“中”使用[0xD6,0xD0]这两个字节存储。不用国家制定了不同的标准，使用两个字节来表示一个字符的各种汉字延伸编码方式称为ANSI编码。简体中文系统下，ANSI编码代表GB2312编码。</p>\n<h4 id=\"3-3-Unicode编码\"><a href=\"#3-3-Unicode编码\" class=\"headerlink\" title=\"3.3 Unicode编码\"></a>3.3 Unicode编码</h4><p>&#160;&#160;&#160;&#160;为了国际间信息交流方便，制定了Unicode字符集，为每种语言中的字符设定了统一并唯一的数字编号。</p>\n<p>&#160;&#160;&#160;&#160;Unicode字符集简写为UCS(Unicode Character Set)。早期的unicodeUnicode标准有UCS-2、UCS-4的说法。UCS-2用两个字节编码，UCS-4用4个字节编码。</p>\n<h3 id=\"4-编码区别\"><a href=\"#4-编码区别\" class=\"headerlink\" title=\"4. 编码区别\"></a>4. 编码区别</h3><h4 id=\"4-1-GB2312、GBK、GB18030\"><a href=\"#4-1-GB2312、GBK、GB18030\" class=\"headerlink\" title=\"4.1 GB2312、GBK、GB18030\"></a>4.1 GB2312、GBK、GB18030</h4><ol>\n<li><strong>GB2312</strong><br> ASCII码中127号之后的奇异符号们直接取消掉, 规定：一个小于127的字符的意义与原来相同，但两个大于127的字符连在一起时，表示一个汉字，前面的一个字节（称之为高字节）从0xA1用到0xF7，后面一个字节（低字节）从0xA1到0xFE，这样我们就可以组合出大约7000多个简体汉字了。这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。这种汉字方案叫做 “GB2312”。GB2312 是对 ASCII 的中文扩展。兼容ASCII。</li>\n<li><strong>GBK</strong><br> 不再要求低字节一定是127号之后的内码，只要第一个字节是大于127就固定表示这是一个汉字的开始，不管后面跟的是不是扩展字符集里的内容。对GB2312的扩展</li>\n<li><strong>GB18030</strong><br> 在GBK基础上扩展了少数民族的文字</li>\n</ol>\n<h4 id=\"4-2-UTF-8、UTF-16\"><a href=\"#4-2-UTF-8、UTF-16\" class=\"headerlink\" title=\"4.2 UTF-8、UTF-16\"></a>4.2 UTF-8、UTF-16</h4><p>&#160;&#160;&#160;&#160;Unicode中所有字符都使用一个”Unicode”进行表示，采用双字节编码，和单字节编码的ASCII编码不兼容。UTF即UCS Transformation Format，即UCS转换(传输)格式。是将Unicode编码规则和计算机的实际编码对应起来的规则，流行的UTF有两种，UTF-8和UTF-16。</p>\n<ol>\n<li><strong>UTF-8</strong><br>| UCS-2编码(16进制)  | UTF-8 字节流(二进制) |<br>|——–|——–|<br>|    0000 - 007F    |    0xxxxxxx    |<br>|    0080 - 07FF    |    110xxxxx 10xxxxxx    |<br>|    0800 - FFFF    |   1110xxxx 10xxxxxx 10xxxxxx      |</li>\n</ol>\n<p>&#160;&#160;&#160;&#160;例如“汉”字的Unicode编码是6C49。6C49在0800-FFFF之间，所以肯定要用3字节模板了：1110xxxx 10xxxxxx 10xxxxxx。将6C49写成二进制是：0110 110001 001001，用这个比特流依次代替模板中的x，得到：11100110 10110001 10001001，即E6 B1 89。</p>\n<p>&#160;&#160;&#160;&#160;UTF-16以16位为单元对UCS进行编码。对于小于0x10000的UCS码，UTF-16编码就等于UCS码对应的16位无符号整数。对于不小于0x10000的UCS码，定义了一个算法。不过由于实际使用的UCS2，或者UCS4的BMP必然小于0x10000，所以就目前而言，可以认为UTF-16和UCS-2基本相同。但UCS-2只是一个编码方案，UTF-16却要用于实际的传输，所以就不得不考虑字节序的问题。</p>\n<ol>\n<li><strong>UTF-16</strong></li>\n</ol>\n<p>&#160;&#160;&#160;&#160;UTF-16以16位为单元对UCS进行编码。对于小于0x10000的UCS码，UTF-16编码就等于UCS码对应的16位无符号整数。对于不小于0x10000的UCS码，定义了一个算法。不过由于实际使用的UCS2，或者UCS4的BMP必然小于0x10000，所以就目前而言，可以认为UTF-16和UCS-2基本相同。但UCS-2只是一个编码方案，UTF-16却要用于实际的传输，所以就不得不考虑字节序的问题。</p>\n<p>&#160;&#160;&#160;&#160;UTF-16不兼容ASCII。</p>\n<h4 id=\"5-1-UTF的字节序和BOM\"><a href=\"#5-1-UTF的字节序和BOM\" class=\"headerlink\" title=\"5.1 UTF的字节序和BOM\"></a>5.1 UTF的字节序和BOM</h4><h5 id=\"5-1-1-字节序列\"><a href=\"#5-1-1-字节序列\" class=\"headerlink\" title=\"5.1.1 字节序列\"></a>5.1.1 字节序列</h5><p>&#160;&#160;&#160;&#160;UTF-8以字节为编码单元，而UTF-16两个字节编码单元，解释UTF-16文本前，先要弄清每个编码单元的字节序。Unicode规范中推荐的标记字节顺序的方法是BOM，也就是Byte Order Mark。</p>\n<p>&#160;&#160;&#160;&#160;在UCS编码中有一个叫做”ZERO WIDTH NO-BREAK SPACE”的字符，它的编码是FEFF。而FFFE在UCS中是不存在的字符，所以不应该出现在实际传输中。UCS规范建议我们在传输字节流前，先传输字符”ZERO WIDTH NO-BREAK SPACE”。这样如果接收者收到FEFF，就表明这个字节流是Big-Endian的；如果收到FFFE，就表明这个字节流是Little-Endian的。因此字符”ZERO WIDTH NO-BREAK SPACE”又被称作BOM。</p>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cj0xtcup40000k2j9q4t8d7r5","tag_id":"cj0xtcupc0003k2j9gfaew9qj","_id":"cj0xtcupj0008k2j9sfu3mgk0"},{"post_id":"cj0xtcup90002k2j9m6g10qx5","tag_id":"cj0xtcupi0007k2j98lx66yp7","_id":"cj0xtcupr000dk2j9fiym7xn4"},{"post_id":"cj0xtcupe0004k2j9vc1h6rbo","tag_id":"cj0xtcupi0007k2j98lx66yp7","_id":"cj0xtcupt000gk2j9j2ybm6yz"},{"post_id":"cj0xtcupg0005k2j9qrv2albu","tag_id":"cj0xtcupi0007k2j98lx66yp7","_id":"cj0xtcupt000ik2j97x7o2wku"},{"post_id":"cj0xtcupi0006k2j9rg6ec12s","tag_id":"cj0xtcupt000hk2j942xjisbj","_id":"cj0xtcupx000kk2j9p6b9ubyh"},{"post_id":"cj0xtcupj0009k2j9oxo3419m","tag_id":"cj0xtcupt000hk2j942xjisbj","_id":"cj0xtcupx000mk2j9xjzb354i"},{"post_id":"cj0xtcupn000ak2j97hwwjm7n","tag_id":"cj0xtcupt000hk2j942xjisbj","_id":"cj0xtcupy000ok2j9rxy7lydg"},{"post_id":"cj0xtcupr000ck2j9q0qv8opc","tag_id":"cj0xtcupt000hk2j942xjisbj","_id":"cj0xtcuq0000qk2j9xbkcox8c"},{"post_id":"cj0xtcups000ek2j9bpbp5v6y","tag_id":"cj0xtcupz000pk2j95nwdps0d","_id":"cj0xtcuq0000rk2j901c9wb12"}],"Tag":[{"name":"hexo","_id":"cj0xtcupc0003k2j9gfaew9qj"},{"name":"React-Native","_id":"cj0xtcupi0007k2j98lx66yp7"},{"name":"volley","_id":"cj0xtcupt000hk2j942xjisbj"},{"name":"other","_id":"cj0xtcupz000pk2j95nwdps0d"}]}}