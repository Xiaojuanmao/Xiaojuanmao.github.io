{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/apollo/source/favicon.png","path":"favicon.png","modified":0,"renderable":1},{"_id":"themes/apollo/source/css/apollo.css","path":"css/apollo.css","modified":0,"renderable":1},{"_id":"themes/apollo/source/scss/apollo.scss","path":"scss/apollo.scss","modified":0,"renderable":1},{"_id":"themes/apollo/source/font/sourcesanspro.woff","path":"font/sourcesanspro.woff","modified":0,"renderable":1},{"_id":"themes/apollo/source/font/sourcesanspro.woff2","path":"font/sourcesanspro.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.jpg","path":"images/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/images/img_1.jpg","path":"images/img_1.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"ec0f7df9269f3cea2acb1eb526d5c61d182b7a5e","modified":1593744048118},{"_id":"themes/apollo/.gitignore","hash":"a006beea0877a0aa3610ee00e73f62cb1d45125b","modified":1593745142012},{"_id":"themes/apollo/LICENSE","hash":"6e31ac9076bfc8f09ae47977419eee4edfb63e5b","modified":1593745142012},{"_id":"themes/apollo/README.md","hash":"8ce63966d1c7429121920c164c8613507ce30126","modified":1593745142012},{"_id":"themes/apollo/_config.yml","hash":"261de70c54a5b6bac83afc8e1a77bbd715fae547","modified":1593745142013},{"_id":"themes/apollo/gulpfile.js","hash":"857a026b6643a2cd52c65d4ae0dc7fe9618206ee","modified":1593745142013},{"_id":"themes/apollo/package.json","hash":"eb1e76ec0b7ed6c6c7b2bd32b4f1e1bbe15800ca","modified":1593745142015},{"_id":"source/_posts/Github-Hexo搭建个人博客.md","hash":"4540561f583fb25b5522b321b3a4ec0178a972bb","modified":1593744048119},{"_id":"source/_posts/MessageQueue中的nativePollOnce.md","hash":"52a444403fbfffdca1de6fc3be310f4ed39238b9","modified":1593744048119},{"_id":"source/_posts/React-Native笔记-一.md","hash":"a81554d40ede2c20b785073bdc6b4768ff13a381","modified":1593744048119},{"_id":"source/_posts/React-Native笔记-三.md","hash":"de7b9d64d2d060c0ae791b8c813da704654c9597","modified":1593744048120},{"_id":"source/_posts/React-Native笔记-二.md","hash":"2e48d99fa6efc0be297716cda05f17517b44ed4a","modified":1593744048120},{"_id":"source/_posts/SharedPreferece产生的Concurrent Modification Exception.md","hash":"46606faa0af086d1313239ba31e44c6298e26d01","modified":1593744048120},{"_id":"source/_posts/ViewPagerAdapter调用NotifyData后数据不刷新.md","hash":"ecb8d4a1a31686b499fbb434d1853277d52adc13","modified":1593744048120},{"_id":"source/_posts/Volley框架解析-一-整体介绍.md","hash":"f45cd4a3947e6228ac92fc0be2e23613f07ee702","modified":1593744048120},{"_id":"source/_posts/Volley框架解析-七-Request解析.md","hash":"ceda82a9b4b3ff92f55d85acc4e2bde3ebf64594","modified":1593744048120},{"_id":"source/_posts/Volley框架解析-三-Dispatcher解析.md","hash":"af998908441b7db0ee2c56eae39150deb73c0944","modified":1593744048121},{"_id":"source/_posts/Volley框架解析-二-Volley以及RequestQueue解析.md","hash":"4cdbf78fb5efea42ade08d2ff85b9e64a1b68c62","modified":1593744048121},{"_id":"source/_posts/Volley框架解析-五-HttpStack接口及其默认实现类解析.md","hash":"1899f168674a7f18f110dc49f3f7ea7b362b8bc4","modified":1593744048121},{"_id":"source/_posts/Volley框架解析-六-Cache接口及其默认实现类解析.md","hash":"60308ad664ddd56a376952536e638575e563d3e6","modified":1593744048122},{"_id":"source/_posts/关于字符编码.md","hash":"269e427f33aa3370e68f4e26655cf01b081bebe6","modified":1593744048122},{"_id":"source/tags/index.md","hash":"81959eff6a04fd89a73868dde300a3ca69ed8e05","modified":1593744048122},{"_id":"source/_posts/Volley框架解析-四-Network接口及其实现.md","hash":"aad138303370e1d8cb91e8273b81e494f342dfb5","modified":1593744048122},{"_id":"source/about/index.md","hash":"f218557089c0f5d2c9f27f41dadf0d28c52841fd","modified":1593746885771},{"_id":"themes/apollo/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1593745142006},{"_id":"themes/apollo/.git/config","hash":"e8486e77527181934f2dda23e50b879ab7641244","modified":1593745142008},{"_id":"themes/apollo/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1593745139266},{"_id":"themes/apollo/.git/index","hash":"097b4bd471704b539183f04290b94fd67df2e837","modified":1593745142019},{"_id":"themes/apollo/.git/packed-refs","hash":"e8f4e51aae7eb425ca993521e350f13a44684e27","modified":1593745142005},{"_id":"themes/apollo/doc/doc-en.md","hash":"409e931a444c02a57b64a0a44dde6e66c1881ca0","modified":1593745142013},{"_id":"themes/apollo/doc/doc-zh.md","hash":"2a6a81840cdaf497969268a12d8f62c98cc38103","modified":1593745142013},{"_id":"themes/apollo/languages/en.yml","hash":"ca168b190932229884db1de755ec2f793c758a16","modified":1593745142013},{"_id":"themes/apollo/languages/zh-cn.yml","hash":"22a2d16fe8c0dddb016b5325b9b9c182a1b49ae1","modified":1593745142013},{"_id":"themes/apollo/layout/archive.jade","hash":"62797414355bf4474092bc3a32726c8340820ffb","modified":1593745142014},{"_id":"themes/apollo/layout/index.jade","hash":"55f2f1b4b5364a0e09cb18e1112664c6415fb881","modified":1593745142014},{"_id":"themes/apollo/layout/post.jade","hash":"245c26244c075c3632d1545c3b228ee9d112f15d","modified":1593745142015},{"_id":"themes/apollo/source/favicon.png","hash":"a9cdcb22d1e74d5480323e19d1983de5a6873b8c","modified":1593745142016},{"_id":"themes/apollo/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1593745139267},{"_id":"themes/apollo/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1593745139266},{"_id":"themes/apollo/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1593745139267},{"_id":"themes/apollo/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1593745139267},{"_id":"themes/apollo/.git/hooks/fsmonitor-watchman.sample","hash":"f7c0aa40cb0d620ff0bca3efe3521ec79e5d7156","modified":1593745139267},{"_id":"themes/apollo/.git/hooks/pre-commit.sample","hash":"33729ad4ce51acda35094e581e4088f3167a0af8","modified":1593745139266},{"_id":"themes/apollo/.git/hooks/pre-merge-commit.sample","hash":"04c64e58bc25c149482ed45dbd79e40effb89eb7","modified":1593745139267},{"_id":"themes/apollo/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1593745139268},{"_id":"themes/apollo/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1593745139266},{"_id":"themes/apollo/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1593745139267},{"_id":"themes/apollo/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1593745139267},{"_id":"themes/apollo/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1593745139268},{"_id":"themes/apollo/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1593745139265},{"_id":"themes/apollo/.git/logs/HEAD","hash":"038202bbbf1c79cfc76960fc23822a620e0ca167","modified":1593745142007},{"_id":"themes/apollo/layout/mixins/paginator.jade","hash":"f4ee2fb61a32e199b48cf93771749edc8a007391","modified":1593745142014},{"_id":"themes/apollo/layout/mixins/post.jade","hash":"f23c6c40e14cdf16783b3c2baf736c9dce18408c","modified":1593745142014},{"_id":"themes/apollo/layout/partial/comment.jade","hash":"ff0a2c269c2434da2ac5529872f1d6184a71f96d","modified":1593745142014},{"_id":"themes/apollo/layout/partial/copyright.jade","hash":"217f8b17054e5079f2d30bb7e2e4e36c0f2161b7","modified":1593745142014},{"_id":"themes/apollo/layout/partial/head.jade","hash":"43d2db73f0247a9a3ed00ecb95b537a872b7201a","modified":1593745142015},{"_id":"themes/apollo/layout/partial/layout.jade","hash":"529c2ec06cfbc3d5b6d66dd320db50dfab5577a6","modified":1593745142015},{"_id":"themes/apollo/layout/partial/nav.jade","hash":"f4842d9d3d763fbb823d112a6f49f24cc42a0ad4","modified":1593745142015},{"_id":"themes/apollo/layout/partial/scripts.jade","hash":"6bff591ae3d1ff6750f239c4c933ad61f009f36a","modified":1593745142015},{"_id":"themes/apollo/source/css/apollo.css","hash":"e07a11a5da5fc097f023e06a85575356066afd09","modified":1593745142016},{"_id":"themes/apollo/source/scss/apollo.scss","hash":"e0092f469264b55b25e0d441274f1c812147e7d1","modified":1593745142018},{"_id":"themes/apollo/source/font/sourcesanspro.woff","hash":"a6722c9b6439b7a020a9be3d3178970757a9265c","modified":1593745142017},{"_id":"themes/apollo/source/font/sourcesanspro.woff2","hash":"da65f527a8da65d5eb6721626d28cfdb46ab104a","modified":1593745142017},{"_id":"themes/apollo/.git/objects/pack/pack-fee69b8778eac14809a79cc0926be11cc8d6723c.idx","hash":"7ea3cd0510a4f4387420e2371d44d15bfbf1d3d6","modified":1593745141998},{"_id":"themes/apollo/.git/refs/heads/master","hash":"66cd499048bb66d272f803d69453b912aecd9b8c","modified":1593745142007},{"_id":"themes/apollo/source/scss/_partial/archive-post-list.scss","hash":"d2f740a7d48349b7536777c795f82ab740836d0f","modified":1593745142017},{"_id":"themes/apollo/source/scss/_partial/base.scss","hash":"ae967b2049ecb9b8c4e139ecce32fd9fb5358ac5","modified":1593745142017},{"_id":"themes/apollo/source/scss/_partial/copyright.scss","hash":"1309667e3000037170cfbb5b8c9c65f4ffcf6814","modified":1593745142017},{"_id":"themes/apollo/source/scss/_partial/footer.scss","hash":"094aca6e52f11b139ac7980ca03fa7b9d8fc7b2f","modified":1593745142017},{"_id":"themes/apollo/source/scss/_partial/header.scss","hash":"153bde88bf8ffeae4ffd813d8cc694dd83d33d94","modified":1593745142018},{"_id":"themes/apollo/source/scss/_partial/home-post-list.scss","hash":"6b5c59f3d2295944f934aee2c1156012a3306d5d","modified":1593745142018},{"_id":"themes/apollo/source/scss/_partial/mq.scss","hash":"fc5dda52cfbb10e27e2471e03f4606fb3d588225","modified":1593745142018},{"_id":"themes/apollo/source/scss/_partial/normalize.scss","hash":"fd0b27bed6f103ea95b08f698ea663ff576dbcf1","modified":1593745142018},{"_id":"themes/apollo/source/scss/_partial/post.scss","hash":"1998f207541a2590a5624549f96c5e65d136690a","modified":1593745142018},{"_id":"themes/apollo/.git/logs/refs/heads/master","hash":"038202bbbf1c79cfc76960fc23822a620e0ca167","modified":1593745142007},{"_id":"themes/apollo/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1593745142006},{"_id":"themes/apollo/.git/logs/refs/remotes/origin/HEAD","hash":"038202bbbf1c79cfc76960fc23822a620e0ca167","modified":1593745142006},{"_id":"themes/apollo/.git/objects/pack/pack-fee69b8778eac14809a79cc0926be11cc8d6723c.pack","hash":"8229cf34b38dc1147eb1f40787bd552ef249328e","modified":1593745141997},{"_id":"public/tags/index.html","hash":"820a1b324f54141e9c977d51ba5987084625c567","modified":1593746351927},{"_id":"public/about/index.html","hash":"34dc656fde208ad9c75b723e5c6b9af394380707","modified":1593746906943},{"_id":"public/2018/04/12/SharedPreferece产生的Concurrent Modification Exception/index.html","hash":"69e6bc50b139c261e55c96b124ef17ecc7cca2e3","modified":1593746351928},{"_id":"public/2018/04/12/ViewPagerAdapter调用NotifyData后数据不刷新/index.html","hash":"75139aabbe0f76f3446412751dd59f2f959d7fde","modified":1593746351928},{"_id":"public/2018/04/12/MessageQueue中的nativePollOnce/index.html","hash":"b098195be5b1422a87876f530e7d191bca50da70","modified":1593746351928},{"_id":"public/2017/04/24/Volley框架解析-七-Request解析/index.html","hash":"9406a9d551aae52f86601cee074ce443361a9126","modified":1593746351928},{"_id":"public/2017/04/20/Volley框架解析-六-Cache接口及其默认实现类解析/index.html","hash":"adbe664fc9b72511e4bf3792f21c0b1d0c84feeb","modified":1593746351929},{"_id":"public/2017/04/19/Volley框架解析-五-HttpStack接口及其默认实现类解析/index.html","hash":"ae4f1ca667ae171ee3164e92525dc1d2b1a1a1af","modified":1593746351929},{"_id":"public/2017/03/21/关于字符编码/index.html","hash":"dd480415706f23b26848b4ed177cb30944be88c5","modified":1593746351929},{"_id":"public/2017/03/20/Volley框架解析-四-Network接口及其实现/index.html","hash":"bd0c78cba339a78635737653f0fa507574eb043c","modified":1593746351929},{"_id":"public/2017/03/01/Volley框架解析-三-Dispatcher解析/index.html","hash":"29cbbd186d613bc5c66c1981427be70c71fa83cf","modified":1593746351929},{"_id":"public/2017/02/28/Volley框架解析-二-Volley以及RequestQueue解析/index.html","hash":"dfc2c4ee84e82c0d043c7ad7de623fcecc6a5b13","modified":1593746351929},{"_id":"public/2017/02/26/Volley框架解析-一-整体介绍/index.html","hash":"1e03ec8fb0aab84442722ac1e4b105a7be870384","modified":1593746351929},{"_id":"public/2017/02/24/React-Native笔记-三/index.html","hash":"780322b0e77a575d703ba3b0e08cb99cb0f832bf","modified":1593746351929},{"_id":"public/2017/02/24/React-Native笔记-二/index.html","hash":"8acf5d5e5469c8322e28da4991fa7dfcce105cb9","modified":1593746351929},{"_id":"public/2017/02/24/React-Native笔记-一/index.html","hash":"170713ae3025c86fc701a3f00b6d654e2e87f78f","modified":1593746351929},{"_id":"public/2017/02/23/Github-Hexo搭建个人博客/index.html","hash":"6efe407eb6664cbe9d4a97fe3a4b714eeaa1d6f5","modified":1593746351929},{"_id":"public/archives/index.html","hash":"c463ffe233f2a187fb69122f90f474b1e63298b2","modified":1593746351928},{"_id":"public/tags/hexo/index.html","hash":"e3a3ded8ca1b9dcba09bafe531bafca22addc997","modified":1593746351928},{"_id":"public/tags/Android/index.html","hash":"b3609fe46a113712ec6efca03993e9689e1bea90","modified":1593746351928},{"_id":"public/tags/React-Native/index.html","hash":"3aea62ce162078fd19920222f3524b993e2e8e3f","modified":1593746351928},{"_id":"public/tags/volley/index.html","hash":"229e27627508d5c054eb4f0a155057d743d103a5","modified":1593746351928},{"_id":"public/tags/volley/page/2/index.html","hash":"18cba610243d2805f2ceef1ef052bd3afeff9802","modified":1593746351928},{"_id":"public/tags/other/index.html","hash":"7d645c05a2f5f84831c1a5def0d92e5839511b51","modified":1593746351928},{"_id":"public/index.html","hash":"1d22460e3a2e7ffd36520d1efb1ce22e5ce096cf","modified":1593746351929},{"_id":"public/page/2/index.html","hash":"3555d577ee46bf3a5b01173d93738c4d25ecf55e","modified":1593746351929},{"_id":"public/page/3/index.html","hash":"c6ff45516bf600bf9205ef538fa79e162d97bb19","modified":1593746351929},{"_id":"public/archives/page/2/index.html","hash":"54aa90aef471832e73731a5c1bd9778c8606bbb6","modified":1593746351928},{"_id":"public/archives/page/3/index.html","hash":"5b17d2aaa004082514767f28e7fa613cd7fb04af","modified":1593746351928},{"_id":"public/archives/2017/index.html","hash":"9380964bfd06fafbe41f366797e479c403a4b07a","modified":1593746351928},{"_id":"public/archives/2017/page/2/index.html","hash":"057aa5c319a7ca91e680a3c5d47c2e02350ab12d","modified":1593746351928},{"_id":"public/archives/2017/page/3/index.html","hash":"658f89533c5afbf3233b27a049fb339e13819da1","modified":1593746351928},{"_id":"public/archives/2017/02/index.html","hash":"11793cd249a09080dc3e478ec29c7f681ffa55ec","modified":1593746351928},{"_id":"public/archives/2017/02/page/2/index.html","hash":"b896b4a41d8f1ff17fb9b8f4ee38cb73c06d4411","modified":1593746351928},{"_id":"public/archives/2017/03/index.html","hash":"d15f103add5aaa772b63d4920a2781eeef28808e","modified":1593746351928},{"_id":"public/archives/2017/04/index.html","hash":"ca97cbd447fd3048818f9e197aaa146bebe1b9e3","modified":1593746351928},{"_id":"public/archives/2018/index.html","hash":"a737028a32f337a25a22eb19e75a2a7b4ea31aab","modified":1593746351928},{"_id":"public/archives/2018/04/index.html","hash":"ef31b9052f1864024c5e9767b4a7d33f47d4c3c7","modified":1593746351928},{"_id":"public/favicon.png","hash":"a9cdcb22d1e74d5480323e19d1983de5a6873b8c","modified":1593745759974},{"_id":"public/scss/apollo.scss","hash":"e0092f469264b55b25e0d441274f1c812147e7d1","modified":1593745759974},{"_id":"public/font/sourcesanspro.woff2","hash":"da65f527a8da65d5eb6721626d28cfdb46ab104a","modified":1593745759974},{"_id":"public/font/sourcesanspro.woff","hash":"a6722c9b6439b7a020a9be3d3178970757a9265c","modified":1593745759974},{"_id":"public/css/apollo.css","hash":"e07a11a5da5fc097f023e06a85575356066afd09","modified":1593745759978},{"_id":"themes/next/.gitignore","hash":"5f09fca02e030b7676c1d312cd88ce8fbccf381c","modified":1593744048142},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1593744048142},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1593744048142},{"_id":"themes/next/.javascript_ignore","hash":"f9ea3c5395f8feb225a24e2c32baa79afda30c16","modified":1593744048143},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1593744048143},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1593744048143},{"_id":"themes/next/.travis.yml","hash":"c42d9608c8c7fe90de7b1581a8dc3886e90c179e","modified":1593744048143},{"_id":"themes/next/README.en.md","hash":"4ece25ee5f64447cd522e54cb0fffd9a375f0bd4","modified":1593744048144},{"_id":"themes/next/bower.json","hash":"5abc236d9cc2512f5457ed57c1fba76669eb7399","modified":1593744048144},{"_id":"themes/next/README.md","hash":"500b5606eb6a09c979d16128f8b00f4bf9bc95ac","modified":1593744048144},{"_id":"themes/next/_config.yml","hash":"f08c347164391df2dcc19ea433514213be8c6406","modified":1593744048144},{"_id":"themes/next/gulpfile.coffee","hash":"b00e93c5c8667a4fbed71046dc93ce6784bf6257","modified":1593744048145},{"_id":"themes/next/package.json","hash":"a042faed34835a52505643aa2d841cd2dcf5dff6","modified":1593744048158},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5ab257af816986cd0e53f9527a92d5934ac70ae9","modified":1593744048142},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"c2024ded82143807c28a299c5fe6b927ef3525ff","modified":1593744048142},{"_id":"themes/next/languages/de.yml","hash":"1fdea1f84b7f691f5b4dd4d2b43eeb27b10fa0c8","modified":1593744048145},{"_id":"themes/next/languages/en.yml","hash":"95ec5cdfb563854f231b76162a3494f6ecc5bf61","modified":1593744048145},{"_id":"themes/next/languages/fr-FR.yml","hash":"e98f1558347752a20019b71f0b1f9c8be1b34f42","modified":1593744048145},{"_id":"themes/next/languages/default.yml","hash":"95ec5cdfb563854f231b76162a3494f6ecc5bf61","modified":1593744048145},{"_id":"themes/next/languages/ja.yml","hash":"49f12149edcc1892b26a6207328cda64da20116d","modified":1593744048146},{"_id":"themes/next/languages/pt.yml","hash":"6b660b117314cad93f08757601df3adb04c68beb","modified":1593744048146},{"_id":"themes/next/languages/pt-BR.yml","hash":"7742ba4c0d682cbe1d38305332ebc928abd754b5","modified":1593744048146},{"_id":"themes/next/languages/id.yml","hash":"34396bef27c4ab9e9a3c5d3e3aa94b0e3b3a7b0d","modified":1593744048145},{"_id":"themes/next/languages/ru.yml","hash":"5022885d8955e1b91d8841048db272bf99c59a76","modified":1593744048146},{"_id":"themes/next/languages/zh-Hans.yml","hash":"40d01dc46d57f71c2ef635c45b295d4355456e90","modified":1593744048147},{"_id":"themes/next/languages/zh-CN.yml","hash":"eb793985eb5b715a06e93b3fb8795a64c17807d3","modified":1593744048147},{"_id":"themes/next/languages/zh-hk.yml","hash":"19c23d21f262e24c06ee6ddfd51d2a6585304f88","modified":1593744048147},{"_id":"themes/next/layout/_layout.swig","hash":"2c0c3547a5b470024326a33ae2779d5ee0252266","modified":1593744048149},{"_id":"themes/next/languages/zh-tw.yml","hash":"68407799271c78ecc07f03d238257dd8c65ad42d","modified":1593744048147},{"_id":"themes/next/languages/ko.yml","hash":"b6bc5d6b0c000deb44099b42d3aebb8c49dbfca9","modified":1593744048146},{"_id":"themes/next/layout/category.swig","hash":"6422d196ceaff4220d54b8af770e7e957f3364ad","modified":1593744048157},{"_id":"themes/next/layout/index.swig","hash":"427d0b95b854e311ae363088ab39a393bf8fdc8b","modified":1593744048158},{"_id":"themes/next/layout/page.swig","hash":"3727fab9dadb967e9c2204edca787dc72264674a","modified":1593744048158},{"_id":"themes/next/layout/post.swig","hash":"e2e512142961ddfe77eba29eaa88f4a2ee43ae18","modified":1593744048158},{"_id":"themes/next/layout/archive.swig","hash":"b5b59d70fc1563f482fa07afd435752774ad5981","modified":1593744048157},{"_id":"themes/next/layout/schedule.swig","hash":"1f1cdc268f4ef773fd3ae693bbdf7d0b2f45c3a3","modified":1593744048158},{"_id":"themes/next/layout/tag.swig","hash":"07cf49c49c39a14dfbe9ce8e7d7eea3d4d0a4911","modified":1593744048158},{"_id":"themes/next/scripts/merge-configs.js","hash":"0c56be2e85c694247cfa327ea6d627b99ca265e8","modified":1593744048158},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1593744048214},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1593744048215},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1593744048214},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1593744048179},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1593744048148},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1593744048148},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"5864f5567ba5efeabcf6ea355013c0b603ee07f2","modified":1593744048149},{"_id":"themes/next/layout/_macro/post.swig","hash":"6243bc0778f87186ba78bb6022f40d719565fd19","modified":1593744048149},{"_id":"themes/next/layout/_macro/reward.swig","hash":"37e5b7c42ec17b9b6b786c5512bcc481a21c974e","modified":1593744048149},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"b57650032ed47b8bd357ec4dcc02d872fdd0e3e1","modified":1593744048149},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"14e785adeb0e671ba0ff9a553e6f0d8def6c670c","modified":1593744048149},{"_id":"themes/next/layout/_partials/comments.swig","hash":"970aa668680896262b1056bb5787fc9ec8754495","modified":1593744048150},{"_id":"themes/next/layout/_partials/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1593744048150},{"_id":"themes/next/layout/_partials/footer.swig","hash":"7172c6053118b7c291a56a7860128a652ae66b83","modified":1593744048150},{"_id":"themes/next/layout/_partials/head.swig","hash":"a0eafe24d1dae30c790ae35612154b3ffbbd5cce","modified":1593744048150},{"_id":"themes/next/layout/_partials/header.swig","hash":"665fee16093356d710f5c257b5e0d8e7416ab797","modified":1593744048151},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1593744048151},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1593744048151},{"_id":"themes/next/layout/_scripts/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1593744048153},{"_id":"themes/next/layout/_partials/search.swig","hash":"7b61e96508df70152b809ea5354236ab7f0d54f4","modified":1593744048151},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1593744048153},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1593744048153},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"4512867d80d9eddfc3a0f5fea3c456f33aa9d522","modified":1593744048157},{"_id":"themes/next/scripts/tags/button.js","hash":"62e6dbeb53d07627a048132c79630b45d9a8f2cc","modified":1593744048158},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1593744048159},{"_id":"themes/next/scripts/tags/exturl.js","hash":"79378f3a1cd90518b07808ed09156a3ab55ffa31","modified":1593744048159},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1593744048159},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1593744048159},{"_id":"themes/next/scripts/tags/note.js","hash":"6752925eedbdb939d8ec4d11bdfb75199f18dd70","modified":1593744048159},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1593744048178},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1593744048179},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1593744048185},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1593744048185},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1593744048185},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1593744048186},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1593744048186},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1593744048186},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1593744048187},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1593744048194},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1593744048194},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1593744048195},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1593744048195},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1593744048195},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1593744048153},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1593744048153},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1593744048171},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1593744048171},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1593744048171},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1593744048178},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1593744048178},{"_id":"themes/next/layout/_components/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1593744048148},{"_id":"themes/next/layout/_components/algolia-search/dom.swig","hash":"636f1181dd5887a70b4a08ca8f655d4e46635792","modified":1593744048148},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1593744048150},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1593744048150},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"741f09b2ba4e440011c15f5d288b109b82c87f1b","modified":1593744048151},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1593744048151},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1593744048151},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"63315fcf210799f894208c9f512737096df84962","modified":1593744048153},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1593744048152},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1593744048152},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1593744048152},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1593744048153},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1593744048154},{"_id":"themes/next/layout/_scripts/third-party/analytics.swig","hash":"e46900412e28f529c26e25e6bada342006435a32","modified":1593744048154},{"_id":"themes/next/layout/_scripts/third-party/comments.swig","hash":"a279e1881208aff2f669fe235e9661ab825bc540","modified":1593744048155},{"_id":"themes/next/layout/_scripts/third-party/lean-analytics.swig","hash":"92dc60821307fc9769bea9b2d60adaeb798342af","modified":1593744048156},{"_id":"themes/next/layout/_scripts/third-party/localsearch.swig","hash":"ceb39c100c99900294ddee8b1ff81fcaf43873b5","modified":1593744048157},{"_id":"themes/next/layout/_scripts/third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1593744048157},{"_id":"themes/next/layout/_scripts/third-party/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1593744048157},{"_id":"themes/next/layout/_scripts/third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1593744048157},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"78a83c38f69a8747bb74e420e6c9eeef1ea76525","modified":1593744048171},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1593744048171},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"715d5b40dc52f319fe4bff0325beb874774d9bd9","modified":1593744048171},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"c8d35a6b9e3bff6d8fdb66de853065af9d37562d","modified":1593744048177},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"06f432f328a5b8a9ef0dbd5301b002aba600b4ce","modified":1593744048178},{"_id":"themes/next/source/css/_variables/base.styl","hash":"3c8dcf93db666ac6f9f8955b5d36a9419430862a","modified":1593744048178},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1593744048196},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"54ca0acff29a414e2c1b7c1790db22f0c775604c","modified":1593744048196},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1593744048196},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1593744048196},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1593744048197},{"_id":"themes/next/source/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1593744048197},{"_id":"themes/next/source/js/src/post-details.js","hash":"661806a916fa46566accb3222da1fb790decb725","modified":1593744048197},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1593744048197},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1593744048198},{"_id":"themes/next/source/js/src/utils.js","hash":"86834fb60aad185634f8513b152d472a53d9ca08","modified":1593744048197},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1593744048200},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1593744048203},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1593744048203},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1593744048205},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1593744048204},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1593744048204},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"c1072942459fa0880e8a33a1bd929176b62b4171","modified":1593744048205},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1593744048205},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1593744048205},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1593744048205},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1593744048209},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1593744048210},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1593744048210},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1593744048210},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1593744048211},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1593744048211},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1593744048211},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1593744048211},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1593744048212},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1593744048213},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1593744048213},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1593744048214},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1593744048210},{"_id":"themes/next/layout/_scripts/third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1593744048154},{"_id":"themes/next/layout/_scripts/third-party/analytics/busuanzi-counter.swig","hash":"4fcbf57c4918528ab51d3d042cff92cf5aefb599","modified":1593744048154},{"_id":"themes/next/layout/_scripts/third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1593744048154},{"_id":"themes/next/layout/_scripts/third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1593744048154},{"_id":"themes/next/layout/_scripts/third-party/analytics/facebook-sdk.swig","hash":"394d008e5e94575280407ad8a1607a028026cbc3","modified":1593744048154},{"_id":"themes/next/layout/_scripts/third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1593744048154},{"_id":"themes/next/layout/_scripts/third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1593744048155},{"_id":"themes/next/layout/_scripts/third-party/analytics/tencent-mta.swig","hash":"a652f202bd5b30c648c228ab8f0e997eb4928e44","modified":1593744048155},{"_id":"themes/next/layout/_scripts/third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1593744048155},{"_id":"themes/next/layout/_scripts/third-party/comments/disqus.swig","hash":"fb1d04ede838b52ca7541973f86c3810f1ad396e","modified":1593744048155},{"_id":"themes/next/layout/_scripts/third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1593744048155},{"_id":"themes/next/layout/_scripts/third-party/comments/gentie.swig","hash":"03592d1d731592103a41ebb87437fe4b0a4c78ca","modified":1593744048156},{"_id":"themes/next/layout/_scripts/third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1593744048156},{"_id":"themes/next/layout/_scripts/third-party/comments/livere.swig","hash":"7240f2e5ec7115f8abbbc4c9ef73d4bed180fdc7","modified":1593744048156},{"_id":"themes/next/layout/_scripts/third-party/comments/youyan.swig","hash":"af9dd8a4aed7d06cf47b363eebff48850888566c","modified":1593744048156},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"59ad08bcc6fe9793594869ac2b4c525021453e78","modified":1593744048160},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"26d18060b9a13cc3c3feb90c3ed48aed711095a1","modified":1593744048160},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"0dfb4b3ba3180d7285e66f270e1d3fa0f132c3d2","modified":1593744048160},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1593744048160},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1593744048160},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1593744048164},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1593744048168},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1593744048170},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"5304f99581da3a31de3ecec959b7adf9002fde83","modified":1593744048170},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1593744048170},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1593744048170},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"013619c472c7e4b08311c464fcbe9fcf5edde603","modified":1593744048171},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1593744048171},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1593744048172},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1593744048172},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1593744048172},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1593744048173},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"fda14bc35be2e1b332809b55b3d07155a833dbf4","modified":1593744048173},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1593744048173},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1593744048173},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1593744048174},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1593744048174},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"82bbaa6322764779a1ac2e2c8390ce901c7972e2","modified":1593744048174},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1593744048174},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1593744048175},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1593744048176},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"f15537cee1a9ef4fa1e72a1670ebce4097db8115","modified":1593744048176},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"7e18f08c2c82f71e83860f232d43d8b89865ac2e","modified":1593744048176},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1593744048177},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"e3e23751d4ad24e8714b425d768cf68e37de7ded","modified":1593744048177},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1593744048177},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"79da92119bc246fe05d1626ac98426a83ec90a94","modified":1593744048197},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1593744048200},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1593744048200},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1593744048200},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1593744048200},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1593744048200},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1593744048201},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1593744048202},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1593744048204},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1593744048203},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1593744048202},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1593744048205},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"4eda182cbcc046dbf449aef97c02c230cf80a494","modified":1593744048206},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1593744048206},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"fb5b49426dee7f1508500e698d1b3c6b04c8fcce","modified":1593744048206},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1593744048211},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1593744048211},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1593744048207},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1593744048209},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1593744048209},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1593744048162},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"8994ffcce84deac0471532f270f97c44fea54dc0","modified":1593744048161},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1593744048161},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1593744048162},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"c890ce7fe933abad7baf39764a01894924854e92","modified":1593744048162},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1593744048162},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1593744048163},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"4b7f81e1006e7acee3d1c840ccba155239f830cc","modified":1593744048163},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1593744048163},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"7778920dd105fa4de3a7ab206eeba30b1a7bac45","modified":1593744048163},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1593744048163},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1593744048164},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1593744048164},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1593744048164},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"beccb53dcd658136fb91a0c5678dea8f37d6e0b6","modified":1593744048164},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"8fae54591877a73dff0b29b2be2e8935e3c63575","modified":1593744048165},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1593744048165},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"b25132fe6a7ad67059a2c3afc60feabb479bdd75","modified":1593744048165},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1593744048165},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"b9a2e76f019a5941191f1263b54aef7b69c48789","modified":1593744048166},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1593744048166},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"e792c8dc41561c96d128e9b421187f1c3dc978a0","modified":1593744048166},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1593744048166},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"963105a531403d7aad6d9e5e23e3bfabb8ec065a","modified":1593744048166},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1593744048166},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"bfd806d0a9f21446a22df82ac02e37d0075cc3b5","modified":1593744048166},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"2e7ec9aaa3293941106b1bdd09055246aa3c3dc6","modified":1593744048166},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1593744048167},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"c44f6a553ec7ea5508f2054a13be33a62a15d3a9","modified":1593744048167},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1593744048167},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1593744048167},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"7690b9596ec3a49befbe529a5a2649abec0faf76","modified":1593744048167},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"b8e754c93aa2f3d762f7ffc93bc0e526a729e879","modified":1593744048167},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"234facd038f144bd0fe09a31ed1357c5d74c517f","modified":1593744048167},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1593744048167},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1593744048168},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"b8969e1654eec89a0fd10d88b337fee9cb03cd44","modified":1593744048168},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1593744048168},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1593744048168},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"74d0ba86f698165d13402670382a822c8736a556","modified":1593744048169},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"8fe1e55bc290e6aaf07cc644fe27b62107a272a8","modified":1593744048169},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1593744048169},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1593744048169},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1593744048169},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1593744048169},{"_id":"themes/next/source/css/_common/components/third-party/gentie.styl","hash":"586a3ec0f1015e7207cd6a2474362e068c341744","modified":1593744048169},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1593744048170},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"173490e21bece35a34858e8e534cf86e34561350","modified":1593744048170},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"42348219db93a85d2ee23cb06cebd4d8ab121726","modified":1593744048170},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1593744048173},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1593744048174},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1593744048176},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1593744048201},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1593744048201},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1593744048201},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1593744048201},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1593744048201},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1593744048201},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1593744048208},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1593744048207},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1593744048213},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1593744048199},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"c0522272bbaef2acb3d341912754d6ea2d0ecfc0","modified":1593744048208},{"_id":"themes/next/source/images/avatar.jpg","hash":"c02ef6d1b68f8a052b64d7578a7e779682308d1f","modified":1593744048185},{"_id":"themes/next/source/images/img_1.jpg","hash":"2de606f7832229d8e789cf32f66d8baec512b6ae","modified":1593744048193},{"_id":"public/images/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1593745820549},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1593745820549},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1593745820549},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1593745820549},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1593745820549},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1593745820549},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1593745820549},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1593745820549},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1593745820549},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1593745820549},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1593745820549},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1593745820549},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1593745820550},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1593745820550},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1593745820550},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1593745820550},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1593745820550},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1593745820550},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1593745820550},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1593745820550},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1593745820550},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1593745820550},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1593745820550},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1593745820992},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1593745820994},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1593745820995},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1593745820995},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1593745821002},{"_id":"public/js/src/algolia-search.js","hash":"54ca0acff29a414e2c1b7c1790db22f0c775604c","modified":1593745821002},{"_id":"public/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1593745821002},{"_id":"public/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1593745821002},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1593745821002},{"_id":"public/js/src/post-details.js","hash":"661806a916fa46566accb3222da1fb790decb725","modified":1593745821002},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1593745821002},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1593745821002},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1593745821002},{"_id":"public/js/src/utils.js","hash":"86834fb60aad185634f8513b152d472a53d9ca08","modified":1593745821002},{"_id":"public/lib/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1593745821002},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1593745821002},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1593745821003},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1593745821003},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1593745821003},{"_id":"public/lib/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1593745821003},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1593745821003},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1593745821003},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1593745821003},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1593745821003},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1593745821003},{"_id":"public/js/src/schemes/pisces.js","hash":"79da92119bc246fe05d1626ac98426a83ec90a94","modified":1593745821003},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1593745821003},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1593745821003},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1593745821003},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1593745821003},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1593745821003},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1593745821003},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1593745821003},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1593745821003},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1593745821003},{"_id":"public/css/main.css","hash":"99131ec4b9117ae142287d2e2b22bab410bac683","modified":1593745821003},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1593745821003},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1593745821003},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1593745821004},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1593745821004},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1593745821004},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1593745821004},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"4eda182cbcc046dbf449aef97c02c230cf80a494","modified":1593745821004},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"fb5b49426dee7f1508500e698d1b3c6b04c8fcce","modified":1593745821004},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1593745821004},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1593745821004},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1593745821004},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"c0522272bbaef2acb3d341912754d6ea2d0ecfc0","modified":1593745821013},{"_id":"public/images/avatar.jpg","hash":"c02ef6d1b68f8a052b64d7578a7e779682308d1f","modified":1593745821024},{"_id":"public/images/img_1.jpg","hash":"2de606f7832229d8e789cf32f66d8baec512b6ae","modified":1593745821030},{"_id":"public/atom.xml","hash":"8c331fd8be740c72d8ac3df2f1dbed0bda79a388","modified":1593746218035},{"_id":"public/search.xml","hash":"6fd3a1263396fcaaed6936737b81784e6070f3e7","modified":1593746218036},{"_id":"public/sitemap.xml","hash":"328a75b667751c445bb012d6d564a00ae85a5a84","modified":1593746906932},{"_id":"public/scss/apollo.css","hash":"6216c473855db6af71f910746be48405c8c499f6","modified":1593746218070}],"Category":[],"Data":[],"Page":[{"title":"tags","date":"2017-02-26T01:29:44.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2017-02-26 09:29:44\ntype: \"tags\"\n---\n","updated":"2020-07-03T02:40:48.122Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ckc5n2qgv0001w8r1p30auj7a","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"关于我","date":"2017-02-26T01:40:15.000Z","_content":"\n喝酒不抽烟\n\n喜欢电子、民谣、美花\n\n北京后厂村最强突破手\n\nCSGO跪地三十发 一枪不中\n\n王者荣耀老年组冠军\n\n\n摸过Cocos、Unity、IOS、Flutter\n\n\n目前走在Android的路上，对遇到的事物保持好奇心和积极性，期待自己全栈的一天\n\n\nGitHub: https://github.com/Xiaojuanmao\n","source":"about/index.md","raw":"---\ntitle: 关于我\ndate: 2017-02-26 09:40:15\n\n---\n\n喝酒不抽烟\n\n喜欢电子、民谣、美花\n\n北京后厂村最强突破手\n\nCSGO跪地三十发 一枪不中\n\n王者荣耀老年组冠军\n\n\n摸过Cocos、Unity、IOS、Flutter\n\n\n目前走在Android的路上，对遇到的事物保持好奇心和积极性，期待自己全栈的一天\n\n\nGitHub: https://github.com/Xiaojuanmao\n","updated":"2020-07-03T03:28:05.771Z","path":"about/index.html","_id":"ckc5n2qgx0003w8r1rt3mqncv","comments":1,"layout":"page","content":"<p>喝酒不抽烟</p>\n<p>喜欢电子、民谣、美花</p>\n<p>北京后厂村最强突破手</p>\n<p>CSGO跪地三十发 一枪不中</p>\n<p>王者荣耀老年组冠军</p>\n<p>摸过Cocos、Unity、IOS、Flutter</p>\n<p>目前走在Android的路上，对遇到的事物保持好奇心和积极性，期待自己全栈的一天</p>\n<p>GitHub: <a href=\"https://github.com/Xiaojuanmao\" target=\"_blank\" rel=\"noopener\">https://github.com/Xiaojuanmao</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>喝酒不抽烟</p>\n<p>喜欢电子、民谣、美花</p>\n<p>北京后厂村最强突破手</p>\n<p>CSGO跪地三十发 一枪不中</p>\n<p>王者荣耀老年组冠军</p>\n<p>摸过Cocos、Unity、IOS、Flutter</p>\n<p>目前走在Android的路上，对遇到的事物保持好奇心和积极性，期待自己全栈的一天</p>\n<p>GitHub: <a href=\"https://github.com/Xiaojuanmao\" target=\"_blank\" rel=\"noopener\">https://github.com/Xiaojuanmao</a></p>\n"}],"Post":[{"title":"Github+Hexo搭建个人博客","date":"2017-02-22T16:52:12.000Z","_content":"\n# Ubuntu上结合Github用Hexo搭建博客\n\n### [](#u7B80_u4ECB \"简介\")简介\n在搭建博客的过程中会涉及到下面这些东西：\n\n1.  Hexo\n2.  Git\n3.  Github Pages\n4.  Npm\n5.  Nodejs\n\n**[Hexo](https://github.com/hexojs/hexo)**\n\n```\n一款基于Node.js的简单、快速、强大的静态博客框架\n\n```\n\n<!--more-->\n\n**Hexo搭建博客和github有什么关系**\n\n那Hexo就是一个博客框架，关Github什么事情呢，这还被你说对了，还真不怎么和github相关，用hexo弄一个博客出来很简单。当然你也可以选择用wordpress来结合hexo，只是这里选择用github pages服务，那又说到了一个东西:**github pages**。\n\n**[Github Pages](https://pages.github.com/)**\n\n上面是网址，可以自己进去看看，简单的说就是github提供的一种用来展示托管在自己github仓库上的静态网页。github pages也有自己的一套框架，只用github pages也可以搭建自己的博客。\n\n**[Npm](https://www.npmjs.com/)**\n\n一个NodeJs包管理和分发工具，全称为Node Package Manager。和Ruby的gem，Python的pypi类似。通过npm能快速的部署hexo框架，毕竟hexo基于nodejs。\n\n**[Node.js](https://nodejs.org/en/)**\n\nNode是一个Javascript运行环境(runtime)。实际上它是对Google V8引擎进行了封装。V8引 擎执行Javascript的速度非常快，性能非常好。Node对一些特殊用例进行了优化，提供了替代的API，使得V8在非浏览器环境下运行得更好。\n\n### [](#u5B89_u88C5 \"安装\")安装\n\n#### [](#1-__u5B89_u88C5Node-js \"1\\. 安装Node.js\")1\\. 安装Node.js\n\n在Ubuntu下面部署很容易的= =,在终端输入：\n\n```\nsudo apt-get install --yes nodejs\n\n```\n\nNodejs的部署工作就完成了。其他的Linux发行版可以参照下面的教程[Installing Node.js via package manager](https://github.com/nodejs/node-v0.x-archive/wiki/Installing-Node.js-via-package-manager)\n\n也可以在Node的官网上直接[下载](https://nodejs.org/en/download/)安装。\n\n安装好之后，在终端输入nodejs即可进入到nodejs的交互模式中。\n\n**Note**\n需要注意一个问题就是，在hexo中的nodejs文件在运行时使用的是`node xxx/js`这样的形式，而在Ubuntu下面直接运行`node xxx.js`会失败，报错为`/usr/bin/env: node: No such file or directory`，网上有些说是和node的版本有关，实际上是因为NodeJs在Ubuntu上默认安装之后，需要`nodejs xxx.js`这样用，解决方法为创建如下软链接，保证可以运行`node xxx.js`:\n\n```\nln -s /usr/bin/nodejs /usr/bin/node\n\n```\n\n#### [](#2-__u5B89_u88C5npm \"2\\. 安装npm\")2\\. 安装npm\n\n在终端输入：\n\n```\nsudo apt-get install npm\n\n```\n\n#### [](#3-__u5B89_u88C5hexo \"3\\. 安装hexo\")3\\. 安装hexo\n\n终端输入：\n\n```\nnpm install hexo-cli -g\n\n```\n\n在这里可能会报错，由于没有root权限导致无法安装hexo，`sudo su`root一下再安装一次就好了。\n\n到这里就完成了对Hexo的初步安装了，直接在终端输入`hexo`会出现相关的信息。\n\n#### [](#4-__u5B89_u88C5git \"4\\. 安装git\")4\\. 安装git\n\n首先安装git\n\n```\nsudo apt-get update\nsudo apt-get install git\n\n```\n\n设置用户信息\n\n```\n$ git config --global user.name \"Xiaojuanmao\"//用户名\n$ git config --global user.email  \"daque@hustunique.com\"//填写自己的邮箱\n\n```\n\n检查SSH keys\n\n```\n$ cd ~/. ssh\n\n```\n\n如果提示No such file or directory 说明你是第一次使用git。按照如下步骤处理SSH Keys，如果存在SSH Keys，则直接跳过下面分割线内的部分。\n\n* * *\n\n**配置SSH Keys**\n\n*   生成新的SSH Keys\n\n    ```\n    $ ssh-keygen -t rsa -C \"邮件地址@youremail.com\"\n\n    ```\n\n    会出现下面的提示：\n\n    ```\n    Generating public/private rsa key pair.\n    Enter file in which to save the key\n    (/Users/your_user_directory/.ssh/id_rsa):\n\n    ```\n\n    直接回车，存储在默认的目录下面。系统会提示输入密码，密码的作用是在向仓库提交代码的时候用到，可以防止其他人向自己的仓库提交代码。输入密码后，相关的会生成.ssh文件。\n\n*   添加新的SSH Keys到GitHub\n\n    通过下面的命令进入目录，该目录下存放着刚才生成的密钥文件\n\n    ```\n    $ cd ~/. ssh\n\n    ```\n\n    登陆github系统。点击右上角的 Account Settings—->SSH Public keys —-> add another public keys。打开刚才目录下面的`id_rsa.pub`文件，将文件内容复制到key文本框中就可以了。\n\n*   测试SSH\n    可以输入下面的命令，测试SSH是否设置成功\n\n    ```\n    ssh -T git@github.com\n\n    ```\n\n    如果出现下面的信息，则说明设置成功\n\n    ```\n    Hi XXX! You've successfully authenticated, but GitHub does not provide shell access.\n\n    ```\n\n    **Note**\n    也可能会报出错误：`Agent admitted failure to sign using the key.Permission denied (publickey).`这是由于没有将新建的ssh密钥加入，下面的命令可以解决：\n\n    ```\n    ssh-add   ~/.ssh/id_rsa\n\n    ```\n\n* * *\n\n### [](#u4F7F_u7528 \"使用\")使用\n\n#### [](#1-__u4F7F_u7528github_u521B_u5EFA_u535A_u5BA2_u4ED3_u5E93 \"1\\. 使用github创建博客仓库\")1\\. 使用github创建博客仓库\n在github上创建一个仓库，**仓库的名字和用户名必须对应**，如我的帐户名为`Xiaojuanmao`,则创建的仓库名称为`Xiaojuanmao.github.io`。这样存放在github上的远程仓库就准备好了，下面来用hexo来初始化本地的仓库内容。\n\n#### [](#2-_Hexo_u521D_u59CB_u5316 \"2\\. Hexo初始化\")2\\. Hexo初始化\n\n在主文件夹下创建一个hexo文件夹，进入文件夹，在终端输入如下的命令\n\n```\nhexo init\n\n```\n\n会给出这样的反馈：`INFO Copying data to ~/hexo INFO You are almost done! Don't forget to run 'npm install' before you start blogging with Hexo!`\n接着按照上面的提示，输入命令\n\n```\nnpm install\n\n```\n\n会自动在目录下面安装node_modules。接着在命令行中启动本地的服务器，可以用来预览个人博客的样子：\n\n```\nhexo server\n\n```\n\n反馈信息会提示已经在挂在了本地的服务器：`INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.`\n\n在浏览器中打开`http://0.0.0.0\"4000/`可以看到网页的整个框架已经生成了。有个默认的主题，如果觉得这个主题不好看，hexo还有好多主题可供更换。\n\n#### [](#3-__u6DFB_u52A0_u6587_u7AE0 \"3\\. 添加文章\")3\\. 添加文章\n\n打开命令行，进入到hexo的目录下，利用如下的命令，可以新建一个.md格式的文件。\n\n```\nhexo new \"My New Post\"\n反馈信息：INFO  Created: ~/hexo/source/_posts/My-New-Post.md\n\n```\n\n刷新刚才的`localhost:4000`，就能看到一篇新的博客出现了，用起来还是炒鸡方便的。创建之后再去编辑这个.md文件，写自己想写的内容就可以了。\n\n#### [](#4-__u751F_u6210_u9759_u6001_u7F51_u9875 \"4\\. 生成静态网页\")4\\. 生成静态网页\n\n下面的命令生成静态的网页，在将本地的内容部署到github上面去之前，一定要先执行这个步骤。\n\n```\nhexo generate\n   或者 hexo g\n\n```\n\n执行完之后，会在./public的目录下生成一系列的.html,.css文件。\n\n#### [](#5-__u90E8_u7F72_u5230Github \"5\\. 部署到Github\")5\\. 部署到Github\n\n在和github完成对接之前，需要去配置hexo自己的配置文件`_config.yml`。关于这个文件里面的一些内容，需要进行一些修改：\n\n```\n# Hexo Configuration\n## Docs: http://hexo.io/docs/configuration.html\n## Source: https://github.com/hexojs/hexo/\n\n# Site\ntitle: Xiaojuanmao's Blog # 网站的标题\nsubtitle: Life began in 1990 # 网站的副标题\ndescription: Coding Life # 显示在网页最下面的描述，类似于tag\nauthor: Xiaoxiaoda\nemail: daque@hustunique.com\nlanguage: zh_CN\ntimezone:\n\n# Deployment\n## Docs: http://hexo.io/docs/deployment.html\ndeploy:\n  type: git #这里不要写github了，hexo3.0之后用git代替了github\n  repository: git@github.com:Xiaojuanmao/Xiaojuanmao.github.io.git # 填写自己的git仓库地址，之前创建好了的\n  branch: master\n\n```\n\n更改完配置文件之后保存，通过下面的命令部署到github上：\n\n```\nhexo generate 或者 hexo g  #生成静态网页\nhexo deploy 或者 hexo d #部署到github\n上面两个命令可以和并为 hexo d -g\n\n```\n\n**Note**\n部署的过程中可能会出现如下的问题：\n\n```\nERROR Deployer not found: github\n\n```\n\n遇到这个不要慌，是hexo升级到3.0之后用git代替了github，所以需要再输入下面的命令，安装git的deployer\n\n```\nnpm install hexo-deployer-git --save\n\n```\n\n安装之后就可以将静态的网页部署到github的远程仓库上面。","source":"_posts/Github-Hexo搭建个人博客.md","raw":"---\ntitle: Github+Hexo搭建个人博客\ndate: 2017-02-23 00:52:12\ntags: hexo\n\n---\n\n# Ubuntu上结合Github用Hexo搭建博客\n\n### [](#u7B80_u4ECB \"简介\")简介\n在搭建博客的过程中会涉及到下面这些东西：\n\n1.  Hexo\n2.  Git\n3.  Github Pages\n4.  Npm\n5.  Nodejs\n\n**[Hexo](https://github.com/hexojs/hexo)**\n\n```\n一款基于Node.js的简单、快速、强大的静态博客框架\n\n```\n\n<!--more-->\n\n**Hexo搭建博客和github有什么关系**\n\n那Hexo就是一个博客框架，关Github什么事情呢，这还被你说对了，还真不怎么和github相关，用hexo弄一个博客出来很简单。当然你也可以选择用wordpress来结合hexo，只是这里选择用github pages服务，那又说到了一个东西:**github pages**。\n\n**[Github Pages](https://pages.github.com/)**\n\n上面是网址，可以自己进去看看，简单的说就是github提供的一种用来展示托管在自己github仓库上的静态网页。github pages也有自己的一套框架，只用github pages也可以搭建自己的博客。\n\n**[Npm](https://www.npmjs.com/)**\n\n一个NodeJs包管理和分发工具，全称为Node Package Manager。和Ruby的gem，Python的pypi类似。通过npm能快速的部署hexo框架，毕竟hexo基于nodejs。\n\n**[Node.js](https://nodejs.org/en/)**\n\nNode是一个Javascript运行环境(runtime)。实际上它是对Google V8引擎进行了封装。V8引 擎执行Javascript的速度非常快，性能非常好。Node对一些特殊用例进行了优化，提供了替代的API，使得V8在非浏览器环境下运行得更好。\n\n### [](#u5B89_u88C5 \"安装\")安装\n\n#### [](#1-__u5B89_u88C5Node-js \"1\\. 安装Node.js\")1\\. 安装Node.js\n\n在Ubuntu下面部署很容易的= =,在终端输入：\n\n```\nsudo apt-get install --yes nodejs\n\n```\n\nNodejs的部署工作就完成了。其他的Linux发行版可以参照下面的教程[Installing Node.js via package manager](https://github.com/nodejs/node-v0.x-archive/wiki/Installing-Node.js-via-package-manager)\n\n也可以在Node的官网上直接[下载](https://nodejs.org/en/download/)安装。\n\n安装好之后，在终端输入nodejs即可进入到nodejs的交互模式中。\n\n**Note**\n需要注意一个问题就是，在hexo中的nodejs文件在运行时使用的是`node xxx/js`这样的形式，而在Ubuntu下面直接运行`node xxx.js`会失败，报错为`/usr/bin/env: node: No such file or directory`，网上有些说是和node的版本有关，实际上是因为NodeJs在Ubuntu上默认安装之后，需要`nodejs xxx.js`这样用，解决方法为创建如下软链接，保证可以运行`node xxx.js`:\n\n```\nln -s /usr/bin/nodejs /usr/bin/node\n\n```\n\n#### [](#2-__u5B89_u88C5npm \"2\\. 安装npm\")2\\. 安装npm\n\n在终端输入：\n\n```\nsudo apt-get install npm\n\n```\n\n#### [](#3-__u5B89_u88C5hexo \"3\\. 安装hexo\")3\\. 安装hexo\n\n终端输入：\n\n```\nnpm install hexo-cli -g\n\n```\n\n在这里可能会报错，由于没有root权限导致无法安装hexo，`sudo su`root一下再安装一次就好了。\n\n到这里就完成了对Hexo的初步安装了，直接在终端输入`hexo`会出现相关的信息。\n\n#### [](#4-__u5B89_u88C5git \"4\\. 安装git\")4\\. 安装git\n\n首先安装git\n\n```\nsudo apt-get update\nsudo apt-get install git\n\n```\n\n设置用户信息\n\n```\n$ git config --global user.name \"Xiaojuanmao\"//用户名\n$ git config --global user.email  \"daque@hustunique.com\"//填写自己的邮箱\n\n```\n\n检查SSH keys\n\n```\n$ cd ~/. ssh\n\n```\n\n如果提示No such file or directory 说明你是第一次使用git。按照如下步骤处理SSH Keys，如果存在SSH Keys，则直接跳过下面分割线内的部分。\n\n* * *\n\n**配置SSH Keys**\n\n*   生成新的SSH Keys\n\n    ```\n    $ ssh-keygen -t rsa -C \"邮件地址@youremail.com\"\n\n    ```\n\n    会出现下面的提示：\n\n    ```\n    Generating public/private rsa key pair.\n    Enter file in which to save the key\n    (/Users/your_user_directory/.ssh/id_rsa):\n\n    ```\n\n    直接回车，存储在默认的目录下面。系统会提示输入密码，密码的作用是在向仓库提交代码的时候用到，可以防止其他人向自己的仓库提交代码。输入密码后，相关的会生成.ssh文件。\n\n*   添加新的SSH Keys到GitHub\n\n    通过下面的命令进入目录，该目录下存放着刚才生成的密钥文件\n\n    ```\n    $ cd ~/. ssh\n\n    ```\n\n    登陆github系统。点击右上角的 Account Settings—->SSH Public keys —-> add another public keys。打开刚才目录下面的`id_rsa.pub`文件，将文件内容复制到key文本框中就可以了。\n\n*   测试SSH\n    可以输入下面的命令，测试SSH是否设置成功\n\n    ```\n    ssh -T git@github.com\n\n    ```\n\n    如果出现下面的信息，则说明设置成功\n\n    ```\n    Hi XXX! You've successfully authenticated, but GitHub does not provide shell access.\n\n    ```\n\n    **Note**\n    也可能会报出错误：`Agent admitted failure to sign using the key.Permission denied (publickey).`这是由于没有将新建的ssh密钥加入，下面的命令可以解决：\n\n    ```\n    ssh-add   ~/.ssh/id_rsa\n\n    ```\n\n* * *\n\n### [](#u4F7F_u7528 \"使用\")使用\n\n#### [](#1-__u4F7F_u7528github_u521B_u5EFA_u535A_u5BA2_u4ED3_u5E93 \"1\\. 使用github创建博客仓库\")1\\. 使用github创建博客仓库\n在github上创建一个仓库，**仓库的名字和用户名必须对应**，如我的帐户名为`Xiaojuanmao`,则创建的仓库名称为`Xiaojuanmao.github.io`。这样存放在github上的远程仓库就准备好了，下面来用hexo来初始化本地的仓库内容。\n\n#### [](#2-_Hexo_u521D_u59CB_u5316 \"2\\. Hexo初始化\")2\\. Hexo初始化\n\n在主文件夹下创建一个hexo文件夹，进入文件夹，在终端输入如下的命令\n\n```\nhexo init\n\n```\n\n会给出这样的反馈：`INFO Copying data to ~/hexo INFO You are almost done! Don't forget to run 'npm install' before you start blogging with Hexo!`\n接着按照上面的提示，输入命令\n\n```\nnpm install\n\n```\n\n会自动在目录下面安装node_modules。接着在命令行中启动本地的服务器，可以用来预览个人博客的样子：\n\n```\nhexo server\n\n```\n\n反馈信息会提示已经在挂在了本地的服务器：`INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.`\n\n在浏览器中打开`http://0.0.0.0\"4000/`可以看到网页的整个框架已经生成了。有个默认的主题，如果觉得这个主题不好看，hexo还有好多主题可供更换。\n\n#### [](#3-__u6DFB_u52A0_u6587_u7AE0 \"3\\. 添加文章\")3\\. 添加文章\n\n打开命令行，进入到hexo的目录下，利用如下的命令，可以新建一个.md格式的文件。\n\n```\nhexo new \"My New Post\"\n反馈信息：INFO  Created: ~/hexo/source/_posts/My-New-Post.md\n\n```\n\n刷新刚才的`localhost:4000`，就能看到一篇新的博客出现了，用起来还是炒鸡方便的。创建之后再去编辑这个.md文件，写自己想写的内容就可以了。\n\n#### [](#4-__u751F_u6210_u9759_u6001_u7F51_u9875 \"4\\. 生成静态网页\")4\\. 生成静态网页\n\n下面的命令生成静态的网页，在将本地的内容部署到github上面去之前，一定要先执行这个步骤。\n\n```\nhexo generate\n   或者 hexo g\n\n```\n\n执行完之后，会在./public的目录下生成一系列的.html,.css文件。\n\n#### [](#5-__u90E8_u7F72_u5230Github \"5\\. 部署到Github\")5\\. 部署到Github\n\n在和github完成对接之前，需要去配置hexo自己的配置文件`_config.yml`。关于这个文件里面的一些内容，需要进行一些修改：\n\n```\n# Hexo Configuration\n## Docs: http://hexo.io/docs/configuration.html\n## Source: https://github.com/hexojs/hexo/\n\n# Site\ntitle: Xiaojuanmao's Blog # 网站的标题\nsubtitle: Life began in 1990 # 网站的副标题\ndescription: Coding Life # 显示在网页最下面的描述，类似于tag\nauthor: Xiaoxiaoda\nemail: daque@hustunique.com\nlanguage: zh_CN\ntimezone:\n\n# Deployment\n## Docs: http://hexo.io/docs/deployment.html\ndeploy:\n  type: git #这里不要写github了，hexo3.0之后用git代替了github\n  repository: git@github.com:Xiaojuanmao/Xiaojuanmao.github.io.git # 填写自己的git仓库地址，之前创建好了的\n  branch: master\n\n```\n\n更改完配置文件之后保存，通过下面的命令部署到github上：\n\n```\nhexo generate 或者 hexo g  #生成静态网页\nhexo deploy 或者 hexo d #部署到github\n上面两个命令可以和并为 hexo d -g\n\n```\n\n**Note**\n部署的过程中可能会出现如下的问题：\n\n```\nERROR Deployer not found: github\n\n```\n\n遇到这个不要慌，是hexo升级到3.0之后用git代替了github，所以需要再输入下面的命令，安装git的deployer\n\n```\nnpm install hexo-deployer-git --save\n\n```\n\n安装之后就可以将静态的网页部署到github的远程仓库上面。","slug":"Github-Hexo搭建个人博客","published":1,"updated":"2020-07-03T02:40:48.119Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc5n2qgt0000w8r185msl1ai","content":"<h1 id=\"Ubuntu上结合Github用Hexo搭建博客\"><a href=\"#Ubuntu上结合Github用Hexo搭建博客\" class=\"headerlink\" title=\"Ubuntu上结合Github用Hexo搭建博客\"></a>Ubuntu上结合Github用Hexo搭建博客</h1><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a><a href=\"#u7B80_u4ECB\" title=\"简介\"></a>简介</h3><p>在搭建博客的过程中会涉及到下面这些东西：</p>\n<ol>\n<li>Hexo</li>\n<li>Git</li>\n<li>Github Pages</li>\n<li>Npm</li>\n<li>Nodejs</li>\n</ol>\n<p><strong><a href=\"https://github.com/hexojs/hexo\" target=\"_blank\" rel=\"noopener\">Hexo</a></strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">一款基于Node.js的简单、快速、强大的静态博客框架</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p><strong>Hexo搭建博客和github有什么关系</strong></p>\n<p>那Hexo就是一个博客框架，关Github什么事情呢，这还被你说对了，还真不怎么和github相关，用hexo弄一个博客出来很简单。当然你也可以选择用wordpress来结合hexo，只是这里选择用github pages服务，那又说到了一个东西:<strong>github pages</strong>。</p>\n<p><strong><a href=\"https://pages.github.com/\" target=\"_blank\" rel=\"noopener\">Github Pages</a></strong></p>\n<p>上面是网址，可以自己进去看看，简单的说就是github提供的一种用来展示托管在自己github仓库上的静态网页。github pages也有自己的一套框架，只用github pages也可以搭建自己的博客。</p>\n<p><strong><a href=\"https://www.npmjs.com/\" target=\"_blank\" rel=\"noopener\">Npm</a></strong></p>\n<p>一个NodeJs包管理和分发工具，全称为Node Package Manager。和Ruby的gem，Python的pypi类似。通过npm能快速的部署hexo框架，毕竟hexo基于nodejs。</p>\n<p><strong><a href=\"https://nodejs.org/en/\" target=\"_blank\" rel=\"noopener\">Node.js</a></strong></p>\n<p>Node是一个Javascript运行环境(runtime)。实际上它是对Google V8引擎进行了封装。V8引 擎执行Javascript的速度非常快，性能非常好。Node对一些特殊用例进行了优化，提供了替代的API，使得V8在非浏览器环境下运行得更好。</p>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a><a href=\"#u5B89_u88C5\" title=\"安装\"></a>安装</h3><h4 id=\"1-安装Node-js\"><a href=\"#1-安装Node-js\" class=\"headerlink\" title=\"1. 安装Node.js\"></a><a href=\"#1-__u5B89_u88C5Node-js\" title=\"1\\. 安装Node.js\"></a>1. 安装Node.js</h4><p>在Ubuntu下面部署很容易的= =,在终端输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install --yes nodejs</div></pre></td></tr></table></figure>\n<p>Nodejs的部署工作就完成了。其他的Linux发行版可以参照下面的教程<a href=\"https://github.com/nodejs/node-v0.x-archive/wiki/Installing-Node.js-via-package-manager\" target=\"_blank\" rel=\"noopener\">Installing Node.js via package manager</a></p>\n<p>也可以在Node的官网上直接<a href=\"https://nodejs.org/en/download/\" target=\"_blank\" rel=\"noopener\">下载</a>安装。</p>\n<p>安装好之后，在终端输入nodejs即可进入到nodejs的交互模式中。</p>\n<p><strong>Note</strong><br>需要注意一个问题就是，在hexo中的nodejs文件在运行时使用的是<code>node xxx/js</code>这样的形式，而在Ubuntu下面直接运行<code>node xxx.js</code>会失败，报错为<code>/usr/bin/env: node: No such file or directory</code>，网上有些说是和node的版本有关，实际上是因为NodeJs在Ubuntu上默认安装之后，需要<code>nodejs xxx.js</code>这样用，解决方法为创建如下软链接，保证可以运行<code>node xxx.js</code>:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ln -s /usr/bin/nodejs /usr/bin/node</div></pre></td></tr></table></figure>\n<h4 id=\"2-安装npm\"><a href=\"#2-安装npm\" class=\"headerlink\" title=\"2. 安装npm\"></a><a href=\"#2-__u5B89_u88C5npm\" title=\"2\\. 安装npm\"></a>2. 安装npm</h4><p>在终端输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install npm</div></pre></td></tr></table></figure>\n<h4 id=\"3-安装hexo\"><a href=\"#3-安装hexo\" class=\"headerlink\" title=\"3. 安装hexo\"></a><a href=\"#3-__u5B89_u88C5hexo\" title=\"3\\. 安装hexo\"></a>3. 安装hexo</h4><p>终端输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install hexo-cli -g</div></pre></td></tr></table></figure>\n<p>在这里可能会报错，由于没有root权限导致无法安装hexo，<code>sudo su</code>root一下再安装一次就好了。</p>\n<p>到这里就完成了对Hexo的初步安装了，直接在终端输入<code>hexo</code>会出现相关的信息。</p>\n<h4 id=\"4-安装git\"><a href=\"#4-安装git\" class=\"headerlink\" title=\"4. 安装git\"></a><a href=\"#4-__u5B89_u88C5git\" title=\"4\\. 安装git\"></a>4. 安装git</h4><p>首先安装git</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get update</div><div class=\"line\">sudo apt-get install git</div></pre></td></tr></table></figure>\n<p>设置用户信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git config --global user.name &quot;Xiaojuanmao&quot;//用户名</div><div class=\"line\">$ git config --global user.email  &quot;daque@hustunique.com&quot;//填写自己的邮箱</div></pre></td></tr></table></figure>\n<p>检查SSH keys</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ cd ~/. ssh</div></pre></td></tr></table></figure>\n<p>如果提示No such file or directory 说明你是第一次使用git。按照如下步骤处理SSH Keys，如果存在SSH Keys，则直接跳过下面分割线内的部分。</p>\n<hr>\n<p><strong>配置SSH Keys</strong></p>\n<ul>\n<li><p>生成新的SSH Keys</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ ssh-keygen -t rsa -C &quot;邮件地址@youremail.com&quot;</div></pre></td></tr></table></figure>\n<p>会出现下面的提示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Generating public/private rsa key pair.</div><div class=\"line\">Enter file in which to save the key</div><div class=\"line\">(/Users/your_user_directory/.ssh/id_rsa):</div></pre></td></tr></table></figure>\n<p>直接回车，存储在默认的目录下面。系统会提示输入密码，密码的作用是在向仓库提交代码的时候用到，可以防止其他人向自己的仓库提交代码。输入密码后，相关的会生成.ssh文件。</p>\n</li>\n<li><p>添加新的SSH Keys到GitHub</p>\n<p>通过下面的命令进入目录，该目录下存放着刚才生成的密钥文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ cd ~/. ssh</div></pre></td></tr></table></figure>\n<p>登陆github系统。点击右上角的 Account Settings—-&gt;SSH Public keys —-&gt; add another public keys。打开刚才目录下面的<code>id_rsa.pub</code>文件，将文件内容复制到key文本框中就可以了。</p>\n</li>\n<li><p>测试SSH<br>可以输入下面的命令，测试SSH是否设置成功</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ssh -T git@github.com</div></pre></td></tr></table></figure>\n<p>如果出现下面的信息，则说明设置成功</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Hi XXX! You&apos;ve successfully authenticated, but GitHub does not provide shell access.</div></pre></td></tr></table></figure>\n<p><strong>Note</strong><br>也可能会报出错误：<code>Agent admitted failure to sign using the key.Permission denied (publickey).</code>这是由于没有将新建的ssh密钥加入，下面的命令可以解决：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ssh-add   ~/.ssh/id_rsa</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<hr>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a><a href=\"#u4F7F_u7528\" title=\"使用\"></a>使用</h3><h4 id=\"1-使用github创建博客仓库\"><a href=\"#1-使用github创建博客仓库\" class=\"headerlink\" title=\"1. 使用github创建博客仓库\"></a><a href=\"#1-__u4F7F_u7528github_u521B_u5EFA_u535A_u5BA2_u4ED3_u5E93\" title=\"1\\. 使用github创建博客仓库\"></a>1. 使用github创建博客仓库</h4><p>在github上创建一个仓库，<strong>仓库的名字和用户名必须对应</strong>，如我的帐户名为<code>Xiaojuanmao</code>,则创建的仓库名称为<code>Xiaojuanmao.github.io</code>。这样存放在github上的远程仓库就准备好了，下面来用hexo来初始化本地的仓库内容。</p>\n<h4 id=\"2-Hexo初始化\"><a href=\"#2-Hexo初始化\" class=\"headerlink\" title=\"2. Hexo初始化\"></a><a href=\"#2-_Hexo_u521D_u59CB_u5316\" title=\"2\\. Hexo初始化\"></a>2. Hexo初始化</h4><p>在主文件夹下创建一个hexo文件夹，进入文件夹，在终端输入如下的命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo init</div></pre></td></tr></table></figure>\n<p>会给出这样的反馈：<code>INFO Copying data to ~/hexo INFO You are almost done! Don&#39;t forget to run &#39;npm install&#39; before you start blogging with Hexo!</code><br>接着按照上面的提示，输入命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install</div></pre></td></tr></table></figure>\n<p>会自动在目录下面安装node_modules。接着在命令行中启动本地的服务器，可以用来预览个人博客的样子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo server</div></pre></td></tr></table></figure>\n<p>反馈信息会提示已经在挂在了本地的服务器：<code>INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.</code></p>\n<p>在浏览器中打开<code>http://0.0.0.0&quot;4000/</code>可以看到网页的整个框架已经生成了。有个默认的主题，如果觉得这个主题不好看，hexo还有好多主题可供更换。</p>\n<h4 id=\"3-添加文章\"><a href=\"#3-添加文章\" class=\"headerlink\" title=\"3. 添加文章\"></a><a href=\"#3-__u6DFB_u52A0_u6587_u7AE0\" title=\"3\\. 添加文章\"></a>3. 添加文章</h4><p>打开命令行，进入到hexo的目录下，利用如下的命令，可以新建一个.md格式的文件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo new &quot;My New Post&quot;</div><div class=\"line\">反馈信息：INFO  Created: ~/hexo/source/_posts/My-New-Post.md</div></pre></td></tr></table></figure>\n<p>刷新刚才的<code>localhost:4000</code>，就能看到一篇新的博客出现了，用起来还是炒鸡方便的。创建之后再去编辑这个.md文件，写自己想写的内容就可以了。</p>\n<h4 id=\"4-生成静态网页\"><a href=\"#4-生成静态网页\" class=\"headerlink\" title=\"4. 生成静态网页\"></a><a href=\"#4-__u751F_u6210_u9759_u6001_u7F51_u9875\" title=\"4\\. 生成静态网页\"></a>4. 生成静态网页</h4><p>下面的命令生成静态的网页，在将本地的内容部署到github上面去之前，一定要先执行这个步骤。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo generate</div><div class=\"line\">   或者 hexo g</div></pre></td></tr></table></figure>\n<p>执行完之后，会在./public的目录下生成一系列的.html,.css文件。</p>\n<h4 id=\"5-部署到Github\"><a href=\"#5-部署到Github\" class=\"headerlink\" title=\"5. 部署到Github\"></a><a href=\"#5-__u90E8_u7F72_u5230Github\" title=\"5\\. 部署到Github\"></a>5. 部署到Github</h4><p>在和github完成对接之前，需要去配置hexo自己的配置文件<code>_config.yml</code>。关于这个文件里面的一些内容，需要进行一些修改：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Hexo Configuration</div><div class=\"line\">## Docs: http://hexo.io/docs/configuration.html</div><div class=\"line\">## Source: https://github.com/hexojs/hexo/</div><div class=\"line\"></div><div class=\"line\"># Site</div><div class=\"line\">title: Xiaojuanmao&apos;s Blog # 网站的标题</div><div class=\"line\">subtitle: Life began in 1990 # 网站的副标题</div><div class=\"line\">description: Coding Life # 显示在网页最下面的描述，类似于tag</div><div class=\"line\">author: Xiaoxiaoda</div><div class=\"line\">email: daque@hustunique.com</div><div class=\"line\">language: zh_CN</div><div class=\"line\">timezone:</div><div class=\"line\"></div><div class=\"line\"># Deployment</div><div class=\"line\">## Docs: http://hexo.io/docs/deployment.html</div><div class=\"line\">deploy:</div><div class=\"line\">  type: git #这里不要写github了，hexo3.0之后用git代替了github</div><div class=\"line\">  repository: git@github.com:Xiaojuanmao/Xiaojuanmao.github.io.git # 填写自己的git仓库地址，之前创建好了的</div><div class=\"line\">  branch: master</div></pre></td></tr></table></figure>\n<p>更改完配置文件之后保存，通过下面的命令部署到github上：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo generate 或者 hexo g  #生成静态网页</div><div class=\"line\">hexo deploy 或者 hexo d #部署到github</div><div class=\"line\">上面两个命令可以和并为 hexo d -g</div></pre></td></tr></table></figure>\n<p><strong>Note</strong><br>部署的过程中可能会出现如下的问题：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ERROR Deployer not found: github</div></pre></td></tr></table></figure>\n<p>遇到这个不要慌，是hexo升级到3.0之后用git代替了github，所以需要再输入下面的命令，安装git的deployer</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install hexo-deployer-git --save</div></pre></td></tr></table></figure>\n<p>安装之后就可以将静态的网页部署到github的远程仓库上面。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"Ubuntu上结合Github用Hexo搭建博客\"><a href=\"#Ubuntu上结合Github用Hexo搭建博客\" class=\"headerlink\" title=\"Ubuntu上结合Github用Hexo搭建博客\"></a>Ubuntu上结合Github用Hexo搭建博客</h1><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a><a href=\"#u7B80_u4ECB\" title=\"简介\"></a>简介</h3><p>在搭建博客的过程中会涉及到下面这些东西：</p>\n<ol>\n<li>Hexo</li>\n<li>Git</li>\n<li>Github Pages</li>\n<li>Npm</li>\n<li>Nodejs</li>\n</ol>\n<p><strong><a href=\"https://github.com/hexojs/hexo\" target=\"_blank\" rel=\"noopener\">Hexo</a></strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">一款基于Node.js的简单、快速、强大的静态博客框架</div></pre></td></tr></table></figure>","more":"<p><strong>Hexo搭建博客和github有什么关系</strong></p>\n<p>那Hexo就是一个博客框架，关Github什么事情呢，这还被你说对了，还真不怎么和github相关，用hexo弄一个博客出来很简单。当然你也可以选择用wordpress来结合hexo，只是这里选择用github pages服务，那又说到了一个东西:<strong>github pages</strong>。</p>\n<p><strong><a href=\"https://pages.github.com/\" target=\"_blank\" rel=\"noopener\">Github Pages</a></strong></p>\n<p>上面是网址，可以自己进去看看，简单的说就是github提供的一种用来展示托管在自己github仓库上的静态网页。github pages也有自己的一套框架，只用github pages也可以搭建自己的博客。</p>\n<p><strong><a href=\"https://www.npmjs.com/\" target=\"_blank\" rel=\"noopener\">Npm</a></strong></p>\n<p>一个NodeJs包管理和分发工具，全称为Node Package Manager。和Ruby的gem，Python的pypi类似。通过npm能快速的部署hexo框架，毕竟hexo基于nodejs。</p>\n<p><strong><a href=\"https://nodejs.org/en/\" target=\"_blank\" rel=\"noopener\">Node.js</a></strong></p>\n<p>Node是一个Javascript运行环境(runtime)。实际上它是对Google V8引擎进行了封装。V8引 擎执行Javascript的速度非常快，性能非常好。Node对一些特殊用例进行了优化，提供了替代的API，使得V8在非浏览器环境下运行得更好。</p>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a><a href=\"#u5B89_u88C5\" title=\"安装\"></a>安装</h3><h4 id=\"1-安装Node-js\"><a href=\"#1-安装Node-js\" class=\"headerlink\" title=\"1. 安装Node.js\"></a><a href=\"#1-__u5B89_u88C5Node-js\" title=\"1\\. 安装Node.js\"></a>1. 安装Node.js</h4><p>在Ubuntu下面部署很容易的= =,在终端输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install --yes nodejs</div></pre></td></tr></table></figure>\n<p>Nodejs的部署工作就完成了。其他的Linux发行版可以参照下面的教程<a href=\"https://github.com/nodejs/node-v0.x-archive/wiki/Installing-Node.js-via-package-manager\" target=\"_blank\" rel=\"noopener\">Installing Node.js via package manager</a></p>\n<p>也可以在Node的官网上直接<a href=\"https://nodejs.org/en/download/\" target=\"_blank\" rel=\"noopener\">下载</a>安装。</p>\n<p>安装好之后，在终端输入nodejs即可进入到nodejs的交互模式中。</p>\n<p><strong>Note</strong><br>需要注意一个问题就是，在hexo中的nodejs文件在运行时使用的是<code>node xxx/js</code>这样的形式，而在Ubuntu下面直接运行<code>node xxx.js</code>会失败，报错为<code>/usr/bin/env: node: No such file or directory</code>，网上有些说是和node的版本有关，实际上是因为NodeJs在Ubuntu上默认安装之后，需要<code>nodejs xxx.js</code>这样用，解决方法为创建如下软链接，保证可以运行<code>node xxx.js</code>:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ln -s /usr/bin/nodejs /usr/bin/node</div></pre></td></tr></table></figure>\n<h4 id=\"2-安装npm\"><a href=\"#2-安装npm\" class=\"headerlink\" title=\"2. 安装npm\"></a><a href=\"#2-__u5B89_u88C5npm\" title=\"2\\. 安装npm\"></a>2. 安装npm</h4><p>在终端输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install npm</div></pre></td></tr></table></figure>\n<h4 id=\"3-安装hexo\"><a href=\"#3-安装hexo\" class=\"headerlink\" title=\"3. 安装hexo\"></a><a href=\"#3-__u5B89_u88C5hexo\" title=\"3\\. 安装hexo\"></a>3. 安装hexo</h4><p>终端输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install hexo-cli -g</div></pre></td></tr></table></figure>\n<p>在这里可能会报错，由于没有root权限导致无法安装hexo，<code>sudo su</code>root一下再安装一次就好了。</p>\n<p>到这里就完成了对Hexo的初步安装了，直接在终端输入<code>hexo</code>会出现相关的信息。</p>\n<h4 id=\"4-安装git\"><a href=\"#4-安装git\" class=\"headerlink\" title=\"4. 安装git\"></a><a href=\"#4-__u5B89_u88C5git\" title=\"4\\. 安装git\"></a>4. 安装git</h4><p>首先安装git</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get update</div><div class=\"line\">sudo apt-get install git</div></pre></td></tr></table></figure>\n<p>设置用户信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git config --global user.name &quot;Xiaojuanmao&quot;//用户名</div><div class=\"line\">$ git config --global user.email  &quot;daque@hustunique.com&quot;//填写自己的邮箱</div></pre></td></tr></table></figure>\n<p>检查SSH keys</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ cd ~/. ssh</div></pre></td></tr></table></figure>\n<p>如果提示No such file or directory 说明你是第一次使用git。按照如下步骤处理SSH Keys，如果存在SSH Keys，则直接跳过下面分割线内的部分。</p>\n<hr>\n<p><strong>配置SSH Keys</strong></p>\n<ul>\n<li><p>生成新的SSH Keys</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ ssh-keygen -t rsa -C &quot;邮件地址@youremail.com&quot;</div></pre></td></tr></table></figure>\n<p>会出现下面的提示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Generating public/private rsa key pair.</div><div class=\"line\">Enter file in which to save the key</div><div class=\"line\">(/Users/your_user_directory/.ssh/id_rsa):</div></pre></td></tr></table></figure>\n<p>直接回车，存储在默认的目录下面。系统会提示输入密码，密码的作用是在向仓库提交代码的时候用到，可以防止其他人向自己的仓库提交代码。输入密码后，相关的会生成.ssh文件。</p>\n</li>\n<li><p>添加新的SSH Keys到GitHub</p>\n<p>通过下面的命令进入目录，该目录下存放着刚才生成的密钥文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ cd ~/. ssh</div></pre></td></tr></table></figure>\n<p>登陆github系统。点击右上角的 Account Settings—-&gt;SSH Public keys —-&gt; add another public keys。打开刚才目录下面的<code>id_rsa.pub</code>文件，将文件内容复制到key文本框中就可以了。</p>\n</li>\n<li><p>测试SSH<br>可以输入下面的命令，测试SSH是否设置成功</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ssh -T git@github.com</div></pre></td></tr></table></figure>\n<p>如果出现下面的信息，则说明设置成功</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Hi XXX! You&apos;ve successfully authenticated, but GitHub does not provide shell access.</div></pre></td></tr></table></figure>\n<p><strong>Note</strong><br>也可能会报出错误：<code>Agent admitted failure to sign using the key.Permission denied (publickey).</code>这是由于没有将新建的ssh密钥加入，下面的命令可以解决：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ssh-add   ~/.ssh/id_rsa</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<hr>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a><a href=\"#u4F7F_u7528\" title=\"使用\"></a>使用</h3><h4 id=\"1-使用github创建博客仓库\"><a href=\"#1-使用github创建博客仓库\" class=\"headerlink\" title=\"1. 使用github创建博客仓库\"></a><a href=\"#1-__u4F7F_u7528github_u521B_u5EFA_u535A_u5BA2_u4ED3_u5E93\" title=\"1\\. 使用github创建博客仓库\"></a>1. 使用github创建博客仓库</h4><p>在github上创建一个仓库，<strong>仓库的名字和用户名必须对应</strong>，如我的帐户名为<code>Xiaojuanmao</code>,则创建的仓库名称为<code>Xiaojuanmao.github.io</code>。这样存放在github上的远程仓库就准备好了，下面来用hexo来初始化本地的仓库内容。</p>\n<h4 id=\"2-Hexo初始化\"><a href=\"#2-Hexo初始化\" class=\"headerlink\" title=\"2. Hexo初始化\"></a><a href=\"#2-_Hexo_u521D_u59CB_u5316\" title=\"2\\. Hexo初始化\"></a>2. Hexo初始化</h4><p>在主文件夹下创建一个hexo文件夹，进入文件夹，在终端输入如下的命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo init</div></pre></td></tr></table></figure>\n<p>会给出这样的反馈：<code>INFO Copying data to ~/hexo INFO You are almost done! Don&#39;t forget to run &#39;npm install&#39; before you start blogging with Hexo!</code><br>接着按照上面的提示，输入命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install</div></pre></td></tr></table></figure>\n<p>会自动在目录下面安装node_modules。接着在命令行中启动本地的服务器，可以用来预览个人博客的样子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo server</div></pre></td></tr></table></figure>\n<p>反馈信息会提示已经在挂在了本地的服务器：<code>INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.</code></p>\n<p>在浏览器中打开<code>http://0.0.0.0&quot;4000/</code>可以看到网页的整个框架已经生成了。有个默认的主题，如果觉得这个主题不好看，hexo还有好多主题可供更换。</p>\n<h4 id=\"3-添加文章\"><a href=\"#3-添加文章\" class=\"headerlink\" title=\"3. 添加文章\"></a><a href=\"#3-__u6DFB_u52A0_u6587_u7AE0\" title=\"3\\. 添加文章\"></a>3. 添加文章</h4><p>打开命令行，进入到hexo的目录下，利用如下的命令，可以新建一个.md格式的文件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo new &quot;My New Post&quot;</div><div class=\"line\">反馈信息：INFO  Created: ~/hexo/source/_posts/My-New-Post.md</div></pre></td></tr></table></figure>\n<p>刷新刚才的<code>localhost:4000</code>，就能看到一篇新的博客出现了，用起来还是炒鸡方便的。创建之后再去编辑这个.md文件，写自己想写的内容就可以了。</p>\n<h4 id=\"4-生成静态网页\"><a href=\"#4-生成静态网页\" class=\"headerlink\" title=\"4. 生成静态网页\"></a><a href=\"#4-__u751F_u6210_u9759_u6001_u7F51_u9875\" title=\"4\\. 生成静态网页\"></a>4. 生成静态网页</h4><p>下面的命令生成静态的网页，在将本地的内容部署到github上面去之前，一定要先执行这个步骤。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo generate</div><div class=\"line\">   或者 hexo g</div></pre></td></tr></table></figure>\n<p>执行完之后，会在./public的目录下生成一系列的.html,.css文件。</p>\n<h4 id=\"5-部署到Github\"><a href=\"#5-部署到Github\" class=\"headerlink\" title=\"5. 部署到Github\"></a><a href=\"#5-__u90E8_u7F72_u5230Github\" title=\"5\\. 部署到Github\"></a>5. 部署到Github</h4><p>在和github完成对接之前，需要去配置hexo自己的配置文件<code>_config.yml</code>。关于这个文件里面的一些内容，需要进行一些修改：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Hexo Configuration</div><div class=\"line\">## Docs: http://hexo.io/docs/configuration.html</div><div class=\"line\">## Source: https://github.com/hexojs/hexo/</div><div class=\"line\"></div><div class=\"line\"># Site</div><div class=\"line\">title: Xiaojuanmao&apos;s Blog # 网站的标题</div><div class=\"line\">subtitle: Life began in 1990 # 网站的副标题</div><div class=\"line\">description: Coding Life # 显示在网页最下面的描述，类似于tag</div><div class=\"line\">author: Xiaoxiaoda</div><div class=\"line\">email: daque@hustunique.com</div><div class=\"line\">language: zh_CN</div><div class=\"line\">timezone:</div><div class=\"line\"></div><div class=\"line\"># Deployment</div><div class=\"line\">## Docs: http://hexo.io/docs/deployment.html</div><div class=\"line\">deploy:</div><div class=\"line\">  type: git #这里不要写github了，hexo3.0之后用git代替了github</div><div class=\"line\">  repository: git@github.com:Xiaojuanmao/Xiaojuanmao.github.io.git # 填写自己的git仓库地址，之前创建好了的</div><div class=\"line\">  branch: master</div></pre></td></tr></table></figure>\n<p>更改完配置文件之后保存，通过下面的命令部署到github上：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo generate 或者 hexo g  #生成静态网页</div><div class=\"line\">hexo deploy 或者 hexo d #部署到github</div><div class=\"line\">上面两个命令可以和并为 hexo d -g</div></pre></td></tr></table></figure>\n<p><strong>Note</strong><br>部署的过程中可能会出现如下的问题：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ERROR Deployer not found: github</div></pre></td></tr></table></figure>\n<p>遇到这个不要慌，是hexo升级到3.0之后用git代替了github，所以需要再输入下面的命令，安装git的deployer</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install hexo-deployer-git --save</div></pre></td></tr></table></figure>\n<p>安装之后就可以将静态的网页部署到github的远程仓库上面。</p>"},{"title":"MessageQueue中的nativePollOnce","date":"2018-04-12T02:04:01.000Z","_content":"\n之前了解过的Handler、MessageQueue以及Looper等机制，在MessageQueue的`nativePollOnce`就终止了，在没有队列中没有消息的状态下，不同Android版本从Linux层面使用管道等方式实现异步阻塞/唤醒。\n\n在C++层的代码中，也存在一套Handler、MessageQueue以及Looper。\n\n`android_os_MessageQueue.cpp`中`nativePollOnce`\n\n```\nstatic void android_os_MessageQueue_nativePollOnce(JNIEnv* env, jobject obj,\n        jlong ptr, jint timeoutMillis) {\n    NativeMessageQueue* nativeMessageQueue = reinterpret_cast<NativeMessageQueue*>(ptr);\n    nativeMessageQueue->pollOnce(env, obj, timeoutMillis);\n}\n```\n\n调用了`nativeMessageQueue`的`pollOnce`方法:\n\n```\nvoid NativeMessageQueue::pollOnce(JNIEnv* env, jobject pollObj, int timeoutMillis) {\n    mPollEnv = env;\n    mPollObj = pollObj;\n    mLooper->pollOnce(timeoutMillis);\n    mPollObj = NULL;\n    mPollEnv = NULL;\n    if (mExceptionObj) {\n        env->Throw(mExceptionObj);\n        env->DeleteLocalRef(mExceptionObj);\n        mExceptionObj = NULL;\n    }\n}\n```\n\n紧接着调用了`Looper.cpp`的`pollOnce`方法:\n\n```\nint Looper::pollOnce(int timeoutMillis, int* outFd, int* outEvents, void** outData) {\n    int result = 0;\n    for (;;) {\n        while (mResponseIndex < mResponses.size()) {\n            const Response& response = mResponses.itemAt(mResponseIndex++);\n            int ident = response.request.ident;\n            if (ident >= 0) {\n                int fd = response.request.fd;\n                int events = response.events;\n                void* data = response.request.data;\n#if DEBUG_POLL_AND_WAKE\n                ALOGD(\"%p ~ pollOnce - returning signalled identifier %d: \"\n                        \"fd=%d, events=0x%x, data=%p\",\n                        this, ident, fd, events, data);\n#endif\n                if (outFd != NULL) *outFd = fd;\n                if (outEvents != NULL) *outEvents = events;\n                if (outData != NULL) *outData = data;\n                return ident;\n            }\n        }\n        if (result != 0) {\n#if DEBUG_POLL_AND_WAKE\n            ALOGD(\"%p ~ pollOnce - returning result %d\", this, result);\n#endif\n            if (outFd != NULL) *outFd = 0;\n            if (outEvents != NULL) *outEvents = 0;\n            if (outData != NULL) *outData = NULL;\n            return result;\n        }\n        result = pollInner(timeoutMillis);\n    }\n}\n```\n\n最后会跟踪到了`Looper.cpp`的`pollInner`方法上，这个方法会对底层的消息进行处理，线程的阻塞也会在函数`epoll_wait()`这里产生。\n\n```\nint Looper::pollInner(int timeoutMillis) {\n#if DEBUG_POLL_AND_WAKE\n    ALOGD(\"%p ~ pollOnce - waiting: timeoutMillis=%d\", this, timeoutMillis);\n#endif\n    // Adjust the timeout based on when the next message is due.\n    if (timeoutMillis != 0 && mNextMessageUptime != LLONG_MAX) {\n        nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC);\n        int messageTimeoutMillis = toMillisecondTimeoutDelay(now, mNextMessageUptime);\n        if (messageTimeoutMillis >= 0\n                && (timeoutMillis < 0 || messageTimeoutMillis < timeoutMillis)) {\n            timeoutMillis = messageTimeoutMillis;\n        }\n#if DEBUG_POLL_AND_WAKE\n        ALOGD(\"%p ~ pollOnce - next message in %\" PRId64 \"ns, adjusted timeout: timeoutMillis=%d\",\n                this, mNextMessageUptime - now, timeoutMillis);\n#endif\n    }\n    // Poll.\n    int result = POLL_WAKE;\n    mResponses.clear();\n    mResponseIndex = 0;\n    // We are about to idle.\n    mPolling = true;\n    struct epoll_event eventItems[EPOLL_MAX_EVENTS];\n    int eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);\n    // No longer idling.\n    mPolling = false;\n    // Acquire lock.\n    mLock.lock();\n    \n    ...\n    \n}\n```\n\n在C++层的`Looper`初始化的过程中，会初始化一个`管道`，管道会提供读、写两个端口，并创建一个`epoll`实例来监控管道的读端口。具体代码如下:\n\n```\nLooper::Looper(bool allowNonCallbacks) :\n        mAllowNonCallbacks(allowNonCallbacks), mSendingMessage(false),\n        mResponseIndex(0), mNextMessageUptime(LLONG_MAX) {\n    int wakeFds[2];\n    int result = pipe(wakeFds); // 创建管道\n    LOG_ALWAYS_FATAL_IF(result != 0, \"Could not create wake pipe.  errno=%d\", errno);\n    mWakeReadPipeFd = wakeFds[0]; // 读端口\n    mWakeWritePipeFd = wakeFds[1]; // 写端口\n    result = fcntl(mWakeReadPipeFd, F_SETFL, O_NONBLOCK);\n    LOG_ALWAYS_FATAL_IF(result != 0, \"Could not make wake read pipe non-blocking.  errno=%d\",\n            errno);\n    result = fcntl(mWakeWritePipeFd, F_SETFL, O_NONBLOCK);\n    LOG_ALWAYS_FATAL_IF(result != 0, \"Could not make wake write pipe non-blocking.  errno=%d\",\n            errno);\n    // Allocate the epoll instance and register the wake pipe.\n    mEpollFd = epoll_create(EPOLL_SIZE_HINT); // 创建一个epoll实例，用来监控mWakeReadPipeFd\n    LOG_ALWAYS_FATAL_IF(mEpollFd < 0, \"Could not create epoll instance.  errno=%d\", errno);\n    struct epoll_event eventItem;\n    memset(& eventItem, 0, sizeof(epoll_event)); // zero out unused members of data field union\n    eventItem.events = EPOLLIN;\n    eventItem.data.fd = mWakeReadPipeFd;\n    result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeReadPipeFd, & eventItem); // 注册监听\n    LOG_ALWAYS_FATAL_IF(result != 0, \"Could not add wake read pipe to epoll instance.  errno=%d\",\n            errno);\n}\n```\n\n使用`epoll`注册监听`Looper`中的`mWakeReadPipeFd`之后，在上面提到过的`epoll_wait()`函数等待的线程，将会在`mWakeWritePipeFd`端口有数据写入的时候被唤醒，在Java层的`MessageQueue`中，有消息加入队列的时候，会检测是否需要唤醒当前在`epoll_wait()`等待的线程，如果需要唤醒，则会调用`MessageQueue.cpp`的`nativeWake()`方法，进而调用到`Looper.cpp`的`wake()`方法:\n\n```\nvoid Looper::wake() {\n#if DEBUG_POLL_AND_WAKE\n    ALOGD(\"%p ~ wake\", this);\n#endif\n    ssize_t nWrite;\n    do {\n        nWrite = write(mWakeWritePipeFd, \"W\", 1);\n    } while (nWrite == -1 && errno == EINTR);\n    if (nWrite != 1) {\n        if (errno != EAGAIN) {\n            ALOGW(\"Could not write wake signal, errno=%d\", errno);\n        }\n    }\n}\n```\n\n唤醒的方式为，向之前创建的管道中写入一个`W`字符，管道的读端将会被唤醒，线程离开`epoll_wait()`方法，开始执行之后的代码，从消息队列中取出消息，开始干活.\n\n##### 参考文章\n\n> http://www.bijishequ.com/detail/214262\n> http://shangjin615.iteye.com/blog/1778615\n\n#### 源代码\n\n[Looper.cpp](https://chromium.googlesource.com/aosp/platform/system/core/+/master/libutils/Looper.cpp)\n\n[MessageQueue.cpp](https://android.googlesource.com/platform/frameworks/base/+/master/core/jni/android_os_MessageQueue.cpp)","source":"_posts/MessageQueue中的nativePollOnce.md","raw":"---\ntitle: MessageQueue中的nativePollOnce\ndate: 2018-04-12 10:04:01\ntags: Android\n\n---\n\n之前了解过的Handler、MessageQueue以及Looper等机制，在MessageQueue的`nativePollOnce`就终止了，在没有队列中没有消息的状态下，不同Android版本从Linux层面使用管道等方式实现异步阻塞/唤醒。\n\n在C++层的代码中，也存在一套Handler、MessageQueue以及Looper。\n\n`android_os_MessageQueue.cpp`中`nativePollOnce`\n\n```\nstatic void android_os_MessageQueue_nativePollOnce(JNIEnv* env, jobject obj,\n        jlong ptr, jint timeoutMillis) {\n    NativeMessageQueue* nativeMessageQueue = reinterpret_cast<NativeMessageQueue*>(ptr);\n    nativeMessageQueue->pollOnce(env, obj, timeoutMillis);\n}\n```\n\n调用了`nativeMessageQueue`的`pollOnce`方法:\n\n```\nvoid NativeMessageQueue::pollOnce(JNIEnv* env, jobject pollObj, int timeoutMillis) {\n    mPollEnv = env;\n    mPollObj = pollObj;\n    mLooper->pollOnce(timeoutMillis);\n    mPollObj = NULL;\n    mPollEnv = NULL;\n    if (mExceptionObj) {\n        env->Throw(mExceptionObj);\n        env->DeleteLocalRef(mExceptionObj);\n        mExceptionObj = NULL;\n    }\n}\n```\n\n紧接着调用了`Looper.cpp`的`pollOnce`方法:\n\n```\nint Looper::pollOnce(int timeoutMillis, int* outFd, int* outEvents, void** outData) {\n    int result = 0;\n    for (;;) {\n        while (mResponseIndex < mResponses.size()) {\n            const Response& response = mResponses.itemAt(mResponseIndex++);\n            int ident = response.request.ident;\n            if (ident >= 0) {\n                int fd = response.request.fd;\n                int events = response.events;\n                void* data = response.request.data;\n#if DEBUG_POLL_AND_WAKE\n                ALOGD(\"%p ~ pollOnce - returning signalled identifier %d: \"\n                        \"fd=%d, events=0x%x, data=%p\",\n                        this, ident, fd, events, data);\n#endif\n                if (outFd != NULL) *outFd = fd;\n                if (outEvents != NULL) *outEvents = events;\n                if (outData != NULL) *outData = data;\n                return ident;\n            }\n        }\n        if (result != 0) {\n#if DEBUG_POLL_AND_WAKE\n            ALOGD(\"%p ~ pollOnce - returning result %d\", this, result);\n#endif\n            if (outFd != NULL) *outFd = 0;\n            if (outEvents != NULL) *outEvents = 0;\n            if (outData != NULL) *outData = NULL;\n            return result;\n        }\n        result = pollInner(timeoutMillis);\n    }\n}\n```\n\n最后会跟踪到了`Looper.cpp`的`pollInner`方法上，这个方法会对底层的消息进行处理，线程的阻塞也会在函数`epoll_wait()`这里产生。\n\n```\nint Looper::pollInner(int timeoutMillis) {\n#if DEBUG_POLL_AND_WAKE\n    ALOGD(\"%p ~ pollOnce - waiting: timeoutMillis=%d\", this, timeoutMillis);\n#endif\n    // Adjust the timeout based on when the next message is due.\n    if (timeoutMillis != 0 && mNextMessageUptime != LLONG_MAX) {\n        nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC);\n        int messageTimeoutMillis = toMillisecondTimeoutDelay(now, mNextMessageUptime);\n        if (messageTimeoutMillis >= 0\n                && (timeoutMillis < 0 || messageTimeoutMillis < timeoutMillis)) {\n            timeoutMillis = messageTimeoutMillis;\n        }\n#if DEBUG_POLL_AND_WAKE\n        ALOGD(\"%p ~ pollOnce - next message in %\" PRId64 \"ns, adjusted timeout: timeoutMillis=%d\",\n                this, mNextMessageUptime - now, timeoutMillis);\n#endif\n    }\n    // Poll.\n    int result = POLL_WAKE;\n    mResponses.clear();\n    mResponseIndex = 0;\n    // We are about to idle.\n    mPolling = true;\n    struct epoll_event eventItems[EPOLL_MAX_EVENTS];\n    int eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);\n    // No longer idling.\n    mPolling = false;\n    // Acquire lock.\n    mLock.lock();\n    \n    ...\n    \n}\n```\n\n在C++层的`Looper`初始化的过程中，会初始化一个`管道`，管道会提供读、写两个端口，并创建一个`epoll`实例来监控管道的读端口。具体代码如下:\n\n```\nLooper::Looper(bool allowNonCallbacks) :\n        mAllowNonCallbacks(allowNonCallbacks), mSendingMessage(false),\n        mResponseIndex(0), mNextMessageUptime(LLONG_MAX) {\n    int wakeFds[2];\n    int result = pipe(wakeFds); // 创建管道\n    LOG_ALWAYS_FATAL_IF(result != 0, \"Could not create wake pipe.  errno=%d\", errno);\n    mWakeReadPipeFd = wakeFds[0]; // 读端口\n    mWakeWritePipeFd = wakeFds[1]; // 写端口\n    result = fcntl(mWakeReadPipeFd, F_SETFL, O_NONBLOCK);\n    LOG_ALWAYS_FATAL_IF(result != 0, \"Could not make wake read pipe non-blocking.  errno=%d\",\n            errno);\n    result = fcntl(mWakeWritePipeFd, F_SETFL, O_NONBLOCK);\n    LOG_ALWAYS_FATAL_IF(result != 0, \"Could not make wake write pipe non-blocking.  errno=%d\",\n            errno);\n    // Allocate the epoll instance and register the wake pipe.\n    mEpollFd = epoll_create(EPOLL_SIZE_HINT); // 创建一个epoll实例，用来监控mWakeReadPipeFd\n    LOG_ALWAYS_FATAL_IF(mEpollFd < 0, \"Could not create epoll instance.  errno=%d\", errno);\n    struct epoll_event eventItem;\n    memset(& eventItem, 0, sizeof(epoll_event)); // zero out unused members of data field union\n    eventItem.events = EPOLLIN;\n    eventItem.data.fd = mWakeReadPipeFd;\n    result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeReadPipeFd, & eventItem); // 注册监听\n    LOG_ALWAYS_FATAL_IF(result != 0, \"Could not add wake read pipe to epoll instance.  errno=%d\",\n            errno);\n}\n```\n\n使用`epoll`注册监听`Looper`中的`mWakeReadPipeFd`之后，在上面提到过的`epoll_wait()`函数等待的线程，将会在`mWakeWritePipeFd`端口有数据写入的时候被唤醒，在Java层的`MessageQueue`中，有消息加入队列的时候，会检测是否需要唤醒当前在`epoll_wait()`等待的线程，如果需要唤醒，则会调用`MessageQueue.cpp`的`nativeWake()`方法，进而调用到`Looper.cpp`的`wake()`方法:\n\n```\nvoid Looper::wake() {\n#if DEBUG_POLL_AND_WAKE\n    ALOGD(\"%p ~ wake\", this);\n#endif\n    ssize_t nWrite;\n    do {\n        nWrite = write(mWakeWritePipeFd, \"W\", 1);\n    } while (nWrite == -1 && errno == EINTR);\n    if (nWrite != 1) {\n        if (errno != EAGAIN) {\n            ALOGW(\"Could not write wake signal, errno=%d\", errno);\n        }\n    }\n}\n```\n\n唤醒的方式为，向之前创建的管道中写入一个`W`字符，管道的读端将会被唤醒，线程离开`epoll_wait()`方法，开始执行之后的代码，从消息队列中取出消息，开始干活.\n\n##### 参考文章\n\n> http://www.bijishequ.com/detail/214262\n> http://shangjin615.iteye.com/blog/1778615\n\n#### 源代码\n\n[Looper.cpp](https://chromium.googlesource.com/aosp/platform/system/core/+/master/libutils/Looper.cpp)\n\n[MessageQueue.cpp](https://android.googlesource.com/platform/frameworks/base/+/master/core/jni/android_os_MessageQueue.cpp)","slug":"MessageQueue中的nativePollOnce","published":1,"updated":"2020-07-03T02:40:48.119Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc5n2qgw0002w8r1w5ri93w1","content":"<p>之前了解过的Handler、MessageQueue以及Looper等机制，在MessageQueue的<code>nativePollOnce</code>就终止了，在没有队列中没有消息的状态下，不同Android版本从Linux层面使用管道等方式实现异步阻塞/唤醒。</p>\n<p>在C++层的代码中，也存在一套Handler、MessageQueue以及Looper。</p>\n<p><code>android_os_MessageQueue.cpp</code>中<code>nativePollOnce</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">static void android_os_MessageQueue_nativePollOnce(JNIEnv* env, jobject obj,</div><div class=\"line\">        jlong ptr, jint timeoutMillis) &#123;</div><div class=\"line\">    NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr);</div><div class=\"line\">    nativeMessageQueue-&gt;pollOnce(env, obj, timeoutMillis);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>调用了<code>nativeMessageQueue</code>的<code>pollOnce</code>方法:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">void NativeMessageQueue::pollOnce(JNIEnv* env, jobject pollObj, int timeoutMillis) &#123;</div><div class=\"line\">    mPollEnv = env;</div><div class=\"line\">    mPollObj = pollObj;</div><div class=\"line\">    mLooper-&gt;pollOnce(timeoutMillis);</div><div class=\"line\">    mPollObj = NULL;</div><div class=\"line\">    mPollEnv = NULL;</div><div class=\"line\">    if (mExceptionObj) &#123;</div><div class=\"line\">        env-&gt;Throw(mExceptionObj);</div><div class=\"line\">        env-&gt;DeleteLocalRef(mExceptionObj);</div><div class=\"line\">        mExceptionObj = NULL;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>紧接着调用了<code>Looper.cpp</code>的<code>pollOnce</code>方法:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">int Looper::pollOnce(int timeoutMillis, int* outFd, int* outEvents, void** outData) &#123;</div><div class=\"line\">    int result = 0;</div><div class=\"line\">    for (;;) &#123;</div><div class=\"line\">        while (mResponseIndex &lt; mResponses.size()) &#123;</div><div class=\"line\">            const Response&amp; response = mResponses.itemAt(mResponseIndex++);</div><div class=\"line\">            int ident = response.request.ident;</div><div class=\"line\">            if (ident &gt;= 0) &#123;</div><div class=\"line\">                int fd = response.request.fd;</div><div class=\"line\">                int events = response.events;</div><div class=\"line\">                void* data = response.request.data;</div><div class=\"line\">#if DEBUG_POLL_AND_WAKE</div><div class=\"line\">                ALOGD(&quot;%p ~ pollOnce - returning signalled identifier %d: &quot;</div><div class=\"line\">                        &quot;fd=%d, events=0x%x, data=%p&quot;,</div><div class=\"line\">                        this, ident, fd, events, data);</div><div class=\"line\">#endif</div><div class=\"line\">                if (outFd != NULL) *outFd = fd;</div><div class=\"line\">                if (outEvents != NULL) *outEvents = events;</div><div class=\"line\">                if (outData != NULL) *outData = data;</div><div class=\"line\">                return ident;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (result != 0) &#123;</div><div class=\"line\">#if DEBUG_POLL_AND_WAKE</div><div class=\"line\">            ALOGD(&quot;%p ~ pollOnce - returning result %d&quot;, this, result);</div><div class=\"line\">#endif</div><div class=\"line\">            if (outFd != NULL) *outFd = 0;</div><div class=\"line\">            if (outEvents != NULL) *outEvents = 0;</div><div class=\"line\">            if (outData != NULL) *outData = NULL;</div><div class=\"line\">            return result;</div><div class=\"line\">        &#125;</div><div class=\"line\">        result = pollInner(timeoutMillis);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>最后会跟踪到了<code>Looper.cpp</code>的<code>pollInner</code>方法上，这个方法会对底层的消息进行处理，线程的阻塞也会在函数<code>epoll_wait()</code>这里产生。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">int Looper::pollInner(int timeoutMillis) &#123;</div><div class=\"line\">#if DEBUG_POLL_AND_WAKE</div><div class=\"line\">    ALOGD(&quot;%p ~ pollOnce - waiting: timeoutMillis=%d&quot;, this, timeoutMillis);</div><div class=\"line\">#endif</div><div class=\"line\">    // Adjust the timeout based on when the next message is due.</div><div class=\"line\">    if (timeoutMillis != 0 &amp;&amp; mNextMessageUptime != LLONG_MAX) &#123;</div><div class=\"line\">        nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC);</div><div class=\"line\">        int messageTimeoutMillis = toMillisecondTimeoutDelay(now, mNextMessageUptime);</div><div class=\"line\">        if (messageTimeoutMillis &gt;= 0</div><div class=\"line\">                &amp;&amp; (timeoutMillis &lt; 0 || messageTimeoutMillis &lt; timeoutMillis)) &#123;</div><div class=\"line\">            timeoutMillis = messageTimeoutMillis;</div><div class=\"line\">        &#125;</div><div class=\"line\">#if DEBUG_POLL_AND_WAKE</div><div class=\"line\">        ALOGD(&quot;%p ~ pollOnce - next message in %&quot; PRId64 &quot;ns, adjusted timeout: timeoutMillis=%d&quot;,</div><div class=\"line\">                this, mNextMessageUptime - now, timeoutMillis);</div><div class=\"line\">#endif</div><div class=\"line\">    &#125;</div><div class=\"line\">    // Poll.</div><div class=\"line\">    int result = POLL_WAKE;</div><div class=\"line\">    mResponses.clear();</div><div class=\"line\">    mResponseIndex = 0;</div><div class=\"line\">    // We are about to idle.</div><div class=\"line\">    mPolling = true;</div><div class=\"line\">    struct epoll_event eventItems[EPOLL_MAX_EVENTS];</div><div class=\"line\">    int eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);</div><div class=\"line\">    // No longer idling.</div><div class=\"line\">    mPolling = false;</div><div class=\"line\">    // Acquire lock.</div><div class=\"line\">    mLock.lock();</div><div class=\"line\">    </div><div class=\"line\">    ...</div><div class=\"line\">    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在C++层的<code>Looper</code>初始化的过程中，会初始化一个<code>管道</code>，管道会提供读、写两个端口，并创建一个<code>epoll</code>实例来监控管道的读端口。具体代码如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">Looper::Looper(bool allowNonCallbacks) :</div><div class=\"line\">        mAllowNonCallbacks(allowNonCallbacks), mSendingMessage(false),</div><div class=\"line\">        mResponseIndex(0), mNextMessageUptime(LLONG_MAX) &#123;</div><div class=\"line\">    int wakeFds[2];</div><div class=\"line\">    int result = pipe(wakeFds); // 创建管道</div><div class=\"line\">    LOG_ALWAYS_FATAL_IF(result != 0, &quot;Could not create wake pipe.  errno=%d&quot;, errno);</div><div class=\"line\">    mWakeReadPipeFd = wakeFds[0]; // 读端口</div><div class=\"line\">    mWakeWritePipeFd = wakeFds[1]; // 写端口</div><div class=\"line\">    result = fcntl(mWakeReadPipeFd, F_SETFL, O_NONBLOCK);</div><div class=\"line\">    LOG_ALWAYS_FATAL_IF(result != 0, &quot;Could not make wake read pipe non-blocking.  errno=%d&quot;,</div><div class=\"line\">            errno);</div><div class=\"line\">    result = fcntl(mWakeWritePipeFd, F_SETFL, O_NONBLOCK);</div><div class=\"line\">    LOG_ALWAYS_FATAL_IF(result != 0, &quot;Could not make wake write pipe non-blocking.  errno=%d&quot;,</div><div class=\"line\">            errno);</div><div class=\"line\">    // Allocate the epoll instance and register the wake pipe.</div><div class=\"line\">    mEpollFd = epoll_create(EPOLL_SIZE_HINT); // 创建一个epoll实例，用来监控mWakeReadPipeFd</div><div class=\"line\">    LOG_ALWAYS_FATAL_IF(mEpollFd &lt; 0, &quot;Could not create epoll instance.  errno=%d&quot;, errno);</div><div class=\"line\">    struct epoll_event eventItem;</div><div class=\"line\">    memset(&amp; eventItem, 0, sizeof(epoll_event)); // zero out unused members of data field union</div><div class=\"line\">    eventItem.events = EPOLLIN;</div><div class=\"line\">    eventItem.data.fd = mWakeReadPipeFd;</div><div class=\"line\">    result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeReadPipeFd, &amp; eventItem); // 注册监听</div><div class=\"line\">    LOG_ALWAYS_FATAL_IF(result != 0, &quot;Could not add wake read pipe to epoll instance.  errno=%d&quot;,</div><div class=\"line\">            errno);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用<code>epoll</code>注册监听<code>Looper</code>中的<code>mWakeReadPipeFd</code>之后，在上面提到过的<code>epoll_wait()</code>函数等待的线程，将会在<code>mWakeWritePipeFd</code>端口有数据写入的时候被唤醒，在Java层的<code>MessageQueue</code>中，有消息加入队列的时候，会检测是否需要唤醒当前在<code>epoll_wait()</code>等待的线程，如果需要唤醒，则会调用<code>MessageQueue.cpp</code>的<code>nativeWake()</code>方法，进而调用到<code>Looper.cpp</code>的<code>wake()</code>方法:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">void Looper::wake() &#123;</div><div class=\"line\">#if DEBUG_POLL_AND_WAKE</div><div class=\"line\">    ALOGD(&quot;%p ~ wake&quot;, this);</div><div class=\"line\">#endif</div><div class=\"line\">    ssize_t nWrite;</div><div class=\"line\">    do &#123;</div><div class=\"line\">        nWrite = write(mWakeWritePipeFd, &quot;W&quot;, 1);</div><div class=\"line\">    &#125; while (nWrite == -1 &amp;&amp; errno == EINTR);</div><div class=\"line\">    if (nWrite != 1) &#123;</div><div class=\"line\">        if (errno != EAGAIN) &#123;</div><div class=\"line\">            ALOGW(&quot;Could not write wake signal, errno=%d&quot;, errno);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>唤醒的方式为，向之前创建的管道中写入一个<code>W</code>字符，管道的读端将会被唤醒，线程离开<code>epoll_wait()</code>方法，开始执行之后的代码，从消息队列中取出消息，开始干活.</p>\n<h5 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h5><blockquote>\n<p><a href=\"http://www.bijishequ.com/detail/214262\" target=\"_blank\" rel=\"noopener\">http://www.bijishequ.com/detail/214262</a><br><a href=\"http://shangjin615.iteye.com/blog/1778615\" target=\"_blank\" rel=\"noopener\">http://shangjin615.iteye.com/blog/1778615</a></p>\n</blockquote>\n<h4 id=\"源代码\"><a href=\"#源代码\" class=\"headerlink\" title=\"源代码\"></a>源代码</h4><p><a href=\"https://chromium.googlesource.com/aosp/platform/system/core/+/master/libutils/Looper.cpp\" target=\"_blank\" rel=\"noopener\">Looper.cpp</a></p>\n<p><a href=\"https://android.googlesource.com/platform/frameworks/base/+/master/core/jni/android_os_MessageQueue.cpp\" target=\"_blank\" rel=\"noopener\">MessageQueue.cpp</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>之前了解过的Handler、MessageQueue以及Looper等机制，在MessageQueue的<code>nativePollOnce</code>就终止了，在没有队列中没有消息的状态下，不同Android版本从Linux层面使用管道等方式实现异步阻塞/唤醒。</p>\n<p>在C++层的代码中，也存在一套Handler、MessageQueue以及Looper。</p>\n<p><code>android_os_MessageQueue.cpp</code>中<code>nativePollOnce</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">static void android_os_MessageQueue_nativePollOnce(JNIEnv* env, jobject obj,</div><div class=\"line\">        jlong ptr, jint timeoutMillis) &#123;</div><div class=\"line\">    NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr);</div><div class=\"line\">    nativeMessageQueue-&gt;pollOnce(env, obj, timeoutMillis);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>调用了<code>nativeMessageQueue</code>的<code>pollOnce</code>方法:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">void NativeMessageQueue::pollOnce(JNIEnv* env, jobject pollObj, int timeoutMillis) &#123;</div><div class=\"line\">    mPollEnv = env;</div><div class=\"line\">    mPollObj = pollObj;</div><div class=\"line\">    mLooper-&gt;pollOnce(timeoutMillis);</div><div class=\"line\">    mPollObj = NULL;</div><div class=\"line\">    mPollEnv = NULL;</div><div class=\"line\">    if (mExceptionObj) &#123;</div><div class=\"line\">        env-&gt;Throw(mExceptionObj);</div><div class=\"line\">        env-&gt;DeleteLocalRef(mExceptionObj);</div><div class=\"line\">        mExceptionObj = NULL;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>紧接着调用了<code>Looper.cpp</code>的<code>pollOnce</code>方法:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">int Looper::pollOnce(int timeoutMillis, int* outFd, int* outEvents, void** outData) &#123;</div><div class=\"line\">    int result = 0;</div><div class=\"line\">    for (;;) &#123;</div><div class=\"line\">        while (mResponseIndex &lt; mResponses.size()) &#123;</div><div class=\"line\">            const Response&amp; response = mResponses.itemAt(mResponseIndex++);</div><div class=\"line\">            int ident = response.request.ident;</div><div class=\"line\">            if (ident &gt;= 0) &#123;</div><div class=\"line\">                int fd = response.request.fd;</div><div class=\"line\">                int events = response.events;</div><div class=\"line\">                void* data = response.request.data;</div><div class=\"line\">#if DEBUG_POLL_AND_WAKE</div><div class=\"line\">                ALOGD(&quot;%p ~ pollOnce - returning signalled identifier %d: &quot;</div><div class=\"line\">                        &quot;fd=%d, events=0x%x, data=%p&quot;,</div><div class=\"line\">                        this, ident, fd, events, data);</div><div class=\"line\">#endif</div><div class=\"line\">                if (outFd != NULL) *outFd = fd;</div><div class=\"line\">                if (outEvents != NULL) *outEvents = events;</div><div class=\"line\">                if (outData != NULL) *outData = data;</div><div class=\"line\">                return ident;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (result != 0) &#123;</div><div class=\"line\">#if DEBUG_POLL_AND_WAKE</div><div class=\"line\">            ALOGD(&quot;%p ~ pollOnce - returning result %d&quot;, this, result);</div><div class=\"line\">#endif</div><div class=\"line\">            if (outFd != NULL) *outFd = 0;</div><div class=\"line\">            if (outEvents != NULL) *outEvents = 0;</div><div class=\"line\">            if (outData != NULL) *outData = NULL;</div><div class=\"line\">            return result;</div><div class=\"line\">        &#125;</div><div class=\"line\">        result = pollInner(timeoutMillis);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>最后会跟踪到了<code>Looper.cpp</code>的<code>pollInner</code>方法上，这个方法会对底层的消息进行处理，线程的阻塞也会在函数<code>epoll_wait()</code>这里产生。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">int Looper::pollInner(int timeoutMillis) &#123;</div><div class=\"line\">#if DEBUG_POLL_AND_WAKE</div><div class=\"line\">    ALOGD(&quot;%p ~ pollOnce - waiting: timeoutMillis=%d&quot;, this, timeoutMillis);</div><div class=\"line\">#endif</div><div class=\"line\">    // Adjust the timeout based on when the next message is due.</div><div class=\"line\">    if (timeoutMillis != 0 &amp;&amp; mNextMessageUptime != LLONG_MAX) &#123;</div><div class=\"line\">        nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC);</div><div class=\"line\">        int messageTimeoutMillis = toMillisecondTimeoutDelay(now, mNextMessageUptime);</div><div class=\"line\">        if (messageTimeoutMillis &gt;= 0</div><div class=\"line\">                &amp;&amp; (timeoutMillis &lt; 0 || messageTimeoutMillis &lt; timeoutMillis)) &#123;</div><div class=\"line\">            timeoutMillis = messageTimeoutMillis;</div><div class=\"line\">        &#125;</div><div class=\"line\">#if DEBUG_POLL_AND_WAKE</div><div class=\"line\">        ALOGD(&quot;%p ~ pollOnce - next message in %&quot; PRId64 &quot;ns, adjusted timeout: timeoutMillis=%d&quot;,</div><div class=\"line\">                this, mNextMessageUptime - now, timeoutMillis);</div><div class=\"line\">#endif</div><div class=\"line\">    &#125;</div><div class=\"line\">    // Poll.</div><div class=\"line\">    int result = POLL_WAKE;</div><div class=\"line\">    mResponses.clear();</div><div class=\"line\">    mResponseIndex = 0;</div><div class=\"line\">    // We are about to idle.</div><div class=\"line\">    mPolling = true;</div><div class=\"line\">    struct epoll_event eventItems[EPOLL_MAX_EVENTS];</div><div class=\"line\">    int eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);</div><div class=\"line\">    // No longer idling.</div><div class=\"line\">    mPolling = false;</div><div class=\"line\">    // Acquire lock.</div><div class=\"line\">    mLock.lock();</div><div class=\"line\">    </div><div class=\"line\">    ...</div><div class=\"line\">    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在C++层的<code>Looper</code>初始化的过程中，会初始化一个<code>管道</code>，管道会提供读、写两个端口，并创建一个<code>epoll</code>实例来监控管道的读端口。具体代码如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">Looper::Looper(bool allowNonCallbacks) :</div><div class=\"line\">        mAllowNonCallbacks(allowNonCallbacks), mSendingMessage(false),</div><div class=\"line\">        mResponseIndex(0), mNextMessageUptime(LLONG_MAX) &#123;</div><div class=\"line\">    int wakeFds[2];</div><div class=\"line\">    int result = pipe(wakeFds); // 创建管道</div><div class=\"line\">    LOG_ALWAYS_FATAL_IF(result != 0, &quot;Could not create wake pipe.  errno=%d&quot;, errno);</div><div class=\"line\">    mWakeReadPipeFd = wakeFds[0]; // 读端口</div><div class=\"line\">    mWakeWritePipeFd = wakeFds[1]; // 写端口</div><div class=\"line\">    result = fcntl(mWakeReadPipeFd, F_SETFL, O_NONBLOCK);</div><div class=\"line\">    LOG_ALWAYS_FATAL_IF(result != 0, &quot;Could not make wake read pipe non-blocking.  errno=%d&quot;,</div><div class=\"line\">            errno);</div><div class=\"line\">    result = fcntl(mWakeWritePipeFd, F_SETFL, O_NONBLOCK);</div><div class=\"line\">    LOG_ALWAYS_FATAL_IF(result != 0, &quot;Could not make wake write pipe non-blocking.  errno=%d&quot;,</div><div class=\"line\">            errno);</div><div class=\"line\">    // Allocate the epoll instance and register the wake pipe.</div><div class=\"line\">    mEpollFd = epoll_create(EPOLL_SIZE_HINT); // 创建一个epoll实例，用来监控mWakeReadPipeFd</div><div class=\"line\">    LOG_ALWAYS_FATAL_IF(mEpollFd &lt; 0, &quot;Could not create epoll instance.  errno=%d&quot;, errno);</div><div class=\"line\">    struct epoll_event eventItem;</div><div class=\"line\">    memset(&amp; eventItem, 0, sizeof(epoll_event)); // zero out unused members of data field union</div><div class=\"line\">    eventItem.events = EPOLLIN;</div><div class=\"line\">    eventItem.data.fd = mWakeReadPipeFd;</div><div class=\"line\">    result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeReadPipeFd, &amp; eventItem); // 注册监听</div><div class=\"line\">    LOG_ALWAYS_FATAL_IF(result != 0, &quot;Could not add wake read pipe to epoll instance.  errno=%d&quot;,</div><div class=\"line\">            errno);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用<code>epoll</code>注册监听<code>Looper</code>中的<code>mWakeReadPipeFd</code>之后，在上面提到过的<code>epoll_wait()</code>函数等待的线程，将会在<code>mWakeWritePipeFd</code>端口有数据写入的时候被唤醒，在Java层的<code>MessageQueue</code>中，有消息加入队列的时候，会检测是否需要唤醒当前在<code>epoll_wait()</code>等待的线程，如果需要唤醒，则会调用<code>MessageQueue.cpp</code>的<code>nativeWake()</code>方法，进而调用到<code>Looper.cpp</code>的<code>wake()</code>方法:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">void Looper::wake() &#123;</div><div class=\"line\">#if DEBUG_POLL_AND_WAKE</div><div class=\"line\">    ALOGD(&quot;%p ~ wake&quot;, this);</div><div class=\"line\">#endif</div><div class=\"line\">    ssize_t nWrite;</div><div class=\"line\">    do &#123;</div><div class=\"line\">        nWrite = write(mWakeWritePipeFd, &quot;W&quot;, 1);</div><div class=\"line\">    &#125; while (nWrite == -1 &amp;&amp; errno == EINTR);</div><div class=\"line\">    if (nWrite != 1) &#123;</div><div class=\"line\">        if (errno != EAGAIN) &#123;</div><div class=\"line\">            ALOGW(&quot;Could not write wake signal, errno=%d&quot;, errno);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>唤醒的方式为，向之前创建的管道中写入一个<code>W</code>字符，管道的读端将会被唤醒，线程离开<code>epoll_wait()</code>方法，开始执行之后的代码，从消息队列中取出消息，开始干活.</p>\n<h5 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h5><blockquote>\n<p><a href=\"http://www.bijishequ.com/detail/214262\" target=\"_blank\" rel=\"noopener\">http://www.bijishequ.com/detail/214262</a><br><a href=\"http://shangjin615.iteye.com/blog/1778615\" target=\"_blank\" rel=\"noopener\">http://shangjin615.iteye.com/blog/1778615</a></p>\n</blockquote>\n<h4 id=\"源代码\"><a href=\"#源代码\" class=\"headerlink\" title=\"源代码\"></a>源代码</h4><p><a href=\"https://chromium.googlesource.com/aosp/platform/system/core/+/master/libutils/Looper.cpp\" target=\"_blank\" rel=\"noopener\">Looper.cpp</a></p>\n<p><a href=\"https://android.googlesource.com/platform/frameworks/base/+/master/core/jni/android_os_MessageQueue.cpp\" target=\"_blank\" rel=\"noopener\">MessageQueue.cpp</a></p>\n"},{"title":"React-Native笔记(一)","date":"2017-02-24T03:36:05.000Z","_content":"\n## React-Native笔记(一)\n创建项目 `react-native init projectname`\n\n手动运行packager，用于调试项目 `react-native start`\n\n查看日志 `adb locat *:S ReactNative:V ReactNativeJS:V`\n\n<!--more-->\n\n\n## 代码\n\n### import\n在index.android.js中，导入需要用到的组件,例如`Component`，`AppRegistry`，`View`等等\n```\n import React, { Component } from 'react';\n import { AppRegistry, StyleSheet, Text, View} from 'react-native';\n```\n\n### AppRegistry\n应用作为最大的一个Component，需要在最后通过`AppRegistry.registerComponent('AppName', () => AppName)`注册并运行\n\n### props(属性)\n常见基础组件有各种属性(props)，例如`Image`就有`source`和`style`等属性来控制图片地址和尺寸,下列代码中的name就是自定义的props\n\n```\nclass Greeting extends Component {\n  render() {\n    return (\n      <Text>Hello {this.props.name}!</Text>\n    );\n  }\n}\n\n```\n\n### state(状态)\n`props`由父组件指定，在生命周期中不会再改变，而`state`能够用于改变的数据。需要再`Constructor`中对`state`进行初始化，实例如下:\n\n```\nclass Blink extends Component {\n\tconstructor(props) {\n\t  super(props);\n\t  this.state = { showText: true};\n\n\t  setInterval(() => {\n\t  \tthis.setState({ showText: !this.state.showText});\n\t  }, 1000);\n\t}\n\n\n\trender() {\n\t\tlet display = this.state.showText ? this.props.text : ' ';\n\t\treturn (\n\t\t\t<Text>{display}</Text>\n\t\t);\n\t}\n}\n```\n\n### 样式\n所有核心组件都接受`style`属性，样式名称要求使用驼峰命名法。\n使用过程中建议用`StyleSheet.create`来集中定义组件样式，类似于`Android`中定义各种`style`一样。\n借鉴了`CSS`中层叠覆盖的做法，属性能够被覆盖\n\n```\nconst styles = StyleSheet.create({\n\tbigblue: {\n\t\tcolor: 'blue',\n\t\t    \t<View style={{\n   \t\t\tpadding: 10,\n    \t}}>\n\n    \t\t<TextInput\n    \t\t\tstyle={{height: 40}}\n    \t\t\tplaceholder=\"Type here to translate!\"\n    \t\t\tonChangeText={(text) => this.setState({text})} /> \n\n    \t\t<Text style={{padding: 10, fontSize: 42}} >\n    \t\t\t{this.state.text.spilt(' ').map((word) => word && 'woo').join(' ')}\n    \t\t</Text>\n    \t</View>\nfontWeight: 'bold',\n\t\tfontSize: 30,\n\t},\n\tred: {\n\t\tcolor: 'red',\n\t}\n})\n```\n\n\n### 控件尺寸\n\n**固定尺寸**\n在样式中设置`width`和`height`。\n```\n<View style={{width: 50, height: 50}} />\n```\n\n**弹性(flex)尺寸**\n在组件样式中使用`flex`来指定控件所占比例，`flex:1`指定组件撑满剩余空间，多个并列的`flex:1`平分剩余控件\n> 组件能够撑满剩余空间的前提是其父容器的尺寸不为零。如果父容器既没有固定的width和height，也没有设定flex，则父容器的尺寸为零。其子组件如果使用了flex，也是无法显示的。\n\n\n```\n<View style={{flex:1}}>\n    \t\t<View style={{flex:1, backgroundColor: 'powderblue'}} />\n    \t\t<View style={{flex:2, backgroundColor: 'skyblue'}} />\n    \t\t<View style={{flex:3, backgroundColor: 'steelblue'}} />\n    \t</View>\n```\n\n### Flexbox布局\n\n[布局属性文档](http://reactnative.cn/docs/0.41/layout-props.html)\n\n\n`Flexbox`规则用来指定某个组件的子元素布局。\n\n> React Native中的Flexbox的工作原理和web上的CSS基本一致，当然也存在少许差异。首先是默认值不同：flexDirection的默认值是column而不是row，而flex也只能指定一个数字值。\n\n**Flex Direction**\n`flexDirection`样式决定布局的**主轴**，子元素沿着**主轴**方向排列，默认为`column`方向,下面的三个`view`横向排列\n```\n<View style={{flex:1, flexDirection: 'row'}}>\n\t...\n</View>\n```\n\n**Justify Content**\n`justifyContent`决定子元素沿着**主轴**的排列方式。可选属性如下：\n\n| 名称 | 功能 |\n|--------|--------|\n|    默认    |    相邻无间距排列    |\n|    flex-start    |    同上    |\n|    center    |    从中间开始依次排列    |\n|    flex-end    |   从父布局尾端开始排列     |\n|    space-around    |    每个子布局周围距离一致    |\n|    space-between    |    子布局之间距离一致，和父布局无距离    |\n\n```\n<View style={{\n    \t\tflex:1,\n    \t\tflexDirection: 'row',\n    \t\tjustifyContent: 'flex-start',\n    \t}}>\n        ...\n    \t</View>\n```\n\n**Align Items**\n`alignItems`决定子元素**次轴**排列方式，**次轴**和**主轴**方向垂直。\n\n| 名称 | 功能 |\n|--------|--------|\n|    flex-start    |    次轴顶端排列    |\n|    center    |    次轴中间开始排列    |\n|    flex-end    |   次轴尾端开始排列     |\n|    stretch   |    每个子布局周围距离一致    |\n\n\n> 要使stretch选项生效的话，子元素在次轴方向上不能有固定的尺寸。\n\n\n### 处理文本输入\n使用`TextInput`来允许用户输入文本。\n\n`onChangeText`属性接受一个函数，在文本发生变化的时候调用该函数。\n`onSubmitEditting`属性会在文本被提交之后调用(用户按下软键盘上的提交按钮)。\n","source":"_posts/React-Native笔记-一.md","raw":"---\ntitle: React-Native笔记(一)\ndate: 2017-02-24 11:36:05\ntags: React-Native\n\n---\n\n## React-Native笔记(一)\n创建项目 `react-native init projectname`\n\n手动运行packager，用于调试项目 `react-native start`\n\n查看日志 `adb locat *:S ReactNative:V ReactNativeJS:V`\n\n<!--more-->\n\n\n## 代码\n\n### import\n在index.android.js中，导入需要用到的组件,例如`Component`，`AppRegistry`，`View`等等\n```\n import React, { Component } from 'react';\n import { AppRegistry, StyleSheet, Text, View} from 'react-native';\n```\n\n### AppRegistry\n应用作为最大的一个Component，需要在最后通过`AppRegistry.registerComponent('AppName', () => AppName)`注册并运行\n\n### props(属性)\n常见基础组件有各种属性(props)，例如`Image`就有`source`和`style`等属性来控制图片地址和尺寸,下列代码中的name就是自定义的props\n\n```\nclass Greeting extends Component {\n  render() {\n    return (\n      <Text>Hello {this.props.name}!</Text>\n    );\n  }\n}\n\n```\n\n### state(状态)\n`props`由父组件指定，在生命周期中不会再改变，而`state`能够用于改变的数据。需要再`Constructor`中对`state`进行初始化，实例如下:\n\n```\nclass Blink extends Component {\n\tconstructor(props) {\n\t  super(props);\n\t  this.state = { showText: true};\n\n\t  setInterval(() => {\n\t  \tthis.setState({ showText: !this.state.showText});\n\t  }, 1000);\n\t}\n\n\n\trender() {\n\t\tlet display = this.state.showText ? this.props.text : ' ';\n\t\treturn (\n\t\t\t<Text>{display}</Text>\n\t\t);\n\t}\n}\n```\n\n### 样式\n所有核心组件都接受`style`属性，样式名称要求使用驼峰命名法。\n使用过程中建议用`StyleSheet.create`来集中定义组件样式，类似于`Android`中定义各种`style`一样。\n借鉴了`CSS`中层叠覆盖的做法，属性能够被覆盖\n\n```\nconst styles = StyleSheet.create({\n\tbigblue: {\n\t\tcolor: 'blue',\n\t\t    \t<View style={{\n   \t\t\tpadding: 10,\n    \t}}>\n\n    \t\t<TextInput\n    \t\t\tstyle={{height: 40}}\n    \t\t\tplaceholder=\"Type here to translate!\"\n    \t\t\tonChangeText={(text) => this.setState({text})} /> \n\n    \t\t<Text style={{padding: 10, fontSize: 42}} >\n    \t\t\t{this.state.text.spilt(' ').map((word) => word && 'woo').join(' ')}\n    \t\t</Text>\n    \t</View>\nfontWeight: 'bold',\n\t\tfontSize: 30,\n\t},\n\tred: {\n\t\tcolor: 'red',\n\t}\n})\n```\n\n\n### 控件尺寸\n\n**固定尺寸**\n在样式中设置`width`和`height`。\n```\n<View style={{width: 50, height: 50}} />\n```\n\n**弹性(flex)尺寸**\n在组件样式中使用`flex`来指定控件所占比例，`flex:1`指定组件撑满剩余空间，多个并列的`flex:1`平分剩余控件\n> 组件能够撑满剩余空间的前提是其父容器的尺寸不为零。如果父容器既没有固定的width和height，也没有设定flex，则父容器的尺寸为零。其子组件如果使用了flex，也是无法显示的。\n\n\n```\n<View style={{flex:1}}>\n    \t\t<View style={{flex:1, backgroundColor: 'powderblue'}} />\n    \t\t<View style={{flex:2, backgroundColor: 'skyblue'}} />\n    \t\t<View style={{flex:3, backgroundColor: 'steelblue'}} />\n    \t</View>\n```\n\n### Flexbox布局\n\n[布局属性文档](http://reactnative.cn/docs/0.41/layout-props.html)\n\n\n`Flexbox`规则用来指定某个组件的子元素布局。\n\n> React Native中的Flexbox的工作原理和web上的CSS基本一致，当然也存在少许差异。首先是默认值不同：flexDirection的默认值是column而不是row，而flex也只能指定一个数字值。\n\n**Flex Direction**\n`flexDirection`样式决定布局的**主轴**，子元素沿着**主轴**方向排列，默认为`column`方向,下面的三个`view`横向排列\n```\n<View style={{flex:1, flexDirection: 'row'}}>\n\t...\n</View>\n```\n\n**Justify Content**\n`justifyContent`决定子元素沿着**主轴**的排列方式。可选属性如下：\n\n| 名称 | 功能 |\n|--------|--------|\n|    默认    |    相邻无间距排列    |\n|    flex-start    |    同上    |\n|    center    |    从中间开始依次排列    |\n|    flex-end    |   从父布局尾端开始排列     |\n|    space-around    |    每个子布局周围距离一致    |\n|    space-between    |    子布局之间距离一致，和父布局无距离    |\n\n```\n<View style={{\n    \t\tflex:1,\n    \t\tflexDirection: 'row',\n    \t\tjustifyContent: 'flex-start',\n    \t}}>\n        ...\n    \t</View>\n```\n\n**Align Items**\n`alignItems`决定子元素**次轴**排列方式，**次轴**和**主轴**方向垂直。\n\n| 名称 | 功能 |\n|--------|--------|\n|    flex-start    |    次轴顶端排列    |\n|    center    |    次轴中间开始排列    |\n|    flex-end    |   次轴尾端开始排列     |\n|    stretch   |    每个子布局周围距离一致    |\n\n\n> 要使stretch选项生效的话，子元素在次轴方向上不能有固定的尺寸。\n\n\n### 处理文本输入\n使用`TextInput`来允许用户输入文本。\n\n`onChangeText`属性接受一个函数，在文本发生变化的时候调用该函数。\n`onSubmitEditting`属性会在文本被提交之后调用(用户按下软键盘上的提交按钮)。\n","slug":"React-Native笔记-一","published":1,"updated":"2020-07-03T02:40:48.119Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc5n2qgz0005w8r1j7lkzgfl","content":"<h2 id=\"React-Native笔记-一\"><a href=\"#React-Native笔记-一\" class=\"headerlink\" title=\"React-Native笔记(一)\"></a>React-Native笔记(一)</h2><p>创建项目 <code>react-native init projectname</code></p>\n<p>手动运行packager，用于调试项目 <code>react-native start</code></p>\n<p>查看日志 <code>adb locat *:S ReactNative:V ReactNativeJS:V</code></p>\n<a id=\"more\"></a>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><h3 id=\"import\"><a href=\"#import\" class=\"headerlink\" title=\"import\"></a>import</h3><p>在index.android.js中，导入需要用到的组件,例如<code>Component</code>，<code>AppRegistry</code>，<code>View</code>等等<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">import React, &#123; Component &#125; from &apos;react&apos;;</div><div class=\"line\">import &#123; AppRegistry, StyleSheet, Text, View&#125; from &apos;react-native&apos;;</div></pre></td></tr></table></figure></p>\n<h3 id=\"AppRegistry\"><a href=\"#AppRegistry\" class=\"headerlink\" title=\"AppRegistry\"></a>AppRegistry</h3><p>应用作为最大的一个Component，需要在最后通过<code>AppRegistry.registerComponent(&#39;AppName&#39;, () =&gt; AppName)</code>注册并运行</p>\n<h3 id=\"props-属性\"><a href=\"#props-属性\" class=\"headerlink\" title=\"props(属性)\"></a>props(属性)</h3><p>常见基础组件有各种属性(props)，例如<code>Image</code>就有<code>source</code>和<code>style</code>等属性来控制图片地址和尺寸,下列代码中的name就是自定义的props</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Greeting extends Component &#123;</div><div class=\"line\">  render() &#123;</div><div class=\"line\">    return (</div><div class=\"line\">      &lt;Text&gt;Hello &#123;this.props.name&#125;!&lt;/Text&gt;</div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"state-状态\"><a href=\"#state-状态\" class=\"headerlink\" title=\"state(状态)\"></a>state(状态)</h3><p><code>props</code>由父组件指定，在生命周期中不会再改变，而<code>state</code>能够用于改变的数据。需要再<code>Constructor</code>中对<code>state</code>进行初始化，实例如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Blink extends Component &#123;</div><div class=\"line\">\tconstructor(props) &#123;</div><div class=\"line\">\t  super(props);</div><div class=\"line\">\t  this.state = &#123; showText: true&#125;;</div><div class=\"line\"></div><div class=\"line\">\t  setInterval(() =&gt; &#123;</div><div class=\"line\">\t  \tthis.setState(&#123; showText: !this.state.showText&#125;);</div><div class=\"line\">\t  &#125;, 1000);</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\trender() &#123;</div><div class=\"line\">\t\tlet display = this.state.showText ? this.props.text : &apos; &apos;;</div><div class=\"line\">\t\treturn (</div><div class=\"line\">\t\t\t&lt;Text&gt;&#123;display&#125;&lt;/Text&gt;</div><div class=\"line\">\t\t);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"样式\"><a href=\"#样式\" class=\"headerlink\" title=\"样式\"></a>样式</h3><p>所有核心组件都接受<code>style</code>属性，样式名称要求使用驼峰命名法。<br>使用过程中建议用<code>StyleSheet.create</code>来集中定义组件样式，类似于<code>Android</code>中定义各种<code>style</code>一样。<br>借鉴了<code>CSS</code>中层叠覆盖的做法，属性能够被覆盖</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">const styles = StyleSheet.create(&#123;</div><div class=\"line\">\tbigblue: &#123;</div><div class=\"line\">\t\tcolor: &apos;blue&apos;,</div><div class=\"line\">\t\t    \t&lt;View style=&#123;&#123;</div><div class=\"line\">   \t\t\tpadding: 10,</div><div class=\"line\">    \t&#125;&#125;&gt;</div><div class=\"line\"></div><div class=\"line\">    \t\t&lt;TextInput</div><div class=\"line\">    \t\t\tstyle=&#123;&#123;height: 40&#125;&#125;</div><div class=\"line\">    \t\t\tplaceholder=&quot;Type here to translate!&quot;</div><div class=\"line\">    \t\t\tonChangeText=&#123;(text) =&gt; this.setState(&#123;text&#125;)&#125; /&gt; </div><div class=\"line\"></div><div class=\"line\">    \t\t&lt;Text style=&#123;&#123;padding: 10, fontSize: 42&#125;&#125; &gt;</div><div class=\"line\">    \t\t\t&#123;this.state.text.spilt(&apos; &apos;).map((word) =&gt; word &amp;&amp; &apos;woo&apos;).join(&apos; &apos;)&#125;</div><div class=\"line\">    \t\t&lt;/Text&gt;</div><div class=\"line\">    \t&lt;/View&gt;</div><div class=\"line\">fontWeight: &apos;bold&apos;,</div><div class=\"line\">\t\tfontSize: 30,</div><div class=\"line\">\t&#125;,</div><div class=\"line\">\tred: &#123;</div><div class=\"line\">\t\tcolor: &apos;red&apos;,</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h3 id=\"控件尺寸\"><a href=\"#控件尺寸\" class=\"headerlink\" title=\"控件尺寸\"></a>控件尺寸</h3><p><strong>固定尺寸</strong><br>在样式中设置<code>width</code>和<code>height</code>。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;View style=&#123;&#123;width: 50, height: 50&#125;&#125; /&gt;</div></pre></td></tr></table></figure></p>\n<p><strong>弹性(flex)尺寸</strong><br>在组件样式中使用<code>flex</code>来指定控件所占比例，<code>flex:1</code>指定组件撑满剩余空间，多个并列的<code>flex:1</code>平分剩余控件</p>\n<blockquote>\n<p>组件能够撑满剩余空间的前提是其父容器的尺寸不为零。如果父容器既没有固定的width和height，也没有设定flex，则父容器的尺寸为零。其子组件如果使用了flex，也是无法显示的。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;View style=&#123;&#123;flex:1&#125;&#125;&gt;</div><div class=\"line\">    \t\t&lt;View style=&#123;&#123;flex:1, backgroundColor: &apos;powderblue&apos;&#125;&#125; /&gt;</div><div class=\"line\">    \t\t&lt;View style=&#123;&#123;flex:2, backgroundColor: &apos;skyblue&apos;&#125;&#125; /&gt;</div><div class=\"line\">    \t\t&lt;View style=&#123;&#123;flex:3, backgroundColor: &apos;steelblue&apos;&#125;&#125; /&gt;</div><div class=\"line\">    \t&lt;/View&gt;</div></pre></td></tr></table></figure>\n<h3 id=\"Flexbox布局\"><a href=\"#Flexbox布局\" class=\"headerlink\" title=\"Flexbox布局\"></a>Flexbox布局</h3><p><a href=\"http://reactnative.cn/docs/0.41/layout-props.html\" target=\"_blank\" rel=\"noopener\">布局属性文档</a></p>\n<p><code>Flexbox</code>规则用来指定某个组件的子元素布局。</p>\n<blockquote>\n<p>React Native中的Flexbox的工作原理和web上的CSS基本一致，当然也存在少许差异。首先是默认值不同：flexDirection的默认值是column而不是row，而flex也只能指定一个数字值。</p>\n</blockquote>\n<p><strong>Flex Direction</strong><br><code>flexDirection</code>样式决定布局的<strong>主轴</strong>，子元素沿着<strong>主轴</strong>方向排列，默认为<code>column</code>方向,下面的三个<code>view</code>横向排列<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;View style=&#123;&#123;flex:1, flexDirection: &apos;row&apos;&#125;&#125;&gt;</div><div class=\"line\">\t...</div><div class=\"line\">&lt;/View&gt;</div></pre></td></tr></table></figure></p>\n<p><strong>Justify Content</strong><br><code>justifyContent</code>决定子元素沿着<strong>主轴</strong>的排列方式。可选属性如下：</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>默认</td>\n<td>相邻无间距排列</td>\n</tr>\n<tr>\n<td>flex-start</td>\n<td>同上</td>\n</tr>\n<tr>\n<td>center</td>\n<td>从中间开始依次排列</td>\n</tr>\n<tr>\n<td>flex-end</td>\n<td>从父布局尾端开始排列</td>\n</tr>\n<tr>\n<td>space-around</td>\n<td>每个子布局周围距离一致</td>\n</tr>\n<tr>\n<td>space-between</td>\n<td>子布局之间距离一致，和父布局无距离</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;View style=&#123;&#123;</div><div class=\"line\">    \t\tflex:1,</div><div class=\"line\">    \t\tflexDirection: &apos;row&apos;,</div><div class=\"line\">    \t\tjustifyContent: &apos;flex-start&apos;,</div><div class=\"line\">    \t&#125;&#125;&gt;</div><div class=\"line\">        ...</div><div class=\"line\">    \t&lt;/View&gt;</div></pre></td></tr></table></figure>\n<p><strong>Align Items</strong><br><code>alignItems</code>决定子元素<strong>次轴</strong>排列方式，<strong>次轴</strong>和<strong>主轴</strong>方向垂直。</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>flex-start</td>\n<td>次轴顶端排列</td>\n</tr>\n<tr>\n<td>center</td>\n<td>次轴中间开始排列</td>\n</tr>\n<tr>\n<td>flex-end</td>\n<td>次轴尾端开始排列</td>\n</tr>\n<tr>\n<td>stretch</td>\n<td>每个子布局周围距离一致</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>要使stretch选项生效的话，子元素在次轴方向上不能有固定的尺寸。</p>\n</blockquote>\n<h3 id=\"处理文本输入\"><a href=\"#处理文本输入\" class=\"headerlink\" title=\"处理文本输入\"></a>处理文本输入</h3><p>使用<code>TextInput</code>来允许用户输入文本。</p>\n<p><code>onChangeText</code>属性接受一个函数，在文本发生变化的时候调用该函数。<br><code>onSubmitEditting</code>属性会在文本被提交之后调用(用户按下软键盘上的提交按钮)。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"React-Native笔记-一\"><a href=\"#React-Native笔记-一\" class=\"headerlink\" title=\"React-Native笔记(一)\"></a>React-Native笔记(一)</h2><p>创建项目 <code>react-native init projectname</code></p>\n<p>手动运行packager，用于调试项目 <code>react-native start</code></p>\n<p>查看日志 <code>adb locat *:S ReactNative:V ReactNativeJS:V</code></p>","more":"<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><h3 id=\"import\"><a href=\"#import\" class=\"headerlink\" title=\"import\"></a>import</h3><p>在index.android.js中，导入需要用到的组件,例如<code>Component</code>，<code>AppRegistry</code>，<code>View</code>等等<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">import React, &#123; Component &#125; from &apos;react&apos;;</div><div class=\"line\">import &#123; AppRegistry, StyleSheet, Text, View&#125; from &apos;react-native&apos;;</div></pre></td></tr></table></figure></p>\n<h3 id=\"AppRegistry\"><a href=\"#AppRegistry\" class=\"headerlink\" title=\"AppRegistry\"></a>AppRegistry</h3><p>应用作为最大的一个Component，需要在最后通过<code>AppRegistry.registerComponent(&#39;AppName&#39;, () =&gt; AppName)</code>注册并运行</p>\n<h3 id=\"props-属性\"><a href=\"#props-属性\" class=\"headerlink\" title=\"props(属性)\"></a>props(属性)</h3><p>常见基础组件有各种属性(props)，例如<code>Image</code>就有<code>source</code>和<code>style</code>等属性来控制图片地址和尺寸,下列代码中的name就是自定义的props</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Greeting extends Component &#123;</div><div class=\"line\">  render() &#123;</div><div class=\"line\">    return (</div><div class=\"line\">      &lt;Text&gt;Hello &#123;this.props.name&#125;!&lt;/Text&gt;</div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"state-状态\"><a href=\"#state-状态\" class=\"headerlink\" title=\"state(状态)\"></a>state(状态)</h3><p><code>props</code>由父组件指定，在生命周期中不会再改变，而<code>state</code>能够用于改变的数据。需要再<code>Constructor</code>中对<code>state</code>进行初始化，实例如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Blink extends Component &#123;</div><div class=\"line\">\tconstructor(props) &#123;</div><div class=\"line\">\t  super(props);</div><div class=\"line\">\t  this.state = &#123; showText: true&#125;;</div><div class=\"line\"></div><div class=\"line\">\t  setInterval(() =&gt; &#123;</div><div class=\"line\">\t  \tthis.setState(&#123; showText: !this.state.showText&#125;);</div><div class=\"line\">\t  &#125;, 1000);</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\trender() &#123;</div><div class=\"line\">\t\tlet display = this.state.showText ? this.props.text : &apos; &apos;;</div><div class=\"line\">\t\treturn (</div><div class=\"line\">\t\t\t&lt;Text&gt;&#123;display&#125;&lt;/Text&gt;</div><div class=\"line\">\t\t);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"样式\"><a href=\"#样式\" class=\"headerlink\" title=\"样式\"></a>样式</h3><p>所有核心组件都接受<code>style</code>属性，样式名称要求使用驼峰命名法。<br>使用过程中建议用<code>StyleSheet.create</code>来集中定义组件样式，类似于<code>Android</code>中定义各种<code>style</code>一样。<br>借鉴了<code>CSS</code>中层叠覆盖的做法，属性能够被覆盖</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">const styles = StyleSheet.create(&#123;</div><div class=\"line\">\tbigblue: &#123;</div><div class=\"line\">\t\tcolor: &apos;blue&apos;,</div><div class=\"line\">\t\t    \t&lt;View style=&#123;&#123;</div><div class=\"line\">   \t\t\tpadding: 10,</div><div class=\"line\">    \t&#125;&#125;&gt;</div><div class=\"line\"></div><div class=\"line\">    \t\t&lt;TextInput</div><div class=\"line\">    \t\t\tstyle=&#123;&#123;height: 40&#125;&#125;</div><div class=\"line\">    \t\t\tplaceholder=&quot;Type here to translate!&quot;</div><div class=\"line\">    \t\t\tonChangeText=&#123;(text) =&gt; this.setState(&#123;text&#125;)&#125; /&gt; </div><div class=\"line\"></div><div class=\"line\">    \t\t&lt;Text style=&#123;&#123;padding: 10, fontSize: 42&#125;&#125; &gt;</div><div class=\"line\">    \t\t\t&#123;this.state.text.spilt(&apos; &apos;).map((word) =&gt; word &amp;&amp; &apos;woo&apos;).join(&apos; &apos;)&#125;</div><div class=\"line\">    \t\t&lt;/Text&gt;</div><div class=\"line\">    \t&lt;/View&gt;</div><div class=\"line\">fontWeight: &apos;bold&apos;,</div><div class=\"line\">\t\tfontSize: 30,</div><div class=\"line\">\t&#125;,</div><div class=\"line\">\tred: &#123;</div><div class=\"line\">\t\tcolor: &apos;red&apos;,</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h3 id=\"控件尺寸\"><a href=\"#控件尺寸\" class=\"headerlink\" title=\"控件尺寸\"></a>控件尺寸</h3><p><strong>固定尺寸</strong><br>在样式中设置<code>width</code>和<code>height</code>。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;View style=&#123;&#123;width: 50, height: 50&#125;&#125; /&gt;</div></pre></td></tr></table></figure></p>\n<p><strong>弹性(flex)尺寸</strong><br>在组件样式中使用<code>flex</code>来指定控件所占比例，<code>flex:1</code>指定组件撑满剩余空间，多个并列的<code>flex:1</code>平分剩余控件</p>\n<blockquote>\n<p>组件能够撑满剩余空间的前提是其父容器的尺寸不为零。如果父容器既没有固定的width和height，也没有设定flex，则父容器的尺寸为零。其子组件如果使用了flex，也是无法显示的。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;View style=&#123;&#123;flex:1&#125;&#125;&gt;</div><div class=\"line\">    \t\t&lt;View style=&#123;&#123;flex:1, backgroundColor: &apos;powderblue&apos;&#125;&#125; /&gt;</div><div class=\"line\">    \t\t&lt;View style=&#123;&#123;flex:2, backgroundColor: &apos;skyblue&apos;&#125;&#125; /&gt;</div><div class=\"line\">    \t\t&lt;View style=&#123;&#123;flex:3, backgroundColor: &apos;steelblue&apos;&#125;&#125; /&gt;</div><div class=\"line\">    \t&lt;/View&gt;</div></pre></td></tr></table></figure>\n<h3 id=\"Flexbox布局\"><a href=\"#Flexbox布局\" class=\"headerlink\" title=\"Flexbox布局\"></a>Flexbox布局</h3><p><a href=\"http://reactnative.cn/docs/0.41/layout-props.html\" target=\"_blank\" rel=\"noopener\">布局属性文档</a></p>\n<p><code>Flexbox</code>规则用来指定某个组件的子元素布局。</p>\n<blockquote>\n<p>React Native中的Flexbox的工作原理和web上的CSS基本一致，当然也存在少许差异。首先是默认值不同：flexDirection的默认值是column而不是row，而flex也只能指定一个数字值。</p>\n</blockquote>\n<p><strong>Flex Direction</strong><br><code>flexDirection</code>样式决定布局的<strong>主轴</strong>，子元素沿着<strong>主轴</strong>方向排列，默认为<code>column</code>方向,下面的三个<code>view</code>横向排列<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;View style=&#123;&#123;flex:1, flexDirection: &apos;row&apos;&#125;&#125;&gt;</div><div class=\"line\">\t...</div><div class=\"line\">&lt;/View&gt;</div></pre></td></tr></table></figure></p>\n<p><strong>Justify Content</strong><br><code>justifyContent</code>决定子元素沿着<strong>主轴</strong>的排列方式。可选属性如下：</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>默认</td>\n<td>相邻无间距排列</td>\n</tr>\n<tr>\n<td>flex-start</td>\n<td>同上</td>\n</tr>\n<tr>\n<td>center</td>\n<td>从中间开始依次排列</td>\n</tr>\n<tr>\n<td>flex-end</td>\n<td>从父布局尾端开始排列</td>\n</tr>\n<tr>\n<td>space-around</td>\n<td>每个子布局周围距离一致</td>\n</tr>\n<tr>\n<td>space-between</td>\n<td>子布局之间距离一致，和父布局无距离</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;View style=&#123;&#123;</div><div class=\"line\">    \t\tflex:1,</div><div class=\"line\">    \t\tflexDirection: &apos;row&apos;,</div><div class=\"line\">    \t\tjustifyContent: &apos;flex-start&apos;,</div><div class=\"line\">    \t&#125;&#125;&gt;</div><div class=\"line\">        ...</div><div class=\"line\">    \t&lt;/View&gt;</div></pre></td></tr></table></figure>\n<p><strong>Align Items</strong><br><code>alignItems</code>决定子元素<strong>次轴</strong>排列方式，<strong>次轴</strong>和<strong>主轴</strong>方向垂直。</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>flex-start</td>\n<td>次轴顶端排列</td>\n</tr>\n<tr>\n<td>center</td>\n<td>次轴中间开始排列</td>\n</tr>\n<tr>\n<td>flex-end</td>\n<td>次轴尾端开始排列</td>\n</tr>\n<tr>\n<td>stretch</td>\n<td>每个子布局周围距离一致</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>要使stretch选项生效的话，子元素在次轴方向上不能有固定的尺寸。</p>\n</blockquote>\n<h3 id=\"处理文本输入\"><a href=\"#处理文本输入\" class=\"headerlink\" title=\"处理文本输入\"></a>处理文本输入</h3><p>使用<code>TextInput</code>来允许用户输入文本。</p>\n<p><code>onChangeText</code>属性接受一个函数，在文本发生变化的时候调用该函数。<br><code>onSubmitEditting</code>属性会在文本被提交之后调用(用户按下软键盘上的提交按钮)。</p>"},{"title":"React-Native笔记(三)","date":"2017-02-24T03:36:14.000Z","_content":"## React-Native笔记(三)\n\n### 网络\n`React Native`提供了和web标准一直的`Fetch API`来满足网络获取数据的需求。\n\n**发起网络请求**\n获取固定地址内容，不进行处理\n```\nfetch('https://www.baidu.com')\n```\n\n<!--more-->\n\n获取内容并对数据进行加工\n\n```\n fetch('http://bbs.reactnative.cn/api/category/3')\n            .then((response) => response.json())\n            .then((jsonData) => {\n                this.setState({\n                    title: jsonData.topics[0].title,\n                })\n            })\n            .catch((error) => {\n                console.warn(error);\n            })\n```\n\n### WebSocket支持\n对`websocket`支持，可以在单个TCP连接上提供全双工的通信通道。\n\n```\nvar ws = new WebSocket('ws://host.com/path');\n\nws.onopen = () => {\n  // 打开一个连接\n\n  ws.send('something'); // 发送一个消息\n};\n\nws.onmessage = (e) => {\n  // 接收到了一个消息\n  console.log(e.data);\n};\n\nws.onerror = (e) => {\n  // 发生了一个错误\n  console.log(e.message);\n};\n\nws.onclose = (e) => {\n  // 连接被关闭了\n  console.log(e.code, e.reason);\n};\n```\n\n### 页面跳转\n\n**场景(Scene)**\n各种组件组合在一起，形成了一个界面，也就是一个场景\n\n一个简单的场景如下：\n```\nMyScene.js\n\nimport React, { Component } from 'react';\nimport { View, Text } from 'react-native';\n\n/**\n * 导出当前组件\n */\n\nexport default class MyScene extends Component {\n    static defaultProps = {\n        title: 'MyScene',\n    };\n\n    render() {\n        return (\n            <View>\n                <Text>Hi ! My name is {this.props.title} </Text>\n            </View>\n        )\n    }\n}\n```\n\n**Navigator**\n官方首推`Navigator`来作为导航器组件，实现界面跳转,先渲染出一个`Navigator`组件，通过`Navigator`的`renderScene`属性来渲染其他的`Scene`。将之前的那个场景给渲染进来。\n\n**单个渲染**\n\n```\n <Navigator\n                initialRoute={{title: 'My Initial Scene', index: 0}}\n                renderScene={(route, navigator) => {\n                    return <MyScene title={route.title} />\n                }}\n            />\n```\n使用导航器经常会碰到“路由(route)”的概念。“路由”抽象自现实生活中的路牌，在RN中专指包含了场景信息的对象。\n```\n\n\n**实现跳转**\n场景之间的切换，`navigator`提供了两个主要的方法：\n* `push` 将`route`对象推入并渲染\n* `pop` 将`route`对象弹出导航栈\n\n**基本场景**\n```\nimport React, { Component, PropTypes } from 'react';\nimport { View, Text, TouchableHighlight } from 'react-native';\n\nexport default class MyScene extends Component {\n  static propTypes = {\n    title: PropTypes.string.isRequired,\n    onForward: PropTypes.func.isRequired,\n    onBack: PropTypes.func.isRequired,\n  }\n  render() {\n    return (\n      <View>\n        <Text>Current Scene: { this.props.title }</Text>\n        <TouchableHighlight onPress={this.props.onForward}>\n          <Text>点我进入下一场景</Text>\n        </TouchableHighlight>\n        <TouchableHighlight onPress={this.props.onBack}>\n          <Text>点我返回上一场景</Text>\n        </TouchableHighlight>    \n      </View>\n    )\n  }\n}\n```\n\n**导航器**\n\n```\nimport React, {Component} from 'react';\nimport {AppRegistry, Navigator, Text, View} from 'react-native';\n\nimport MyScene from './MyScene';\n\nclass AwesomeProject extends Component {\n\n    render() {\n        return (\n            <Navigator\n                initialRoute={{title: 'My Initial Scene', index: 0}}\n                renderScene={(route, navigator) => {\n                    return <MyScene title={route.title}\n\n                     onForward= { () => {\n                         const nextIndex = route.index + 1;\n                         navigator.push({\n                             title: 'Scene ' + nextIndex,\n                             index: nextIndex\n                         });\n                     }}\n\n                     onBack= { () => {\n                         if (route.index > 0) {\n                             navigator.pop();\n                         }\n                     }}\n\n                     />\n                }}\n            />\n        );\n    }\n\n}\n\nAppRegistry.registerComponent('AwesomeProject', () => AwesomeProject);\n```","source":"_posts/React-Native笔记-三.md","raw":"---\ntitle: React-Native笔记(三)\ndate: 2017-02-24 11:36:14\ntags: React-Native\n\n---\n## React-Native笔记(三)\n\n### 网络\n`React Native`提供了和web标准一直的`Fetch API`来满足网络获取数据的需求。\n\n**发起网络请求**\n获取固定地址内容，不进行处理\n```\nfetch('https://www.baidu.com')\n```\n\n<!--more-->\n\n获取内容并对数据进行加工\n\n```\n fetch('http://bbs.reactnative.cn/api/category/3')\n            .then((response) => response.json())\n            .then((jsonData) => {\n                this.setState({\n                    title: jsonData.topics[0].title,\n                })\n            })\n            .catch((error) => {\n                console.warn(error);\n            })\n```\n\n### WebSocket支持\n对`websocket`支持，可以在单个TCP连接上提供全双工的通信通道。\n\n```\nvar ws = new WebSocket('ws://host.com/path');\n\nws.onopen = () => {\n  // 打开一个连接\n\n  ws.send('something'); // 发送一个消息\n};\n\nws.onmessage = (e) => {\n  // 接收到了一个消息\n  console.log(e.data);\n};\n\nws.onerror = (e) => {\n  // 发生了一个错误\n  console.log(e.message);\n};\n\nws.onclose = (e) => {\n  // 连接被关闭了\n  console.log(e.code, e.reason);\n};\n```\n\n### 页面跳转\n\n**场景(Scene)**\n各种组件组合在一起，形成了一个界面，也就是一个场景\n\n一个简单的场景如下：\n```\nMyScene.js\n\nimport React, { Component } from 'react';\nimport { View, Text } from 'react-native';\n\n/**\n * 导出当前组件\n */\n\nexport default class MyScene extends Component {\n    static defaultProps = {\n        title: 'MyScene',\n    };\n\n    render() {\n        return (\n            <View>\n                <Text>Hi ! My name is {this.props.title} </Text>\n            </View>\n        )\n    }\n}\n```\n\n**Navigator**\n官方首推`Navigator`来作为导航器组件，实现界面跳转,先渲染出一个`Navigator`组件，通过`Navigator`的`renderScene`属性来渲染其他的`Scene`。将之前的那个场景给渲染进来。\n\n**单个渲染**\n\n```\n <Navigator\n                initialRoute={{title: 'My Initial Scene', index: 0}}\n                renderScene={(route, navigator) => {\n                    return <MyScene title={route.title} />\n                }}\n            />\n```\n使用导航器经常会碰到“路由(route)”的概念。“路由”抽象自现实生活中的路牌，在RN中专指包含了场景信息的对象。\n```\n\n\n**实现跳转**\n场景之间的切换，`navigator`提供了两个主要的方法：\n* `push` 将`route`对象推入并渲染\n* `pop` 将`route`对象弹出导航栈\n\n**基本场景**\n```\nimport React, { Component, PropTypes } from 'react';\nimport { View, Text, TouchableHighlight } from 'react-native';\n\nexport default class MyScene extends Component {\n  static propTypes = {\n    title: PropTypes.string.isRequired,\n    onForward: PropTypes.func.isRequired,\n    onBack: PropTypes.func.isRequired,\n  }\n  render() {\n    return (\n      <View>\n        <Text>Current Scene: { this.props.title }</Text>\n        <TouchableHighlight onPress={this.props.onForward}>\n          <Text>点我进入下一场景</Text>\n        </TouchableHighlight>\n        <TouchableHighlight onPress={this.props.onBack}>\n          <Text>点我返回上一场景</Text>\n        </TouchableHighlight>    \n      </View>\n    )\n  }\n}\n```\n\n**导航器**\n\n```\nimport React, {Component} from 'react';\nimport {AppRegistry, Navigator, Text, View} from 'react-native';\n\nimport MyScene from './MyScene';\n\nclass AwesomeProject extends Component {\n\n    render() {\n        return (\n            <Navigator\n                initialRoute={{title: 'My Initial Scene', index: 0}}\n                renderScene={(route, navigator) => {\n                    return <MyScene title={route.title}\n\n                     onForward= { () => {\n                         const nextIndex = route.index + 1;\n                         navigator.push({\n                             title: 'Scene ' + nextIndex,\n                             index: nextIndex\n                         });\n                     }}\n\n                     onBack= { () => {\n                         if (route.index > 0) {\n                             navigator.pop();\n                         }\n                     }}\n\n                     />\n                }}\n            />\n        );\n    }\n\n}\n\nAppRegistry.registerComponent('AwesomeProject', () => AwesomeProject);\n```","slug":"React-Native笔记-三","published":1,"updated":"2020-07-03T02:40:48.120Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc5n2qh00006w8r13m985ufw","content":"<h2 id=\"React-Native笔记-三\"><a href=\"#React-Native笔记-三\" class=\"headerlink\" title=\"React-Native笔记(三)\"></a>React-Native笔记(三)</h2><h3 id=\"网络\"><a href=\"#网络\" class=\"headerlink\" title=\"网络\"></a>网络</h3><p><code>React Native</code>提供了和web标准一直的<code>Fetch API</code>来满足网络获取数据的需求。</p>\n<p><strong>发起网络请求</strong><br>获取固定地址内容，不进行处理<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">fetch(&apos;https://www.baidu.com&apos;)</div></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<p>获取内容并对数据进行加工</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">fetch(&apos;http://bbs.reactnative.cn/api/category/3&apos;)</div><div class=\"line\">           .then((response) =&gt; response.json())</div><div class=\"line\">           .then((jsonData) =&gt; &#123;</div><div class=\"line\">               this.setState(&#123;</div><div class=\"line\">                   title: jsonData.topics[0].title,</div><div class=\"line\">               &#125;)</div><div class=\"line\">           &#125;)</div><div class=\"line\">           .catch((error) =&gt; &#123;</div><div class=\"line\">               console.warn(error);</div><div class=\"line\">           &#125;)</div></pre></td></tr></table></figure>\n<h3 id=\"WebSocket支持\"><a href=\"#WebSocket支持\" class=\"headerlink\" title=\"WebSocket支持\"></a>WebSocket支持</h3><p>对<code>websocket</code>支持，可以在单个TCP连接上提供全双工的通信通道。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">var ws = new WebSocket(&apos;ws://host.com/path&apos;);</div><div class=\"line\"></div><div class=\"line\">ws.onopen = () =&gt; &#123;</div><div class=\"line\">  // 打开一个连接</div><div class=\"line\"></div><div class=\"line\">  ws.send(&apos;something&apos;); // 发送一个消息</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">ws.onmessage = (e) =&gt; &#123;</div><div class=\"line\">  // 接收到了一个消息</div><div class=\"line\">  console.log(e.data);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">ws.onerror = (e) =&gt; &#123;</div><div class=\"line\">  // 发生了一个错误</div><div class=\"line\">  console.log(e.message);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">ws.onclose = (e) =&gt; &#123;</div><div class=\"line\">  // 连接被关闭了</div><div class=\"line\">  console.log(e.code, e.reason);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"页面跳转\"><a href=\"#页面跳转\" class=\"headerlink\" title=\"页面跳转\"></a>页面跳转</h3><p><strong>场景(Scene)</strong><br>各种组件组合在一起，形成了一个界面，也就是一个场景</p>\n<p>一个简单的场景如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">MyScene.js</div><div class=\"line\"></div><div class=\"line\">import React, &#123; Component &#125; from &apos;react&apos;;</div><div class=\"line\">import &#123; View, Text &#125; from &apos;react-native&apos;;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\"> * 导出当前组件</div><div class=\"line\"> */</div><div class=\"line\"></div><div class=\"line\">export default class MyScene extends Component &#123;</div><div class=\"line\">    static defaultProps = &#123;</div><div class=\"line\">        title: &apos;MyScene&apos;,</div><div class=\"line\">    &#125;;</div><div class=\"line\"></div><div class=\"line\">    render() &#123;</div><div class=\"line\">        return (</div><div class=\"line\">            &lt;View&gt;</div><div class=\"line\">                &lt;Text&gt;Hi ! My name is &#123;this.props.title&#125; &lt;/Text&gt;</div><div class=\"line\">            &lt;/View&gt;</div><div class=\"line\">        )</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><strong>Navigator</strong><br>官方首推<code>Navigator</code>来作为导航器组件，实现界面跳转,先渲染出一个<code>Navigator</code>组件，通过<code>Navigator</code>的<code>renderScene</code>属性来渲染其他的<code>Scene</code>。将之前的那个场景给渲染进来。</p>\n<p><strong>单个渲染</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;Navigator</div><div class=\"line\">               initialRoute=&#123;&#123;title: &apos;My Initial Scene&apos;, index: 0&#125;&#125;</div><div class=\"line\">               renderScene=&#123;(route, navigator) =&gt; &#123;</div><div class=\"line\">                   return &lt;MyScene title=&#123;route.title&#125; /&gt;</div><div class=\"line\">               &#125;&#125;</div><div class=\"line\">           /&gt;</div></pre></td></tr></table></figure>\n<p>使用导航器经常会碰到“路由(route)”的概念。“路由”抽象自现实生活中的路牌，在RN中专指包含了场景信息的对象。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">**实现跳转**</div><div class=\"line\">场景之间的切换，`navigator`提供了两个主要的方法：</div><div class=\"line\">* `push` 将`route`对象推入并渲染</div><div class=\"line\">* `pop` 将`route`对象弹出导航栈</div><div class=\"line\"></div><div class=\"line\">**基本场景**</div></pre></td></tr></table></figure></p>\n<p>import React, { Component, PropTypes } from ‘react’;<br>import { View, Text, TouchableHighlight } from ‘react-native’;</p>\n<p>export default class MyScene extends Component {<br>  static propTypes = {<br>    title: PropTypes.string.isRequired,<br>    onForward: PropTypes.func.isRequired,<br>    onBack: PropTypes.func.isRequired,<br>  }<br>  render() {<br>    return (<br>      <view><br>        <text>Current Scene: { this.props.title }</text><br>        <touchablehighlight onpress=\"{this.props.onForward}\"><br>          <text>点我进入下一场景</text><br>        </touchablehighlight><br>        <touchablehighlight onpress=\"{this.props.onBack}\"><br>          <text>点我返回上一场景</text><br>        </touchablehighlight><br>      </view><br>    )<br>  }<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">**导航器**</div></pre></td></tr></table></figure></p>\n<p>import React, {Component} from ‘react’;<br>import {AppRegistry, Navigator, Text, View} from ‘react-native’;</p>\n<p>import MyScene from ‘./MyScene’;</p>\n<p>class AwesomeProject extends Component {</p>\n<pre><code>render() {\n    return (\n        &lt;Navigator\n            initialRoute={{title: 'My Initial Scene', index: 0}}\n            renderScene={(route, navigator) =&gt; {\n                return &lt;MyScene title={route.title}\n\n                 onForward= { () =&gt; {\n                     const nextIndex = route.index + 1;\n                     navigator.push({\n                         title: &apos;Scene &apos; + nextIndex,\n                         index: nextIndex\n                     });\n                 }}\n\n                 onBack= { () =&gt; {\n                     if (route.index &gt; 0) {\n                         navigator.pop();\n                     }\n                 }}\n\n                 /&gt;\n            }}\n        /&gt;\n    );\n}\n</code></pre><p>}</p>\n<p>AppRegistry.registerComponent(‘AwesomeProject’, () =&gt; AwesomeProject);<br>```</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"React-Native笔记-三\"><a href=\"#React-Native笔记-三\" class=\"headerlink\" title=\"React-Native笔记(三)\"></a>React-Native笔记(三)</h2><h3 id=\"网络\"><a href=\"#网络\" class=\"headerlink\" title=\"网络\"></a>网络</h3><p><code>React Native</code>提供了和web标准一直的<code>Fetch API</code>来满足网络获取数据的需求。</p>\n<p><strong>发起网络请求</strong><br>获取固定地址内容，不进行处理<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">fetch(&apos;https://www.baidu.com&apos;)</div></pre></td></tr></table></figure></p>","more":"<p>获取内容并对数据进行加工</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">fetch(&apos;http://bbs.reactnative.cn/api/category/3&apos;)</div><div class=\"line\">           .then((response) =&gt; response.json())</div><div class=\"line\">           .then((jsonData) =&gt; &#123;</div><div class=\"line\">               this.setState(&#123;</div><div class=\"line\">                   title: jsonData.topics[0].title,</div><div class=\"line\">               &#125;)</div><div class=\"line\">           &#125;)</div><div class=\"line\">           .catch((error) =&gt; &#123;</div><div class=\"line\">               console.warn(error);</div><div class=\"line\">           &#125;)</div></pre></td></tr></table></figure>\n<h3 id=\"WebSocket支持\"><a href=\"#WebSocket支持\" class=\"headerlink\" title=\"WebSocket支持\"></a>WebSocket支持</h3><p>对<code>websocket</code>支持，可以在单个TCP连接上提供全双工的通信通道。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">var ws = new WebSocket(&apos;ws://host.com/path&apos;);</div><div class=\"line\"></div><div class=\"line\">ws.onopen = () =&gt; &#123;</div><div class=\"line\">  // 打开一个连接</div><div class=\"line\"></div><div class=\"line\">  ws.send(&apos;something&apos;); // 发送一个消息</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">ws.onmessage = (e) =&gt; &#123;</div><div class=\"line\">  // 接收到了一个消息</div><div class=\"line\">  console.log(e.data);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">ws.onerror = (e) =&gt; &#123;</div><div class=\"line\">  // 发生了一个错误</div><div class=\"line\">  console.log(e.message);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">ws.onclose = (e) =&gt; &#123;</div><div class=\"line\">  // 连接被关闭了</div><div class=\"line\">  console.log(e.code, e.reason);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"页面跳转\"><a href=\"#页面跳转\" class=\"headerlink\" title=\"页面跳转\"></a>页面跳转</h3><p><strong>场景(Scene)</strong><br>各种组件组合在一起，形成了一个界面，也就是一个场景</p>\n<p>一个简单的场景如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">MyScene.js</div><div class=\"line\"></div><div class=\"line\">import React, &#123; Component &#125; from &apos;react&apos;;</div><div class=\"line\">import &#123; View, Text &#125; from &apos;react-native&apos;;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\"> * 导出当前组件</div><div class=\"line\"> */</div><div class=\"line\"></div><div class=\"line\">export default class MyScene extends Component &#123;</div><div class=\"line\">    static defaultProps = &#123;</div><div class=\"line\">        title: &apos;MyScene&apos;,</div><div class=\"line\">    &#125;;</div><div class=\"line\"></div><div class=\"line\">    render() &#123;</div><div class=\"line\">        return (</div><div class=\"line\">            &lt;View&gt;</div><div class=\"line\">                &lt;Text&gt;Hi ! My name is &#123;this.props.title&#125; &lt;/Text&gt;</div><div class=\"line\">            &lt;/View&gt;</div><div class=\"line\">        )</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><strong>Navigator</strong><br>官方首推<code>Navigator</code>来作为导航器组件，实现界面跳转,先渲染出一个<code>Navigator</code>组件，通过<code>Navigator</code>的<code>renderScene</code>属性来渲染其他的<code>Scene</code>。将之前的那个场景给渲染进来。</p>\n<p><strong>单个渲染</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;Navigator</div><div class=\"line\">               initialRoute=&#123;&#123;title: &apos;My Initial Scene&apos;, index: 0&#125;&#125;</div><div class=\"line\">               renderScene=&#123;(route, navigator) =&gt; &#123;</div><div class=\"line\">                   return &lt;MyScene title=&#123;route.title&#125; /&gt;</div><div class=\"line\">               &#125;&#125;</div><div class=\"line\">           /&gt;</div></pre></td></tr></table></figure>\n<p>使用导航器经常会碰到“路由(route)”的概念。“路由”抽象自现实生活中的路牌，在RN中专指包含了场景信息的对象。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">**实现跳转**</div><div class=\"line\">场景之间的切换，`navigator`提供了两个主要的方法：</div><div class=\"line\">* `push` 将`route`对象推入并渲染</div><div class=\"line\">* `pop` 将`route`对象弹出导航栈</div><div class=\"line\"></div><div class=\"line\">**基本场景**</div></pre></td></tr></table></figure></p>\n<p>import React, { Component, PropTypes } from ‘react’;<br>import { View, Text, TouchableHighlight } from ‘react-native’;</p>\n<p>export default class MyScene extends Component {<br>  static propTypes = {<br>    title: PropTypes.string.isRequired,<br>    onForward: PropTypes.func.isRequired,<br>    onBack: PropTypes.func.isRequired,<br>  }<br>  render() {<br>    return (<br>      <view><br>        <text>Current Scene: { this.props.title }</text><br>        <touchablehighlight onpress=\"{this.props.onForward}\"><br>          <text>点我进入下一场景</text><br>        </touchablehighlight><br>        <touchablehighlight onpress=\"{this.props.onBack}\"><br>          <text>点我返回上一场景</text><br>        </touchablehighlight><br>      </view><br>    )<br>  }<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">**导航器**</div></pre></td></tr></table></figure></p>\n<p>import React, {Component} from ‘react’;<br>import {AppRegistry, Navigator, Text, View} from ‘react-native’;</p>\n<p>import MyScene from ‘./MyScene’;</p>\n<p>class AwesomeProject extends Component {</p>\n<pre><code>render() {\n    return (\n        &lt;Navigator\n            initialRoute={{title: 'My Initial Scene', index: 0}}\n            renderScene={(route, navigator) =&gt; {\n                return &lt;MyScene title={route.title}\n\n                 onForward= { () =&gt; {\n                     const nextIndex = route.index + 1;\n                     navigator.push({\n                         title: &apos;Scene &apos; + nextIndex,\n                         index: nextIndex\n                     });\n                 }}\n\n                 onBack= { () =&gt; {\n                     if (route.index &gt; 0) {\n                         navigator.pop();\n                     }\n                 }}\n\n                 /&gt;\n            }}\n        /&gt;\n    );\n}\n</code></pre><p>}</p>\n<p>AppRegistry.registerComponent(‘AwesomeProject’, () =&gt; AwesomeProject);<br>```</p>"},{"title":"React-Native笔记(二)","date":"2017-02-24T03:36:10.000Z","_content":"\n## React-Native笔记(二)\n\n### 图片\n\n**静态图片**\n引用图片只需要将图片文件放在项目文件夹中，指定路径引用\n\n```\n<Image source={require('./my-icon.png')} />\n```\n系统会从一个引用了图片的组件所在的根目录出发，去寻找这张图片。\n提供`@2x`,`@3x`来指明图片的精度。\n使用`my-icon.ios.png`以及`my-icon.android.png`来提供不同平台的图片。\n\n<!--more-->\n\n在`require()`里面的图片名字必须为静态字符串\n\n> 加入新的图片资源后，可能需要重启packager引入新的图片资源\n\n**原生与React Native**\n使用react native的时候也能够使用原生打包的资源文件\n\n```\n<Image source={{uri: 'app_icon'}} style={{width: 40, height: 40}} />\n```\n\n> 这一做法并没有任何安全检查。你需要自己确保图片在应用中确实存在，而且还需要指定尺寸。\n\n\n**网络图片**\n使用网络图片的时候需要指定图片的尺寸\n\n```\n// 正确\n<Image source={{uri: 'https://facebook.github.io/react/img/logo_og.png'}}\n       style={{width: 400, height: 400}} />\n\n// 错误\n<Image source={{uri: 'https://facebook.github.io/react/img/logo_og.png'}} />\n```\n\n### ScrollView\n`ScrollView`是一个通用的可滚动容器，支持竖直、水平滚动\n\n```\n    \t<ScrollView> \n\n    \t\t<Text style={{fontSize:32}}>Scroll me plz</Text>\n\n    \t\t<Text style={{fontSize:32}}>Scroll me plz</Text>\n\n    \t\t<Image source={require('./test.jpg')} />\n    \t</ScrollView>\n```\n\n**可点击组件**\n使用`Touchable`开头的一系列组件能够捕捉用户点击操作。\n`onPress`属性接受一个处理点击事件的函数，在点击操作开始并终止于组件的时候，相应的函数会被调用。\n`onLongPress`属性用来处理长按事件。\n\n```\n_onPressButton() {\n    console.log(\"You tapped the button!\");\n  }\n\n<TouchableHighlight onPress={this._onPressButton}>\n        <Text>Button</Text>\n      </TouchableHighlight>\n```\n\n可以通过使用不同组件提供给用户不同的触摸反馈:\n\n* `TouchableHighlight`会在用户手指按下的时候变暗\n* `TouchableNativeFeedback`会在Android上体现出原生的视觉效果\n* `TouchableOpacity`会在用户按下的时候改变透明度\n* `TouchableWithoutFeedback`没有任何反馈\n\n\n###ListView\n动态渲染屏幕上可见的元素\n`dataSource`属性，设定列表的数据源\n`renderRow`属性，诸葛解析数据源中的数据，染回一个设定好格式的组件来渲染\n\n```\nclass ListViewBasics extends Component {\n  // 初始化模拟数据\n  constructor(props) {\n    super(props);\n    const ds = new ListView.DataSource({rowHasChanged: (r1, r2) => r1 !== r2});\n    this.state = {\n      dataSource: ds.cloneWithRows([\n        'John', 'Joel', 'James', 'Jimmy', 'Jackson', 'Jillian', 'Julie', 'Devin'\n      ])\n    };\n  }\n  render() {\n    return (\n      <View style={{flex: 1, paddingTop: 22}}>\n        <ListView\n          dataSource={this.state.dataSource}\n          renderRow={(rowData) => <Text>{rowData}</Text>}\n        />\n      </View>\n    );\n  }\n}\n```","source":"_posts/React-Native笔记-二.md","raw":"---\ntitle: React-Native笔记(二)\ndate: 2017-02-24 11:36:10\ntags: React-Native\n\n---\n\n## React-Native笔记(二)\n\n### 图片\n\n**静态图片**\n引用图片只需要将图片文件放在项目文件夹中，指定路径引用\n\n```\n<Image source={require('./my-icon.png')} />\n```\n系统会从一个引用了图片的组件所在的根目录出发，去寻找这张图片。\n提供`@2x`,`@3x`来指明图片的精度。\n使用`my-icon.ios.png`以及`my-icon.android.png`来提供不同平台的图片。\n\n<!--more-->\n\n在`require()`里面的图片名字必须为静态字符串\n\n> 加入新的图片资源后，可能需要重启packager引入新的图片资源\n\n**原生与React Native**\n使用react native的时候也能够使用原生打包的资源文件\n\n```\n<Image source={{uri: 'app_icon'}} style={{width: 40, height: 40}} />\n```\n\n> 这一做法并没有任何安全检查。你需要自己确保图片在应用中确实存在，而且还需要指定尺寸。\n\n\n**网络图片**\n使用网络图片的时候需要指定图片的尺寸\n\n```\n// 正确\n<Image source={{uri: 'https://facebook.github.io/react/img/logo_og.png'}}\n       style={{width: 400, height: 400}} />\n\n// 错误\n<Image source={{uri: 'https://facebook.github.io/react/img/logo_og.png'}} />\n```\n\n### ScrollView\n`ScrollView`是一个通用的可滚动容器，支持竖直、水平滚动\n\n```\n    \t<ScrollView> \n\n    \t\t<Text style={{fontSize:32}}>Scroll me plz</Text>\n\n    \t\t<Text style={{fontSize:32}}>Scroll me plz</Text>\n\n    \t\t<Image source={require('./test.jpg')} />\n    \t</ScrollView>\n```\n\n**可点击组件**\n使用`Touchable`开头的一系列组件能够捕捉用户点击操作。\n`onPress`属性接受一个处理点击事件的函数，在点击操作开始并终止于组件的时候，相应的函数会被调用。\n`onLongPress`属性用来处理长按事件。\n\n```\n_onPressButton() {\n    console.log(\"You tapped the button!\");\n  }\n\n<TouchableHighlight onPress={this._onPressButton}>\n        <Text>Button</Text>\n      </TouchableHighlight>\n```\n\n可以通过使用不同组件提供给用户不同的触摸反馈:\n\n* `TouchableHighlight`会在用户手指按下的时候变暗\n* `TouchableNativeFeedback`会在Android上体现出原生的视觉效果\n* `TouchableOpacity`会在用户按下的时候改变透明度\n* `TouchableWithoutFeedback`没有任何反馈\n\n\n###ListView\n动态渲染屏幕上可见的元素\n`dataSource`属性，设定列表的数据源\n`renderRow`属性，诸葛解析数据源中的数据，染回一个设定好格式的组件来渲染\n\n```\nclass ListViewBasics extends Component {\n  // 初始化模拟数据\n  constructor(props) {\n    super(props);\n    const ds = new ListView.DataSource({rowHasChanged: (r1, r2) => r1 !== r2});\n    this.state = {\n      dataSource: ds.cloneWithRows([\n        'John', 'Joel', 'James', 'Jimmy', 'Jackson', 'Jillian', 'Julie', 'Devin'\n      ])\n    };\n  }\n  render() {\n    return (\n      <View style={{flex: 1, paddingTop: 22}}>\n        <ListView\n          dataSource={this.state.dataSource}\n          renderRow={(rowData) => <Text>{rowData}</Text>}\n        />\n      </View>\n    );\n  }\n}\n```","slug":"React-Native笔记-二","published":1,"updated":"2020-07-03T02:40:48.120Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc5n2qh10007w8r1h6wlbk2z","content":"<h2 id=\"React-Native笔记-二\"><a href=\"#React-Native笔记-二\" class=\"headerlink\" title=\"React-Native笔记(二)\"></a>React-Native笔记(二)</h2><h3 id=\"图片\"><a href=\"#图片\" class=\"headerlink\" title=\"图片\"></a>图片</h3><p><strong>静态图片</strong><br>引用图片只需要将图片文件放在项目文件夹中，指定路径引用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;Image source=&#123;require(&apos;./my-icon.png&apos;)&#125; /&gt;</div></pre></td></tr></table></figure>\n<p>系统会从一个引用了图片的组件所在的根目录出发，去寻找这张图片。<br>提供<code>@2x</code>,<code>@3x</code>来指明图片的精度。<br>使用<code>my-icon.ios.png</code>以及<code>my-icon.android.png</code>来提供不同平台的图片。</p>\n<a id=\"more\"></a>\n<p>在<code>require()</code>里面的图片名字必须为静态字符串</p>\n<blockquote>\n<p>加入新的图片资源后，可能需要重启packager引入新的图片资源</p>\n</blockquote>\n<p><strong>原生与React Native</strong><br>使用react native的时候也能够使用原生打包的资源文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;Image source=&#123;&#123;uri: &apos;app_icon&apos;&#125;&#125; style=&#123;&#123;width: 40, height: 40&#125;&#125; /&gt;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>这一做法并没有任何安全检查。你需要自己确保图片在应用中确实存在，而且还需要指定尺寸。</p>\n</blockquote>\n<p><strong>网络图片</strong><br>使用网络图片的时候需要指定图片的尺寸</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 正确</div><div class=\"line\">&lt;Image source=&#123;&#123;uri: &apos;https://facebook.github.io/react/img/logo_og.png&apos;&#125;&#125;</div><div class=\"line\">       style=&#123;&#123;width: 400, height: 400&#125;&#125; /&gt;</div><div class=\"line\"></div><div class=\"line\">// 错误</div><div class=\"line\">&lt;Image source=&#123;&#123;uri: &apos;https://facebook.github.io/react/img/logo_og.png&apos;&#125;&#125; /&gt;</div></pre></td></tr></table></figure>\n<h3 id=\"ScrollView\"><a href=\"#ScrollView\" class=\"headerlink\" title=\"ScrollView\"></a>ScrollView</h3><p><code>ScrollView</code>是一个通用的可滚动容器，支持竖直、水平滚动</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;ScrollView&gt; </div><div class=\"line\"></div><div class=\"line\">\t&lt;Text style=&#123;&#123;fontSize:32&#125;&#125;&gt;Scroll me plz&lt;/Text&gt;</div><div class=\"line\"></div><div class=\"line\">\t&lt;Text style=&#123;&#123;fontSize:32&#125;&#125;&gt;Scroll me plz&lt;/Text&gt;</div><div class=\"line\"></div><div class=\"line\">\t&lt;Image source=&#123;require(&apos;./test.jpg&apos;)&#125; /&gt;</div><div class=\"line\">&lt;/ScrollView&gt;</div></pre></td></tr></table></figure>\n<p><strong>可点击组件</strong><br>使用<code>Touchable</code>开头的一系列组件能够捕捉用户点击操作。<br><code>onPress</code>属性接受一个处理点击事件的函数，在点击操作开始并终止于组件的时候，相应的函数会被调用。<br><code>onLongPress</code>属性用来处理长按事件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">_onPressButton() &#123;</div><div class=\"line\">    console.log(&quot;You tapped the button!&quot;);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">&lt;TouchableHighlight onPress=&#123;this._onPressButton&#125;&gt;</div><div class=\"line\">        &lt;Text&gt;Button&lt;/Text&gt;</div><div class=\"line\">      &lt;/TouchableHighlight&gt;</div></pre></td></tr></table></figure>\n<p>可以通过使用不同组件提供给用户不同的触摸反馈:</p>\n<ul>\n<li><code>TouchableHighlight</code>会在用户手指按下的时候变暗</li>\n<li><code>TouchableNativeFeedback</code>会在Android上体现出原生的视觉效果</li>\n<li><code>TouchableOpacity</code>会在用户按下的时候改变透明度</li>\n<li><code>TouchableWithoutFeedback</code>没有任何反馈</li>\n</ul>\n<p>###ListView<br>动态渲染屏幕上可见的元素<br><code>dataSource</code>属性，设定列表的数据源<br><code>renderRow</code>属性，诸葛解析数据源中的数据，染回一个设定好格式的组件来渲染</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">class ListViewBasics extends Component &#123;</div><div class=\"line\">  // 初始化模拟数据</div><div class=\"line\">  constructor(props) &#123;</div><div class=\"line\">    super(props);</div><div class=\"line\">    const ds = new ListView.DataSource(&#123;rowHasChanged: (r1, r2) =&gt; r1 !== r2&#125;);</div><div class=\"line\">    this.state = &#123;</div><div class=\"line\">      dataSource: ds.cloneWithRows([</div><div class=\"line\">        &apos;John&apos;, &apos;Joel&apos;, &apos;James&apos;, &apos;Jimmy&apos;, &apos;Jackson&apos;, &apos;Jillian&apos;, &apos;Julie&apos;, &apos;Devin&apos;</div><div class=\"line\">      ])</div><div class=\"line\">    &#125;;</div><div class=\"line\">  &#125;</div><div class=\"line\">  render() &#123;</div><div class=\"line\">    return (</div><div class=\"line\">      &lt;View style=&#123;&#123;flex: 1, paddingTop: 22&#125;&#125;&gt;</div><div class=\"line\">        &lt;ListView</div><div class=\"line\">          dataSource=&#123;this.state.dataSource&#125;</div><div class=\"line\">          renderRow=&#123;(rowData) =&gt; &lt;Text&gt;&#123;rowData&#125;&lt;/Text&gt;&#125;</div><div class=\"line\">        /&gt;</div><div class=\"line\">      &lt;/View&gt;</div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"React-Native笔记-二\"><a href=\"#React-Native笔记-二\" class=\"headerlink\" title=\"React-Native笔记(二)\"></a>React-Native笔记(二)</h2><h3 id=\"图片\"><a href=\"#图片\" class=\"headerlink\" title=\"图片\"></a>图片</h3><p><strong>静态图片</strong><br>引用图片只需要将图片文件放在项目文件夹中，指定路径引用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;Image source=&#123;require(&apos;./my-icon.png&apos;)&#125; /&gt;</div></pre></td></tr></table></figure>\n<p>系统会从一个引用了图片的组件所在的根目录出发，去寻找这张图片。<br>提供<code>@2x</code>,<code>@3x</code>来指明图片的精度。<br>使用<code>my-icon.ios.png</code>以及<code>my-icon.android.png</code>来提供不同平台的图片。</p>","more":"<p>在<code>require()</code>里面的图片名字必须为静态字符串</p>\n<blockquote>\n<p>加入新的图片资源后，可能需要重启packager引入新的图片资源</p>\n</blockquote>\n<p><strong>原生与React Native</strong><br>使用react native的时候也能够使用原生打包的资源文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;Image source=&#123;&#123;uri: &apos;app_icon&apos;&#125;&#125; style=&#123;&#123;width: 40, height: 40&#125;&#125; /&gt;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>这一做法并没有任何安全检查。你需要自己确保图片在应用中确实存在，而且还需要指定尺寸。</p>\n</blockquote>\n<p><strong>网络图片</strong><br>使用网络图片的时候需要指定图片的尺寸</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 正确</div><div class=\"line\">&lt;Image source=&#123;&#123;uri: &apos;https://facebook.github.io/react/img/logo_og.png&apos;&#125;&#125;</div><div class=\"line\">       style=&#123;&#123;width: 400, height: 400&#125;&#125; /&gt;</div><div class=\"line\"></div><div class=\"line\">// 错误</div><div class=\"line\">&lt;Image source=&#123;&#123;uri: &apos;https://facebook.github.io/react/img/logo_og.png&apos;&#125;&#125; /&gt;</div></pre></td></tr></table></figure>\n<h3 id=\"ScrollView\"><a href=\"#ScrollView\" class=\"headerlink\" title=\"ScrollView\"></a>ScrollView</h3><p><code>ScrollView</code>是一个通用的可滚动容器，支持竖直、水平滚动</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;ScrollView&gt; </div><div class=\"line\"></div><div class=\"line\">\t&lt;Text style=&#123;&#123;fontSize:32&#125;&#125;&gt;Scroll me plz&lt;/Text&gt;</div><div class=\"line\"></div><div class=\"line\">\t&lt;Text style=&#123;&#123;fontSize:32&#125;&#125;&gt;Scroll me plz&lt;/Text&gt;</div><div class=\"line\"></div><div class=\"line\">\t&lt;Image source=&#123;require(&apos;./test.jpg&apos;)&#125; /&gt;</div><div class=\"line\">&lt;/ScrollView&gt;</div></pre></td></tr></table></figure>\n<p><strong>可点击组件</strong><br>使用<code>Touchable</code>开头的一系列组件能够捕捉用户点击操作。<br><code>onPress</code>属性接受一个处理点击事件的函数，在点击操作开始并终止于组件的时候，相应的函数会被调用。<br><code>onLongPress</code>属性用来处理长按事件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">_onPressButton() &#123;</div><div class=\"line\">    console.log(&quot;You tapped the button!&quot;);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">&lt;TouchableHighlight onPress=&#123;this._onPressButton&#125;&gt;</div><div class=\"line\">        &lt;Text&gt;Button&lt;/Text&gt;</div><div class=\"line\">      &lt;/TouchableHighlight&gt;</div></pre></td></tr></table></figure>\n<p>可以通过使用不同组件提供给用户不同的触摸反馈:</p>\n<ul>\n<li><code>TouchableHighlight</code>会在用户手指按下的时候变暗</li>\n<li><code>TouchableNativeFeedback</code>会在Android上体现出原生的视觉效果</li>\n<li><code>TouchableOpacity</code>会在用户按下的时候改变透明度</li>\n<li><code>TouchableWithoutFeedback</code>没有任何反馈</li>\n</ul>\n<p>###ListView<br>动态渲染屏幕上可见的元素<br><code>dataSource</code>属性，设定列表的数据源<br><code>renderRow</code>属性，诸葛解析数据源中的数据，染回一个设定好格式的组件来渲染</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">class ListViewBasics extends Component &#123;</div><div class=\"line\">  // 初始化模拟数据</div><div class=\"line\">  constructor(props) &#123;</div><div class=\"line\">    super(props);</div><div class=\"line\">    const ds = new ListView.DataSource(&#123;rowHasChanged: (r1, r2) =&gt; r1 !== r2&#125;);</div><div class=\"line\">    this.state = &#123;</div><div class=\"line\">      dataSource: ds.cloneWithRows([</div><div class=\"line\">        &apos;John&apos;, &apos;Joel&apos;, &apos;James&apos;, &apos;Jimmy&apos;, &apos;Jackson&apos;, &apos;Jillian&apos;, &apos;Julie&apos;, &apos;Devin&apos;</div><div class=\"line\">      ])</div><div class=\"line\">    &#125;;</div><div class=\"line\">  &#125;</div><div class=\"line\">  render() &#123;</div><div class=\"line\">    return (</div><div class=\"line\">      &lt;View style=&#123;&#123;flex: 1, paddingTop: 22&#125;&#125;&gt;</div><div class=\"line\">        &lt;ListView</div><div class=\"line\">          dataSource=&#123;this.state.dataSource&#125;</div><div class=\"line\">          renderRow=&#123;(rowData) =&gt; &lt;Text&gt;&#123;rowData&#125;&lt;/Text&gt;&#125;</div><div class=\"line\">        /&gt;</div><div class=\"line\">      &lt;/View&gt;</div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"SharedPreferece产生的Concurrent Modification Exception","date":"2018-04-12T02:04:03.000Z","_content":"\n在使用SharedPreference的过程中，Bugly上报出`Concurrent ModificationException`\n\n```\njava.util.HashMap$HashIterator.nextEntry(HashMap.java:806)\njava.util.HashMap$KeyIterator.next(HashMap.java:833)\ncom.android.internal.util.XmlUtils.writeSetXml(XmlUtils.java:298)\ncom.android.internal.util.XmlUtils.writeValueXml(XmlUtils.java:447)\ncom.android.internal.util.XmlUtils.writeMapXml(XmlUtils.java:241)\ncom.android.internal.util.XmlUtils.writeMapXml(XmlUtils.java:181)\nandroid.app.SharedPreferencesImpl.writeToFile(SharedPreferencesImpl.java:596)\nandroid.app.SharedPreferencesImpl.access$800(SharedPreferencesImpl.java:52)\nandroid.app.SharedPreferencesImpl$2.run(SharedPreferencesImpl.java:511)\njava.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112)\njava.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587)\njava.lang.Thread.run(Thread.java:841)\n\n```\n\n最开始以为是由于使用了`RxJava`导致的多线程读写问题，但后来阅读`SharedPreferenceImpl`代码时发现，有使用`synchronized`来保证线程安全，排除多线程的可能性。\n\n在`HashIterator`的源码中，抛出`ConcurrentModificationException`的片段如下\n```\nif(HashMap.this.modCount != this.expectedModCount) {\n                throw new ConcurrentModificationException();\n            } else if(var2 == null) {\n                throw new NoSuchElementException();\n            } else {\n                if((this.next = (this.current = var2).next) == null) {\n                    HashMap.Node[] var1 = HashMap.this.table;\n                    if(HashMap.this.table != null) {\n                        while(this.index < var1.length && (this.next = var1[this.index++]) == null) {\n                            ;\n                        }\n                    }\n                }\n\n                return var2;\n            }\n```\n\n基本情况就是同一`HashMap`或者`HashSet`被多个线程同时修改了，导致集合的大小和预期不一致，抛出了异常。在网上查找原因时，注意到了`SharedPreference`中有个函数：\n\n```\n  /**\n     * Retrieve a set of String values from the preferences.\n     * \n     * <p>Note that you <em>must not</em> modify the set instance returned\n     * by this call.  The consistency of the stored data is not guaranteed\n     * if you do, nor is your ability to modify the instance at all.\n     *\n     * @param key The name of the preference to retrieve.\n     * @param defValues Values to return if this preference does not exist.\n     * \n     * @return Returns the preference values if they exist, or defValues.\n     * Throws ClassCastException if there is a preference with this name\n     * that is not a Set.\n     * \n     * @throws ClassCastException\n     */\n    @Nullable\n    Set<String> getStringSet(String key, @Nullable Set<String> defValues);\n    \n```\n明确提到了不能直接修改返回的`Set`，其实现类`SharedPreferenceImpl`中的代码,直接从`Map`中返回了集合，多个线程同时获取了同一个集合，同时修改肯定会出错:\n\n```\n  @Nullable\n    public Set<String> getStringSet(String key, @Nullable Set<String> defValues) {\n        synchronized (mLock) {\n            awaitLoadedLocked();\n            Set<String> v = (Set<String>) mMap.get(key);\n            return v != null ? v : defValues;\n        }\n    }\n```\n\n#### 解决方案\n\n在使用了`getStringSet`的地方，将返回的`Set`拷贝一份再使用，能够避免这个问题。\n\n##### 参考文章\n> https://janatechnology.wordpress.com/2016/01/29/concurrent-modification-exceptions-on-androids-shared-preferences/\n","source":"_posts/SharedPreferece产生的Concurrent Modification Exception.md","raw":"---\ntitle: SharedPreferece产生的Concurrent Modification Exception\ndate: 2018-04-12 10:04:03\ntags: Android\n\n---\n\n在使用SharedPreference的过程中，Bugly上报出`Concurrent ModificationException`\n\n```\njava.util.HashMap$HashIterator.nextEntry(HashMap.java:806)\njava.util.HashMap$KeyIterator.next(HashMap.java:833)\ncom.android.internal.util.XmlUtils.writeSetXml(XmlUtils.java:298)\ncom.android.internal.util.XmlUtils.writeValueXml(XmlUtils.java:447)\ncom.android.internal.util.XmlUtils.writeMapXml(XmlUtils.java:241)\ncom.android.internal.util.XmlUtils.writeMapXml(XmlUtils.java:181)\nandroid.app.SharedPreferencesImpl.writeToFile(SharedPreferencesImpl.java:596)\nandroid.app.SharedPreferencesImpl.access$800(SharedPreferencesImpl.java:52)\nandroid.app.SharedPreferencesImpl$2.run(SharedPreferencesImpl.java:511)\njava.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112)\njava.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587)\njava.lang.Thread.run(Thread.java:841)\n\n```\n\n最开始以为是由于使用了`RxJava`导致的多线程读写问题，但后来阅读`SharedPreferenceImpl`代码时发现，有使用`synchronized`来保证线程安全，排除多线程的可能性。\n\n在`HashIterator`的源码中，抛出`ConcurrentModificationException`的片段如下\n```\nif(HashMap.this.modCount != this.expectedModCount) {\n                throw new ConcurrentModificationException();\n            } else if(var2 == null) {\n                throw new NoSuchElementException();\n            } else {\n                if((this.next = (this.current = var2).next) == null) {\n                    HashMap.Node[] var1 = HashMap.this.table;\n                    if(HashMap.this.table != null) {\n                        while(this.index < var1.length && (this.next = var1[this.index++]) == null) {\n                            ;\n                        }\n                    }\n                }\n\n                return var2;\n            }\n```\n\n基本情况就是同一`HashMap`或者`HashSet`被多个线程同时修改了，导致集合的大小和预期不一致，抛出了异常。在网上查找原因时，注意到了`SharedPreference`中有个函数：\n\n```\n  /**\n     * Retrieve a set of String values from the preferences.\n     * \n     * <p>Note that you <em>must not</em> modify the set instance returned\n     * by this call.  The consistency of the stored data is not guaranteed\n     * if you do, nor is your ability to modify the instance at all.\n     *\n     * @param key The name of the preference to retrieve.\n     * @param defValues Values to return if this preference does not exist.\n     * \n     * @return Returns the preference values if they exist, or defValues.\n     * Throws ClassCastException if there is a preference with this name\n     * that is not a Set.\n     * \n     * @throws ClassCastException\n     */\n    @Nullable\n    Set<String> getStringSet(String key, @Nullable Set<String> defValues);\n    \n```\n明确提到了不能直接修改返回的`Set`，其实现类`SharedPreferenceImpl`中的代码,直接从`Map`中返回了集合，多个线程同时获取了同一个集合，同时修改肯定会出错:\n\n```\n  @Nullable\n    public Set<String> getStringSet(String key, @Nullable Set<String> defValues) {\n        synchronized (mLock) {\n            awaitLoadedLocked();\n            Set<String> v = (Set<String>) mMap.get(key);\n            return v != null ? v : defValues;\n        }\n    }\n```\n\n#### 解决方案\n\n在使用了`getStringSet`的地方，将返回的`Set`拷贝一份再使用，能够避免这个问题。\n\n##### 参考文章\n> https://janatechnology.wordpress.com/2016/01/29/concurrent-modification-exceptions-on-androids-shared-preferences/\n","slug":"SharedPreferece产生的Concurrent Modification Exception","published":1,"updated":"2020-07-03T02:40:48.120Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc5n2qh2000aw8r1vw9z4e2v","content":"<p>在使用SharedPreference的过程中，Bugly上报出<code>Concurrent ModificationException</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">java.util.HashMap$HashIterator.nextEntry(HashMap.java:806)</div><div class=\"line\">java.util.HashMap$KeyIterator.next(HashMap.java:833)</div><div class=\"line\">com.android.internal.util.XmlUtils.writeSetXml(XmlUtils.java:298)</div><div class=\"line\">com.android.internal.util.XmlUtils.writeValueXml(XmlUtils.java:447)</div><div class=\"line\">com.android.internal.util.XmlUtils.writeMapXml(XmlUtils.java:241)</div><div class=\"line\">com.android.internal.util.XmlUtils.writeMapXml(XmlUtils.java:181)</div><div class=\"line\">android.app.SharedPreferencesImpl.writeToFile(SharedPreferencesImpl.java:596)</div><div class=\"line\">android.app.SharedPreferencesImpl.access$800(SharedPreferencesImpl.java:52)</div><div class=\"line\">android.app.SharedPreferencesImpl$2.run(SharedPreferencesImpl.java:511)</div><div class=\"line\">java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112)</div><div class=\"line\">java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587)</div><div class=\"line\">java.lang.Thread.run(Thread.java:841)</div></pre></td></tr></table></figure>\n<p>最开始以为是由于使用了<code>RxJava</code>导致的多线程读写问题，但后来阅读<code>SharedPreferenceImpl</code>代码时发现，有使用<code>synchronized</code>来保证线程安全，排除多线程的可能性。</p>\n<p>在<code>HashIterator</code>的源码中，抛出<code>ConcurrentModificationException</code>的片段如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">if(HashMap.this.modCount != this.expectedModCount) &#123;</div><div class=\"line\">                throw new ConcurrentModificationException();</div><div class=\"line\">            &#125; else if(var2 == null) &#123;</div><div class=\"line\">                throw new NoSuchElementException();</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                if((this.next = (this.current = var2).next) == null) &#123;</div><div class=\"line\">                    HashMap.Node[] var1 = HashMap.this.table;</div><div class=\"line\">                    if(HashMap.this.table != null) &#123;</div><div class=\"line\">                        while(this.index &lt; var1.length &amp;&amp; (this.next = var1[this.index++]) == null) &#123;</div><div class=\"line\">                            ;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                return var2;</div><div class=\"line\">            &#125;</div></pre></td></tr></table></figure></p>\n<p>基本情况就是同一<code>HashMap</code>或者<code>HashSet</code>被多个线程同时修改了，导致集合的大小和预期不一致，抛出了异常。在网上查找原因时，注意到了<code>SharedPreference</code>中有个函数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\">   * Retrieve a set of String values from the preferences.</div><div class=\"line\">   * </div><div class=\"line\">   * &lt;p&gt;Note that you &lt;em&gt;must not&lt;/em&gt; modify the set instance returned</div><div class=\"line\">   * by this call.  The consistency of the stored data is not guaranteed</div><div class=\"line\">   * if you do, nor is your ability to modify the instance at all.</div><div class=\"line\">   *</div><div class=\"line\">   * @param key The name of the preference to retrieve.</div><div class=\"line\">   * @param defValues Values to return if this preference does not exist.</div><div class=\"line\">   * </div><div class=\"line\">   * @return Returns the preference values if they exist, or defValues.</div><div class=\"line\">   * Throws ClassCastException if there is a preference with this name</div><div class=\"line\">   * that is not a Set.</div><div class=\"line\">   * </div><div class=\"line\">   * @throws ClassCastException</div><div class=\"line\">   */</div><div class=\"line\">  @Nullable</div><div class=\"line\">  Set&lt;String&gt; getStringSet(String key, @Nullable Set&lt;String&gt; defValues);</div></pre></td></tr></table></figure>\n<p>明确提到了不能直接修改返回的<code>Set</code>，其实现类<code>SharedPreferenceImpl</code>中的代码,直接从<code>Map</code>中返回了集合，多个线程同时获取了同一个集合，同时修改肯定会出错:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Nullable</div><div class=\"line\">  public Set&lt;String&gt; getStringSet(String key, @Nullable Set&lt;String&gt; defValues) &#123;</div><div class=\"line\">      synchronized (mLock) &#123;</div><div class=\"line\">          awaitLoadedLocked();</div><div class=\"line\">          Set&lt;String&gt; v = (Set&lt;String&gt;) mMap.get(key);</div><div class=\"line\">          return v != null ? v : defValues;</div><div class=\"line\">      &#125;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<h4 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h4><p>在使用了<code>getStringSet</code>的地方，将返回的<code>Set</code>拷贝一份再使用，能够避免这个问题。</p>\n<h5 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h5><blockquote>\n<p><a href=\"https://janatechnology.wordpress.com/2016/01/29/concurrent-modification-exceptions-on-androids-shared-preferences/\" target=\"_blank\" rel=\"noopener\">https://janatechnology.wordpress.com/2016/01/29/concurrent-modification-exceptions-on-androids-shared-preferences/</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>在使用SharedPreference的过程中，Bugly上报出<code>Concurrent ModificationException</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">java.util.HashMap$HashIterator.nextEntry(HashMap.java:806)</div><div class=\"line\">java.util.HashMap$KeyIterator.next(HashMap.java:833)</div><div class=\"line\">com.android.internal.util.XmlUtils.writeSetXml(XmlUtils.java:298)</div><div class=\"line\">com.android.internal.util.XmlUtils.writeValueXml(XmlUtils.java:447)</div><div class=\"line\">com.android.internal.util.XmlUtils.writeMapXml(XmlUtils.java:241)</div><div class=\"line\">com.android.internal.util.XmlUtils.writeMapXml(XmlUtils.java:181)</div><div class=\"line\">android.app.SharedPreferencesImpl.writeToFile(SharedPreferencesImpl.java:596)</div><div class=\"line\">android.app.SharedPreferencesImpl.access$800(SharedPreferencesImpl.java:52)</div><div class=\"line\">android.app.SharedPreferencesImpl$2.run(SharedPreferencesImpl.java:511)</div><div class=\"line\">java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112)</div><div class=\"line\">java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587)</div><div class=\"line\">java.lang.Thread.run(Thread.java:841)</div></pre></td></tr></table></figure>\n<p>最开始以为是由于使用了<code>RxJava</code>导致的多线程读写问题，但后来阅读<code>SharedPreferenceImpl</code>代码时发现，有使用<code>synchronized</code>来保证线程安全，排除多线程的可能性。</p>\n<p>在<code>HashIterator</code>的源码中，抛出<code>ConcurrentModificationException</code>的片段如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">if(HashMap.this.modCount != this.expectedModCount) &#123;</div><div class=\"line\">                throw new ConcurrentModificationException();</div><div class=\"line\">            &#125; else if(var2 == null) &#123;</div><div class=\"line\">                throw new NoSuchElementException();</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                if((this.next = (this.current = var2).next) == null) &#123;</div><div class=\"line\">                    HashMap.Node[] var1 = HashMap.this.table;</div><div class=\"line\">                    if(HashMap.this.table != null) &#123;</div><div class=\"line\">                        while(this.index &lt; var1.length &amp;&amp; (this.next = var1[this.index++]) == null) &#123;</div><div class=\"line\">                            ;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                return var2;</div><div class=\"line\">            &#125;</div></pre></td></tr></table></figure></p>\n<p>基本情况就是同一<code>HashMap</code>或者<code>HashSet</code>被多个线程同时修改了，导致集合的大小和预期不一致，抛出了异常。在网上查找原因时，注意到了<code>SharedPreference</code>中有个函数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\">   * Retrieve a set of String values from the preferences.</div><div class=\"line\">   * </div><div class=\"line\">   * &lt;p&gt;Note that you &lt;em&gt;must not&lt;/em&gt; modify the set instance returned</div><div class=\"line\">   * by this call.  The consistency of the stored data is not guaranteed</div><div class=\"line\">   * if you do, nor is your ability to modify the instance at all.</div><div class=\"line\">   *</div><div class=\"line\">   * @param key The name of the preference to retrieve.</div><div class=\"line\">   * @param defValues Values to return if this preference does not exist.</div><div class=\"line\">   * </div><div class=\"line\">   * @return Returns the preference values if they exist, or defValues.</div><div class=\"line\">   * Throws ClassCastException if there is a preference with this name</div><div class=\"line\">   * that is not a Set.</div><div class=\"line\">   * </div><div class=\"line\">   * @throws ClassCastException</div><div class=\"line\">   */</div><div class=\"line\">  @Nullable</div><div class=\"line\">  Set&lt;String&gt; getStringSet(String key, @Nullable Set&lt;String&gt; defValues);</div></pre></td></tr></table></figure>\n<p>明确提到了不能直接修改返回的<code>Set</code>，其实现类<code>SharedPreferenceImpl</code>中的代码,直接从<code>Map</code>中返回了集合，多个线程同时获取了同一个集合，同时修改肯定会出错:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Nullable</div><div class=\"line\">  public Set&lt;String&gt; getStringSet(String key, @Nullable Set&lt;String&gt; defValues) &#123;</div><div class=\"line\">      synchronized (mLock) &#123;</div><div class=\"line\">          awaitLoadedLocked();</div><div class=\"line\">          Set&lt;String&gt; v = (Set&lt;String&gt;) mMap.get(key);</div><div class=\"line\">          return v != null ? v : defValues;</div><div class=\"line\">      &#125;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<h4 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h4><p>在使用了<code>getStringSet</code>的地方，将返回的<code>Set</code>拷贝一份再使用，能够避免这个问题。</p>\n<h5 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h5><blockquote>\n<p><a href=\"https://janatechnology.wordpress.com/2016/01/29/concurrent-modification-exceptions-on-androids-shared-preferences/\" target=\"_blank\" rel=\"noopener\">https://janatechnology.wordpress.com/2016/01/29/concurrent-modification-exceptions-on-androids-shared-preferences/</a></p>\n</blockquote>\n"},{"title":"ViewPagerAdapter调用NotifyData后数据不刷新","date":"2018-04-12T02:04:02.000Z","_content":"\n线上存在一个关于PagerAdapter的少量崩溃，描述如下：\n> The application's PagerAdapter changed the adapter's contents without calling PagerAdapter#notifyDataSetChanged!\n\n由于在使用`PagerAdapter`的过程中，使用的数据源是从外界传入的，数据源被改变之后未调用`notifyDataSetChanged`函数来刷新并通知`Adapter`，此时滑动`ViewPager`时候会产生上述崩溃。\n\n在`ViewPager`内部的`PagerObserver`中有如下代码，检测数据源的数量是否处于同步状态，并会抛出异常:\n\n```\n     if (N != mExpectedAdapterCount) {\n            String resName;\n            try {\n                resName = getResources().getResourceName(getId());\n            } catch (Resources.NotFoundException e) {\n                resName = Integer.toHexString(getId());\n            }\n            throw new IllegalStateException(\"The application's PagerAdapter changed the adapter's\"\n                    + \" contents without calling PagerAdapter#notifyDataSetChanged!\"\n                    + \" Expected adapter item count: \" + mExpectedAdapterCount + \", found: \" + N\n                    + \" Pager id: \" + resName\n                    + \" Pager class: \" + getClass()\n                    + \" Problematic adapter: \" + mAdapter.getClass());\n        }\n```\n\n最初的解决办法是按照异常的提示，直接在修改了数据源的地方调用`notifyDataSetChanged()`函数，崩溃消失，出现了数据错位的现象。\n\n之后了解到，`ViewPager`的数据绑定和`RecyclerView`存在不同，`RecyclerView`在数据源变动之后会调用`onBindData`将数据源重新进行绑定，而`ViewPager`会根据`PagerAdapter`中的`getItemPosition`函数来决定是否刷新，默认的实现都是不刷新。\n\n```\n /**\n     * Called when the host view is attempting to determine if an item's position\n     * has changed. Returns {@link #POSITION_UNCHANGED} if the position of the given\n     * item has not changed or {@link #POSITION_NONE} if the item is no longer present\n     * in the adapter.\n     *\n     * <p>The default implementation assumes that items will never\n     * change position and always returns {@link #POSITION_UNCHANGED}.\n     *\n     * @param object Object representing an item, previously returned by a call to\n     *               {@link #instantiateItem(View, int)}.\n     * @return object's new position index from [0, {@link #getCount()}),\n     *         {@link #POSITION_UNCHANGED} if the object's position has not changed,\n     *         or {@link #POSITION_NONE} if the item is no longer present.\n     */\n    public int getItemPosition(@NonNull Object object) {\n        return POSITION_UNCHANGED;\n    }\n```\n\n此函数返回`POSITION_UNCHANGED`则不会进行数据刷新，而`POSITION_NONE`则会重新生成并绑定数据。对于数据源产生混乱的情况，通过控制该函数的返回值即可解决。\n\n最终的解决办法为通过设置`TAG`来判断当前数据源是否和Index匹配，不匹配则重新刷新，匹配则不用处理\n\n\n##### 参考文章\n\n> https://www.jianshu.com/p/266861496508","source":"_posts/ViewPagerAdapter调用NotifyData后数据不刷新.md","raw":"---\ntitle: ViewPagerAdapter调用NotifyData后数据不刷新\ndate: 2018-04-12 10:04:02\ntags: Android\n\n---\n\n线上存在一个关于PagerAdapter的少量崩溃，描述如下：\n> The application's PagerAdapter changed the adapter's contents without calling PagerAdapter#notifyDataSetChanged!\n\n由于在使用`PagerAdapter`的过程中，使用的数据源是从外界传入的，数据源被改变之后未调用`notifyDataSetChanged`函数来刷新并通知`Adapter`，此时滑动`ViewPager`时候会产生上述崩溃。\n\n在`ViewPager`内部的`PagerObserver`中有如下代码，检测数据源的数量是否处于同步状态，并会抛出异常:\n\n```\n     if (N != mExpectedAdapterCount) {\n            String resName;\n            try {\n                resName = getResources().getResourceName(getId());\n            } catch (Resources.NotFoundException e) {\n                resName = Integer.toHexString(getId());\n            }\n            throw new IllegalStateException(\"The application's PagerAdapter changed the adapter's\"\n                    + \" contents without calling PagerAdapter#notifyDataSetChanged!\"\n                    + \" Expected adapter item count: \" + mExpectedAdapterCount + \", found: \" + N\n                    + \" Pager id: \" + resName\n                    + \" Pager class: \" + getClass()\n                    + \" Problematic adapter: \" + mAdapter.getClass());\n        }\n```\n\n最初的解决办法是按照异常的提示，直接在修改了数据源的地方调用`notifyDataSetChanged()`函数，崩溃消失，出现了数据错位的现象。\n\n之后了解到，`ViewPager`的数据绑定和`RecyclerView`存在不同，`RecyclerView`在数据源变动之后会调用`onBindData`将数据源重新进行绑定，而`ViewPager`会根据`PagerAdapter`中的`getItemPosition`函数来决定是否刷新，默认的实现都是不刷新。\n\n```\n /**\n     * Called when the host view is attempting to determine if an item's position\n     * has changed. Returns {@link #POSITION_UNCHANGED} if the position of the given\n     * item has not changed or {@link #POSITION_NONE} if the item is no longer present\n     * in the adapter.\n     *\n     * <p>The default implementation assumes that items will never\n     * change position and always returns {@link #POSITION_UNCHANGED}.\n     *\n     * @param object Object representing an item, previously returned by a call to\n     *               {@link #instantiateItem(View, int)}.\n     * @return object's new position index from [0, {@link #getCount()}),\n     *         {@link #POSITION_UNCHANGED} if the object's position has not changed,\n     *         or {@link #POSITION_NONE} if the item is no longer present.\n     */\n    public int getItemPosition(@NonNull Object object) {\n        return POSITION_UNCHANGED;\n    }\n```\n\n此函数返回`POSITION_UNCHANGED`则不会进行数据刷新，而`POSITION_NONE`则会重新生成并绑定数据。对于数据源产生混乱的情况，通过控制该函数的返回值即可解决。\n\n最终的解决办法为通过设置`TAG`来判断当前数据源是否和Index匹配，不匹配则重新刷新，匹配则不用处理\n\n\n##### 参考文章\n\n> https://www.jianshu.com/p/266861496508","slug":"ViewPagerAdapter调用NotifyData后数据不刷新","published":1,"updated":"2020-07-03T02:40:48.120Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc5n2qh3000bw8r1p7eagb1n","content":"<p>线上存在一个关于PagerAdapter的少量崩溃，描述如下：</p>\n<blockquote>\n<p>The application’s PagerAdapter changed the adapter’s contents without calling PagerAdapter#notifyDataSetChanged!</p>\n</blockquote>\n<p>由于在使用<code>PagerAdapter</code>的过程中，使用的数据源是从外界传入的，数据源被改变之后未调用<code>notifyDataSetChanged</code>函数来刷新并通知<code>Adapter</code>，此时滑动<code>ViewPager</code>时候会产生上述崩溃。</p>\n<p>在<code>ViewPager</code>内部的<code>PagerObserver</code>中有如下代码，检测数据源的数量是否处于同步状态，并会抛出异常:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (N != mExpectedAdapterCount) &#123;</div><div class=\"line\">       String resName;</div><div class=\"line\">       try &#123;</div><div class=\"line\">           resName = getResources().getResourceName(getId());</div><div class=\"line\">       &#125; catch (Resources.NotFoundException e) &#123;</div><div class=\"line\">           resName = Integer.toHexString(getId());</div><div class=\"line\">       &#125;</div><div class=\"line\">       throw new IllegalStateException(&quot;The application&apos;s PagerAdapter changed the adapter&apos;s&quot;</div><div class=\"line\">               + &quot; contents without calling PagerAdapter#notifyDataSetChanged!&quot;</div><div class=\"line\">               + &quot; Expected adapter item count: &quot; + mExpectedAdapterCount + &quot;, found: &quot; + N</div><div class=\"line\">               + &quot; Pager id: &quot; + resName</div><div class=\"line\">               + &quot; Pager class: &quot; + getClass()</div><div class=\"line\">               + &quot; Problematic adapter: &quot; + mAdapter.getClass());</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>最初的解决办法是按照异常的提示，直接在修改了数据源的地方调用<code>notifyDataSetChanged()</code>函数，崩溃消失，出现了数据错位的现象。</p>\n<p>之后了解到，<code>ViewPager</code>的数据绑定和<code>RecyclerView</code>存在不同，<code>RecyclerView</code>在数据源变动之后会调用<code>onBindData</code>将数据源重新进行绑定，而<code>ViewPager</code>会根据<code>PagerAdapter</code>中的<code>getItemPosition</code>函数来决定是否刷新，默认的实现都是不刷新。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\">    * Called when the host view is attempting to determine if an item&apos;s position</div><div class=\"line\">    * has changed. Returns &#123;@link #POSITION_UNCHANGED&#125; if the position of the given</div><div class=\"line\">    * item has not changed or &#123;@link #POSITION_NONE&#125; if the item is no longer present</div><div class=\"line\">    * in the adapter.</div><div class=\"line\">    *</div><div class=\"line\">    * &lt;p&gt;The default implementation assumes that items will never</div><div class=\"line\">    * change position and always returns &#123;@link #POSITION_UNCHANGED&#125;.</div><div class=\"line\">    *</div><div class=\"line\">    * @param object Object representing an item, previously returned by a call to</div><div class=\"line\">    *               &#123;@link #instantiateItem(View, int)&#125;.</div><div class=\"line\">    * @return object&apos;s new position index from [0, &#123;@link #getCount()&#125;),</div><div class=\"line\">    *         &#123;@link #POSITION_UNCHANGED&#125; if the object&apos;s position has not changed,</div><div class=\"line\">    *         or &#123;@link #POSITION_NONE&#125; if the item is no longer present.</div><div class=\"line\">    */</div><div class=\"line\">   public int getItemPosition(@NonNull Object object) &#123;</div><div class=\"line\">       return POSITION_UNCHANGED;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>此函数返回<code>POSITION_UNCHANGED</code>则不会进行数据刷新，而<code>POSITION_NONE</code>则会重新生成并绑定数据。对于数据源产生混乱的情况，通过控制该函数的返回值即可解决。</p>\n<p>最终的解决办法为通过设置<code>TAG</code>来判断当前数据源是否和Index匹配，不匹配则重新刷新，匹配则不用处理</p>\n<h5 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h5><blockquote>\n<p><a href=\"https://www.jianshu.com/p/266861496508\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/266861496508</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>线上存在一个关于PagerAdapter的少量崩溃，描述如下：</p>\n<blockquote>\n<p>The application’s PagerAdapter changed the adapter’s contents without calling PagerAdapter#notifyDataSetChanged!</p>\n</blockquote>\n<p>由于在使用<code>PagerAdapter</code>的过程中，使用的数据源是从外界传入的，数据源被改变之后未调用<code>notifyDataSetChanged</code>函数来刷新并通知<code>Adapter</code>，此时滑动<code>ViewPager</code>时候会产生上述崩溃。</p>\n<p>在<code>ViewPager</code>内部的<code>PagerObserver</code>中有如下代码，检测数据源的数量是否处于同步状态，并会抛出异常:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (N != mExpectedAdapterCount) &#123;</div><div class=\"line\">       String resName;</div><div class=\"line\">       try &#123;</div><div class=\"line\">           resName = getResources().getResourceName(getId());</div><div class=\"line\">       &#125; catch (Resources.NotFoundException e) &#123;</div><div class=\"line\">           resName = Integer.toHexString(getId());</div><div class=\"line\">       &#125;</div><div class=\"line\">       throw new IllegalStateException(&quot;The application&apos;s PagerAdapter changed the adapter&apos;s&quot;</div><div class=\"line\">               + &quot; contents without calling PagerAdapter#notifyDataSetChanged!&quot;</div><div class=\"line\">               + &quot; Expected adapter item count: &quot; + mExpectedAdapterCount + &quot;, found: &quot; + N</div><div class=\"line\">               + &quot; Pager id: &quot; + resName</div><div class=\"line\">               + &quot; Pager class: &quot; + getClass()</div><div class=\"line\">               + &quot; Problematic adapter: &quot; + mAdapter.getClass());</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>最初的解决办法是按照异常的提示，直接在修改了数据源的地方调用<code>notifyDataSetChanged()</code>函数，崩溃消失，出现了数据错位的现象。</p>\n<p>之后了解到，<code>ViewPager</code>的数据绑定和<code>RecyclerView</code>存在不同，<code>RecyclerView</code>在数据源变动之后会调用<code>onBindData</code>将数据源重新进行绑定，而<code>ViewPager</code>会根据<code>PagerAdapter</code>中的<code>getItemPosition</code>函数来决定是否刷新，默认的实现都是不刷新。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\">    * Called when the host view is attempting to determine if an item&apos;s position</div><div class=\"line\">    * has changed. Returns &#123;@link #POSITION_UNCHANGED&#125; if the position of the given</div><div class=\"line\">    * item has not changed or &#123;@link #POSITION_NONE&#125; if the item is no longer present</div><div class=\"line\">    * in the adapter.</div><div class=\"line\">    *</div><div class=\"line\">    * &lt;p&gt;The default implementation assumes that items will never</div><div class=\"line\">    * change position and always returns &#123;@link #POSITION_UNCHANGED&#125;.</div><div class=\"line\">    *</div><div class=\"line\">    * @param object Object representing an item, previously returned by a call to</div><div class=\"line\">    *               &#123;@link #instantiateItem(View, int)&#125;.</div><div class=\"line\">    * @return object&apos;s new position index from [0, &#123;@link #getCount()&#125;),</div><div class=\"line\">    *         &#123;@link #POSITION_UNCHANGED&#125; if the object&apos;s position has not changed,</div><div class=\"line\">    *         or &#123;@link #POSITION_NONE&#125; if the item is no longer present.</div><div class=\"line\">    */</div><div class=\"line\">   public int getItemPosition(@NonNull Object object) &#123;</div><div class=\"line\">       return POSITION_UNCHANGED;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>此函数返回<code>POSITION_UNCHANGED</code>则不会进行数据刷新，而<code>POSITION_NONE</code>则会重新生成并绑定数据。对于数据源产生混乱的情况，通过控制该函数的返回值即可解决。</p>\n<p>最终的解决办法为通过设置<code>TAG</code>来判断当前数据源是否和Index匹配，不匹配则重新刷新，匹配则不用处理</p>\n<h5 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h5><blockquote>\n<p><a href=\"https://www.jianshu.com/p/266861496508\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/266861496508</a></p>\n</blockquote>\n"},{"title":"Volley框架解析(一)整体介绍","date":"2017-02-26T02:04:01.000Z","_content":"\n## Volley框架解析(一)整体介绍\n\n感谢各位菊苣，[grumoon](https://github.com/grumoon \"grumoon\"),[huxian99](https://github.com/huxian99 \"huxian99\"),[trinea](https://github.com/trinea \"trinea\"),[郭霖juju](http://blog.csdn.net/guolin_blog \"郭霖juju\")的图片素材，以及详细的分析。\n\n其他菊苣关于Volley解析的链接如下：\n\n[codeKK—Volley源码解析](http://www.codekk.com/open-source-project-analysis/detail/Android/grumoon/Volley%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90)\n\n[郭霖juju—Android Volley完全解析(一)，初识Volley的基本用法](http://blog.csdn.net/guolin_blog/article/details/17482095/ \"郭霖juju\")\n\n<!--more-->\n\n***\n\n### [](#u9898_u5916_u8BDD_28_u53EF_u76F4_u63A5_u8DF3_u8FC7orz \"题外话(可直接跳过orz\")题外话(可直接跳过orz\n\n在Android路上的第一个涉及到网络的项目中，就用到了Volley，当时也就照着网上的方法用了用，用到后面发现满足不了需求之后，尝试着去自定义了一些request，自己去结合Volley来处理服务器返回的cookie。第一个项目已经过去时间比较长了，突然想到想深入的了解下Volley,于是就开始了Volley源码之旅…..本人比较笨，需要比其他人花更多的时间来消化，没办法orz。看了比较长的一段时间后，把自己边看边写的笔记拿出来和大家分享。\n\n### [](#1-_Volley_u7B80_u4ECB \"1\\. Volley简介\")1\\. Volley简介\n\n#### [](#1-1_Volley_u662F_u4EC0_u4E48 \"1.1 Volley是什么\")1.1 Volley是什么\n\nVolley是Google推出的Android异步网络请求框架和图片加载的框架。适合数据量小的,通信频繁的各种请求,官方已经封装好了各种API,而且还提供了很灵活的自定义请求接口,不仅使用起来方便,可扩展性也很强.\n![volley](https://raw.githubusercontent.com/android-cn/android-open-project-analysis/master/tool-lib/network/volley/image/volley.png)\n\n可以通过下面的几种途径获取到volley的代码：\n\n```\ngit clone https://android.googlesource.com/platform/frameworks/volley  \n\njar包下载地址： http://www.kwstu.com/ResourcesView/kwstu_201441183330928 \n\n```\n\n#### [](#1-2__u6574_u4F53_u6846_u67B6 \"1.2 整体框架\")1.2 整体框架\n\n这是从上面提到的菊苣那里拿来的一张图，十分感谢Orz,这张图大致的分析出了Volley中Request从开始到结束需要经历的一个流程，在后面会详细的分析request每一步的动向，这里先简单的做个介绍。\n![design](https://raw.githubusercontent.com/android-cn/android-open-project-analysis/master/tool-lib/network/volley/image/design.png)\n\n**最开始用到Volley发送请求的时候需要通过如下的几行代码(注意给应用添加网络访问的权限)**\n\n```\n//先新建一个请求队列(RequestQueue)\nRequestQueue mQueue = Volley.newRequestQueue(context); \n\n//新建一个request\nStringRequest stringRequest = new StringRequest(\"http://www.xxxxxxx.com\",\n                    new Response.Listener<String>() {\n                        @Override\n                        public void onResponse(String response) {\n                            Log.d(\"TAG\", response);\n                        }\n                    }, new Response.ErrorListener() {\n                        @Override\n                        public void onErrorResponse(VolleyError error) {\n                            Log.e(\"TAG\", error.getMessage(), error);\n                        }\n                    });\n\n//将request加入到队列(RequestQueue)当中\nmQueue.add(stringRequest); \n\n```\n\n做完上面的这些工作,如果不出问题，等着request返回结果就可以了。结合上面的图片，mQueue(**RequestQueue**)被创建之后，会启动新的工作线程(**dispatcher**)开始工作，mQueue里面有专门用来存放request的容器，只要没被stop,这些工作线程会不停的从容器中取出request进行处理,工作线程大致分为两类：\n\n1.  处理有缓存存在的request的dispatcher。该工作线程会涉及到从之前存储的有效缓存(**cache**)中读取数据并返回给调用者。\n2.  处理网络请求的request的dispatcher。该工作线程会涉及到从网络(**network**)获取有效的数据，并返回合适数据给调用者，并会根据request的设置来决定是否将请求结果缓存到本地。\n\n    在工作线程得到了请求响应结果response之后，会将response交给**ResponseDelivery**来处理并通过回调传递给调用者。\n\n    通过上面的介绍，应该能大致的了解volley中，一个request创建并加入到RequestQueue之后大致的一个走向。\n\n#### [](#1-3__u57FA_u7840_u7C7B_u7684_u7B80_u4ECB \"1.3 基础类的简介\")1.3 基础类的简介\n\n在Volley中一共有43个类(不知道当前阅读的是否为最新版本的，不过核心类差不了很远）,主要介绍一下核心类以及其在Volley中起的作用，后面会对核心类的每行代码进行展开分析。\n\n**Volley.java:** 从上面的用法`Volley.newRequestQueue`就能看出，Volley类是对外的接口，里面仅有4个重载了的`newRequestQueue()`函数，用来以各种不同的方式创建并启动一个RequestQueue。\n\n**RequestQueue.java:** 外界通过Volley中的接口来创建其实例，RequestQueue的作用就是存放所有add进来的Request(所有的Request不仅会存放在`mCurrentRequests`里面，其原型是一个HashSet。而且Request还会被分类存放在`mCacheQueue`和`mNetworkQueue`中，分类的标准是是否涉及到网络数据的获取),并且里面会有两类调度器`mDispatchers`和`mCacheDispatcher`来负责处理Request。前者用来处理涉及到网络的Request，后者用来处理直接从缓存中获取数据的Request。它俩获得了数据之后都会交给`mDelivery`(ResponseDelivery.java的实例)来传递回caller。\n\n**Request.java:** 请求类的基类，所有请求类都从该类继承。里面包含了请求方法(POST,GET等)，用户可自定义符合需求的Request，自由度很大。\n\n**NetworkDispatcher.java:** 处理网络请求的调度器，继承自`Thread`类，其中包含了用于存储涉及网络请求的`mQueue`，以及用于网络请求的接口类`mNetwork`(Network.java实例)。在被停止之前进行死循环，调度器会不停的从`mQueue`中取出request来处理，将结果通过`mCache`(Cache.java实例)写入本地缓存中，通过`mDelivery`(ResponseDelivery.java实例)将结果回传给caller。\n\n**CacheDispatcher.java:** 处理缓存请求的调度器，继承自`Thread`类，包含了用于存储涉及缓存请求的队列`mCacheQueue`，和上面的网络调度器工作原理类似。只是从缓存中取出数据再通过`mDelivery`返回给caller。\n\n**ResponseDelivery.java:** 一个用于将Response传递给调用者的回调接口，包含了两类回调方法，`postResponse(Request<?> request, Response<?> response, Runnable runnable)`和`postError(Request<?> request, VolleyError error)`。\n\n**Network.java:** 用于网络请求调用的接口，包含一个方法`performRequest()`。\n\n**BasicNetwork.java:** 继承了Network类，是Volley中默认使用的网络请求处理工具类。在该类里面会处理Request发送前的一系列工作，以及发送工作和发送后返回NetworkResponse的解析工作。里面真正实现网络请求的发送工作是利用了其中的`mHttpStack`(HttpStack.java实例)。\n\n**HttpStack.java:** 网络请求接口类，包含一个方法`performRequest(Request<?> request, Map<String, String> additionalHeaders)`。该方法和BasicNetwork类中实现的方法`performRequest(Request<?> request)`不同。前者在后者的方法中被调用，来实现真正的网络请求。\n\n**HurlStack.java:** 实现了HttpStack接口，在android版本在2.3之上的系统中，通过HttpURLConnection类实现网络请求。\n\n**HttpClientStack.java:** 实现了HttpStack接口，在android版本在2.3之下的系统中，通过HttpClient类实现网络请求。\n\n**Cache.java:** 读写缓存类的接口类，抽象出了一系列有关缓存读写的方法。\n\n**DiskBasedCache.java:** 继承并实现了Cache中的一系列方法，是Volley中默认使用的缓存读写工具类。\n\n**Response.java:** Volley自定义的bean类，Request通过上面实现了HttpStack接口的两种实现方法发出之后，会返回相应的`NetworkResponse`类实例，这个类是`org.apache.http`包里面的类，`NetworkResponse`实例返回后，解析出有用的信息，并组成Response实例。\n\n上面简单的介绍了Volley中的核心类，再盗用一张图orz，再次感谢上面的菊苣们。![design](https://raw.githubusercontent.com/android-cn/android-open-project-analysis/master/tool-lib/network/volley/image/Volley-run-flow-chart.png)\n\n上图清晰的画出了，请求从加入到队列，怎么被分步骤处理，分缓存和网络两条路径，先查询是否存在请求对应的缓存，如存在有效缓存则直接取出缓存数据返回给调用者，如不存在有效缓存则从网络获取数据，写入缓存并返回将结果返回给调用者。\n\n对Volley整体上的简单介绍就先到这里了，后面会将阅读源码时候的笔记整理之后再和大家分享。","source":"_posts/Volley框架解析-一-整体介绍.md","raw":"---\ntitle: Volley框架解析(一)整体介绍\ndate: 2017-02-26 10:04:01\ntags: volley\n\n---\n\n## Volley框架解析(一)整体介绍\n\n感谢各位菊苣，[grumoon](https://github.com/grumoon \"grumoon\"),[huxian99](https://github.com/huxian99 \"huxian99\"),[trinea](https://github.com/trinea \"trinea\"),[郭霖juju](http://blog.csdn.net/guolin_blog \"郭霖juju\")的图片素材，以及详细的分析。\n\n其他菊苣关于Volley解析的链接如下：\n\n[codeKK—Volley源码解析](http://www.codekk.com/open-source-project-analysis/detail/Android/grumoon/Volley%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90)\n\n[郭霖juju—Android Volley完全解析(一)，初识Volley的基本用法](http://blog.csdn.net/guolin_blog/article/details/17482095/ \"郭霖juju\")\n\n<!--more-->\n\n***\n\n### [](#u9898_u5916_u8BDD_28_u53EF_u76F4_u63A5_u8DF3_u8FC7orz \"题外话(可直接跳过orz\")题外话(可直接跳过orz\n\n在Android路上的第一个涉及到网络的项目中，就用到了Volley，当时也就照着网上的方法用了用，用到后面发现满足不了需求之后，尝试着去自定义了一些request，自己去结合Volley来处理服务器返回的cookie。第一个项目已经过去时间比较长了，突然想到想深入的了解下Volley,于是就开始了Volley源码之旅…..本人比较笨，需要比其他人花更多的时间来消化，没办法orz。看了比较长的一段时间后，把自己边看边写的笔记拿出来和大家分享。\n\n### [](#1-_Volley_u7B80_u4ECB \"1\\. Volley简介\")1\\. Volley简介\n\n#### [](#1-1_Volley_u662F_u4EC0_u4E48 \"1.1 Volley是什么\")1.1 Volley是什么\n\nVolley是Google推出的Android异步网络请求框架和图片加载的框架。适合数据量小的,通信频繁的各种请求,官方已经封装好了各种API,而且还提供了很灵活的自定义请求接口,不仅使用起来方便,可扩展性也很强.\n![volley](https://raw.githubusercontent.com/android-cn/android-open-project-analysis/master/tool-lib/network/volley/image/volley.png)\n\n可以通过下面的几种途径获取到volley的代码：\n\n```\ngit clone https://android.googlesource.com/platform/frameworks/volley  \n\njar包下载地址： http://www.kwstu.com/ResourcesView/kwstu_201441183330928 \n\n```\n\n#### [](#1-2__u6574_u4F53_u6846_u67B6 \"1.2 整体框架\")1.2 整体框架\n\n这是从上面提到的菊苣那里拿来的一张图，十分感谢Orz,这张图大致的分析出了Volley中Request从开始到结束需要经历的一个流程，在后面会详细的分析request每一步的动向，这里先简单的做个介绍。\n![design](https://raw.githubusercontent.com/android-cn/android-open-project-analysis/master/tool-lib/network/volley/image/design.png)\n\n**最开始用到Volley发送请求的时候需要通过如下的几行代码(注意给应用添加网络访问的权限)**\n\n```\n//先新建一个请求队列(RequestQueue)\nRequestQueue mQueue = Volley.newRequestQueue(context); \n\n//新建一个request\nStringRequest stringRequest = new StringRequest(\"http://www.xxxxxxx.com\",\n                    new Response.Listener<String>() {\n                        @Override\n                        public void onResponse(String response) {\n                            Log.d(\"TAG\", response);\n                        }\n                    }, new Response.ErrorListener() {\n                        @Override\n                        public void onErrorResponse(VolleyError error) {\n                            Log.e(\"TAG\", error.getMessage(), error);\n                        }\n                    });\n\n//将request加入到队列(RequestQueue)当中\nmQueue.add(stringRequest); \n\n```\n\n做完上面的这些工作,如果不出问题，等着request返回结果就可以了。结合上面的图片，mQueue(**RequestQueue**)被创建之后，会启动新的工作线程(**dispatcher**)开始工作，mQueue里面有专门用来存放request的容器，只要没被stop,这些工作线程会不停的从容器中取出request进行处理,工作线程大致分为两类：\n\n1.  处理有缓存存在的request的dispatcher。该工作线程会涉及到从之前存储的有效缓存(**cache**)中读取数据并返回给调用者。\n2.  处理网络请求的request的dispatcher。该工作线程会涉及到从网络(**network**)获取有效的数据，并返回合适数据给调用者，并会根据request的设置来决定是否将请求结果缓存到本地。\n\n    在工作线程得到了请求响应结果response之后，会将response交给**ResponseDelivery**来处理并通过回调传递给调用者。\n\n    通过上面的介绍，应该能大致的了解volley中，一个request创建并加入到RequestQueue之后大致的一个走向。\n\n#### [](#1-3__u57FA_u7840_u7C7B_u7684_u7B80_u4ECB \"1.3 基础类的简介\")1.3 基础类的简介\n\n在Volley中一共有43个类(不知道当前阅读的是否为最新版本的，不过核心类差不了很远）,主要介绍一下核心类以及其在Volley中起的作用，后面会对核心类的每行代码进行展开分析。\n\n**Volley.java:** 从上面的用法`Volley.newRequestQueue`就能看出，Volley类是对外的接口，里面仅有4个重载了的`newRequestQueue()`函数，用来以各种不同的方式创建并启动一个RequestQueue。\n\n**RequestQueue.java:** 外界通过Volley中的接口来创建其实例，RequestQueue的作用就是存放所有add进来的Request(所有的Request不仅会存放在`mCurrentRequests`里面，其原型是一个HashSet。而且Request还会被分类存放在`mCacheQueue`和`mNetworkQueue`中，分类的标准是是否涉及到网络数据的获取),并且里面会有两类调度器`mDispatchers`和`mCacheDispatcher`来负责处理Request。前者用来处理涉及到网络的Request，后者用来处理直接从缓存中获取数据的Request。它俩获得了数据之后都会交给`mDelivery`(ResponseDelivery.java的实例)来传递回caller。\n\n**Request.java:** 请求类的基类，所有请求类都从该类继承。里面包含了请求方法(POST,GET等)，用户可自定义符合需求的Request，自由度很大。\n\n**NetworkDispatcher.java:** 处理网络请求的调度器，继承自`Thread`类，其中包含了用于存储涉及网络请求的`mQueue`，以及用于网络请求的接口类`mNetwork`(Network.java实例)。在被停止之前进行死循环，调度器会不停的从`mQueue`中取出request来处理，将结果通过`mCache`(Cache.java实例)写入本地缓存中，通过`mDelivery`(ResponseDelivery.java实例)将结果回传给caller。\n\n**CacheDispatcher.java:** 处理缓存请求的调度器，继承自`Thread`类，包含了用于存储涉及缓存请求的队列`mCacheQueue`，和上面的网络调度器工作原理类似。只是从缓存中取出数据再通过`mDelivery`返回给caller。\n\n**ResponseDelivery.java:** 一个用于将Response传递给调用者的回调接口，包含了两类回调方法，`postResponse(Request<?> request, Response<?> response, Runnable runnable)`和`postError(Request<?> request, VolleyError error)`。\n\n**Network.java:** 用于网络请求调用的接口，包含一个方法`performRequest()`。\n\n**BasicNetwork.java:** 继承了Network类，是Volley中默认使用的网络请求处理工具类。在该类里面会处理Request发送前的一系列工作，以及发送工作和发送后返回NetworkResponse的解析工作。里面真正实现网络请求的发送工作是利用了其中的`mHttpStack`(HttpStack.java实例)。\n\n**HttpStack.java:** 网络请求接口类，包含一个方法`performRequest(Request<?> request, Map<String, String> additionalHeaders)`。该方法和BasicNetwork类中实现的方法`performRequest(Request<?> request)`不同。前者在后者的方法中被调用，来实现真正的网络请求。\n\n**HurlStack.java:** 实现了HttpStack接口，在android版本在2.3之上的系统中，通过HttpURLConnection类实现网络请求。\n\n**HttpClientStack.java:** 实现了HttpStack接口，在android版本在2.3之下的系统中，通过HttpClient类实现网络请求。\n\n**Cache.java:** 读写缓存类的接口类，抽象出了一系列有关缓存读写的方法。\n\n**DiskBasedCache.java:** 继承并实现了Cache中的一系列方法，是Volley中默认使用的缓存读写工具类。\n\n**Response.java:** Volley自定义的bean类，Request通过上面实现了HttpStack接口的两种实现方法发出之后，会返回相应的`NetworkResponse`类实例，这个类是`org.apache.http`包里面的类，`NetworkResponse`实例返回后，解析出有用的信息，并组成Response实例。\n\n上面简单的介绍了Volley中的核心类，再盗用一张图orz，再次感谢上面的菊苣们。![design](https://raw.githubusercontent.com/android-cn/android-open-project-analysis/master/tool-lib/network/volley/image/Volley-run-flow-chart.png)\n\n上图清晰的画出了，请求从加入到队列，怎么被分步骤处理，分缓存和网络两条路径，先查询是否存在请求对应的缓存，如存在有效缓存则直接取出缓存数据返回给调用者，如不存在有效缓存则从网络获取数据，写入缓存并返回将结果返回给调用者。\n\n对Volley整体上的简单介绍就先到这里了，后面会将阅读源码时候的笔记整理之后再和大家分享。","slug":"Volley框架解析-一-整体介绍","published":1,"updated":"2020-07-03T02:40:48.120Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc5n2qh4000ew8r1n0mgp1om","content":"<h2 id=\"Volley框架解析-一-整体介绍\"><a href=\"#Volley框架解析-一-整体介绍\" class=\"headerlink\" title=\"Volley框架解析(一)整体介绍\"></a>Volley框架解析(一)整体介绍</h2><p>感谢各位菊苣，<a href=\"https://github.com/grumoon\" title=\"grumoon\" target=\"_blank\" rel=\"noopener\">grumoon</a>,<a href=\"https://github.com/huxian99\" title=\"huxian99\" target=\"_blank\" rel=\"noopener\">huxian99</a>,<a href=\"https://github.com/trinea\" title=\"trinea\" target=\"_blank\" rel=\"noopener\">trinea</a>,<a href=\"http://blog.csdn.net/guolin_blog\" title=\"郭霖juju\" target=\"_blank\" rel=\"noopener\">郭霖juju</a>的图片素材，以及详细的分析。</p>\n<p>其他菊苣关于Volley解析的链接如下：</p>\n<p><a href=\"http://www.codekk.com/open-source-project-analysis/detail/Android/grumoon/Volley%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90\" target=\"_blank\" rel=\"noopener\">codeKK—Volley源码解析</a></p>\n<p><a href=\"http://blog.csdn.net/guolin_blog/article/details/17482095/\" title=\"郭霖juju\" target=\"_blank\" rel=\"noopener\">郭霖juju—Android Volley完全解析(一)，初识Volley的基本用法</a></p>\n<a id=\"more\"></a>\n<hr>\n<h3 id=\"题外话-可直接跳过orz\"><a href=\"#题外话-可直接跳过orz\" class=\"headerlink\" title=\"题外话(可直接跳过orz\"></a><a href=\"#u9898_u5916_u8BDD_28_u53EF_u76F4_u63A5_u8DF3_u8FC7orz\" title=\"题外话(可直接跳过orz\"></a>题外话(可直接跳过orz</h3><p>在Android路上的第一个涉及到网络的项目中，就用到了Volley，当时也就照着网上的方法用了用，用到后面发现满足不了需求之后，尝试着去自定义了一些request，自己去结合Volley来处理服务器返回的cookie。第一个项目已经过去时间比较长了，突然想到想深入的了解下Volley,于是就开始了Volley源码之旅…..本人比较笨，需要比其他人花更多的时间来消化，没办法orz。看了比较长的一段时间后，把自己边看边写的笔记拿出来和大家分享。</p>\n<h3 id=\"1-Volley简介\"><a href=\"#1-Volley简介\" class=\"headerlink\" title=\"1. Volley简介\"></a><a href=\"#1-_Volley_u7B80_u4ECB\" title=\"1\\. Volley简介\"></a>1. Volley简介</h3><h4 id=\"1-1-Volley是什么\"><a href=\"#1-1-Volley是什么\" class=\"headerlink\" title=\"1.1 Volley是什么\"></a><a href=\"#1-1_Volley_u662F_u4EC0_u4E48\" title=\"1.1 Volley是什么\"></a>1.1 Volley是什么</h4><p>Volley是Google推出的Android异步网络请求框架和图片加载的框架。适合数据量小的,通信频繁的各种请求,官方已经封装好了各种API,而且还提供了很灵活的自定义请求接口,不仅使用起来方便,可扩展性也很强.<br><img src=\"https://raw.githubusercontent.com/android-cn/android-open-project-analysis/master/tool-lib/network/volley/image/volley.png\" alt=\"volley\"></p>\n<p>可以通过下面的几种途径获取到volley的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">git clone https://android.googlesource.com/platform/frameworks/volley  </div><div class=\"line\"></div><div class=\"line\">jar包下载地址： http://www.kwstu.com/ResourcesView/kwstu_201441183330928</div></pre></td></tr></table></figure>\n<h4 id=\"1-2-整体框架\"><a href=\"#1-2-整体框架\" class=\"headerlink\" title=\"1.2 整体框架\"></a><a href=\"#1-2__u6574_u4F53_u6846_u67B6\" title=\"1.2 整体框架\"></a>1.2 整体框架</h4><p>这是从上面提到的菊苣那里拿来的一张图，十分感谢Orz,这张图大致的分析出了Volley中Request从开始到结束需要经历的一个流程，在后面会详细的分析request每一步的动向，这里先简单的做个介绍。<br><img src=\"https://raw.githubusercontent.com/android-cn/android-open-project-analysis/master/tool-lib/network/volley/image/design.png\" alt=\"design\"></p>\n<p><strong>最开始用到Volley发送请求的时候需要通过如下的几行代码(注意给应用添加网络访问的权限)</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">//先新建一个请求队列(RequestQueue)</div><div class=\"line\">RequestQueue mQueue = Volley.newRequestQueue(context); </div><div class=\"line\"></div><div class=\"line\">//新建一个request</div><div class=\"line\">StringRequest stringRequest = new StringRequest(&quot;http://www.xxxxxxx.com&quot;,</div><div class=\"line\">                    new Response.Listener&lt;String&gt;() &#123;</div><div class=\"line\">                        @Override</div><div class=\"line\">                        public void onResponse(String response) &#123;</div><div class=\"line\">                            Log.d(&quot;TAG&quot;, response);</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;, new Response.ErrorListener() &#123;</div><div class=\"line\">                        @Override</div><div class=\"line\">                        public void onErrorResponse(VolleyError error) &#123;</div><div class=\"line\">                            Log.e(&quot;TAG&quot;, error.getMessage(), error);</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;);</div><div class=\"line\"></div><div class=\"line\">//将request加入到队列(RequestQueue)当中</div><div class=\"line\">mQueue.add(stringRequest);</div></pre></td></tr></table></figure>\n<p>做完上面的这些工作,如果不出问题，等着request返回结果就可以了。结合上面的图片，mQueue(<strong>RequestQueue</strong>)被创建之后，会启动新的工作线程(<strong>dispatcher</strong>)开始工作，mQueue里面有专门用来存放request的容器，只要没被stop,这些工作线程会不停的从容器中取出request进行处理,工作线程大致分为两类：</p>\n<ol>\n<li>处理有缓存存在的request的dispatcher。该工作线程会涉及到从之前存储的有效缓存(<strong>cache</strong>)中读取数据并返回给调用者。</li>\n<li><p>处理网络请求的request的dispatcher。该工作线程会涉及到从网络(<strong>network</strong>)获取有效的数据，并返回合适数据给调用者，并会根据request的设置来决定是否将请求结果缓存到本地。</p>\n<p>在工作线程得到了请求响应结果response之后，会将response交给<strong>ResponseDelivery</strong>来处理并通过回调传递给调用者。</p>\n<p>通过上面的介绍，应该能大致的了解volley中，一个request创建并加入到RequestQueue之后大致的一个走向。</p>\n</li>\n</ol>\n<h4 id=\"1-3-基础类的简介\"><a href=\"#1-3-基础类的简介\" class=\"headerlink\" title=\"1.3 基础类的简介\"></a><a href=\"#1-3__u57FA_u7840_u7C7B_u7684_u7B80_u4ECB\" title=\"1.3 基础类的简介\"></a>1.3 基础类的简介</h4><p>在Volley中一共有43个类(不知道当前阅读的是否为最新版本的，不过核心类差不了很远）,主要介绍一下核心类以及其在Volley中起的作用，后面会对核心类的每行代码进行展开分析。</p>\n<p><strong>Volley.java:</strong> 从上面的用法<code>Volley.newRequestQueue</code>就能看出，Volley类是对外的接口，里面仅有4个重载了的<code>newRequestQueue()</code>函数，用来以各种不同的方式创建并启动一个RequestQueue。</p>\n<p><strong>RequestQueue.java:</strong> 外界通过Volley中的接口来创建其实例，RequestQueue的作用就是存放所有add进来的Request(所有的Request不仅会存放在<code>mCurrentRequests</code>里面，其原型是一个HashSet。而且Request还会被分类存放在<code>mCacheQueue</code>和<code>mNetworkQueue</code>中，分类的标准是是否涉及到网络数据的获取),并且里面会有两类调度器<code>mDispatchers</code>和<code>mCacheDispatcher</code>来负责处理Request。前者用来处理涉及到网络的Request，后者用来处理直接从缓存中获取数据的Request。它俩获得了数据之后都会交给<code>mDelivery</code>(ResponseDelivery.java的实例)来传递回caller。</p>\n<p><strong>Request.java:</strong> 请求类的基类，所有请求类都从该类继承。里面包含了请求方法(POST,GET等)，用户可自定义符合需求的Request，自由度很大。</p>\n<p><strong>NetworkDispatcher.java:</strong> 处理网络请求的调度器，继承自<code>Thread</code>类，其中包含了用于存储涉及网络请求的<code>mQueue</code>，以及用于网络请求的接口类<code>mNetwork</code>(Network.java实例)。在被停止之前进行死循环，调度器会不停的从<code>mQueue</code>中取出request来处理，将结果通过<code>mCache</code>(Cache.java实例)写入本地缓存中，通过<code>mDelivery</code>(ResponseDelivery.java实例)将结果回传给caller。</p>\n<p><strong>CacheDispatcher.java:</strong> 处理缓存请求的调度器，继承自<code>Thread</code>类，包含了用于存储涉及缓存请求的队列<code>mCacheQueue</code>，和上面的网络调度器工作原理类似。只是从缓存中取出数据再通过<code>mDelivery</code>返回给caller。</p>\n<p><strong>ResponseDelivery.java:</strong> 一个用于将Response传递给调用者的回调接口，包含了两类回调方法，<code>postResponse(Request&lt;?&gt; request, Response&lt;?&gt; response, Runnable runnable)</code>和<code>postError(Request&lt;?&gt; request, VolleyError error)</code>。</p>\n<p><strong>Network.java:</strong> 用于网络请求调用的接口，包含一个方法<code>performRequest()</code>。</p>\n<p><strong>BasicNetwork.java:</strong> 继承了Network类，是Volley中默认使用的网络请求处理工具类。在该类里面会处理Request发送前的一系列工作，以及发送工作和发送后返回NetworkResponse的解析工作。里面真正实现网络请求的发送工作是利用了其中的<code>mHttpStack</code>(HttpStack.java实例)。</p>\n<p><strong>HttpStack.java:</strong> 网络请求接口类，包含一个方法<code>performRequest(Request&lt;?&gt; request, Map&lt;String, String&gt; additionalHeaders)</code>。该方法和BasicNetwork类中实现的方法<code>performRequest(Request&lt;?&gt; request)</code>不同。前者在后者的方法中被调用，来实现真正的网络请求。</p>\n<p><strong>HurlStack.java:</strong> 实现了HttpStack接口，在android版本在2.3之上的系统中，通过HttpURLConnection类实现网络请求。</p>\n<p><strong>HttpClientStack.java:</strong> 实现了HttpStack接口，在android版本在2.3之下的系统中，通过HttpClient类实现网络请求。</p>\n<p><strong>Cache.java:</strong> 读写缓存类的接口类，抽象出了一系列有关缓存读写的方法。</p>\n<p><strong>DiskBasedCache.java:</strong> 继承并实现了Cache中的一系列方法，是Volley中默认使用的缓存读写工具类。</p>\n<p><strong>Response.java:</strong> Volley自定义的bean类，Request通过上面实现了HttpStack接口的两种实现方法发出之后，会返回相应的<code>NetworkResponse</code>类实例，这个类是<code>org.apache.http</code>包里面的类，<code>NetworkResponse</code>实例返回后，解析出有用的信息，并组成Response实例。</p>\n<p>上面简单的介绍了Volley中的核心类，再盗用一张图orz，再次感谢上面的菊苣们。<img src=\"https://raw.githubusercontent.com/android-cn/android-open-project-analysis/master/tool-lib/network/volley/image/Volley-run-flow-chart.png\" alt=\"design\"></p>\n<p>上图清晰的画出了，请求从加入到队列，怎么被分步骤处理，分缓存和网络两条路径，先查询是否存在请求对应的缓存，如存在有效缓存则直接取出缓存数据返回给调用者，如不存在有效缓存则从网络获取数据，写入缓存并返回将结果返回给调用者。</p>\n<p>对Volley整体上的简单介绍就先到这里了，后面会将阅读源码时候的笔记整理之后再和大家分享。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"Volley框架解析-一-整体介绍\"><a href=\"#Volley框架解析-一-整体介绍\" class=\"headerlink\" title=\"Volley框架解析(一)整体介绍\"></a>Volley框架解析(一)整体介绍</h2><p>感谢各位菊苣，<a href=\"https://github.com/grumoon\" title=\"grumoon\" target=\"_blank\" rel=\"noopener\">grumoon</a>,<a href=\"https://github.com/huxian99\" title=\"huxian99\" target=\"_blank\" rel=\"noopener\">huxian99</a>,<a href=\"https://github.com/trinea\" title=\"trinea\" target=\"_blank\" rel=\"noopener\">trinea</a>,<a href=\"http://blog.csdn.net/guolin_blog\" title=\"郭霖juju\" target=\"_blank\" rel=\"noopener\">郭霖juju</a>的图片素材，以及详细的分析。</p>\n<p>其他菊苣关于Volley解析的链接如下：</p>\n<p><a href=\"http://www.codekk.com/open-source-project-analysis/detail/Android/grumoon/Volley%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90\" target=\"_blank\" rel=\"noopener\">codeKK—Volley源码解析</a></p>\n<p><a href=\"http://blog.csdn.net/guolin_blog/article/details/17482095/\" title=\"郭霖juju\" target=\"_blank\" rel=\"noopener\">郭霖juju—Android Volley完全解析(一)，初识Volley的基本用法</a></p>","more":"<hr>\n<h3 id=\"题外话-可直接跳过orz\"><a href=\"#题外话-可直接跳过orz\" class=\"headerlink\" title=\"题外话(可直接跳过orz\"></a><a href=\"#u9898_u5916_u8BDD_28_u53EF_u76F4_u63A5_u8DF3_u8FC7orz\" title=\"题外话(可直接跳过orz\"></a>题外话(可直接跳过orz</h3><p>在Android路上的第一个涉及到网络的项目中，就用到了Volley，当时也就照着网上的方法用了用，用到后面发现满足不了需求之后，尝试着去自定义了一些request，自己去结合Volley来处理服务器返回的cookie。第一个项目已经过去时间比较长了，突然想到想深入的了解下Volley,于是就开始了Volley源码之旅…..本人比较笨，需要比其他人花更多的时间来消化，没办法orz。看了比较长的一段时间后，把自己边看边写的笔记拿出来和大家分享。</p>\n<h3 id=\"1-Volley简介\"><a href=\"#1-Volley简介\" class=\"headerlink\" title=\"1. Volley简介\"></a><a href=\"#1-_Volley_u7B80_u4ECB\" title=\"1\\. Volley简介\"></a>1. Volley简介</h3><h4 id=\"1-1-Volley是什么\"><a href=\"#1-1-Volley是什么\" class=\"headerlink\" title=\"1.1 Volley是什么\"></a><a href=\"#1-1_Volley_u662F_u4EC0_u4E48\" title=\"1.1 Volley是什么\"></a>1.1 Volley是什么</h4><p>Volley是Google推出的Android异步网络请求框架和图片加载的框架。适合数据量小的,通信频繁的各种请求,官方已经封装好了各种API,而且还提供了很灵活的自定义请求接口,不仅使用起来方便,可扩展性也很强.<br><img src=\"https://raw.githubusercontent.com/android-cn/android-open-project-analysis/master/tool-lib/network/volley/image/volley.png\" alt=\"volley\"></p>\n<p>可以通过下面的几种途径获取到volley的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">git clone https://android.googlesource.com/platform/frameworks/volley  </div><div class=\"line\"></div><div class=\"line\">jar包下载地址： http://www.kwstu.com/ResourcesView/kwstu_201441183330928</div></pre></td></tr></table></figure>\n<h4 id=\"1-2-整体框架\"><a href=\"#1-2-整体框架\" class=\"headerlink\" title=\"1.2 整体框架\"></a><a href=\"#1-2__u6574_u4F53_u6846_u67B6\" title=\"1.2 整体框架\"></a>1.2 整体框架</h4><p>这是从上面提到的菊苣那里拿来的一张图，十分感谢Orz,这张图大致的分析出了Volley中Request从开始到结束需要经历的一个流程，在后面会详细的分析request每一步的动向，这里先简单的做个介绍。<br><img src=\"https://raw.githubusercontent.com/android-cn/android-open-project-analysis/master/tool-lib/network/volley/image/design.png\" alt=\"design\"></p>\n<p><strong>最开始用到Volley发送请求的时候需要通过如下的几行代码(注意给应用添加网络访问的权限)</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">//先新建一个请求队列(RequestQueue)</div><div class=\"line\">RequestQueue mQueue = Volley.newRequestQueue(context); </div><div class=\"line\"></div><div class=\"line\">//新建一个request</div><div class=\"line\">StringRequest stringRequest = new StringRequest(&quot;http://www.xxxxxxx.com&quot;,</div><div class=\"line\">                    new Response.Listener&lt;String&gt;() &#123;</div><div class=\"line\">                        @Override</div><div class=\"line\">                        public void onResponse(String response) &#123;</div><div class=\"line\">                            Log.d(&quot;TAG&quot;, response);</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;, new Response.ErrorListener() &#123;</div><div class=\"line\">                        @Override</div><div class=\"line\">                        public void onErrorResponse(VolleyError error) &#123;</div><div class=\"line\">                            Log.e(&quot;TAG&quot;, error.getMessage(), error);</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;);</div><div class=\"line\"></div><div class=\"line\">//将request加入到队列(RequestQueue)当中</div><div class=\"line\">mQueue.add(stringRequest);</div></pre></td></tr></table></figure>\n<p>做完上面的这些工作,如果不出问题，等着request返回结果就可以了。结合上面的图片，mQueue(<strong>RequestQueue</strong>)被创建之后，会启动新的工作线程(<strong>dispatcher</strong>)开始工作，mQueue里面有专门用来存放request的容器，只要没被stop,这些工作线程会不停的从容器中取出request进行处理,工作线程大致分为两类：</p>\n<ol>\n<li>处理有缓存存在的request的dispatcher。该工作线程会涉及到从之前存储的有效缓存(<strong>cache</strong>)中读取数据并返回给调用者。</li>\n<li><p>处理网络请求的request的dispatcher。该工作线程会涉及到从网络(<strong>network</strong>)获取有效的数据，并返回合适数据给调用者，并会根据request的设置来决定是否将请求结果缓存到本地。</p>\n<p>在工作线程得到了请求响应结果response之后，会将response交给<strong>ResponseDelivery</strong>来处理并通过回调传递给调用者。</p>\n<p>通过上面的介绍，应该能大致的了解volley中，一个request创建并加入到RequestQueue之后大致的一个走向。</p>\n</li>\n</ol>\n<h4 id=\"1-3-基础类的简介\"><a href=\"#1-3-基础类的简介\" class=\"headerlink\" title=\"1.3 基础类的简介\"></a><a href=\"#1-3__u57FA_u7840_u7C7B_u7684_u7B80_u4ECB\" title=\"1.3 基础类的简介\"></a>1.3 基础类的简介</h4><p>在Volley中一共有43个类(不知道当前阅读的是否为最新版本的，不过核心类差不了很远）,主要介绍一下核心类以及其在Volley中起的作用，后面会对核心类的每行代码进行展开分析。</p>\n<p><strong>Volley.java:</strong> 从上面的用法<code>Volley.newRequestQueue</code>就能看出，Volley类是对外的接口，里面仅有4个重载了的<code>newRequestQueue()</code>函数，用来以各种不同的方式创建并启动一个RequestQueue。</p>\n<p><strong>RequestQueue.java:</strong> 外界通过Volley中的接口来创建其实例，RequestQueue的作用就是存放所有add进来的Request(所有的Request不仅会存放在<code>mCurrentRequests</code>里面，其原型是一个HashSet。而且Request还会被分类存放在<code>mCacheQueue</code>和<code>mNetworkQueue</code>中，分类的标准是是否涉及到网络数据的获取),并且里面会有两类调度器<code>mDispatchers</code>和<code>mCacheDispatcher</code>来负责处理Request。前者用来处理涉及到网络的Request，后者用来处理直接从缓存中获取数据的Request。它俩获得了数据之后都会交给<code>mDelivery</code>(ResponseDelivery.java的实例)来传递回caller。</p>\n<p><strong>Request.java:</strong> 请求类的基类，所有请求类都从该类继承。里面包含了请求方法(POST,GET等)，用户可自定义符合需求的Request，自由度很大。</p>\n<p><strong>NetworkDispatcher.java:</strong> 处理网络请求的调度器，继承自<code>Thread</code>类，其中包含了用于存储涉及网络请求的<code>mQueue</code>，以及用于网络请求的接口类<code>mNetwork</code>(Network.java实例)。在被停止之前进行死循环，调度器会不停的从<code>mQueue</code>中取出request来处理，将结果通过<code>mCache</code>(Cache.java实例)写入本地缓存中，通过<code>mDelivery</code>(ResponseDelivery.java实例)将结果回传给caller。</p>\n<p><strong>CacheDispatcher.java:</strong> 处理缓存请求的调度器，继承自<code>Thread</code>类，包含了用于存储涉及缓存请求的队列<code>mCacheQueue</code>，和上面的网络调度器工作原理类似。只是从缓存中取出数据再通过<code>mDelivery</code>返回给caller。</p>\n<p><strong>ResponseDelivery.java:</strong> 一个用于将Response传递给调用者的回调接口，包含了两类回调方法，<code>postResponse(Request&lt;?&gt; request, Response&lt;?&gt; response, Runnable runnable)</code>和<code>postError(Request&lt;?&gt; request, VolleyError error)</code>。</p>\n<p><strong>Network.java:</strong> 用于网络请求调用的接口，包含一个方法<code>performRequest()</code>。</p>\n<p><strong>BasicNetwork.java:</strong> 继承了Network类，是Volley中默认使用的网络请求处理工具类。在该类里面会处理Request发送前的一系列工作，以及发送工作和发送后返回NetworkResponse的解析工作。里面真正实现网络请求的发送工作是利用了其中的<code>mHttpStack</code>(HttpStack.java实例)。</p>\n<p><strong>HttpStack.java:</strong> 网络请求接口类，包含一个方法<code>performRequest(Request&lt;?&gt; request, Map&lt;String, String&gt; additionalHeaders)</code>。该方法和BasicNetwork类中实现的方法<code>performRequest(Request&lt;?&gt; request)</code>不同。前者在后者的方法中被调用，来实现真正的网络请求。</p>\n<p><strong>HurlStack.java:</strong> 实现了HttpStack接口，在android版本在2.3之上的系统中，通过HttpURLConnection类实现网络请求。</p>\n<p><strong>HttpClientStack.java:</strong> 实现了HttpStack接口，在android版本在2.3之下的系统中，通过HttpClient类实现网络请求。</p>\n<p><strong>Cache.java:</strong> 读写缓存类的接口类，抽象出了一系列有关缓存读写的方法。</p>\n<p><strong>DiskBasedCache.java:</strong> 继承并实现了Cache中的一系列方法，是Volley中默认使用的缓存读写工具类。</p>\n<p><strong>Response.java:</strong> Volley自定义的bean类，Request通过上面实现了HttpStack接口的两种实现方法发出之后，会返回相应的<code>NetworkResponse</code>类实例，这个类是<code>org.apache.http</code>包里面的类，<code>NetworkResponse</code>实例返回后，解析出有用的信息，并组成Response实例。</p>\n<p>上面简单的介绍了Volley中的核心类，再盗用一张图orz，再次感谢上面的菊苣们。<img src=\"https://raw.githubusercontent.com/android-cn/android-open-project-analysis/master/tool-lib/network/volley/image/Volley-run-flow-chart.png\" alt=\"design\"></p>\n<p>上图清晰的画出了，请求从加入到队列，怎么被分步骤处理，分缓存和网络两条路径，先查询是否存在请求对应的缓存，如存在有效缓存则直接取出缓存数据返回给调用者，如不存在有效缓存则从网络获取数据，写入缓存并返回将结果返回给调用者。</p>\n<p>对Volley整体上的简单介绍就先到这里了，后面会将阅读源码时候的笔记整理之后再和大家分享。</p>"},{"title":"Volley框架解析-七-Request解析","date":"2017-04-24T14:13:25.000Z","_content":"\n# Volley框架解析(七)-----Request解析\n\n### 1. 前言\n\n了解了request队列的调度程序，request结果的处理方式，以及request请求出错的处理方式，对请求结果进行缓存方面的工作等等。这篇博客就是专门分析`Request`了。\n\n### 2. Request.java\n\nVolley封装的一个抽象类，Request.java提供了很大的便利性，可供我们自定义Request,之前在使用Volley的时候自定义了一些reuqest的，也总结过自定义request的方法，在这篇博客中有提到[Volley使用技巧—–自定义Request](http://blog.csdn.net/jing_unique_da/article/details/45101331 \"Volley使用技巧-----自定义Request\")。下面就开始分析`Request.java`的源码。\n\n<!--more-->\n\n```\n/**\n * Base class for all network requests.\n * 在volley中涉及到的所有request的基础类\n *\n * @param <T> The type of parsed response this request expects.\n * 泛型类T是请求端希望服务器能返回的数据类型\n *\n * 关于其实现的一个Comparable接口，从字面上来看就是\"可比较的\"\n * 官方的解释如下：\n * This interface should be implemented by all classes that wish to define \n * a natural order of their instances. sort(List) and java.util.Arrays#sort \n * can then be used to automatically sort lists of classes that implement this interface.\n * 意思就是说如果你希望你的类在一个list中能够使用sort等函数自动排序的话，就实现这个接口吧= =\n * (需要重写里面的方法compareTo(), 里面是比较了两个request的优先级)\n */\npublic abstract class Request<T> implements Comparable<Request<T>> {\n\n    /**\n     * Default encoding for POST or PUT parameters. See {@link #getParamsEncoding()}.\n     * POST或者是PUT请求参数的默认编码格式 \"UTF-8\"\n     */\n    private static final String DEFAULT_PARAMS_ENCODING = \"UTF-8\";\n\n    /**\n     * Supported request methods.\n     * 支持的请求方式，有各种,常用的GET, POST, PUT应该是比较熟悉\n     */\n    public interface Method {\n        int DEPRECATED_GET_OR_POST = -1;\n        int GET = 0;\n        int POST = 1;\n        int PUT = 2;\n        int DELETE = 3;\n        int HEAD = 4;\n        int OPTIONS = 5;\n        int TRACE = 6;\n        int PATCH = 7;\n    }\n\n    /**\n     * An event log tracing the lifetime of this request; for debugging. \n     * 为了debug方便，volley弄了一套VolleyLog\n     * 在一个request整个生命周期内不停的打出log\n     * 都可以方便从log监控该request现在的情况\n     */\n    private final MarkerLog mEventLog = MarkerLog.ENABLED ? new MarkerLog() : null;\n\n    /**\n     * Request method of this request.  Currently supports GET, POST, PUT, DELETE, HEAD, OPTIONS,\n     * TRACE, and PATCH.\n     * 当前request涉及到的请求方式\n     * 目前所支持的有GET, POST, PUT等\n     */\n    private final int mMethod;\n\n    /** \n     * URL of this request.\n     * 原始Url\n     */\n    private final String mUrl;\n\n    /**\n     * The redirect url to use for 3xx http responses \n     * request重定向之后的url\n     */\n    private String mRedirectUrl;\n\n    /** The unique identifier of the request \n     *  从后面可以看出在构造request的时候\n     *  mIdentifier是通过createIdentifier()函数\n     *  由传入的url和请求的method以及当前系统时间还有一个计数器counter构造出的\n     *  独一无二的身份标识\n     */\n    private String mIdentifier;\n\n    /** \n     * Default tag for {@link TrafficStats}. \n     * \n     */\n    private final int mDefaultTrafficStatsTag;\n\n    /** Listener interface for errors. */\n    private final Response.ErrorListener mErrorListener;\n\n    /** Sequence number of this request, used to enforce FIFO ordering. */\n    private Integer mSequence;\n\n    /** The request queue this request is associated with. */\n    private RequestQueue mRequestQueue;\n\n    /** Whether or not responses to this request should be cached. */\n    private boolean mShouldCache = true;\n\n    /** Whether or not this request has been canceled. */\n    private boolean mCanceled = false;\n\n    /** Whether or not a response has been delivered for this request yet. */\n    private boolean mResponseDelivered = false;\n\n    // A cheap variant of request tracing used to dump slow requests.\n    private long mRequestBirthTime = 0;\n\n    /** \n     * Threshold at which we should log the request (even when debug logging is not enabled). \n     * 用来判定是否打出将一个request打出slow_request的log的时间阀值\n     * 如果request响应时间超过了这个阀值，则会打出log，说明一下情况\n     */\n    private static final long SLOW_REQUEST_THRESHOLD_MS = 3000;\n\n    /**\n     * The retry policy for this request. \n     * 在前面已经介绍到了，RetryPolicy.java及其默认实现类\n     * 是用来处理request重新发送的一种策略，也就是重试方针\n     * 里面记录着重试的最大次数以及当前重试了几次等\n     */\n    private RetryPolicy mRetryPolicy;\n\n    /**\n     * When a request can be retrieved from cache but must be refreshed from\n     * the network, the cache entry will be stored here so that in the event of\n     * a \"Not Modified\" response, we can be sure it hasn't been evicted from cache.\n     *\n     * 当一个请求的结果有缓存但是需要从服务器刷新一下的时候\n     * 缓存的入口，在向服务器发送条件请求时，服务器返回304之后\n     * 就可以从这个缓存的入口找到该请求在本地对应的缓存数据了。= =直接拿来用咯\n     */\n    private Cache.Entry mCacheEntry = null;\n\n    /** An opaque token tagging this request; used for bulk cancellation. \n     *  一个关于该request的不公开透明的token，用于批量取消\n     * 在RequestQueue.java中会用到这个mTag\n     * 用mTag可以取消request\n     */\n    private Object mTag;\n\n    /**\n     * Creates a new request with the given URL and error listener.  Note that\n     * the normal response listener is not provided here as delivery of responses\n     * is provided by subclasses, who have a better idea of how to deliver an\n     * already-parsed response.\n     *\n     * 根据给定的url和errorListener创建一个新的request\n     * 需要注意的是这里并没有涉及到responseListener方面的设置\n     * 因为将其放在request的子类去设置能更好的去传递一个已经解析好了的response\n     *\n     * 这个方法已经不推荐使用了，推荐使用下面的一个构造方法，因为这个方法存在默认的method\n     * 没有很大的自由度去自定义request\n     *\n     * @deprecated Use {@link #Request(int, String, com.android.volley.Response.ErrorListener)}.\n     */\n    @Deprecated\n    public Request(String url, Response.ErrorListener listener) {\n        this(Method.DEPRECATED_GET_OR_POST, url, listener);\n    }\n\n    /**\n     * Creates a new request with the given method (one of the values from {@link Method}),\n     * URL, and error listener.  Note that the normal response listener is not provided here as\n     * delivery of responses is provided by subclasses, who have a better idea of how to deliver\n     * an already-parsed response.\n     * \n     * setRetryPolicy()该方法设置了request所谓的“重试策略”。\n     * 跳转到DefaultRetryPolicy.java(系列博客的第四篇---Volley框架解析(四))\n     */\n    public Request(int method, String url, Response.ErrorListener listener) {\n        mMethod = method;\n        mUrl = url;\n        mIdentifier = createIdentifier(method, url);\n        mErrorListener = listener;\n        setRetryPolicy(new DefaultRetryPolicy());\n\n        mDefaultTrafficStatsTag = findDefaultTrafficStatsTag(url);\n    }\n\n    /**\n     * Return the method for this request.  Can be one of the values in {@link Method}.\n     */\n    public int getMethod() {\n        return mMethod;\n    }\n\n    /**\n     * Set a tag on this request. Can be used to cancel all requests with this\n     * tag by {@link RequestQueue#cancelAll(Object)}.\n     *\n     * 为了方便从网络请求队列里面取消request，可以通过打tag的方式\n     * @return This Request object to allow for chaining.\n     */\n    public Request<?> setTag(Object tag) {\n        mTag = tag;\n        return this;\n    }\n\n    /**\n     * Returns this request's tag.\n     * @see Request#setTag(Object)\n     */\n    public Object getTag() {\n        return mTag;\n    }\n\n    /**\n     * @return this request's {@link com.android.volley.Response.ErrorListener}.\n     */\n    public Response.ErrorListener getErrorListener() {\n        return mErrorListener;\n    }\n\n    /**\n     * @return A tag for use with {@link TrafficStats#setThreadStatsTag(int)}\n     */\n    public int getTrafficStatsTag() {\n        return mDefaultTrafficStatsTag;\n    }\n\n    /**\n     * @return The hashcode of the URL's host component, or 0 if there is none.\n     * 返回了request的url中的host的hashcode\n     */\n    private static int findDefaultTrafficStatsTag(String url) {\n        if (!TextUtils.isEmpty(url)) {\n            Uri uri = Uri.parse(url);\n            if (uri != null) {\n                String host = uri.getHost();\n                if (host != null) {\n                    return host.hashCode();\n                }\n            }\n        }\n        return 0;\n    }\n\n    /**\n     * Sets the retry policy for this request.\n     * 给request设置重试策略\n     * @return This Request object to allow for chaining.\n     */\n    public Request<?> setRetryPolicy(RetryPolicy retryPolicy) {\n        mRetryPolicy = retryPolicy;\n        return this;\n    }\n\n    /**\n     * Adds an event to this request's event log; for debugging.\n     */\n    public void addMarker(String tag) {\n        if (MarkerLog.ENABLED) {\n            mEventLog.add(tag, Thread.currentThread().getId());\n        } else if (mRequestBirthTime == 0) {\n            mRequestBirthTime = SystemClock.elapsedRealtime();\n        }\n    }\n\n    /**\n     * Notifies the request queue that this request has finished (successfully or with error).\n     * 该函数用来告诉request队列，当前的request已经完成了(包括成功和失败)\n     * <p>Also dumps all events from this request's event log; for debugging.</p>\n     */\n    void finish(final String tag) {\n\n        /**\n         * 告诉RequestQueue，这个tag对应的request已经结束了\n         * ReuqestQueue会将这个request移出队列\n         * 并将具有相同cacheKey的等待中reuqest全部移除\n         */\n        if (mRequestQueue != null) {\n            mRequestQueue.finish(this);\n        }\n\n        /**\n         * 如果允许打出log\n         * 则log提示这个request已经结束了\n         */\n        if (MarkerLog.ENABLED) {\n            final long threadId = Thread.currentThread().getId();\n            if (Looper.myLooper() != Looper.getMainLooper()) {\n                // If we finish marking off of the main thread, we need to\n                // actually do it on the main thread to ensure correct ordering.\n                Handler mainThread = new Handler(Looper.getMainLooper());\n                mainThread.post(new Runnable() {\n                    @Override\n                    public void run() {\n                        mEventLog.add(tag, threadId);\n                        mEventLog.finish(this.toString());\n                    }\n                });\n                return;\n            }\n\n            mEventLog.add(tag, threadId);\n            mEventLog.finish(this.toString());\n        } else {\n            long requestTime = SystemClock.elapsedRealtime() - mRequestBirthTime;\n            if (requestTime >= SLOW_REQUEST_THRESHOLD_MS) {\n                VolleyLog.d(\"%d ms: %s\", requestTime, this.toString());\n            }\n        }\n    }\n\n    /**\n     * Associates this request with the given queue. The request queue will be notified when this\n     * request has finished.\n     * \n     * 将和request相关的那个RequestQueue与request关联起来\n     * 持有一个对象的引用\n     * 在request结束的时候好通知RequestQueue\n     * \n     * @return This Request object to allow for chaining.\n     */\n    public Request<?> setRequestQueue(RequestQueue requestQueue) {\n        mRequestQueue = requestQueue;\n        return this;\n    }\n\n    /**\n     * Sets the sequence number of this request.  Used by {@link RequestQueue}.\n     * 在RequestQueue中调用，request加入到RequestQueue的时候\n     * 需要开始排队等待处理\n     * 这个函数的作用就是发号码牌给每个request(排队专用，想的还比较周到= =)\n     * @return This Request object to allow for chaining.\n     */\n    public final Request<?> setSequence(int sequence) {\n        mSequence = sequence;\n        return this;\n    }\n\n    /**\n     * Returns the sequence number of this request.\n     */\n    public final int getSequence() {\n        if (mSequence == null) {\n            throw new IllegalStateException(\"getSequence called before setSequence\");\n        }\n        return mSequence;\n    }\n\n    /**\n     * Returns the URL of this request.\n     * 返回真实访问的url,如果有重定向出现\n     * 则真实url是重定向后的url\n     * 否则是原始的url\n     */\n    public String getUrl() {\n        return (mRedirectUrl != null) ? mRedirectUrl : mUrl;\n    }\n\n    /**\n     * Returns the URL of the request before any redirects have occurred.\n     * 返回最原始的url,在任何重定向发生之前\n     */\n    public String getOriginUrl() {\n        return mUrl;\n    }\n\n    /**\n     * Returns the identifier of the request.\n     */\n    public String getIdentifier() {\n        return mIdentifier;\n    }\n\n    /**\n     * Sets the redirect url to handle 3xx http responses.\n     * 发生重定向之后可以通过该函数来设置重定向后的url\n     */\n    public void setRedirectUrl(String redirectUrl) {\n        mRedirectUrl = redirectUrl;\n    }\n\n    /**\n     * Returns the cache key for this request.  \n     * By default, this is the URL.\n     * 默认使用url来作为cacheKey\n     */\n    public String getCacheKey() {\n        return getUrl();\n    }\n\n    /**\n     * Annotates this request with an entry retrieved for it from cache.\n     * Used for cache coherency support.\n     * \n     * @return This Request object to allow for chaining.\n     */\n    public Request<?> setCacheEntry(Cache.Entry entry) {\n        mCacheEntry = entry;\n        return this;\n    }\n\n    /**\n     * Returns the annotated cache entry, or null if there isn't one.\n     */\n    public Cache.Entry getCacheEntry() {\n        return mCacheEntry;\n    }\n\n    /**\n     * Mark this request as canceled.  No callback will be delivered.\n     */\n    public void cancel() {\n        mCanceled = true;\n    }\n\n    /**\n     * Returns true if this request has been canceled.\n     */\n    public boolean isCanceled() {\n        return mCanceled;\n    }\n\n    /**\n     * Returns a list of extra HTTP headers to go along with this request. Can\n     * throw {@link AuthFailureError} as authentication may be required to\n     * provide these values.\n     * 返回在Request中的HTTPheader，这个里面存放了一些关于Request的基本信息\n     * 例如请求方式，cookie等东西\n     * @throws AuthFailureError In the event of auth failure\n     */\n    public Map<String, String> getHeaders() throws AuthFailureError {\n        return Collections.emptyMap();\n    }\n\n    /**\n     * Returns a Map of POST parameters to be used for this request, or null if\n     * a simple GET should be used.  Can throw {@link AuthFailureError} as\n     * authentication may be required to provide these values.\n     * 返回request中用于POST请求的一些参数\n     * 这些参数以键值对的形式存在，如果是GET方法，则传回Null\n     *　\n     * <p>Note that only one of getPostParams() and getPostBody() can return a non-null\n     * value.</p>\n     * @throws AuthFailureError In the event of auth failure\n     *\n     * @deprecated Use {@link #getParams()} instead.\n     */\n    @Deprecated\n    protected Map<String, String> getPostParams() throws AuthFailureError {\n        return getParams();\n    }\n\n    /**\n     * Returns which encoding should be used when converting POST parameters returned by\n     * {@link #getPostParams()} into a raw POST body.\n     * \n     * \n     * <p>This controls both encodings:\n     * <ol>\n     *     <li>The string encoding used when converting parameter names and values into bytes prior\n     *         to URL encoding them.</li>\n     *     <li>The string encoding used when converting the URL encoded parameters into a raw\n     *         byte array.</li>\n     * </ol>\n     *\n     * @deprecated Use {@link #getParamsEncoding()} instead.\n     */\n    @Deprecated\n    protected String getPostParamsEncoding() {\n        return getParamsEncoding();\n    }\n\n    /**\n     * @deprecated Use {@link #getBodyContentType()} instead.\n     * 返回请求体的内容种类\n     * 包括application/json等内容\n     */\n    @Deprecated\n    public String getPostBodyContentType() {\n        return getBodyContentType();\n    }\n\n    /**\n     * Returns the raw POST body to be sent.\n     * 该函数被建议不要使用了，用getBody代替\n     * \n     * @throws AuthFailureError In the event of auth failure\n     *\n     * @deprecated Use {@link #getBody()} instead.\n     */\n    @Deprecated\n    public byte[] getPostBody() throws AuthFailureError {\n        // Note: For compatibility with legacy clients of volley, this implementation must remain\n        // here instead of simply calling the getBody() function because this function must\n        // call getPostParams() and getPostParamsEncoding() since legacy clients would have\n        // overridden these two member functions for POST requests.\n        Map<String, String> postParams = getPostParams();\n        if (postParams != null && postParams.size() > 0) {\n            return encodeParameters(postParams, getPostParamsEncoding());\n        }\n        return null;\n    }\n\n    /**\n     * Returns a Map of parameters to be used for a POST or PUT request.  Can throw\n     * {@link AuthFailureError} as authentication may be required to provide these values.\n     *\n     * <p>Note that you can directly override {@link #getBody()} for custom data.</p>\n     *\n     * @throws AuthFailureError in the event of auth failure\n     */\n    protected Map<String, String> getParams() throws AuthFailureError {\n        return null;\n    }\n\n    /**\n     * Returns which encoding should be used when converting POST or PUT parameters returned by\n     * {@link #getParams()} into a raw POST or PUT body.\n     *\n     * <p>This controls both encodings:\n     * <ol>\n     *     <li>The string encoding used when converting parameter names and values into bytes prior\n     *         to URL encoding them.</li>\n     *     <li>The string encoding used when converting the URL encoded parameters into a raw\n     *         byte array.</li>\n     * </ol>\n     */\n    protected String getParamsEncoding() {\n        return DEFAULT_PARAMS_ENCODING;\n    }\n\n    /**\n     * Returns the content type of the POST or PUT body.\n     * 返回请求体的内容种类\n     */\n    public String getBodyContentType() {\n        return \"application/x-www-form-urlencoded; charset=\" + getParamsEncoding();\n    }\n\n    /**\n     * Returns the raw POST or PUT body to be sent.\n     * 返回将要发送的request的POST主体\n     * \n     * <p>By default, the body consists of the request parameters in\n     * application/x-www-form-urlencoded format. When overriding this method, consider overriding\n     * {@link #getBodyContentType()} as well to match the new body format.\n     *\n     * @throws AuthFailureError in the event of auth failure\n     */\n    public byte[] getBody() throws AuthFailureError {\n        Map<String, String> params = getParams();\n        if (params != null && params.size() > 0) {\n            return encodeParameters(params, getParamsEncoding());\n        }\n        return null;\n    }\n\n    /**\n     * Converts <code>params</code> into an application/x-www-form-urlencoded encoded string.\n     * 将请求里面包含的参数转码\n     */\n    private byte[] encodeParameters(Map<String, String> params, String paramsEncoding) {\n        StringBuilder encodedParams = new StringBuilder();\n        try {\n            for (Map.Entry<String, String> entry : params.entrySet()) {\n                encodedParams.append(URLEncoder.encode(entry.getKey(), paramsEncoding));\n                encodedParams.append('=');\n                encodedParams.append(URLEncoder.encode(entry.getValue(), paramsEncoding));\n                encodedParams.append('&');\n            }\n            return encodedParams.toString().getBytes(paramsEncoding);\n        } catch (UnsupportedEncodingException uee) {\n            throw new RuntimeException(\"Encoding not supported: \" + paramsEncoding, uee);\n        }\n    }\n\n    /**\n     * Set whether or not responses to this request should be cached.\n     *\n     * @return This Request object to allow for chaining.\n     */\n    public final Request<?> setShouldCache(boolean shouldCache) {\n        mShouldCache = shouldCache;\n        return this;\n    }\n\n    /**\n     * Returns true if responses to this request should be cached.\n     */\n    public final boolean shouldCache() {\n        return mShouldCache;\n    }\n\n    /**\n     * Priority values.  Requests will be processed from higher priorities to\n     * lower priorities, in FIFO order.\n     * request将按照优先级从高到低，先进先出的顺序被处理\n     */\n    public enum Priority {\n        LOW,\n        NORMAL,\n        HIGH,\n        IMMEDIATE\n    }\n\n    /**\n     * Returns the {@link Priority} of this request; {@link Priority#NORMAL} by default.\n     * 返回request的优先级\n     * 默认为normal\n     */\n    public Priority getPriority() {\n        return Priority.NORMAL;\n    }\n\n    /**\n     * Returns the socket timeout in milliseconds per retry attempt. (This value can be changed\n     * per retry attempt if a backoff is specified via backoffTimeout()). If there are no retry\n     * attempts remaining, this will cause delivery of a {@link TimeoutError} error.\n     * 返回每次超时请求时间阀值\n     * 每次retry如果返回的是请求超时的结果，则timeout会逐渐变大\n     * 如果\n     */\n    public final int getTimeoutMs() {\n        return mRetryPolicy.getCurrentTimeout();\n    }\n\n    /**\n     * Returns the retry policy that should be used  for this request.\n     */\n    public RetryPolicy getRetryPolicy() {\n        return mRetryPolicy;\n    }\n\n    /**\n     * Mark this request as having a response delivered on it.  This can be used\n     * later in the request's lifetime for suppressing identical responses.\n     */\n    public void markDelivered() {\n        mResponseDelivered = true;\n    }\n\n    /**\n     * Returns true if this request has had a response delivered for it.\n     */\n    public boolean hasHadResponseDelivered() {\n        return mResponseDelivered;\n    }\n\n    /**\n     * Subclasses must implement this to parse the raw network response\n     * and return an appropriate response type. This method will be\n     * called from a worker thread.  The response will not be delivered\n     * if you return null.\n     * 子类必须要实现这个方法来解析network response并返回一个合适的返回类型\n     * \n     * @param response Response from the network\n     * @return The parsed response, or null in the case of an error\n     */\n    abstract protected Response<T> parseNetworkResponse(NetworkResponse response);\n\n    /**\n     * Subclasses can override this method to parse 'networkError' and return a more specific error.\n     * 子类重写这个方法，来解析networkError\n     * <p>The default implementation just returns the passed 'networkError'.</p>\n     *\n     * @param volleyError the error retrieved from the network\n     * @return an NetworkError augmented with additional information\n     */\n    protected VolleyError parseNetworkError(VolleyError volleyError) {\n        return volleyError;\n    }\n\n    /**\n     * Subclasses must implement this to perform delivery of the parsed\n     * response to their listeners.  The given response is guaranteed to\n     * be non-null; responses that fail to parse are not delivered.\n     *\n     * 子类必须实现这个方法来传递一个解析好了的response\n     *\n     * @param response The parsed response returned by\n     * {@link #parseNetworkResponse(NetworkResponse)}\n     */\n    abstract protected void deliverResponse(T response);\n\n    /**\n     * Delivers error message to the ErrorListener that the Request was\n     * initialized with.\n     *\n     * @param error Error details\n     */\n    public void deliverError(VolleyError error) {\n        if (mErrorListener != null) {\n            mErrorListener.onErrorResponse(error);\n        }\n    }\n\n    /**\n     * Our comparator sorts from high to low priority, and secondarily by\n     * sequence number to provide FIFO ordering.\n     * Request类实现了Comparable类\n     * 需要重写compareTo()方法\n     * 来达到能够将两个request相互比较的目的\n     * 这里面的比较策略是通过看两request的优先级大小\n     * 高优先级的排在前面，相等的优先级就按照排队时候发放的序列号来比较\n     * (在RequestQueue.java中的add()函数里会给每个加入到队列中的request发放一个sequence)\n     */\n    @Override\n    public int compareTo(Request<T> other) {\n        Priority left = this.getPriority();\n        Priority right = other.getPriority();\n\n        // High-priority requests are \"lesser\" so they are sorted to the front.\n        // Equal priorities are sorted by sequence number to provide FIFO ordering.\n        return left == right ?\n                this.mSequence - other.mSequence :\n                right.ordinal() - left.ordinal();\n    }\n\n    /**\n     * 重写toString()方法\n     * 提供在打印request的时候的一些数据\n     * 也方便序列化\n     */\n    @Override\n    public String toString() {\n        String trafficStatsTag = \"0x\" + Integer.toHexString(getTrafficStatsTag());\n        return (mCanceled ? \"[X] \" : \"[ ] \") + getUrl() + \" \" + trafficStatsTag + \" \"\n                + getPriority() + \" \" + mSequence;\n    }\n\n    private static long sCounter;\n    /**\n     *  sha1(Request:method:url:timestamp:counter)\n     *\n     * @param method http method\n     * @param url               http request url\n     * @return sha1 hash string\n     */\n    private static String createIdentifier(final int method, final String url) {\n        return InternalUtils.sha1Hash(\"Request:\" + method + \":\" + url +\n                \":\" + System.currentTimeMillis() + \":\" + (sCounter++));\n    }\n}\n\n```\n\n在`Request.java`的基础上，Volley示范性的扩展了`StringReuqest.java`以及`JSONArrayRequest.java`等等，在这里就不分析源代码了。","source":"_posts/Volley框架解析-七-Request解析.md","raw":"---\ntitle: Volley框架解析-七-Request解析\ndate: 2017-04-24 22:13:25\ntags: volley\n\n---\n\n# Volley框架解析(七)-----Request解析\n\n### 1. 前言\n\n了解了request队列的调度程序，request结果的处理方式，以及request请求出错的处理方式，对请求结果进行缓存方面的工作等等。这篇博客就是专门分析`Request`了。\n\n### 2. Request.java\n\nVolley封装的一个抽象类，Request.java提供了很大的便利性，可供我们自定义Request,之前在使用Volley的时候自定义了一些reuqest的，也总结过自定义request的方法，在这篇博客中有提到[Volley使用技巧—–自定义Request](http://blog.csdn.net/jing_unique_da/article/details/45101331 \"Volley使用技巧-----自定义Request\")。下面就开始分析`Request.java`的源码。\n\n<!--more-->\n\n```\n/**\n * Base class for all network requests.\n * 在volley中涉及到的所有request的基础类\n *\n * @param <T> The type of parsed response this request expects.\n * 泛型类T是请求端希望服务器能返回的数据类型\n *\n * 关于其实现的一个Comparable接口，从字面上来看就是\"可比较的\"\n * 官方的解释如下：\n * This interface should be implemented by all classes that wish to define \n * a natural order of their instances. sort(List) and java.util.Arrays#sort \n * can then be used to automatically sort lists of classes that implement this interface.\n * 意思就是说如果你希望你的类在一个list中能够使用sort等函数自动排序的话，就实现这个接口吧= =\n * (需要重写里面的方法compareTo(), 里面是比较了两个request的优先级)\n */\npublic abstract class Request<T> implements Comparable<Request<T>> {\n\n    /**\n     * Default encoding for POST or PUT parameters. See {@link #getParamsEncoding()}.\n     * POST或者是PUT请求参数的默认编码格式 \"UTF-8\"\n     */\n    private static final String DEFAULT_PARAMS_ENCODING = \"UTF-8\";\n\n    /**\n     * Supported request methods.\n     * 支持的请求方式，有各种,常用的GET, POST, PUT应该是比较熟悉\n     */\n    public interface Method {\n        int DEPRECATED_GET_OR_POST = -1;\n        int GET = 0;\n        int POST = 1;\n        int PUT = 2;\n        int DELETE = 3;\n        int HEAD = 4;\n        int OPTIONS = 5;\n        int TRACE = 6;\n        int PATCH = 7;\n    }\n\n    /**\n     * An event log tracing the lifetime of this request; for debugging. \n     * 为了debug方便，volley弄了一套VolleyLog\n     * 在一个request整个生命周期内不停的打出log\n     * 都可以方便从log监控该request现在的情况\n     */\n    private final MarkerLog mEventLog = MarkerLog.ENABLED ? new MarkerLog() : null;\n\n    /**\n     * Request method of this request.  Currently supports GET, POST, PUT, DELETE, HEAD, OPTIONS,\n     * TRACE, and PATCH.\n     * 当前request涉及到的请求方式\n     * 目前所支持的有GET, POST, PUT等\n     */\n    private final int mMethod;\n\n    /** \n     * URL of this request.\n     * 原始Url\n     */\n    private final String mUrl;\n\n    /**\n     * The redirect url to use for 3xx http responses \n     * request重定向之后的url\n     */\n    private String mRedirectUrl;\n\n    /** The unique identifier of the request \n     *  从后面可以看出在构造request的时候\n     *  mIdentifier是通过createIdentifier()函数\n     *  由传入的url和请求的method以及当前系统时间还有一个计数器counter构造出的\n     *  独一无二的身份标识\n     */\n    private String mIdentifier;\n\n    /** \n     * Default tag for {@link TrafficStats}. \n     * \n     */\n    private final int mDefaultTrafficStatsTag;\n\n    /** Listener interface for errors. */\n    private final Response.ErrorListener mErrorListener;\n\n    /** Sequence number of this request, used to enforce FIFO ordering. */\n    private Integer mSequence;\n\n    /** The request queue this request is associated with. */\n    private RequestQueue mRequestQueue;\n\n    /** Whether or not responses to this request should be cached. */\n    private boolean mShouldCache = true;\n\n    /** Whether or not this request has been canceled. */\n    private boolean mCanceled = false;\n\n    /** Whether or not a response has been delivered for this request yet. */\n    private boolean mResponseDelivered = false;\n\n    // A cheap variant of request tracing used to dump slow requests.\n    private long mRequestBirthTime = 0;\n\n    /** \n     * Threshold at which we should log the request (even when debug logging is not enabled). \n     * 用来判定是否打出将一个request打出slow_request的log的时间阀值\n     * 如果request响应时间超过了这个阀值，则会打出log，说明一下情况\n     */\n    private static final long SLOW_REQUEST_THRESHOLD_MS = 3000;\n\n    /**\n     * The retry policy for this request. \n     * 在前面已经介绍到了，RetryPolicy.java及其默认实现类\n     * 是用来处理request重新发送的一种策略，也就是重试方针\n     * 里面记录着重试的最大次数以及当前重试了几次等\n     */\n    private RetryPolicy mRetryPolicy;\n\n    /**\n     * When a request can be retrieved from cache but must be refreshed from\n     * the network, the cache entry will be stored here so that in the event of\n     * a \"Not Modified\" response, we can be sure it hasn't been evicted from cache.\n     *\n     * 当一个请求的结果有缓存但是需要从服务器刷新一下的时候\n     * 缓存的入口，在向服务器发送条件请求时，服务器返回304之后\n     * 就可以从这个缓存的入口找到该请求在本地对应的缓存数据了。= =直接拿来用咯\n     */\n    private Cache.Entry mCacheEntry = null;\n\n    /** An opaque token tagging this request; used for bulk cancellation. \n     *  一个关于该request的不公开透明的token，用于批量取消\n     * 在RequestQueue.java中会用到这个mTag\n     * 用mTag可以取消request\n     */\n    private Object mTag;\n\n    /**\n     * Creates a new request with the given URL and error listener.  Note that\n     * the normal response listener is not provided here as delivery of responses\n     * is provided by subclasses, who have a better idea of how to deliver an\n     * already-parsed response.\n     *\n     * 根据给定的url和errorListener创建一个新的request\n     * 需要注意的是这里并没有涉及到responseListener方面的设置\n     * 因为将其放在request的子类去设置能更好的去传递一个已经解析好了的response\n     *\n     * 这个方法已经不推荐使用了，推荐使用下面的一个构造方法，因为这个方法存在默认的method\n     * 没有很大的自由度去自定义request\n     *\n     * @deprecated Use {@link #Request(int, String, com.android.volley.Response.ErrorListener)}.\n     */\n    @Deprecated\n    public Request(String url, Response.ErrorListener listener) {\n        this(Method.DEPRECATED_GET_OR_POST, url, listener);\n    }\n\n    /**\n     * Creates a new request with the given method (one of the values from {@link Method}),\n     * URL, and error listener.  Note that the normal response listener is not provided here as\n     * delivery of responses is provided by subclasses, who have a better idea of how to deliver\n     * an already-parsed response.\n     * \n     * setRetryPolicy()该方法设置了request所谓的“重试策略”。\n     * 跳转到DefaultRetryPolicy.java(系列博客的第四篇---Volley框架解析(四))\n     */\n    public Request(int method, String url, Response.ErrorListener listener) {\n        mMethod = method;\n        mUrl = url;\n        mIdentifier = createIdentifier(method, url);\n        mErrorListener = listener;\n        setRetryPolicy(new DefaultRetryPolicy());\n\n        mDefaultTrafficStatsTag = findDefaultTrafficStatsTag(url);\n    }\n\n    /**\n     * Return the method for this request.  Can be one of the values in {@link Method}.\n     */\n    public int getMethod() {\n        return mMethod;\n    }\n\n    /**\n     * Set a tag on this request. Can be used to cancel all requests with this\n     * tag by {@link RequestQueue#cancelAll(Object)}.\n     *\n     * 为了方便从网络请求队列里面取消request，可以通过打tag的方式\n     * @return This Request object to allow for chaining.\n     */\n    public Request<?> setTag(Object tag) {\n        mTag = tag;\n        return this;\n    }\n\n    /**\n     * Returns this request's tag.\n     * @see Request#setTag(Object)\n     */\n    public Object getTag() {\n        return mTag;\n    }\n\n    /**\n     * @return this request's {@link com.android.volley.Response.ErrorListener}.\n     */\n    public Response.ErrorListener getErrorListener() {\n        return mErrorListener;\n    }\n\n    /**\n     * @return A tag for use with {@link TrafficStats#setThreadStatsTag(int)}\n     */\n    public int getTrafficStatsTag() {\n        return mDefaultTrafficStatsTag;\n    }\n\n    /**\n     * @return The hashcode of the URL's host component, or 0 if there is none.\n     * 返回了request的url中的host的hashcode\n     */\n    private static int findDefaultTrafficStatsTag(String url) {\n        if (!TextUtils.isEmpty(url)) {\n            Uri uri = Uri.parse(url);\n            if (uri != null) {\n                String host = uri.getHost();\n                if (host != null) {\n                    return host.hashCode();\n                }\n            }\n        }\n        return 0;\n    }\n\n    /**\n     * Sets the retry policy for this request.\n     * 给request设置重试策略\n     * @return This Request object to allow for chaining.\n     */\n    public Request<?> setRetryPolicy(RetryPolicy retryPolicy) {\n        mRetryPolicy = retryPolicy;\n        return this;\n    }\n\n    /**\n     * Adds an event to this request's event log; for debugging.\n     */\n    public void addMarker(String tag) {\n        if (MarkerLog.ENABLED) {\n            mEventLog.add(tag, Thread.currentThread().getId());\n        } else if (mRequestBirthTime == 0) {\n            mRequestBirthTime = SystemClock.elapsedRealtime();\n        }\n    }\n\n    /**\n     * Notifies the request queue that this request has finished (successfully or with error).\n     * 该函数用来告诉request队列，当前的request已经完成了(包括成功和失败)\n     * <p>Also dumps all events from this request's event log; for debugging.</p>\n     */\n    void finish(final String tag) {\n\n        /**\n         * 告诉RequestQueue，这个tag对应的request已经结束了\n         * ReuqestQueue会将这个request移出队列\n         * 并将具有相同cacheKey的等待中reuqest全部移除\n         */\n        if (mRequestQueue != null) {\n            mRequestQueue.finish(this);\n        }\n\n        /**\n         * 如果允许打出log\n         * 则log提示这个request已经结束了\n         */\n        if (MarkerLog.ENABLED) {\n            final long threadId = Thread.currentThread().getId();\n            if (Looper.myLooper() != Looper.getMainLooper()) {\n                // If we finish marking off of the main thread, we need to\n                // actually do it on the main thread to ensure correct ordering.\n                Handler mainThread = new Handler(Looper.getMainLooper());\n                mainThread.post(new Runnable() {\n                    @Override\n                    public void run() {\n                        mEventLog.add(tag, threadId);\n                        mEventLog.finish(this.toString());\n                    }\n                });\n                return;\n            }\n\n            mEventLog.add(tag, threadId);\n            mEventLog.finish(this.toString());\n        } else {\n            long requestTime = SystemClock.elapsedRealtime() - mRequestBirthTime;\n            if (requestTime >= SLOW_REQUEST_THRESHOLD_MS) {\n                VolleyLog.d(\"%d ms: %s\", requestTime, this.toString());\n            }\n        }\n    }\n\n    /**\n     * Associates this request with the given queue. The request queue will be notified when this\n     * request has finished.\n     * \n     * 将和request相关的那个RequestQueue与request关联起来\n     * 持有一个对象的引用\n     * 在request结束的时候好通知RequestQueue\n     * \n     * @return This Request object to allow for chaining.\n     */\n    public Request<?> setRequestQueue(RequestQueue requestQueue) {\n        mRequestQueue = requestQueue;\n        return this;\n    }\n\n    /**\n     * Sets the sequence number of this request.  Used by {@link RequestQueue}.\n     * 在RequestQueue中调用，request加入到RequestQueue的时候\n     * 需要开始排队等待处理\n     * 这个函数的作用就是发号码牌给每个request(排队专用，想的还比较周到= =)\n     * @return This Request object to allow for chaining.\n     */\n    public final Request<?> setSequence(int sequence) {\n        mSequence = sequence;\n        return this;\n    }\n\n    /**\n     * Returns the sequence number of this request.\n     */\n    public final int getSequence() {\n        if (mSequence == null) {\n            throw new IllegalStateException(\"getSequence called before setSequence\");\n        }\n        return mSequence;\n    }\n\n    /**\n     * Returns the URL of this request.\n     * 返回真实访问的url,如果有重定向出现\n     * 则真实url是重定向后的url\n     * 否则是原始的url\n     */\n    public String getUrl() {\n        return (mRedirectUrl != null) ? mRedirectUrl : mUrl;\n    }\n\n    /**\n     * Returns the URL of the request before any redirects have occurred.\n     * 返回最原始的url,在任何重定向发生之前\n     */\n    public String getOriginUrl() {\n        return mUrl;\n    }\n\n    /**\n     * Returns the identifier of the request.\n     */\n    public String getIdentifier() {\n        return mIdentifier;\n    }\n\n    /**\n     * Sets the redirect url to handle 3xx http responses.\n     * 发生重定向之后可以通过该函数来设置重定向后的url\n     */\n    public void setRedirectUrl(String redirectUrl) {\n        mRedirectUrl = redirectUrl;\n    }\n\n    /**\n     * Returns the cache key for this request.  \n     * By default, this is the URL.\n     * 默认使用url来作为cacheKey\n     */\n    public String getCacheKey() {\n        return getUrl();\n    }\n\n    /**\n     * Annotates this request with an entry retrieved for it from cache.\n     * Used for cache coherency support.\n     * \n     * @return This Request object to allow for chaining.\n     */\n    public Request<?> setCacheEntry(Cache.Entry entry) {\n        mCacheEntry = entry;\n        return this;\n    }\n\n    /**\n     * Returns the annotated cache entry, or null if there isn't one.\n     */\n    public Cache.Entry getCacheEntry() {\n        return mCacheEntry;\n    }\n\n    /**\n     * Mark this request as canceled.  No callback will be delivered.\n     */\n    public void cancel() {\n        mCanceled = true;\n    }\n\n    /**\n     * Returns true if this request has been canceled.\n     */\n    public boolean isCanceled() {\n        return mCanceled;\n    }\n\n    /**\n     * Returns a list of extra HTTP headers to go along with this request. Can\n     * throw {@link AuthFailureError} as authentication may be required to\n     * provide these values.\n     * 返回在Request中的HTTPheader，这个里面存放了一些关于Request的基本信息\n     * 例如请求方式，cookie等东西\n     * @throws AuthFailureError In the event of auth failure\n     */\n    public Map<String, String> getHeaders() throws AuthFailureError {\n        return Collections.emptyMap();\n    }\n\n    /**\n     * Returns a Map of POST parameters to be used for this request, or null if\n     * a simple GET should be used.  Can throw {@link AuthFailureError} as\n     * authentication may be required to provide these values.\n     * 返回request中用于POST请求的一些参数\n     * 这些参数以键值对的形式存在，如果是GET方法，则传回Null\n     *　\n     * <p>Note that only one of getPostParams() and getPostBody() can return a non-null\n     * value.</p>\n     * @throws AuthFailureError In the event of auth failure\n     *\n     * @deprecated Use {@link #getParams()} instead.\n     */\n    @Deprecated\n    protected Map<String, String> getPostParams() throws AuthFailureError {\n        return getParams();\n    }\n\n    /**\n     * Returns which encoding should be used when converting POST parameters returned by\n     * {@link #getPostParams()} into a raw POST body.\n     * \n     * \n     * <p>This controls both encodings:\n     * <ol>\n     *     <li>The string encoding used when converting parameter names and values into bytes prior\n     *         to URL encoding them.</li>\n     *     <li>The string encoding used when converting the URL encoded parameters into a raw\n     *         byte array.</li>\n     * </ol>\n     *\n     * @deprecated Use {@link #getParamsEncoding()} instead.\n     */\n    @Deprecated\n    protected String getPostParamsEncoding() {\n        return getParamsEncoding();\n    }\n\n    /**\n     * @deprecated Use {@link #getBodyContentType()} instead.\n     * 返回请求体的内容种类\n     * 包括application/json等内容\n     */\n    @Deprecated\n    public String getPostBodyContentType() {\n        return getBodyContentType();\n    }\n\n    /**\n     * Returns the raw POST body to be sent.\n     * 该函数被建议不要使用了，用getBody代替\n     * \n     * @throws AuthFailureError In the event of auth failure\n     *\n     * @deprecated Use {@link #getBody()} instead.\n     */\n    @Deprecated\n    public byte[] getPostBody() throws AuthFailureError {\n        // Note: For compatibility with legacy clients of volley, this implementation must remain\n        // here instead of simply calling the getBody() function because this function must\n        // call getPostParams() and getPostParamsEncoding() since legacy clients would have\n        // overridden these two member functions for POST requests.\n        Map<String, String> postParams = getPostParams();\n        if (postParams != null && postParams.size() > 0) {\n            return encodeParameters(postParams, getPostParamsEncoding());\n        }\n        return null;\n    }\n\n    /**\n     * Returns a Map of parameters to be used for a POST or PUT request.  Can throw\n     * {@link AuthFailureError} as authentication may be required to provide these values.\n     *\n     * <p>Note that you can directly override {@link #getBody()} for custom data.</p>\n     *\n     * @throws AuthFailureError in the event of auth failure\n     */\n    protected Map<String, String> getParams() throws AuthFailureError {\n        return null;\n    }\n\n    /**\n     * Returns which encoding should be used when converting POST or PUT parameters returned by\n     * {@link #getParams()} into a raw POST or PUT body.\n     *\n     * <p>This controls both encodings:\n     * <ol>\n     *     <li>The string encoding used when converting parameter names and values into bytes prior\n     *         to URL encoding them.</li>\n     *     <li>The string encoding used when converting the URL encoded parameters into a raw\n     *         byte array.</li>\n     * </ol>\n     */\n    protected String getParamsEncoding() {\n        return DEFAULT_PARAMS_ENCODING;\n    }\n\n    /**\n     * Returns the content type of the POST or PUT body.\n     * 返回请求体的内容种类\n     */\n    public String getBodyContentType() {\n        return \"application/x-www-form-urlencoded; charset=\" + getParamsEncoding();\n    }\n\n    /**\n     * Returns the raw POST or PUT body to be sent.\n     * 返回将要发送的request的POST主体\n     * \n     * <p>By default, the body consists of the request parameters in\n     * application/x-www-form-urlencoded format. When overriding this method, consider overriding\n     * {@link #getBodyContentType()} as well to match the new body format.\n     *\n     * @throws AuthFailureError in the event of auth failure\n     */\n    public byte[] getBody() throws AuthFailureError {\n        Map<String, String> params = getParams();\n        if (params != null && params.size() > 0) {\n            return encodeParameters(params, getParamsEncoding());\n        }\n        return null;\n    }\n\n    /**\n     * Converts <code>params</code> into an application/x-www-form-urlencoded encoded string.\n     * 将请求里面包含的参数转码\n     */\n    private byte[] encodeParameters(Map<String, String> params, String paramsEncoding) {\n        StringBuilder encodedParams = new StringBuilder();\n        try {\n            for (Map.Entry<String, String> entry : params.entrySet()) {\n                encodedParams.append(URLEncoder.encode(entry.getKey(), paramsEncoding));\n                encodedParams.append('=');\n                encodedParams.append(URLEncoder.encode(entry.getValue(), paramsEncoding));\n                encodedParams.append('&');\n            }\n            return encodedParams.toString().getBytes(paramsEncoding);\n        } catch (UnsupportedEncodingException uee) {\n            throw new RuntimeException(\"Encoding not supported: \" + paramsEncoding, uee);\n        }\n    }\n\n    /**\n     * Set whether or not responses to this request should be cached.\n     *\n     * @return This Request object to allow for chaining.\n     */\n    public final Request<?> setShouldCache(boolean shouldCache) {\n        mShouldCache = shouldCache;\n        return this;\n    }\n\n    /**\n     * Returns true if responses to this request should be cached.\n     */\n    public final boolean shouldCache() {\n        return mShouldCache;\n    }\n\n    /**\n     * Priority values.  Requests will be processed from higher priorities to\n     * lower priorities, in FIFO order.\n     * request将按照优先级从高到低，先进先出的顺序被处理\n     */\n    public enum Priority {\n        LOW,\n        NORMAL,\n        HIGH,\n        IMMEDIATE\n    }\n\n    /**\n     * Returns the {@link Priority} of this request; {@link Priority#NORMAL} by default.\n     * 返回request的优先级\n     * 默认为normal\n     */\n    public Priority getPriority() {\n        return Priority.NORMAL;\n    }\n\n    /**\n     * Returns the socket timeout in milliseconds per retry attempt. (This value can be changed\n     * per retry attempt if a backoff is specified via backoffTimeout()). If there are no retry\n     * attempts remaining, this will cause delivery of a {@link TimeoutError} error.\n     * 返回每次超时请求时间阀值\n     * 每次retry如果返回的是请求超时的结果，则timeout会逐渐变大\n     * 如果\n     */\n    public final int getTimeoutMs() {\n        return mRetryPolicy.getCurrentTimeout();\n    }\n\n    /**\n     * Returns the retry policy that should be used  for this request.\n     */\n    public RetryPolicy getRetryPolicy() {\n        return mRetryPolicy;\n    }\n\n    /**\n     * Mark this request as having a response delivered on it.  This can be used\n     * later in the request's lifetime for suppressing identical responses.\n     */\n    public void markDelivered() {\n        mResponseDelivered = true;\n    }\n\n    /**\n     * Returns true if this request has had a response delivered for it.\n     */\n    public boolean hasHadResponseDelivered() {\n        return mResponseDelivered;\n    }\n\n    /**\n     * Subclasses must implement this to parse the raw network response\n     * and return an appropriate response type. This method will be\n     * called from a worker thread.  The response will not be delivered\n     * if you return null.\n     * 子类必须要实现这个方法来解析network response并返回一个合适的返回类型\n     * \n     * @param response Response from the network\n     * @return The parsed response, or null in the case of an error\n     */\n    abstract protected Response<T> parseNetworkResponse(NetworkResponse response);\n\n    /**\n     * Subclasses can override this method to parse 'networkError' and return a more specific error.\n     * 子类重写这个方法，来解析networkError\n     * <p>The default implementation just returns the passed 'networkError'.</p>\n     *\n     * @param volleyError the error retrieved from the network\n     * @return an NetworkError augmented with additional information\n     */\n    protected VolleyError parseNetworkError(VolleyError volleyError) {\n        return volleyError;\n    }\n\n    /**\n     * Subclasses must implement this to perform delivery of the parsed\n     * response to their listeners.  The given response is guaranteed to\n     * be non-null; responses that fail to parse are not delivered.\n     *\n     * 子类必须实现这个方法来传递一个解析好了的response\n     *\n     * @param response The parsed response returned by\n     * {@link #parseNetworkResponse(NetworkResponse)}\n     */\n    abstract protected void deliverResponse(T response);\n\n    /**\n     * Delivers error message to the ErrorListener that the Request was\n     * initialized with.\n     *\n     * @param error Error details\n     */\n    public void deliverError(VolleyError error) {\n        if (mErrorListener != null) {\n            mErrorListener.onErrorResponse(error);\n        }\n    }\n\n    /**\n     * Our comparator sorts from high to low priority, and secondarily by\n     * sequence number to provide FIFO ordering.\n     * Request类实现了Comparable类\n     * 需要重写compareTo()方法\n     * 来达到能够将两个request相互比较的目的\n     * 这里面的比较策略是通过看两request的优先级大小\n     * 高优先级的排在前面，相等的优先级就按照排队时候发放的序列号来比较\n     * (在RequestQueue.java中的add()函数里会给每个加入到队列中的request发放一个sequence)\n     */\n    @Override\n    public int compareTo(Request<T> other) {\n        Priority left = this.getPriority();\n        Priority right = other.getPriority();\n\n        // High-priority requests are \"lesser\" so they are sorted to the front.\n        // Equal priorities are sorted by sequence number to provide FIFO ordering.\n        return left == right ?\n                this.mSequence - other.mSequence :\n                right.ordinal() - left.ordinal();\n    }\n\n    /**\n     * 重写toString()方法\n     * 提供在打印request的时候的一些数据\n     * 也方便序列化\n     */\n    @Override\n    public String toString() {\n        String trafficStatsTag = \"0x\" + Integer.toHexString(getTrafficStatsTag());\n        return (mCanceled ? \"[X] \" : \"[ ] \") + getUrl() + \" \" + trafficStatsTag + \" \"\n                + getPriority() + \" \" + mSequence;\n    }\n\n    private static long sCounter;\n    /**\n     *  sha1(Request:method:url:timestamp:counter)\n     *\n     * @param method http method\n     * @param url               http request url\n     * @return sha1 hash string\n     */\n    private static String createIdentifier(final int method, final String url) {\n        return InternalUtils.sha1Hash(\"Request:\" + method + \":\" + url +\n                \":\" + System.currentTimeMillis() + \":\" + (sCounter++));\n    }\n}\n\n```\n\n在`Request.java`的基础上，Volley示范性的扩展了`StringReuqest.java`以及`JSONArrayRequest.java`等等，在这里就不分析源代码了。","slug":"Volley框架解析-七-Request解析","published":1,"updated":"2020-07-03T02:40:48.120Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc5n2qh5000gw8r1n8kw5kxw","content":"<h1 id=\"Volley框架解析-七-—–Request解析\"><a href=\"#Volley框架解析-七-—–Request解析\" class=\"headerlink\" title=\"Volley框架解析(七)—–Request解析\"></a>Volley框架解析(七)—–Request解析</h1><h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h3><p>了解了request队列的调度程序，request结果的处理方式，以及request请求出错的处理方式，对请求结果进行缓存方面的工作等等。这篇博客就是专门分析<code>Request</code>了。</p>\n<h3 id=\"2-Request-java\"><a href=\"#2-Request-java\" class=\"headerlink\" title=\"2. Request.java\"></a>2. Request.java</h3><p>Volley封装的一个抽象类，Request.java提供了很大的便利性，可供我们自定义Request,之前在使用Volley的时候自定义了一些reuqest的，也总结过自定义request的方法，在这篇博客中有提到<a href=\"http://blog.csdn.net/jing_unique_da/article/details/45101331\" title=\"Volley使用技巧-----自定义Request\" target=\"_blank\" rel=\"noopener\">Volley使用技巧—–自定义Request</a>。下面就开始分析<code>Request.java</code>的源码。</p>\n<a id=\"more\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div><div class=\"line\">204</div><div class=\"line\">205</div><div class=\"line\">206</div><div class=\"line\">207</div><div class=\"line\">208</div><div class=\"line\">209</div><div class=\"line\">210</div><div class=\"line\">211</div><div class=\"line\">212</div><div class=\"line\">213</div><div class=\"line\">214</div><div class=\"line\">215</div><div class=\"line\">216</div><div class=\"line\">217</div><div class=\"line\">218</div><div class=\"line\">219</div><div class=\"line\">220</div><div class=\"line\">221</div><div class=\"line\">222</div><div class=\"line\">223</div><div class=\"line\">224</div><div class=\"line\">225</div><div class=\"line\">226</div><div class=\"line\">227</div><div class=\"line\">228</div><div class=\"line\">229</div><div class=\"line\">230</div><div class=\"line\">231</div><div class=\"line\">232</div><div class=\"line\">233</div><div class=\"line\">234</div><div class=\"line\">235</div><div class=\"line\">236</div><div class=\"line\">237</div><div class=\"line\">238</div><div class=\"line\">239</div><div class=\"line\">240</div><div class=\"line\">241</div><div class=\"line\">242</div><div class=\"line\">243</div><div class=\"line\">244</div><div class=\"line\">245</div><div class=\"line\">246</div><div class=\"line\">247</div><div class=\"line\">248</div><div class=\"line\">249</div><div class=\"line\">250</div><div class=\"line\">251</div><div class=\"line\">252</div><div class=\"line\">253</div><div class=\"line\">254</div><div class=\"line\">255</div><div class=\"line\">256</div><div class=\"line\">257</div><div class=\"line\">258</div><div class=\"line\">259</div><div class=\"line\">260</div><div class=\"line\">261</div><div class=\"line\">262</div><div class=\"line\">263</div><div class=\"line\">264</div><div class=\"line\">265</div><div class=\"line\">266</div><div class=\"line\">267</div><div class=\"line\">268</div><div class=\"line\">269</div><div class=\"line\">270</div><div class=\"line\">271</div><div class=\"line\">272</div><div class=\"line\">273</div><div class=\"line\">274</div><div class=\"line\">275</div><div class=\"line\">276</div><div class=\"line\">277</div><div class=\"line\">278</div><div class=\"line\">279</div><div class=\"line\">280</div><div class=\"line\">281</div><div class=\"line\">282</div><div class=\"line\">283</div><div class=\"line\">284</div><div class=\"line\">285</div><div class=\"line\">286</div><div class=\"line\">287</div><div class=\"line\">288</div><div class=\"line\">289</div><div class=\"line\">290</div><div class=\"line\">291</div><div class=\"line\">292</div><div class=\"line\">293</div><div class=\"line\">294</div><div class=\"line\">295</div><div class=\"line\">296</div><div class=\"line\">297</div><div class=\"line\">298</div><div class=\"line\">299</div><div class=\"line\">300</div><div class=\"line\">301</div><div class=\"line\">302</div><div class=\"line\">303</div><div class=\"line\">304</div><div class=\"line\">305</div><div class=\"line\">306</div><div class=\"line\">307</div><div class=\"line\">308</div><div class=\"line\">309</div><div class=\"line\">310</div><div class=\"line\">311</div><div class=\"line\">312</div><div class=\"line\">313</div><div class=\"line\">314</div><div class=\"line\">315</div><div class=\"line\">316</div><div class=\"line\">317</div><div class=\"line\">318</div><div class=\"line\">319</div><div class=\"line\">320</div><div class=\"line\">321</div><div class=\"line\">322</div><div class=\"line\">323</div><div class=\"line\">324</div><div class=\"line\">325</div><div class=\"line\">326</div><div class=\"line\">327</div><div class=\"line\">328</div><div class=\"line\">329</div><div class=\"line\">330</div><div class=\"line\">331</div><div class=\"line\">332</div><div class=\"line\">333</div><div class=\"line\">334</div><div class=\"line\">335</div><div class=\"line\">336</div><div class=\"line\">337</div><div class=\"line\">338</div><div class=\"line\">339</div><div class=\"line\">340</div><div class=\"line\">341</div><div class=\"line\">342</div><div class=\"line\">343</div><div class=\"line\">344</div><div class=\"line\">345</div><div class=\"line\">346</div><div class=\"line\">347</div><div class=\"line\">348</div><div class=\"line\">349</div><div class=\"line\">350</div><div class=\"line\">351</div><div class=\"line\">352</div><div class=\"line\">353</div><div class=\"line\">354</div><div class=\"line\">355</div><div class=\"line\">356</div><div class=\"line\">357</div><div class=\"line\">358</div><div class=\"line\">359</div><div class=\"line\">360</div><div class=\"line\">361</div><div class=\"line\">362</div><div class=\"line\">363</div><div class=\"line\">364</div><div class=\"line\">365</div><div class=\"line\">366</div><div class=\"line\">367</div><div class=\"line\">368</div><div class=\"line\">369</div><div class=\"line\">370</div><div class=\"line\">371</div><div class=\"line\">372</div><div class=\"line\">373</div><div class=\"line\">374</div><div class=\"line\">375</div><div class=\"line\">376</div><div class=\"line\">377</div><div class=\"line\">378</div><div class=\"line\">379</div><div class=\"line\">380</div><div class=\"line\">381</div><div class=\"line\">382</div><div class=\"line\">383</div><div class=\"line\">384</div><div class=\"line\">385</div><div class=\"line\">386</div><div class=\"line\">387</div><div class=\"line\">388</div><div class=\"line\">389</div><div class=\"line\">390</div><div class=\"line\">391</div><div class=\"line\">392</div><div class=\"line\">393</div><div class=\"line\">394</div><div class=\"line\">395</div><div class=\"line\">396</div><div class=\"line\">397</div><div class=\"line\">398</div><div class=\"line\">399</div><div class=\"line\">400</div><div class=\"line\">401</div><div class=\"line\">402</div><div class=\"line\">403</div><div class=\"line\">404</div><div class=\"line\">405</div><div class=\"line\">406</div><div class=\"line\">407</div><div class=\"line\">408</div><div class=\"line\">409</div><div class=\"line\">410</div><div class=\"line\">411</div><div class=\"line\">412</div><div class=\"line\">413</div><div class=\"line\">414</div><div class=\"line\">415</div><div class=\"line\">416</div><div class=\"line\">417</div><div class=\"line\">418</div><div class=\"line\">419</div><div class=\"line\">420</div><div class=\"line\">421</div><div class=\"line\">422</div><div class=\"line\">423</div><div class=\"line\">424</div><div class=\"line\">425</div><div class=\"line\">426</div><div class=\"line\">427</div><div class=\"line\">428</div><div class=\"line\">429</div><div class=\"line\">430</div><div class=\"line\">431</div><div class=\"line\">432</div><div class=\"line\">433</div><div class=\"line\">434</div><div class=\"line\">435</div><div class=\"line\">436</div><div class=\"line\">437</div><div class=\"line\">438</div><div class=\"line\">439</div><div class=\"line\">440</div><div class=\"line\">441</div><div class=\"line\">442</div><div class=\"line\">443</div><div class=\"line\">444</div><div class=\"line\">445</div><div class=\"line\">446</div><div class=\"line\">447</div><div class=\"line\">448</div><div class=\"line\">449</div><div class=\"line\">450</div><div class=\"line\">451</div><div class=\"line\">452</div><div class=\"line\">453</div><div class=\"line\">454</div><div class=\"line\">455</div><div class=\"line\">456</div><div class=\"line\">457</div><div class=\"line\">458</div><div class=\"line\">459</div><div class=\"line\">460</div><div class=\"line\">461</div><div class=\"line\">462</div><div class=\"line\">463</div><div class=\"line\">464</div><div class=\"line\">465</div><div class=\"line\">466</div><div class=\"line\">467</div><div class=\"line\">468</div><div class=\"line\">469</div><div class=\"line\">470</div><div class=\"line\">471</div><div class=\"line\">472</div><div class=\"line\">473</div><div class=\"line\">474</div><div class=\"line\">475</div><div class=\"line\">476</div><div class=\"line\">477</div><div class=\"line\">478</div><div class=\"line\">479</div><div class=\"line\">480</div><div class=\"line\">481</div><div class=\"line\">482</div><div class=\"line\">483</div><div class=\"line\">484</div><div class=\"line\">485</div><div class=\"line\">486</div><div class=\"line\">487</div><div class=\"line\">488</div><div class=\"line\">489</div><div class=\"line\">490</div><div class=\"line\">491</div><div class=\"line\">492</div><div class=\"line\">493</div><div class=\"line\">494</div><div class=\"line\">495</div><div class=\"line\">496</div><div class=\"line\">497</div><div class=\"line\">498</div><div class=\"line\">499</div><div class=\"line\">500</div><div class=\"line\">501</div><div class=\"line\">502</div><div class=\"line\">503</div><div class=\"line\">504</div><div class=\"line\">505</div><div class=\"line\">506</div><div class=\"line\">507</div><div class=\"line\">508</div><div class=\"line\">509</div><div class=\"line\">510</div><div class=\"line\">511</div><div class=\"line\">512</div><div class=\"line\">513</div><div class=\"line\">514</div><div class=\"line\">515</div><div class=\"line\">516</div><div class=\"line\">517</div><div class=\"line\">518</div><div class=\"line\">519</div><div class=\"line\">520</div><div class=\"line\">521</div><div class=\"line\">522</div><div class=\"line\">523</div><div class=\"line\">524</div><div class=\"line\">525</div><div class=\"line\">526</div><div class=\"line\">527</div><div class=\"line\">528</div><div class=\"line\">529</div><div class=\"line\">530</div><div class=\"line\">531</div><div class=\"line\">532</div><div class=\"line\">533</div><div class=\"line\">534</div><div class=\"line\">535</div><div class=\"line\">536</div><div class=\"line\">537</div><div class=\"line\">538</div><div class=\"line\">539</div><div class=\"line\">540</div><div class=\"line\">541</div><div class=\"line\">542</div><div class=\"line\">543</div><div class=\"line\">544</div><div class=\"line\">545</div><div class=\"line\">546</div><div class=\"line\">547</div><div class=\"line\">548</div><div class=\"line\">549</div><div class=\"line\">550</div><div class=\"line\">551</div><div class=\"line\">552</div><div class=\"line\">553</div><div class=\"line\">554</div><div class=\"line\">555</div><div class=\"line\">556</div><div class=\"line\">557</div><div class=\"line\">558</div><div class=\"line\">559</div><div class=\"line\">560</div><div class=\"line\">561</div><div class=\"line\">562</div><div class=\"line\">563</div><div class=\"line\">564</div><div class=\"line\">565</div><div class=\"line\">566</div><div class=\"line\">567</div><div class=\"line\">568</div><div class=\"line\">569</div><div class=\"line\">570</div><div class=\"line\">571</div><div class=\"line\">572</div><div class=\"line\">573</div><div class=\"line\">574</div><div class=\"line\">575</div><div class=\"line\">576</div><div class=\"line\">577</div><div class=\"line\">578</div><div class=\"line\">579</div><div class=\"line\">580</div><div class=\"line\">581</div><div class=\"line\">582</div><div class=\"line\">583</div><div class=\"line\">584</div><div class=\"line\">585</div><div class=\"line\">586</div><div class=\"line\">587</div><div class=\"line\">588</div><div class=\"line\">589</div><div class=\"line\">590</div><div class=\"line\">591</div><div class=\"line\">592</div><div class=\"line\">593</div><div class=\"line\">594</div><div class=\"line\">595</div><div class=\"line\">596</div><div class=\"line\">597</div><div class=\"line\">598</div><div class=\"line\">599</div><div class=\"line\">600</div><div class=\"line\">601</div><div class=\"line\">602</div><div class=\"line\">603</div><div class=\"line\">604</div><div class=\"line\">605</div><div class=\"line\">606</div><div class=\"line\">607</div><div class=\"line\">608</div><div class=\"line\">609</div><div class=\"line\">610</div><div class=\"line\">611</div><div class=\"line\">612</div><div class=\"line\">613</div><div class=\"line\">614</div><div class=\"line\">615</div><div class=\"line\">616</div><div class=\"line\">617</div><div class=\"line\">618</div><div class=\"line\">619</div><div class=\"line\">620</div><div class=\"line\">621</div><div class=\"line\">622</div><div class=\"line\">623</div><div class=\"line\">624</div><div class=\"line\">625</div><div class=\"line\">626</div><div class=\"line\">627</div><div class=\"line\">628</div><div class=\"line\">629</div><div class=\"line\">630</div><div class=\"line\">631</div><div class=\"line\">632</div><div class=\"line\">633</div><div class=\"line\">634</div><div class=\"line\">635</div><div class=\"line\">636</div><div class=\"line\">637</div><div class=\"line\">638</div><div class=\"line\">639</div><div class=\"line\">640</div><div class=\"line\">641</div><div class=\"line\">642</div><div class=\"line\">643</div><div class=\"line\">644</div><div class=\"line\">645</div><div class=\"line\">646</div><div class=\"line\">647</div><div class=\"line\">648</div><div class=\"line\">649</div><div class=\"line\">650</div><div class=\"line\">651</div><div class=\"line\">652</div><div class=\"line\">653</div><div class=\"line\">654</div><div class=\"line\">655</div><div class=\"line\">656</div><div class=\"line\">657</div><div class=\"line\">658</div><div class=\"line\">659</div><div class=\"line\">660</div><div class=\"line\">661</div><div class=\"line\">662</div><div class=\"line\">663</div><div class=\"line\">664</div><div class=\"line\">665</div><div class=\"line\">666</div><div class=\"line\">667</div><div class=\"line\">668</div><div class=\"line\">669</div><div class=\"line\">670</div><div class=\"line\">671</div><div class=\"line\">672</div><div class=\"line\">673</div><div class=\"line\">674</div><div class=\"line\">675</div><div class=\"line\">676</div><div class=\"line\">677</div><div class=\"line\">678</div><div class=\"line\">679</div><div class=\"line\">680</div><div class=\"line\">681</div><div class=\"line\">682</div><div class=\"line\">683</div><div class=\"line\">684</div><div class=\"line\">685</div><div class=\"line\">686</div><div class=\"line\">687</div><div class=\"line\">688</div><div class=\"line\">689</div><div class=\"line\">690</div><div class=\"line\">691</div><div class=\"line\">692</div><div class=\"line\">693</div><div class=\"line\">694</div><div class=\"line\">695</div><div class=\"line\">696</div><div class=\"line\">697</div><div class=\"line\">698</div><div class=\"line\">699</div><div class=\"line\">700</div><div class=\"line\">701</div><div class=\"line\">702</div><div class=\"line\">703</div><div class=\"line\">704</div><div class=\"line\">705</div><div class=\"line\">706</div><div class=\"line\">707</div><div class=\"line\">708</div><div class=\"line\">709</div><div class=\"line\">710</div><div class=\"line\">711</div><div class=\"line\">712</div><div class=\"line\">713</div><div class=\"line\">714</div><div class=\"line\">715</div><div class=\"line\">716</div><div class=\"line\">717</div><div class=\"line\">718</div><div class=\"line\">719</div><div class=\"line\">720</div><div class=\"line\">721</div><div class=\"line\">722</div><div class=\"line\">723</div><div class=\"line\">724</div><div class=\"line\">725</div><div class=\"line\">726</div><div class=\"line\">727</div><div class=\"line\">728</div><div class=\"line\">729</div><div class=\"line\">730</div><div class=\"line\">731</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * Base class for all network requests.</div><div class=\"line\"> * 在volley中涉及到的所有request的基础类</div><div class=\"line\"> *</div><div class=\"line\"> * @param &lt;T&gt; The type of parsed response this request expects.</div><div class=\"line\"> * 泛型类T是请求端希望服务器能返回的数据类型</div><div class=\"line\"> *</div><div class=\"line\"> * 关于其实现的一个Comparable接口，从字面上来看就是&quot;可比较的&quot;</div><div class=\"line\"> * 官方的解释如下：</div><div class=\"line\"> * This interface should be implemented by all classes that wish to define </div><div class=\"line\"> * a natural order of their instances. sort(List) and java.util.Arrays#sort </div><div class=\"line\"> * can then be used to automatically sort lists of classes that implement this interface.</div><div class=\"line\"> * 意思就是说如果你希望你的类在一个list中能够使用sort等函数自动排序的话，就实现这个接口吧= =</div><div class=\"line\"> * (需要重写里面的方法compareTo(), 里面是比较了两个request的优先级)</div><div class=\"line\"> */</div><div class=\"line\">public abstract class Request&lt;T&gt; implements Comparable&lt;Request&lt;T&gt;&gt; &#123;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Default encoding for POST or PUT parameters. See &#123;@link #getParamsEncoding()&#125;.</div><div class=\"line\">     * POST或者是PUT请求参数的默认编码格式 &quot;UTF-8&quot;</div><div class=\"line\">     */</div><div class=\"line\">    private static final String DEFAULT_PARAMS_ENCODING = &quot;UTF-8&quot;;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Supported request methods.</div><div class=\"line\">     * 支持的请求方式，有各种,常用的GET, POST, PUT应该是比较熟悉</div><div class=\"line\">     */</div><div class=\"line\">    public interface Method &#123;</div><div class=\"line\">        int DEPRECATED_GET_OR_POST = -1;</div><div class=\"line\">        int GET = 0;</div><div class=\"line\">        int POST = 1;</div><div class=\"line\">        int PUT = 2;</div><div class=\"line\">        int DELETE = 3;</div><div class=\"line\">        int HEAD = 4;</div><div class=\"line\">        int OPTIONS = 5;</div><div class=\"line\">        int TRACE = 6;</div><div class=\"line\">        int PATCH = 7;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * An event log tracing the lifetime of this request; for debugging. </div><div class=\"line\">     * 为了debug方便，volley弄了一套VolleyLog</div><div class=\"line\">     * 在一个request整个生命周期内不停的打出log</div><div class=\"line\">     * 都可以方便从log监控该request现在的情况</div><div class=\"line\">     */</div><div class=\"line\">    private final MarkerLog mEventLog = MarkerLog.ENABLED ? new MarkerLog() : null;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Request method of this request.  Currently supports GET, POST, PUT, DELETE, HEAD, OPTIONS,</div><div class=\"line\">     * TRACE, and PATCH.</div><div class=\"line\">     * 当前request涉及到的请求方式</div><div class=\"line\">     * 目前所支持的有GET, POST, PUT等</div><div class=\"line\">     */</div><div class=\"line\">    private final int mMethod;</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * URL of this request.</div><div class=\"line\">     * 原始Url</div><div class=\"line\">     */</div><div class=\"line\">    private final String mUrl;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * The redirect url to use for 3xx http responses </div><div class=\"line\">     * request重定向之后的url</div><div class=\"line\">     */</div><div class=\"line\">    private String mRedirectUrl;</div><div class=\"line\"></div><div class=\"line\">    /** The unique identifier of the request </div><div class=\"line\">     *  从后面可以看出在构造request的时候</div><div class=\"line\">     *  mIdentifier是通过createIdentifier()函数</div><div class=\"line\">     *  由传入的url和请求的method以及当前系统时间还有一个计数器counter构造出的</div><div class=\"line\">     *  独一无二的身份标识</div><div class=\"line\">     */</div><div class=\"line\">    private String mIdentifier;</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * Default tag for &#123;@link TrafficStats&#125;. </div><div class=\"line\">     * </div><div class=\"line\">     */</div><div class=\"line\">    private final int mDefaultTrafficStatsTag;</div><div class=\"line\"></div><div class=\"line\">    /** Listener interface for errors. */</div><div class=\"line\">    private final Response.ErrorListener mErrorListener;</div><div class=\"line\"></div><div class=\"line\">    /** Sequence number of this request, used to enforce FIFO ordering. */</div><div class=\"line\">    private Integer mSequence;</div><div class=\"line\"></div><div class=\"line\">    /** The request queue this request is associated with. */</div><div class=\"line\">    private RequestQueue mRequestQueue;</div><div class=\"line\"></div><div class=\"line\">    /** Whether or not responses to this request should be cached. */</div><div class=\"line\">    private boolean mShouldCache = true;</div><div class=\"line\"></div><div class=\"line\">    /** Whether or not this request has been canceled. */</div><div class=\"line\">    private boolean mCanceled = false;</div><div class=\"line\"></div><div class=\"line\">    /** Whether or not a response has been delivered for this request yet. */</div><div class=\"line\">    private boolean mResponseDelivered = false;</div><div class=\"line\"></div><div class=\"line\">    // A cheap variant of request tracing used to dump slow requests.</div><div class=\"line\">    private long mRequestBirthTime = 0;</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * Threshold at which we should log the request (even when debug logging is not enabled). </div><div class=\"line\">     * 用来判定是否打出将一个request打出slow_request的log的时间阀值</div><div class=\"line\">     * 如果request响应时间超过了这个阀值，则会打出log，说明一下情况</div><div class=\"line\">     */</div><div class=\"line\">    private static final long SLOW_REQUEST_THRESHOLD_MS = 3000;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * The retry policy for this request. </div><div class=\"line\">     * 在前面已经介绍到了，RetryPolicy.java及其默认实现类</div><div class=\"line\">     * 是用来处理request重新发送的一种策略，也就是重试方针</div><div class=\"line\">     * 里面记录着重试的最大次数以及当前重试了几次等</div><div class=\"line\">     */</div><div class=\"line\">    private RetryPolicy mRetryPolicy;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * When a request can be retrieved from cache but must be refreshed from</div><div class=\"line\">     * the network, the cache entry will be stored here so that in the event of</div><div class=\"line\">     * a &quot;Not Modified&quot; response, we can be sure it hasn&apos;t been evicted from cache.</div><div class=\"line\">     *</div><div class=\"line\">     * 当一个请求的结果有缓存但是需要从服务器刷新一下的时候</div><div class=\"line\">     * 缓存的入口，在向服务器发送条件请求时，服务器返回304之后</div><div class=\"line\">     * 就可以从这个缓存的入口找到该请求在本地对应的缓存数据了。= =直接拿来用咯</div><div class=\"line\">     */</div><div class=\"line\">    private Cache.Entry mCacheEntry = null;</div><div class=\"line\"></div><div class=\"line\">    /** An opaque token tagging this request; used for bulk cancellation. </div><div class=\"line\">     *  一个关于该request的不公开透明的token，用于批量取消</div><div class=\"line\">     * 在RequestQueue.java中会用到这个mTag</div><div class=\"line\">     * 用mTag可以取消request</div><div class=\"line\">     */</div><div class=\"line\">    private Object mTag;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Creates a new request with the given URL and error listener.  Note that</div><div class=\"line\">     * the normal response listener is not provided here as delivery of responses</div><div class=\"line\">     * is provided by subclasses, who have a better idea of how to deliver an</div><div class=\"line\">     * already-parsed response.</div><div class=\"line\">     *</div><div class=\"line\">     * 根据给定的url和errorListener创建一个新的request</div><div class=\"line\">     * 需要注意的是这里并没有涉及到responseListener方面的设置</div><div class=\"line\">     * 因为将其放在request的子类去设置能更好的去传递一个已经解析好了的response</div><div class=\"line\">     *</div><div class=\"line\">     * 这个方法已经不推荐使用了，推荐使用下面的一个构造方法，因为这个方法存在默认的method</div><div class=\"line\">     * 没有很大的自由度去自定义request</div><div class=\"line\">     *</div><div class=\"line\">     * @deprecated Use &#123;@link #Request(int, String, com.android.volley.Response.ErrorListener)&#125;.</div><div class=\"line\">     */</div><div class=\"line\">    @Deprecated</div><div class=\"line\">    public Request(String url, Response.ErrorListener listener) &#123;</div><div class=\"line\">        this(Method.DEPRECATED_GET_OR_POST, url, listener);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Creates a new request with the given method (one of the values from &#123;@link Method&#125;),</div><div class=\"line\">     * URL, and error listener.  Note that the normal response listener is not provided here as</div><div class=\"line\">     * delivery of responses is provided by subclasses, who have a better idea of how to deliver</div><div class=\"line\">     * an already-parsed response.</div><div class=\"line\">     * </div><div class=\"line\">     * setRetryPolicy()该方法设置了request所谓的“重试策略”。</div><div class=\"line\">     * 跳转到DefaultRetryPolicy.java(系列博客的第四篇---Volley框架解析(四))</div><div class=\"line\">     */</div><div class=\"line\">    public Request(int method, String url, Response.ErrorListener listener) &#123;</div><div class=\"line\">        mMethod = method;</div><div class=\"line\">        mUrl = url;</div><div class=\"line\">        mIdentifier = createIdentifier(method, url);</div><div class=\"line\">        mErrorListener = listener;</div><div class=\"line\">        setRetryPolicy(new DefaultRetryPolicy());</div><div class=\"line\"></div><div class=\"line\">        mDefaultTrafficStatsTag = findDefaultTrafficStatsTag(url);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Return the method for this request.  Can be one of the values in &#123;@link Method&#125;.</div><div class=\"line\">     */</div><div class=\"line\">    public int getMethod() &#123;</div><div class=\"line\">        return mMethod;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Set a tag on this request. Can be used to cancel all requests with this</div><div class=\"line\">     * tag by &#123;@link RequestQueue#cancelAll(Object)&#125;.</div><div class=\"line\">     *</div><div class=\"line\">     * 为了方便从网络请求队列里面取消request，可以通过打tag的方式</div><div class=\"line\">     * @return This Request object to allow for chaining.</div><div class=\"line\">     */</div><div class=\"line\">    public Request&lt;?&gt; setTag(Object tag) &#123;</div><div class=\"line\">        mTag = tag;</div><div class=\"line\">        return this;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Returns this request&apos;s tag.</div><div class=\"line\">     * @see Request#setTag(Object)</div><div class=\"line\">     */</div><div class=\"line\">    public Object getTag() &#123;</div><div class=\"line\">        return mTag;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * @return this request&apos;s &#123;@link com.android.volley.Response.ErrorListener&#125;.</div><div class=\"line\">     */</div><div class=\"line\">    public Response.ErrorListener getErrorListener() &#123;</div><div class=\"line\">        return mErrorListener;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * @return A tag for use with &#123;@link TrafficStats#setThreadStatsTag(int)&#125;</div><div class=\"line\">     */</div><div class=\"line\">    public int getTrafficStatsTag() &#123;</div><div class=\"line\">        return mDefaultTrafficStatsTag;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * @return The hashcode of the URL&apos;s host component, or 0 if there is none.</div><div class=\"line\">     * 返回了request的url中的host的hashcode</div><div class=\"line\">     */</div><div class=\"line\">    private static int findDefaultTrafficStatsTag(String url) &#123;</div><div class=\"line\">        if (!TextUtils.isEmpty(url)) &#123;</div><div class=\"line\">            Uri uri = Uri.parse(url);</div><div class=\"line\">            if (uri != null) &#123;</div><div class=\"line\">                String host = uri.getHost();</div><div class=\"line\">                if (host != null) &#123;</div><div class=\"line\">                    return host.hashCode();</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return 0;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Sets the retry policy for this request.</div><div class=\"line\">     * 给request设置重试策略</div><div class=\"line\">     * @return This Request object to allow for chaining.</div><div class=\"line\">     */</div><div class=\"line\">    public Request&lt;?&gt; setRetryPolicy(RetryPolicy retryPolicy) &#123;</div><div class=\"line\">        mRetryPolicy = retryPolicy;</div><div class=\"line\">        return this;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Adds an event to this request&apos;s event log; for debugging.</div><div class=\"line\">     */</div><div class=\"line\">    public void addMarker(String tag) &#123;</div><div class=\"line\">        if (MarkerLog.ENABLED) &#123;</div><div class=\"line\">            mEventLog.add(tag, Thread.currentThread().getId());</div><div class=\"line\">        &#125; else if (mRequestBirthTime == 0) &#123;</div><div class=\"line\">            mRequestBirthTime = SystemClock.elapsedRealtime();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Notifies the request queue that this request has finished (successfully or with error).</div><div class=\"line\">     * 该函数用来告诉request队列，当前的request已经完成了(包括成功和失败)</div><div class=\"line\">     * &lt;p&gt;Also dumps all events from this request&apos;s event log; for debugging.&lt;/p&gt;</div><div class=\"line\">     */</div><div class=\"line\">    void finish(final String tag) &#123;</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * 告诉RequestQueue，这个tag对应的request已经结束了</div><div class=\"line\">         * ReuqestQueue会将这个request移出队列</div><div class=\"line\">         * 并将具有相同cacheKey的等待中reuqest全部移除</div><div class=\"line\">         */</div><div class=\"line\">        if (mRequestQueue != null) &#123;</div><div class=\"line\">            mRequestQueue.finish(this);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * 如果允许打出log</div><div class=\"line\">         * 则log提示这个request已经结束了</div><div class=\"line\">         */</div><div class=\"line\">        if (MarkerLog.ENABLED) &#123;</div><div class=\"line\">            final long threadId = Thread.currentThread().getId();</div><div class=\"line\">            if (Looper.myLooper() != Looper.getMainLooper()) &#123;</div><div class=\"line\">                // If we finish marking off of the main thread, we need to</div><div class=\"line\">                // actually do it on the main thread to ensure correct ordering.</div><div class=\"line\">                Handler mainThread = new Handler(Looper.getMainLooper());</div><div class=\"line\">                mainThread.post(new Runnable() &#123;</div><div class=\"line\">                    @Override</div><div class=\"line\">                    public void run() &#123;</div><div class=\"line\">                        mEventLog.add(tag, threadId);</div><div class=\"line\">                        mEventLog.finish(this.toString());</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;);</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            mEventLog.add(tag, threadId);</div><div class=\"line\">            mEventLog.finish(this.toString());</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            long requestTime = SystemClock.elapsedRealtime() - mRequestBirthTime;</div><div class=\"line\">            if (requestTime &gt;= SLOW_REQUEST_THRESHOLD_MS) &#123;</div><div class=\"line\">                VolleyLog.d(&quot;%d ms: %s&quot;, requestTime, this.toString());</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Associates this request with the given queue. The request queue will be notified when this</div><div class=\"line\">     * request has finished.</div><div class=\"line\">     * </div><div class=\"line\">     * 将和request相关的那个RequestQueue与request关联起来</div><div class=\"line\">     * 持有一个对象的引用</div><div class=\"line\">     * 在request结束的时候好通知RequestQueue</div><div class=\"line\">     * </div><div class=\"line\">     * @return This Request object to allow for chaining.</div><div class=\"line\">     */</div><div class=\"line\">    public Request&lt;?&gt; setRequestQueue(RequestQueue requestQueue) &#123;</div><div class=\"line\">        mRequestQueue = requestQueue;</div><div class=\"line\">        return this;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Sets the sequence number of this request.  Used by &#123;@link RequestQueue&#125;.</div><div class=\"line\">     * 在RequestQueue中调用，request加入到RequestQueue的时候</div><div class=\"line\">     * 需要开始排队等待处理</div><div class=\"line\">     * 这个函数的作用就是发号码牌给每个request(排队专用，想的还比较周到= =)</div><div class=\"line\">     * @return This Request object to allow for chaining.</div><div class=\"line\">     */</div><div class=\"line\">    public final Request&lt;?&gt; setSequence(int sequence) &#123;</div><div class=\"line\">        mSequence = sequence;</div><div class=\"line\">        return this;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Returns the sequence number of this request.</div><div class=\"line\">     */</div><div class=\"line\">    public final int getSequence() &#123;</div><div class=\"line\">        if (mSequence == null) &#123;</div><div class=\"line\">            throw new IllegalStateException(&quot;getSequence called before setSequence&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        return mSequence;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Returns the URL of this request.</div><div class=\"line\">     * 返回真实访问的url,如果有重定向出现</div><div class=\"line\">     * 则真实url是重定向后的url</div><div class=\"line\">     * 否则是原始的url</div><div class=\"line\">     */</div><div class=\"line\">    public String getUrl() &#123;</div><div class=\"line\">        return (mRedirectUrl != null) ? mRedirectUrl : mUrl;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Returns the URL of the request before any redirects have occurred.</div><div class=\"line\">     * 返回最原始的url,在任何重定向发生之前</div><div class=\"line\">     */</div><div class=\"line\">    public String getOriginUrl() &#123;</div><div class=\"line\">        return mUrl;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Returns the identifier of the request.</div><div class=\"line\">     */</div><div class=\"line\">    public String getIdentifier() &#123;</div><div class=\"line\">        return mIdentifier;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Sets the redirect url to handle 3xx http responses.</div><div class=\"line\">     * 发生重定向之后可以通过该函数来设置重定向后的url</div><div class=\"line\">     */</div><div class=\"line\">    public void setRedirectUrl(String redirectUrl) &#123;</div><div class=\"line\">        mRedirectUrl = redirectUrl;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Returns the cache key for this request.  </div><div class=\"line\">     * By default, this is the URL.</div><div class=\"line\">     * 默认使用url来作为cacheKey</div><div class=\"line\">     */</div><div class=\"line\">    public String getCacheKey() &#123;</div><div class=\"line\">        return getUrl();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Annotates this request with an entry retrieved for it from cache.</div><div class=\"line\">     * Used for cache coherency support.</div><div class=\"line\">     * </div><div class=\"line\">     * @return This Request object to allow for chaining.</div><div class=\"line\">     */</div><div class=\"line\">    public Request&lt;?&gt; setCacheEntry(Cache.Entry entry) &#123;</div><div class=\"line\">        mCacheEntry = entry;</div><div class=\"line\">        return this;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Returns the annotated cache entry, or null if there isn&apos;t one.</div><div class=\"line\">     */</div><div class=\"line\">    public Cache.Entry getCacheEntry() &#123;</div><div class=\"line\">        return mCacheEntry;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Mark this request as canceled.  No callback will be delivered.</div><div class=\"line\">     */</div><div class=\"line\">    public void cancel() &#123;</div><div class=\"line\">        mCanceled = true;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Returns true if this request has been canceled.</div><div class=\"line\">     */</div><div class=\"line\">    public boolean isCanceled() &#123;</div><div class=\"line\">        return mCanceled;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Returns a list of extra HTTP headers to go along with this request. Can</div><div class=\"line\">     * throw &#123;@link AuthFailureError&#125; as authentication may be required to</div><div class=\"line\">     * provide these values.</div><div class=\"line\">     * 返回在Request中的HTTPheader，这个里面存放了一些关于Request的基本信息</div><div class=\"line\">     * 例如请求方式，cookie等东西</div><div class=\"line\">     * @throws AuthFailureError In the event of auth failure</div><div class=\"line\">     */</div><div class=\"line\">    public Map&lt;String, String&gt; getHeaders() throws AuthFailureError &#123;</div><div class=\"line\">        return Collections.emptyMap();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Returns a Map of POST parameters to be used for this request, or null if</div><div class=\"line\">     * a simple GET should be used.  Can throw &#123;@link AuthFailureError&#125; as</div><div class=\"line\">     * authentication may be required to provide these values.</div><div class=\"line\">     * 返回request中用于POST请求的一些参数</div><div class=\"line\">     * 这些参数以键值对的形式存在，如果是GET方法，则传回Null</div><div class=\"line\">     *　</div><div class=\"line\">     * &lt;p&gt;Note that only one of getPostParams() and getPostBody() can return a non-null</div><div class=\"line\">     * value.&lt;/p&gt;</div><div class=\"line\">     * @throws AuthFailureError In the event of auth failure</div><div class=\"line\">     *</div><div class=\"line\">     * @deprecated Use &#123;@link #getParams()&#125; instead.</div><div class=\"line\">     */</div><div class=\"line\">    @Deprecated</div><div class=\"line\">    protected Map&lt;String, String&gt; getPostParams() throws AuthFailureError &#123;</div><div class=\"line\">        return getParams();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Returns which encoding should be used when converting POST parameters returned by</div><div class=\"line\">     * &#123;@link #getPostParams()&#125; into a raw POST body.</div><div class=\"line\">     * </div><div class=\"line\">     * </div><div class=\"line\">     * &lt;p&gt;This controls both encodings:</div><div class=\"line\">     * &lt;ol&gt;</div><div class=\"line\">     *     &lt;li&gt;The string encoding used when converting parameter names and values into bytes prior</div><div class=\"line\">     *         to URL encoding them.&lt;/li&gt;</div><div class=\"line\">     *     &lt;li&gt;The string encoding used when converting the URL encoded parameters into a raw</div><div class=\"line\">     *         byte array.&lt;/li&gt;</div><div class=\"line\">     * &lt;/ol&gt;</div><div class=\"line\">     *</div><div class=\"line\">     * @deprecated Use &#123;@link #getParamsEncoding()&#125; instead.</div><div class=\"line\">     */</div><div class=\"line\">    @Deprecated</div><div class=\"line\">    protected String getPostParamsEncoding() &#123;</div><div class=\"line\">        return getParamsEncoding();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * @deprecated Use &#123;@link #getBodyContentType()&#125; instead.</div><div class=\"line\">     * 返回请求体的内容种类</div><div class=\"line\">     * 包括application/json等内容</div><div class=\"line\">     */</div><div class=\"line\">    @Deprecated</div><div class=\"line\">    public String getPostBodyContentType() &#123;</div><div class=\"line\">        return getBodyContentType();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Returns the raw POST body to be sent.</div><div class=\"line\">     * 该函数被建议不要使用了，用getBody代替</div><div class=\"line\">     * </div><div class=\"line\">     * @throws AuthFailureError In the event of auth failure</div><div class=\"line\">     *</div><div class=\"line\">     * @deprecated Use &#123;@link #getBody()&#125; instead.</div><div class=\"line\">     */</div><div class=\"line\">    @Deprecated</div><div class=\"line\">    public byte[] getPostBody() throws AuthFailureError &#123;</div><div class=\"line\">        // Note: For compatibility with legacy clients of volley, this implementation must remain</div><div class=\"line\">        // here instead of simply calling the getBody() function because this function must</div><div class=\"line\">        // call getPostParams() and getPostParamsEncoding() since legacy clients would have</div><div class=\"line\">        // overridden these two member functions for POST requests.</div><div class=\"line\">        Map&lt;String, String&gt; postParams = getPostParams();</div><div class=\"line\">        if (postParams != null &amp;&amp; postParams.size() &gt; 0) &#123;</div><div class=\"line\">            return encodeParameters(postParams, getPostParamsEncoding());</div><div class=\"line\">        &#125;</div><div class=\"line\">        return null;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Returns a Map of parameters to be used for a POST or PUT request.  Can throw</div><div class=\"line\">     * &#123;@link AuthFailureError&#125; as authentication may be required to provide these values.</div><div class=\"line\">     *</div><div class=\"line\">     * &lt;p&gt;Note that you can directly override &#123;@link #getBody()&#125; for custom data.&lt;/p&gt;</div><div class=\"line\">     *</div><div class=\"line\">     * @throws AuthFailureError in the event of auth failure</div><div class=\"line\">     */</div><div class=\"line\">    protected Map&lt;String, String&gt; getParams() throws AuthFailureError &#123;</div><div class=\"line\">        return null;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Returns which encoding should be used when converting POST or PUT parameters returned by</div><div class=\"line\">     * &#123;@link #getParams()&#125; into a raw POST or PUT body.</div><div class=\"line\">     *</div><div class=\"line\">     * &lt;p&gt;This controls both encodings:</div><div class=\"line\">     * &lt;ol&gt;</div><div class=\"line\">     *     &lt;li&gt;The string encoding used when converting parameter names and values into bytes prior</div><div class=\"line\">     *         to URL encoding them.&lt;/li&gt;</div><div class=\"line\">     *     &lt;li&gt;The string encoding used when converting the URL encoded parameters into a raw</div><div class=\"line\">     *         byte array.&lt;/li&gt;</div><div class=\"line\">     * &lt;/ol&gt;</div><div class=\"line\">     */</div><div class=\"line\">    protected String getParamsEncoding() &#123;</div><div class=\"line\">        return DEFAULT_PARAMS_ENCODING;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Returns the content type of the POST or PUT body.</div><div class=\"line\">     * 返回请求体的内容种类</div><div class=\"line\">     */</div><div class=\"line\">    public String getBodyContentType() &#123;</div><div class=\"line\">        return &quot;application/x-www-form-urlencoded; charset=&quot; + getParamsEncoding();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Returns the raw POST or PUT body to be sent.</div><div class=\"line\">     * 返回将要发送的request的POST主体</div><div class=\"line\">     * </div><div class=\"line\">     * &lt;p&gt;By default, the body consists of the request parameters in</div><div class=\"line\">     * application/x-www-form-urlencoded format. When overriding this method, consider overriding</div><div class=\"line\">     * &#123;@link #getBodyContentType()&#125; as well to match the new body format.</div><div class=\"line\">     *</div><div class=\"line\">     * @throws AuthFailureError in the event of auth failure</div><div class=\"line\">     */</div><div class=\"line\">    public byte[] getBody() throws AuthFailureError &#123;</div><div class=\"line\">        Map&lt;String, String&gt; params = getParams();</div><div class=\"line\">        if (params != null &amp;&amp; params.size() &gt; 0) &#123;</div><div class=\"line\">            return encodeParameters(params, getParamsEncoding());</div><div class=\"line\">        &#125;</div><div class=\"line\">        return null;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Converts &lt;code&gt;params&lt;/code&gt; into an application/x-www-form-urlencoded encoded string.</div><div class=\"line\">     * 将请求里面包含的参数转码</div><div class=\"line\">     */</div><div class=\"line\">    private byte[] encodeParameters(Map&lt;String, String&gt; params, String paramsEncoding) &#123;</div><div class=\"line\">        StringBuilder encodedParams = new StringBuilder();</div><div class=\"line\">        try &#123;</div><div class=\"line\">            for (Map.Entry&lt;String, String&gt; entry : params.entrySet()) &#123;</div><div class=\"line\">                encodedParams.append(URLEncoder.encode(entry.getKey(), paramsEncoding));</div><div class=\"line\">                encodedParams.append(&apos;=&apos;);</div><div class=\"line\">                encodedParams.append(URLEncoder.encode(entry.getValue(), paramsEncoding));</div><div class=\"line\">                encodedParams.append(&apos;&amp;&apos;);</div><div class=\"line\">            &#125;</div><div class=\"line\">            return encodedParams.toString().getBytes(paramsEncoding);</div><div class=\"line\">        &#125; catch (UnsupportedEncodingException uee) &#123;</div><div class=\"line\">            throw new RuntimeException(&quot;Encoding not supported: &quot; + paramsEncoding, uee);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Set whether or not responses to this request should be cached.</div><div class=\"line\">     *</div><div class=\"line\">     * @return This Request object to allow for chaining.</div><div class=\"line\">     */</div><div class=\"line\">    public final Request&lt;?&gt; setShouldCache(boolean shouldCache) &#123;</div><div class=\"line\">        mShouldCache = shouldCache;</div><div class=\"line\">        return this;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Returns true if responses to this request should be cached.</div><div class=\"line\">     */</div><div class=\"line\">    public final boolean shouldCache() &#123;</div><div class=\"line\">        return mShouldCache;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Priority values.  Requests will be processed from higher priorities to</div><div class=\"line\">     * lower priorities, in FIFO order.</div><div class=\"line\">     * request将按照优先级从高到低，先进先出的顺序被处理</div><div class=\"line\">     */</div><div class=\"line\">    public enum Priority &#123;</div><div class=\"line\">        LOW,</div><div class=\"line\">        NORMAL,</div><div class=\"line\">        HIGH,</div><div class=\"line\">        IMMEDIATE</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Returns the &#123;@link Priority&#125; of this request; &#123;@link Priority#NORMAL&#125; by default.</div><div class=\"line\">     * 返回request的优先级</div><div class=\"line\">     * 默认为normal</div><div class=\"line\">     */</div><div class=\"line\">    public Priority getPriority() &#123;</div><div class=\"line\">        return Priority.NORMAL;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Returns the socket timeout in milliseconds per retry attempt. (This value can be changed</div><div class=\"line\">     * per retry attempt if a backoff is specified via backoffTimeout()). If there are no retry</div><div class=\"line\">     * attempts remaining, this will cause delivery of a &#123;@link TimeoutError&#125; error.</div><div class=\"line\">     * 返回每次超时请求时间阀值</div><div class=\"line\">     * 每次retry如果返回的是请求超时的结果，则timeout会逐渐变大</div><div class=\"line\">     * 如果</div><div class=\"line\">     */</div><div class=\"line\">    public final int getTimeoutMs() &#123;</div><div class=\"line\">        return mRetryPolicy.getCurrentTimeout();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Returns the retry policy that should be used  for this request.</div><div class=\"line\">     */</div><div class=\"line\">    public RetryPolicy getRetryPolicy() &#123;</div><div class=\"line\">        return mRetryPolicy;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Mark this request as having a response delivered on it.  This can be used</div><div class=\"line\">     * later in the request&apos;s lifetime for suppressing identical responses.</div><div class=\"line\">     */</div><div class=\"line\">    public void markDelivered() &#123;</div><div class=\"line\">        mResponseDelivered = true;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Returns true if this request has had a response delivered for it.</div><div class=\"line\">     */</div><div class=\"line\">    public boolean hasHadResponseDelivered() &#123;</div><div class=\"line\">        return mResponseDelivered;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Subclasses must implement this to parse the raw network response</div><div class=\"line\">     * and return an appropriate response type. This method will be</div><div class=\"line\">     * called from a worker thread.  The response will not be delivered</div><div class=\"line\">     * if you return null.</div><div class=\"line\">     * 子类必须要实现这个方法来解析network response并返回一个合适的返回类型</div><div class=\"line\">     * </div><div class=\"line\">     * @param response Response from the network</div><div class=\"line\">     * @return The parsed response, or null in the case of an error</div><div class=\"line\">     */</div><div class=\"line\">    abstract protected Response&lt;T&gt; parseNetworkResponse(NetworkResponse response);</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Subclasses can override this method to parse &apos;networkError&apos; and return a more specific error.</div><div class=\"line\">     * 子类重写这个方法，来解析networkError</div><div class=\"line\">     * &lt;p&gt;The default implementation just returns the passed &apos;networkError&apos;.&lt;/p&gt;</div><div class=\"line\">     *</div><div class=\"line\">     * @param volleyError the error retrieved from the network</div><div class=\"line\">     * @return an NetworkError augmented with additional information</div><div class=\"line\">     */</div><div class=\"line\">    protected VolleyError parseNetworkError(VolleyError volleyError) &#123;</div><div class=\"line\">        return volleyError;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Subclasses must implement this to perform delivery of the parsed</div><div class=\"line\">     * response to their listeners.  The given response is guaranteed to</div><div class=\"line\">     * be non-null; responses that fail to parse are not delivered.</div><div class=\"line\">     *</div><div class=\"line\">     * 子类必须实现这个方法来传递一个解析好了的response</div><div class=\"line\">     *</div><div class=\"line\">     * @param response The parsed response returned by</div><div class=\"line\">     * &#123;@link #parseNetworkResponse(NetworkResponse)&#125;</div><div class=\"line\">     */</div><div class=\"line\">    abstract protected void deliverResponse(T response);</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Delivers error message to the ErrorListener that the Request was</div><div class=\"line\">     * initialized with.</div><div class=\"line\">     *</div><div class=\"line\">     * @param error Error details</div><div class=\"line\">     */</div><div class=\"line\">    public void deliverError(VolleyError error) &#123;</div><div class=\"line\">        if (mErrorListener != null) &#123;</div><div class=\"line\">            mErrorListener.onErrorResponse(error);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Our comparator sorts from high to low priority, and secondarily by</div><div class=\"line\">     * sequence number to provide FIFO ordering.</div><div class=\"line\">     * Request类实现了Comparable类</div><div class=\"line\">     * 需要重写compareTo()方法</div><div class=\"line\">     * 来达到能够将两个request相互比较的目的</div><div class=\"line\">     * 这里面的比较策略是通过看两request的优先级大小</div><div class=\"line\">     * 高优先级的排在前面，相等的优先级就按照排队时候发放的序列号来比较</div><div class=\"line\">     * (在RequestQueue.java中的add()函数里会给每个加入到队列中的request发放一个sequence)</div><div class=\"line\">     */</div><div class=\"line\">    @Override</div><div class=\"line\">    public int compareTo(Request&lt;T&gt; other) &#123;</div><div class=\"line\">        Priority left = this.getPriority();</div><div class=\"line\">        Priority right = other.getPriority();</div><div class=\"line\"></div><div class=\"line\">        // High-priority requests are &quot;lesser&quot; so they are sorted to the front.</div><div class=\"line\">        // Equal priorities are sorted by sequence number to provide FIFO ordering.</div><div class=\"line\">        return left == right ?</div><div class=\"line\">                this.mSequence - other.mSequence :</div><div class=\"line\">                right.ordinal() - left.ordinal();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * 重写toString()方法</div><div class=\"line\">     * 提供在打印request的时候的一些数据</div><div class=\"line\">     * 也方便序列化</div><div class=\"line\">     */</div><div class=\"line\">    @Override</div><div class=\"line\">    public String toString() &#123;</div><div class=\"line\">        String trafficStatsTag = &quot;0x&quot; + Integer.toHexString(getTrafficStatsTag());</div><div class=\"line\">        return (mCanceled ? &quot;[X] &quot; : &quot;[ ] &quot;) + getUrl() + &quot; &quot; + trafficStatsTag + &quot; &quot;</div><div class=\"line\">                + getPriority() + &quot; &quot; + mSequence;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    private static long sCounter;</div><div class=\"line\">    /**</div><div class=\"line\">     *  sha1(Request:method:url:timestamp:counter)</div><div class=\"line\">     *</div><div class=\"line\">     * @param method http method</div><div class=\"line\">     * @param url               http request url</div><div class=\"line\">     * @return sha1 hash string</div><div class=\"line\">     */</div><div class=\"line\">    private static String createIdentifier(final int method, final String url) &#123;</div><div class=\"line\">        return InternalUtils.sha1Hash(&quot;Request:&quot; + method + &quot;:&quot; + url +</div><div class=\"line\">                &quot;:&quot; + System.currentTimeMillis() + &quot;:&quot; + (sCounter++));</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在<code>Request.java</code>的基础上，Volley示范性的扩展了<code>StringReuqest.java</code>以及<code>JSONArrayRequest.java</code>等等，在这里就不分析源代码了。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"Volley框架解析-七-—–Request解析\"><a href=\"#Volley框架解析-七-—–Request解析\" class=\"headerlink\" title=\"Volley框架解析(七)—–Request解析\"></a>Volley框架解析(七)—–Request解析</h1><h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h3><p>了解了request队列的调度程序，request结果的处理方式，以及request请求出错的处理方式，对请求结果进行缓存方面的工作等等。这篇博客就是专门分析<code>Request</code>了。</p>\n<h3 id=\"2-Request-java\"><a href=\"#2-Request-java\" class=\"headerlink\" title=\"2. Request.java\"></a>2. Request.java</h3><p>Volley封装的一个抽象类，Request.java提供了很大的便利性，可供我们自定义Request,之前在使用Volley的时候自定义了一些reuqest的，也总结过自定义request的方法，在这篇博客中有提到<a href=\"http://blog.csdn.net/jing_unique_da/article/details/45101331\" title=\"Volley使用技巧-----自定义Request\" target=\"_blank\" rel=\"noopener\">Volley使用技巧—–自定义Request</a>。下面就开始分析<code>Request.java</code>的源码。</p>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div><div class=\"line\">204</div><div class=\"line\">205</div><div class=\"line\">206</div><div class=\"line\">207</div><div class=\"line\">208</div><div class=\"line\">209</div><div class=\"line\">210</div><div class=\"line\">211</div><div class=\"line\">212</div><div class=\"line\">213</div><div class=\"line\">214</div><div class=\"line\">215</div><div class=\"line\">216</div><div class=\"line\">217</div><div class=\"line\">218</div><div class=\"line\">219</div><div class=\"line\">220</div><div class=\"line\">221</div><div class=\"line\">222</div><div class=\"line\">223</div><div class=\"line\">224</div><div class=\"line\">225</div><div class=\"line\">226</div><div class=\"line\">227</div><div class=\"line\">228</div><div class=\"line\">229</div><div class=\"line\">230</div><div class=\"line\">231</div><div class=\"line\">232</div><div class=\"line\">233</div><div class=\"line\">234</div><div class=\"line\">235</div><div class=\"line\">236</div><div class=\"line\">237</div><div class=\"line\">238</div><div class=\"line\">239</div><div class=\"line\">240</div><div class=\"line\">241</div><div class=\"line\">242</div><div class=\"line\">243</div><div class=\"line\">244</div><div class=\"line\">245</div><div class=\"line\">246</div><div class=\"line\">247</div><div class=\"line\">248</div><div class=\"line\">249</div><div class=\"line\">250</div><div class=\"line\">251</div><div class=\"line\">252</div><div class=\"line\">253</div><div class=\"line\">254</div><div class=\"line\">255</div><div class=\"line\">256</div><div class=\"line\">257</div><div class=\"line\">258</div><div class=\"line\">259</div><div class=\"line\">260</div><div class=\"line\">261</div><div class=\"line\">262</div><div class=\"line\">263</div><div class=\"line\">264</div><div class=\"line\">265</div><div class=\"line\">266</div><div class=\"line\">267</div><div class=\"line\">268</div><div class=\"line\">269</div><div class=\"line\">270</div><div class=\"line\">271</div><div class=\"line\">272</div><div class=\"line\">273</div><div class=\"line\">274</div><div class=\"line\">275</div><div class=\"line\">276</div><div class=\"line\">277</div><div class=\"line\">278</div><div class=\"line\">279</div><div class=\"line\">280</div><div class=\"line\">281</div><div class=\"line\">282</div><div class=\"line\">283</div><div class=\"line\">284</div><div class=\"line\">285</div><div class=\"line\">286</div><div class=\"line\">287</div><div class=\"line\">288</div><div class=\"line\">289</div><div class=\"line\">290</div><div class=\"line\">291</div><div class=\"line\">292</div><div class=\"line\">293</div><div class=\"line\">294</div><div class=\"line\">295</div><div class=\"line\">296</div><div class=\"line\">297</div><div class=\"line\">298</div><div class=\"line\">299</div><div class=\"line\">300</div><div class=\"line\">301</div><div class=\"line\">302</div><div class=\"line\">303</div><div class=\"line\">304</div><div class=\"line\">305</div><div class=\"line\">306</div><div class=\"line\">307</div><div class=\"line\">308</div><div class=\"line\">309</div><div class=\"line\">310</div><div class=\"line\">311</div><div class=\"line\">312</div><div class=\"line\">313</div><div class=\"line\">314</div><div class=\"line\">315</div><div class=\"line\">316</div><div class=\"line\">317</div><div class=\"line\">318</div><div class=\"line\">319</div><div class=\"line\">320</div><div class=\"line\">321</div><div class=\"line\">322</div><div class=\"line\">323</div><div class=\"line\">324</div><div class=\"line\">325</div><div class=\"line\">326</div><div class=\"line\">327</div><div class=\"line\">328</div><div class=\"line\">329</div><div class=\"line\">330</div><div class=\"line\">331</div><div class=\"line\">332</div><div class=\"line\">333</div><div class=\"line\">334</div><div class=\"line\">335</div><div class=\"line\">336</div><div class=\"line\">337</div><div class=\"line\">338</div><div class=\"line\">339</div><div class=\"line\">340</div><div class=\"line\">341</div><div class=\"line\">342</div><div class=\"line\">343</div><div class=\"line\">344</div><div class=\"line\">345</div><div class=\"line\">346</div><div class=\"line\">347</div><div class=\"line\">348</div><div class=\"line\">349</div><div class=\"line\">350</div><div class=\"line\">351</div><div class=\"line\">352</div><div class=\"line\">353</div><div class=\"line\">354</div><div class=\"line\">355</div><div class=\"line\">356</div><div class=\"line\">357</div><div class=\"line\">358</div><div class=\"line\">359</div><div class=\"line\">360</div><div class=\"line\">361</div><div class=\"line\">362</div><div class=\"line\">363</div><div class=\"line\">364</div><div class=\"line\">365</div><div class=\"line\">366</div><div class=\"line\">367</div><div class=\"line\">368</div><div class=\"line\">369</div><div class=\"line\">370</div><div class=\"line\">371</div><div class=\"line\">372</div><div class=\"line\">373</div><div class=\"line\">374</div><div class=\"line\">375</div><div class=\"line\">376</div><div class=\"line\">377</div><div class=\"line\">378</div><div class=\"line\">379</div><div class=\"line\">380</div><div class=\"line\">381</div><div class=\"line\">382</div><div class=\"line\">383</div><div class=\"line\">384</div><div class=\"line\">385</div><div class=\"line\">386</div><div class=\"line\">387</div><div class=\"line\">388</div><div class=\"line\">389</div><div class=\"line\">390</div><div class=\"line\">391</div><div class=\"line\">392</div><div class=\"line\">393</div><div class=\"line\">394</div><div class=\"line\">395</div><div class=\"line\">396</div><div class=\"line\">397</div><div class=\"line\">398</div><div class=\"line\">399</div><div class=\"line\">400</div><div class=\"line\">401</div><div class=\"line\">402</div><div class=\"line\">403</div><div class=\"line\">404</div><div class=\"line\">405</div><div class=\"line\">406</div><div class=\"line\">407</div><div class=\"line\">408</div><div class=\"line\">409</div><div class=\"line\">410</div><div class=\"line\">411</div><div class=\"line\">412</div><div class=\"line\">413</div><div class=\"line\">414</div><div class=\"line\">415</div><div class=\"line\">416</div><div class=\"line\">417</div><div class=\"line\">418</div><div class=\"line\">419</div><div class=\"line\">420</div><div class=\"line\">421</div><div class=\"line\">422</div><div class=\"line\">423</div><div class=\"line\">424</div><div class=\"line\">425</div><div class=\"line\">426</div><div class=\"line\">427</div><div class=\"line\">428</div><div class=\"line\">429</div><div class=\"line\">430</div><div class=\"line\">431</div><div class=\"line\">432</div><div class=\"line\">433</div><div class=\"line\">434</div><div class=\"line\">435</div><div class=\"line\">436</div><div class=\"line\">437</div><div class=\"line\">438</div><div class=\"line\">439</div><div class=\"line\">440</div><div class=\"line\">441</div><div class=\"line\">442</div><div class=\"line\">443</div><div class=\"line\">444</div><div class=\"line\">445</div><div class=\"line\">446</div><div class=\"line\">447</div><div class=\"line\">448</div><div class=\"line\">449</div><div class=\"line\">450</div><div class=\"line\">451</div><div class=\"line\">452</div><div class=\"line\">453</div><div class=\"line\">454</div><div class=\"line\">455</div><div class=\"line\">456</div><div class=\"line\">457</div><div class=\"line\">458</div><div class=\"line\">459</div><div class=\"line\">460</div><div class=\"line\">461</div><div class=\"line\">462</div><div class=\"line\">463</div><div class=\"line\">464</div><div class=\"line\">465</div><div class=\"line\">466</div><div class=\"line\">467</div><div class=\"line\">468</div><div class=\"line\">469</div><div class=\"line\">470</div><div class=\"line\">471</div><div class=\"line\">472</div><div class=\"line\">473</div><div class=\"line\">474</div><div class=\"line\">475</div><div class=\"line\">476</div><div class=\"line\">477</div><div class=\"line\">478</div><div class=\"line\">479</div><div class=\"line\">480</div><div class=\"line\">481</div><div class=\"line\">482</div><div class=\"line\">483</div><div class=\"line\">484</div><div class=\"line\">485</div><div class=\"line\">486</div><div class=\"line\">487</div><div class=\"line\">488</div><div class=\"line\">489</div><div class=\"line\">490</div><div class=\"line\">491</div><div class=\"line\">492</div><div class=\"line\">493</div><div class=\"line\">494</div><div class=\"line\">495</div><div class=\"line\">496</div><div class=\"line\">497</div><div class=\"line\">498</div><div class=\"line\">499</div><div class=\"line\">500</div><div class=\"line\">501</div><div class=\"line\">502</div><div class=\"line\">503</div><div class=\"line\">504</div><div class=\"line\">505</div><div class=\"line\">506</div><div class=\"line\">507</div><div class=\"line\">508</div><div class=\"line\">509</div><div class=\"line\">510</div><div class=\"line\">511</div><div class=\"line\">512</div><div class=\"line\">513</div><div class=\"line\">514</div><div class=\"line\">515</div><div class=\"line\">516</div><div class=\"line\">517</div><div class=\"line\">518</div><div class=\"line\">519</div><div class=\"line\">520</div><div class=\"line\">521</div><div class=\"line\">522</div><div class=\"line\">523</div><div class=\"line\">524</div><div class=\"line\">525</div><div class=\"line\">526</div><div class=\"line\">527</div><div class=\"line\">528</div><div class=\"line\">529</div><div class=\"line\">530</div><div class=\"line\">531</div><div class=\"line\">532</div><div class=\"line\">533</div><div class=\"line\">534</div><div class=\"line\">535</div><div class=\"line\">536</div><div class=\"line\">537</div><div class=\"line\">538</div><div class=\"line\">539</div><div class=\"line\">540</div><div class=\"line\">541</div><div class=\"line\">542</div><div class=\"line\">543</div><div class=\"line\">544</div><div class=\"line\">545</div><div class=\"line\">546</div><div class=\"line\">547</div><div class=\"line\">548</div><div class=\"line\">549</div><div class=\"line\">550</div><div class=\"line\">551</div><div class=\"line\">552</div><div class=\"line\">553</div><div class=\"line\">554</div><div class=\"line\">555</div><div class=\"line\">556</div><div class=\"line\">557</div><div class=\"line\">558</div><div class=\"line\">559</div><div class=\"line\">560</div><div class=\"line\">561</div><div class=\"line\">562</div><div class=\"line\">563</div><div class=\"line\">564</div><div class=\"line\">565</div><div class=\"line\">566</div><div class=\"line\">567</div><div class=\"line\">568</div><div class=\"line\">569</div><div class=\"line\">570</div><div class=\"line\">571</div><div class=\"line\">572</div><div class=\"line\">573</div><div class=\"line\">574</div><div class=\"line\">575</div><div class=\"line\">576</div><div class=\"line\">577</div><div class=\"line\">578</div><div class=\"line\">579</div><div class=\"line\">580</div><div class=\"line\">581</div><div class=\"line\">582</div><div class=\"line\">583</div><div class=\"line\">584</div><div class=\"line\">585</div><div class=\"line\">586</div><div class=\"line\">587</div><div class=\"line\">588</div><div class=\"line\">589</div><div class=\"line\">590</div><div class=\"line\">591</div><div class=\"line\">592</div><div class=\"line\">593</div><div class=\"line\">594</div><div class=\"line\">595</div><div class=\"line\">596</div><div class=\"line\">597</div><div class=\"line\">598</div><div class=\"line\">599</div><div class=\"line\">600</div><div class=\"line\">601</div><div class=\"line\">602</div><div class=\"line\">603</div><div class=\"line\">604</div><div class=\"line\">605</div><div class=\"line\">606</div><div class=\"line\">607</div><div class=\"line\">608</div><div class=\"line\">609</div><div class=\"line\">610</div><div class=\"line\">611</div><div class=\"line\">612</div><div class=\"line\">613</div><div class=\"line\">614</div><div class=\"line\">615</div><div class=\"line\">616</div><div class=\"line\">617</div><div class=\"line\">618</div><div class=\"line\">619</div><div class=\"line\">620</div><div class=\"line\">621</div><div class=\"line\">622</div><div class=\"line\">623</div><div class=\"line\">624</div><div class=\"line\">625</div><div class=\"line\">626</div><div class=\"line\">627</div><div class=\"line\">628</div><div class=\"line\">629</div><div class=\"line\">630</div><div class=\"line\">631</div><div class=\"line\">632</div><div class=\"line\">633</div><div class=\"line\">634</div><div class=\"line\">635</div><div class=\"line\">636</div><div class=\"line\">637</div><div class=\"line\">638</div><div class=\"line\">639</div><div class=\"line\">640</div><div class=\"line\">641</div><div class=\"line\">642</div><div class=\"line\">643</div><div class=\"line\">644</div><div class=\"line\">645</div><div class=\"line\">646</div><div class=\"line\">647</div><div class=\"line\">648</div><div class=\"line\">649</div><div class=\"line\">650</div><div class=\"line\">651</div><div class=\"line\">652</div><div class=\"line\">653</div><div class=\"line\">654</div><div class=\"line\">655</div><div class=\"line\">656</div><div class=\"line\">657</div><div class=\"line\">658</div><div class=\"line\">659</div><div class=\"line\">660</div><div class=\"line\">661</div><div class=\"line\">662</div><div class=\"line\">663</div><div class=\"line\">664</div><div class=\"line\">665</div><div class=\"line\">666</div><div class=\"line\">667</div><div class=\"line\">668</div><div class=\"line\">669</div><div class=\"line\">670</div><div class=\"line\">671</div><div class=\"line\">672</div><div class=\"line\">673</div><div class=\"line\">674</div><div class=\"line\">675</div><div class=\"line\">676</div><div class=\"line\">677</div><div class=\"line\">678</div><div class=\"line\">679</div><div class=\"line\">680</div><div class=\"line\">681</div><div class=\"line\">682</div><div class=\"line\">683</div><div class=\"line\">684</div><div class=\"line\">685</div><div class=\"line\">686</div><div class=\"line\">687</div><div class=\"line\">688</div><div class=\"line\">689</div><div class=\"line\">690</div><div class=\"line\">691</div><div class=\"line\">692</div><div class=\"line\">693</div><div class=\"line\">694</div><div class=\"line\">695</div><div class=\"line\">696</div><div class=\"line\">697</div><div class=\"line\">698</div><div class=\"line\">699</div><div class=\"line\">700</div><div class=\"line\">701</div><div class=\"line\">702</div><div class=\"line\">703</div><div class=\"line\">704</div><div class=\"line\">705</div><div class=\"line\">706</div><div class=\"line\">707</div><div class=\"line\">708</div><div class=\"line\">709</div><div class=\"line\">710</div><div class=\"line\">711</div><div class=\"line\">712</div><div class=\"line\">713</div><div class=\"line\">714</div><div class=\"line\">715</div><div class=\"line\">716</div><div class=\"line\">717</div><div class=\"line\">718</div><div class=\"line\">719</div><div class=\"line\">720</div><div class=\"line\">721</div><div class=\"line\">722</div><div class=\"line\">723</div><div class=\"line\">724</div><div class=\"line\">725</div><div class=\"line\">726</div><div class=\"line\">727</div><div class=\"line\">728</div><div class=\"line\">729</div><div class=\"line\">730</div><div class=\"line\">731</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * Base class for all network requests.</div><div class=\"line\"> * 在volley中涉及到的所有request的基础类</div><div class=\"line\"> *</div><div class=\"line\"> * @param &lt;T&gt; The type of parsed response this request expects.</div><div class=\"line\"> * 泛型类T是请求端希望服务器能返回的数据类型</div><div class=\"line\"> *</div><div class=\"line\"> * 关于其实现的一个Comparable接口，从字面上来看就是&quot;可比较的&quot;</div><div class=\"line\"> * 官方的解释如下：</div><div class=\"line\"> * This interface should be implemented by all classes that wish to define </div><div class=\"line\"> * a natural order of their instances. sort(List) and java.util.Arrays#sort </div><div class=\"line\"> * can then be used to automatically sort lists of classes that implement this interface.</div><div class=\"line\"> * 意思就是说如果你希望你的类在一个list中能够使用sort等函数自动排序的话，就实现这个接口吧= =</div><div class=\"line\"> * (需要重写里面的方法compareTo(), 里面是比较了两个request的优先级)</div><div class=\"line\"> */</div><div class=\"line\">public abstract class Request&lt;T&gt; implements Comparable&lt;Request&lt;T&gt;&gt; &#123;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Default encoding for POST or PUT parameters. See &#123;@link #getParamsEncoding()&#125;.</div><div class=\"line\">     * POST或者是PUT请求参数的默认编码格式 &quot;UTF-8&quot;</div><div class=\"line\">     */</div><div class=\"line\">    private static final String DEFAULT_PARAMS_ENCODING = &quot;UTF-8&quot;;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Supported request methods.</div><div class=\"line\">     * 支持的请求方式，有各种,常用的GET, POST, PUT应该是比较熟悉</div><div class=\"line\">     */</div><div class=\"line\">    public interface Method &#123;</div><div class=\"line\">        int DEPRECATED_GET_OR_POST = -1;</div><div class=\"line\">        int GET = 0;</div><div class=\"line\">        int POST = 1;</div><div class=\"line\">        int PUT = 2;</div><div class=\"line\">        int DELETE = 3;</div><div class=\"line\">        int HEAD = 4;</div><div class=\"line\">        int OPTIONS = 5;</div><div class=\"line\">        int TRACE = 6;</div><div class=\"line\">        int PATCH = 7;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * An event log tracing the lifetime of this request; for debugging. </div><div class=\"line\">     * 为了debug方便，volley弄了一套VolleyLog</div><div class=\"line\">     * 在一个request整个生命周期内不停的打出log</div><div class=\"line\">     * 都可以方便从log监控该request现在的情况</div><div class=\"line\">     */</div><div class=\"line\">    private final MarkerLog mEventLog = MarkerLog.ENABLED ? new MarkerLog() : null;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Request method of this request.  Currently supports GET, POST, PUT, DELETE, HEAD, OPTIONS,</div><div class=\"line\">     * TRACE, and PATCH.</div><div class=\"line\">     * 当前request涉及到的请求方式</div><div class=\"line\">     * 目前所支持的有GET, POST, PUT等</div><div class=\"line\">     */</div><div class=\"line\">    private final int mMethod;</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * URL of this request.</div><div class=\"line\">     * 原始Url</div><div class=\"line\">     */</div><div class=\"line\">    private final String mUrl;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * The redirect url to use for 3xx http responses </div><div class=\"line\">     * request重定向之后的url</div><div class=\"line\">     */</div><div class=\"line\">    private String mRedirectUrl;</div><div class=\"line\"></div><div class=\"line\">    /** The unique identifier of the request </div><div class=\"line\">     *  从后面可以看出在构造request的时候</div><div class=\"line\">     *  mIdentifier是通过createIdentifier()函数</div><div class=\"line\">     *  由传入的url和请求的method以及当前系统时间还有一个计数器counter构造出的</div><div class=\"line\">     *  独一无二的身份标识</div><div class=\"line\">     */</div><div class=\"line\">    private String mIdentifier;</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * Default tag for &#123;@link TrafficStats&#125;. </div><div class=\"line\">     * </div><div class=\"line\">     */</div><div class=\"line\">    private final int mDefaultTrafficStatsTag;</div><div class=\"line\"></div><div class=\"line\">    /** Listener interface for errors. */</div><div class=\"line\">    private final Response.ErrorListener mErrorListener;</div><div class=\"line\"></div><div class=\"line\">    /** Sequence number of this request, used to enforce FIFO ordering. */</div><div class=\"line\">    private Integer mSequence;</div><div class=\"line\"></div><div class=\"line\">    /** The request queue this request is associated with. */</div><div class=\"line\">    private RequestQueue mRequestQueue;</div><div class=\"line\"></div><div class=\"line\">    /** Whether or not responses to this request should be cached. */</div><div class=\"line\">    private boolean mShouldCache = true;</div><div class=\"line\"></div><div class=\"line\">    /** Whether or not this request has been canceled. */</div><div class=\"line\">    private boolean mCanceled = false;</div><div class=\"line\"></div><div class=\"line\">    /** Whether or not a response has been delivered for this request yet. */</div><div class=\"line\">    private boolean mResponseDelivered = false;</div><div class=\"line\"></div><div class=\"line\">    // A cheap variant of request tracing used to dump slow requests.</div><div class=\"line\">    private long mRequestBirthTime = 0;</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * Threshold at which we should log the request (even when debug logging is not enabled). </div><div class=\"line\">     * 用来判定是否打出将一个request打出slow_request的log的时间阀值</div><div class=\"line\">     * 如果request响应时间超过了这个阀值，则会打出log，说明一下情况</div><div class=\"line\">     */</div><div class=\"line\">    private static final long SLOW_REQUEST_THRESHOLD_MS = 3000;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * The retry policy for this request. </div><div class=\"line\">     * 在前面已经介绍到了，RetryPolicy.java及其默认实现类</div><div class=\"line\">     * 是用来处理request重新发送的一种策略，也就是重试方针</div><div class=\"line\">     * 里面记录着重试的最大次数以及当前重试了几次等</div><div class=\"line\">     */</div><div class=\"line\">    private RetryPolicy mRetryPolicy;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * When a request can be retrieved from cache but must be refreshed from</div><div class=\"line\">     * the network, the cache entry will be stored here so that in the event of</div><div class=\"line\">     * a &quot;Not Modified&quot; response, we can be sure it hasn&apos;t been evicted from cache.</div><div class=\"line\">     *</div><div class=\"line\">     * 当一个请求的结果有缓存但是需要从服务器刷新一下的时候</div><div class=\"line\">     * 缓存的入口，在向服务器发送条件请求时，服务器返回304之后</div><div class=\"line\">     * 就可以从这个缓存的入口找到该请求在本地对应的缓存数据了。= =直接拿来用咯</div><div class=\"line\">     */</div><div class=\"line\">    private Cache.Entry mCacheEntry = null;</div><div class=\"line\"></div><div class=\"line\">    /** An opaque token tagging this request; used for bulk cancellation. </div><div class=\"line\">     *  一个关于该request的不公开透明的token，用于批量取消</div><div class=\"line\">     * 在RequestQueue.java中会用到这个mTag</div><div class=\"line\">     * 用mTag可以取消request</div><div class=\"line\">     */</div><div class=\"line\">    private Object mTag;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Creates a new request with the given URL and error listener.  Note that</div><div class=\"line\">     * the normal response listener is not provided here as delivery of responses</div><div class=\"line\">     * is provided by subclasses, who have a better idea of how to deliver an</div><div class=\"line\">     * already-parsed response.</div><div class=\"line\">     *</div><div class=\"line\">     * 根据给定的url和errorListener创建一个新的request</div><div class=\"line\">     * 需要注意的是这里并没有涉及到responseListener方面的设置</div><div class=\"line\">     * 因为将其放在request的子类去设置能更好的去传递一个已经解析好了的response</div><div class=\"line\">     *</div><div class=\"line\">     * 这个方法已经不推荐使用了，推荐使用下面的一个构造方法，因为这个方法存在默认的method</div><div class=\"line\">     * 没有很大的自由度去自定义request</div><div class=\"line\">     *</div><div class=\"line\">     * @deprecated Use &#123;@link #Request(int, String, com.android.volley.Response.ErrorListener)&#125;.</div><div class=\"line\">     */</div><div class=\"line\">    @Deprecated</div><div class=\"line\">    public Request(String url, Response.ErrorListener listener) &#123;</div><div class=\"line\">        this(Method.DEPRECATED_GET_OR_POST, url, listener);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Creates a new request with the given method (one of the values from &#123;@link Method&#125;),</div><div class=\"line\">     * URL, and error listener.  Note that the normal response listener is not provided here as</div><div class=\"line\">     * delivery of responses is provided by subclasses, who have a better idea of how to deliver</div><div class=\"line\">     * an already-parsed response.</div><div class=\"line\">     * </div><div class=\"line\">     * setRetryPolicy()该方法设置了request所谓的“重试策略”。</div><div class=\"line\">     * 跳转到DefaultRetryPolicy.java(系列博客的第四篇---Volley框架解析(四))</div><div class=\"line\">     */</div><div class=\"line\">    public Request(int method, String url, Response.ErrorListener listener) &#123;</div><div class=\"line\">        mMethod = method;</div><div class=\"line\">        mUrl = url;</div><div class=\"line\">        mIdentifier = createIdentifier(method, url);</div><div class=\"line\">        mErrorListener = listener;</div><div class=\"line\">        setRetryPolicy(new DefaultRetryPolicy());</div><div class=\"line\"></div><div class=\"line\">        mDefaultTrafficStatsTag = findDefaultTrafficStatsTag(url);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Return the method for this request.  Can be one of the values in &#123;@link Method&#125;.</div><div class=\"line\">     */</div><div class=\"line\">    public int getMethod() &#123;</div><div class=\"line\">        return mMethod;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Set a tag on this request. Can be used to cancel all requests with this</div><div class=\"line\">     * tag by &#123;@link RequestQueue#cancelAll(Object)&#125;.</div><div class=\"line\">     *</div><div class=\"line\">     * 为了方便从网络请求队列里面取消request，可以通过打tag的方式</div><div class=\"line\">     * @return This Request object to allow for chaining.</div><div class=\"line\">     */</div><div class=\"line\">    public Request&lt;?&gt; setTag(Object tag) &#123;</div><div class=\"line\">        mTag = tag;</div><div class=\"line\">        return this;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Returns this request&apos;s tag.</div><div class=\"line\">     * @see Request#setTag(Object)</div><div class=\"line\">     */</div><div class=\"line\">    public Object getTag() &#123;</div><div class=\"line\">        return mTag;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * @return this request&apos;s &#123;@link com.android.volley.Response.ErrorListener&#125;.</div><div class=\"line\">     */</div><div class=\"line\">    public Response.ErrorListener getErrorListener() &#123;</div><div class=\"line\">        return mErrorListener;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * @return A tag for use with &#123;@link TrafficStats#setThreadStatsTag(int)&#125;</div><div class=\"line\">     */</div><div class=\"line\">    public int getTrafficStatsTag() &#123;</div><div class=\"line\">        return mDefaultTrafficStatsTag;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * @return The hashcode of the URL&apos;s host component, or 0 if there is none.</div><div class=\"line\">     * 返回了request的url中的host的hashcode</div><div class=\"line\">     */</div><div class=\"line\">    private static int findDefaultTrafficStatsTag(String url) &#123;</div><div class=\"line\">        if (!TextUtils.isEmpty(url)) &#123;</div><div class=\"line\">            Uri uri = Uri.parse(url);</div><div class=\"line\">            if (uri != null) &#123;</div><div class=\"line\">                String host = uri.getHost();</div><div class=\"line\">                if (host != null) &#123;</div><div class=\"line\">                    return host.hashCode();</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return 0;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Sets the retry policy for this request.</div><div class=\"line\">     * 给request设置重试策略</div><div class=\"line\">     * @return This Request object to allow for chaining.</div><div class=\"line\">     */</div><div class=\"line\">    public Request&lt;?&gt; setRetryPolicy(RetryPolicy retryPolicy) &#123;</div><div class=\"line\">        mRetryPolicy = retryPolicy;</div><div class=\"line\">        return this;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Adds an event to this request&apos;s event log; for debugging.</div><div class=\"line\">     */</div><div class=\"line\">    public void addMarker(String tag) &#123;</div><div class=\"line\">        if (MarkerLog.ENABLED) &#123;</div><div class=\"line\">            mEventLog.add(tag, Thread.currentThread().getId());</div><div class=\"line\">        &#125; else if (mRequestBirthTime == 0) &#123;</div><div class=\"line\">            mRequestBirthTime = SystemClock.elapsedRealtime();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Notifies the request queue that this request has finished (successfully or with error).</div><div class=\"line\">     * 该函数用来告诉request队列，当前的request已经完成了(包括成功和失败)</div><div class=\"line\">     * &lt;p&gt;Also dumps all events from this request&apos;s event log; for debugging.&lt;/p&gt;</div><div class=\"line\">     */</div><div class=\"line\">    void finish(final String tag) &#123;</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * 告诉RequestQueue，这个tag对应的request已经结束了</div><div class=\"line\">         * ReuqestQueue会将这个request移出队列</div><div class=\"line\">         * 并将具有相同cacheKey的等待中reuqest全部移除</div><div class=\"line\">         */</div><div class=\"line\">        if (mRequestQueue != null) &#123;</div><div class=\"line\">            mRequestQueue.finish(this);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * 如果允许打出log</div><div class=\"line\">         * 则log提示这个request已经结束了</div><div class=\"line\">         */</div><div class=\"line\">        if (MarkerLog.ENABLED) &#123;</div><div class=\"line\">            final long threadId = Thread.currentThread().getId();</div><div class=\"line\">            if (Looper.myLooper() != Looper.getMainLooper()) &#123;</div><div class=\"line\">                // If we finish marking off of the main thread, we need to</div><div class=\"line\">                // actually do it on the main thread to ensure correct ordering.</div><div class=\"line\">                Handler mainThread = new Handler(Looper.getMainLooper());</div><div class=\"line\">                mainThread.post(new Runnable() &#123;</div><div class=\"line\">                    @Override</div><div class=\"line\">                    public void run() &#123;</div><div class=\"line\">                        mEventLog.add(tag, threadId);</div><div class=\"line\">                        mEventLog.finish(this.toString());</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;);</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            mEventLog.add(tag, threadId);</div><div class=\"line\">            mEventLog.finish(this.toString());</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            long requestTime = SystemClock.elapsedRealtime() - mRequestBirthTime;</div><div class=\"line\">            if (requestTime &gt;= SLOW_REQUEST_THRESHOLD_MS) &#123;</div><div class=\"line\">                VolleyLog.d(&quot;%d ms: %s&quot;, requestTime, this.toString());</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Associates this request with the given queue. The request queue will be notified when this</div><div class=\"line\">     * request has finished.</div><div class=\"line\">     * </div><div class=\"line\">     * 将和request相关的那个RequestQueue与request关联起来</div><div class=\"line\">     * 持有一个对象的引用</div><div class=\"line\">     * 在request结束的时候好通知RequestQueue</div><div class=\"line\">     * </div><div class=\"line\">     * @return This Request object to allow for chaining.</div><div class=\"line\">     */</div><div class=\"line\">    public Request&lt;?&gt; setRequestQueue(RequestQueue requestQueue) &#123;</div><div class=\"line\">        mRequestQueue = requestQueue;</div><div class=\"line\">        return this;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Sets the sequence number of this request.  Used by &#123;@link RequestQueue&#125;.</div><div class=\"line\">     * 在RequestQueue中调用，request加入到RequestQueue的时候</div><div class=\"line\">     * 需要开始排队等待处理</div><div class=\"line\">     * 这个函数的作用就是发号码牌给每个request(排队专用，想的还比较周到= =)</div><div class=\"line\">     * @return This Request object to allow for chaining.</div><div class=\"line\">     */</div><div class=\"line\">    public final Request&lt;?&gt; setSequence(int sequence) &#123;</div><div class=\"line\">        mSequence = sequence;</div><div class=\"line\">        return this;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Returns the sequence number of this request.</div><div class=\"line\">     */</div><div class=\"line\">    public final int getSequence() &#123;</div><div class=\"line\">        if (mSequence == null) &#123;</div><div class=\"line\">            throw new IllegalStateException(&quot;getSequence called before setSequence&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        return mSequence;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Returns the URL of this request.</div><div class=\"line\">     * 返回真实访问的url,如果有重定向出现</div><div class=\"line\">     * 则真实url是重定向后的url</div><div class=\"line\">     * 否则是原始的url</div><div class=\"line\">     */</div><div class=\"line\">    public String getUrl() &#123;</div><div class=\"line\">        return (mRedirectUrl != null) ? mRedirectUrl : mUrl;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Returns the URL of the request before any redirects have occurred.</div><div class=\"line\">     * 返回最原始的url,在任何重定向发生之前</div><div class=\"line\">     */</div><div class=\"line\">    public String getOriginUrl() &#123;</div><div class=\"line\">        return mUrl;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Returns the identifier of the request.</div><div class=\"line\">     */</div><div class=\"line\">    public String getIdentifier() &#123;</div><div class=\"line\">        return mIdentifier;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Sets the redirect url to handle 3xx http responses.</div><div class=\"line\">     * 发生重定向之后可以通过该函数来设置重定向后的url</div><div class=\"line\">     */</div><div class=\"line\">    public void setRedirectUrl(String redirectUrl) &#123;</div><div class=\"line\">        mRedirectUrl = redirectUrl;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Returns the cache key for this request.  </div><div class=\"line\">     * By default, this is the URL.</div><div class=\"line\">     * 默认使用url来作为cacheKey</div><div class=\"line\">     */</div><div class=\"line\">    public String getCacheKey() &#123;</div><div class=\"line\">        return getUrl();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Annotates this request with an entry retrieved for it from cache.</div><div class=\"line\">     * Used for cache coherency support.</div><div class=\"line\">     * </div><div class=\"line\">     * @return This Request object to allow for chaining.</div><div class=\"line\">     */</div><div class=\"line\">    public Request&lt;?&gt; setCacheEntry(Cache.Entry entry) &#123;</div><div class=\"line\">        mCacheEntry = entry;</div><div class=\"line\">        return this;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Returns the annotated cache entry, or null if there isn&apos;t one.</div><div class=\"line\">     */</div><div class=\"line\">    public Cache.Entry getCacheEntry() &#123;</div><div class=\"line\">        return mCacheEntry;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Mark this request as canceled.  No callback will be delivered.</div><div class=\"line\">     */</div><div class=\"line\">    public void cancel() &#123;</div><div class=\"line\">        mCanceled = true;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Returns true if this request has been canceled.</div><div class=\"line\">     */</div><div class=\"line\">    public boolean isCanceled() &#123;</div><div class=\"line\">        return mCanceled;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Returns a list of extra HTTP headers to go along with this request. Can</div><div class=\"line\">     * throw &#123;@link AuthFailureError&#125; as authentication may be required to</div><div class=\"line\">     * provide these values.</div><div class=\"line\">     * 返回在Request中的HTTPheader，这个里面存放了一些关于Request的基本信息</div><div class=\"line\">     * 例如请求方式，cookie等东西</div><div class=\"line\">     * @throws AuthFailureError In the event of auth failure</div><div class=\"line\">     */</div><div class=\"line\">    public Map&lt;String, String&gt; getHeaders() throws AuthFailureError &#123;</div><div class=\"line\">        return Collections.emptyMap();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Returns a Map of POST parameters to be used for this request, or null if</div><div class=\"line\">     * a simple GET should be used.  Can throw &#123;@link AuthFailureError&#125; as</div><div class=\"line\">     * authentication may be required to provide these values.</div><div class=\"line\">     * 返回request中用于POST请求的一些参数</div><div class=\"line\">     * 这些参数以键值对的形式存在，如果是GET方法，则传回Null</div><div class=\"line\">     *　</div><div class=\"line\">     * &lt;p&gt;Note that only one of getPostParams() and getPostBody() can return a non-null</div><div class=\"line\">     * value.&lt;/p&gt;</div><div class=\"line\">     * @throws AuthFailureError In the event of auth failure</div><div class=\"line\">     *</div><div class=\"line\">     * @deprecated Use &#123;@link #getParams()&#125; instead.</div><div class=\"line\">     */</div><div class=\"line\">    @Deprecated</div><div class=\"line\">    protected Map&lt;String, String&gt; getPostParams() throws AuthFailureError &#123;</div><div class=\"line\">        return getParams();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Returns which encoding should be used when converting POST parameters returned by</div><div class=\"line\">     * &#123;@link #getPostParams()&#125; into a raw POST body.</div><div class=\"line\">     * </div><div class=\"line\">     * </div><div class=\"line\">     * &lt;p&gt;This controls both encodings:</div><div class=\"line\">     * &lt;ol&gt;</div><div class=\"line\">     *     &lt;li&gt;The string encoding used when converting parameter names and values into bytes prior</div><div class=\"line\">     *         to URL encoding them.&lt;/li&gt;</div><div class=\"line\">     *     &lt;li&gt;The string encoding used when converting the URL encoded parameters into a raw</div><div class=\"line\">     *         byte array.&lt;/li&gt;</div><div class=\"line\">     * &lt;/ol&gt;</div><div class=\"line\">     *</div><div class=\"line\">     * @deprecated Use &#123;@link #getParamsEncoding()&#125; instead.</div><div class=\"line\">     */</div><div class=\"line\">    @Deprecated</div><div class=\"line\">    protected String getPostParamsEncoding() &#123;</div><div class=\"line\">        return getParamsEncoding();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * @deprecated Use &#123;@link #getBodyContentType()&#125; instead.</div><div class=\"line\">     * 返回请求体的内容种类</div><div class=\"line\">     * 包括application/json等内容</div><div class=\"line\">     */</div><div class=\"line\">    @Deprecated</div><div class=\"line\">    public String getPostBodyContentType() &#123;</div><div class=\"line\">        return getBodyContentType();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Returns the raw POST body to be sent.</div><div class=\"line\">     * 该函数被建议不要使用了，用getBody代替</div><div class=\"line\">     * </div><div class=\"line\">     * @throws AuthFailureError In the event of auth failure</div><div class=\"line\">     *</div><div class=\"line\">     * @deprecated Use &#123;@link #getBody()&#125; instead.</div><div class=\"line\">     */</div><div class=\"line\">    @Deprecated</div><div class=\"line\">    public byte[] getPostBody() throws AuthFailureError &#123;</div><div class=\"line\">        // Note: For compatibility with legacy clients of volley, this implementation must remain</div><div class=\"line\">        // here instead of simply calling the getBody() function because this function must</div><div class=\"line\">        // call getPostParams() and getPostParamsEncoding() since legacy clients would have</div><div class=\"line\">        // overridden these two member functions for POST requests.</div><div class=\"line\">        Map&lt;String, String&gt; postParams = getPostParams();</div><div class=\"line\">        if (postParams != null &amp;&amp; postParams.size() &gt; 0) &#123;</div><div class=\"line\">            return encodeParameters(postParams, getPostParamsEncoding());</div><div class=\"line\">        &#125;</div><div class=\"line\">        return null;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Returns a Map of parameters to be used for a POST or PUT request.  Can throw</div><div class=\"line\">     * &#123;@link AuthFailureError&#125; as authentication may be required to provide these values.</div><div class=\"line\">     *</div><div class=\"line\">     * &lt;p&gt;Note that you can directly override &#123;@link #getBody()&#125; for custom data.&lt;/p&gt;</div><div class=\"line\">     *</div><div class=\"line\">     * @throws AuthFailureError in the event of auth failure</div><div class=\"line\">     */</div><div class=\"line\">    protected Map&lt;String, String&gt; getParams() throws AuthFailureError &#123;</div><div class=\"line\">        return null;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Returns which encoding should be used when converting POST or PUT parameters returned by</div><div class=\"line\">     * &#123;@link #getParams()&#125; into a raw POST or PUT body.</div><div class=\"line\">     *</div><div class=\"line\">     * &lt;p&gt;This controls both encodings:</div><div class=\"line\">     * &lt;ol&gt;</div><div class=\"line\">     *     &lt;li&gt;The string encoding used when converting parameter names and values into bytes prior</div><div class=\"line\">     *         to URL encoding them.&lt;/li&gt;</div><div class=\"line\">     *     &lt;li&gt;The string encoding used when converting the URL encoded parameters into a raw</div><div class=\"line\">     *         byte array.&lt;/li&gt;</div><div class=\"line\">     * &lt;/ol&gt;</div><div class=\"line\">     */</div><div class=\"line\">    protected String getParamsEncoding() &#123;</div><div class=\"line\">        return DEFAULT_PARAMS_ENCODING;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Returns the content type of the POST or PUT body.</div><div class=\"line\">     * 返回请求体的内容种类</div><div class=\"line\">     */</div><div class=\"line\">    public String getBodyContentType() &#123;</div><div class=\"line\">        return &quot;application/x-www-form-urlencoded; charset=&quot; + getParamsEncoding();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Returns the raw POST or PUT body to be sent.</div><div class=\"line\">     * 返回将要发送的request的POST主体</div><div class=\"line\">     * </div><div class=\"line\">     * &lt;p&gt;By default, the body consists of the request parameters in</div><div class=\"line\">     * application/x-www-form-urlencoded format. When overriding this method, consider overriding</div><div class=\"line\">     * &#123;@link #getBodyContentType()&#125; as well to match the new body format.</div><div class=\"line\">     *</div><div class=\"line\">     * @throws AuthFailureError in the event of auth failure</div><div class=\"line\">     */</div><div class=\"line\">    public byte[] getBody() throws AuthFailureError &#123;</div><div class=\"line\">        Map&lt;String, String&gt; params = getParams();</div><div class=\"line\">        if (params != null &amp;&amp; params.size() &gt; 0) &#123;</div><div class=\"line\">            return encodeParameters(params, getParamsEncoding());</div><div class=\"line\">        &#125;</div><div class=\"line\">        return null;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Converts &lt;code&gt;params&lt;/code&gt; into an application/x-www-form-urlencoded encoded string.</div><div class=\"line\">     * 将请求里面包含的参数转码</div><div class=\"line\">     */</div><div class=\"line\">    private byte[] encodeParameters(Map&lt;String, String&gt; params, String paramsEncoding) &#123;</div><div class=\"line\">        StringBuilder encodedParams = new StringBuilder();</div><div class=\"line\">        try &#123;</div><div class=\"line\">            for (Map.Entry&lt;String, String&gt; entry : params.entrySet()) &#123;</div><div class=\"line\">                encodedParams.append(URLEncoder.encode(entry.getKey(), paramsEncoding));</div><div class=\"line\">                encodedParams.append(&apos;=&apos;);</div><div class=\"line\">                encodedParams.append(URLEncoder.encode(entry.getValue(), paramsEncoding));</div><div class=\"line\">                encodedParams.append(&apos;&amp;&apos;);</div><div class=\"line\">            &#125;</div><div class=\"line\">            return encodedParams.toString().getBytes(paramsEncoding);</div><div class=\"line\">        &#125; catch (UnsupportedEncodingException uee) &#123;</div><div class=\"line\">            throw new RuntimeException(&quot;Encoding not supported: &quot; + paramsEncoding, uee);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Set whether or not responses to this request should be cached.</div><div class=\"line\">     *</div><div class=\"line\">     * @return This Request object to allow for chaining.</div><div class=\"line\">     */</div><div class=\"line\">    public final Request&lt;?&gt; setShouldCache(boolean shouldCache) &#123;</div><div class=\"line\">        mShouldCache = shouldCache;</div><div class=\"line\">        return this;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Returns true if responses to this request should be cached.</div><div class=\"line\">     */</div><div class=\"line\">    public final boolean shouldCache() &#123;</div><div class=\"line\">        return mShouldCache;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Priority values.  Requests will be processed from higher priorities to</div><div class=\"line\">     * lower priorities, in FIFO order.</div><div class=\"line\">     * request将按照优先级从高到低，先进先出的顺序被处理</div><div class=\"line\">     */</div><div class=\"line\">    public enum Priority &#123;</div><div class=\"line\">        LOW,</div><div class=\"line\">        NORMAL,</div><div class=\"line\">        HIGH,</div><div class=\"line\">        IMMEDIATE</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Returns the &#123;@link Priority&#125; of this request; &#123;@link Priority#NORMAL&#125; by default.</div><div class=\"line\">     * 返回request的优先级</div><div class=\"line\">     * 默认为normal</div><div class=\"line\">     */</div><div class=\"line\">    public Priority getPriority() &#123;</div><div class=\"line\">        return Priority.NORMAL;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Returns the socket timeout in milliseconds per retry attempt. (This value can be changed</div><div class=\"line\">     * per retry attempt if a backoff is specified via backoffTimeout()). If there are no retry</div><div class=\"line\">     * attempts remaining, this will cause delivery of a &#123;@link TimeoutError&#125; error.</div><div class=\"line\">     * 返回每次超时请求时间阀值</div><div class=\"line\">     * 每次retry如果返回的是请求超时的结果，则timeout会逐渐变大</div><div class=\"line\">     * 如果</div><div class=\"line\">     */</div><div class=\"line\">    public final int getTimeoutMs() &#123;</div><div class=\"line\">        return mRetryPolicy.getCurrentTimeout();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Returns the retry policy that should be used  for this request.</div><div class=\"line\">     */</div><div class=\"line\">    public RetryPolicy getRetryPolicy() &#123;</div><div class=\"line\">        return mRetryPolicy;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Mark this request as having a response delivered on it.  This can be used</div><div class=\"line\">     * later in the request&apos;s lifetime for suppressing identical responses.</div><div class=\"line\">     */</div><div class=\"line\">    public void markDelivered() &#123;</div><div class=\"line\">        mResponseDelivered = true;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Returns true if this request has had a response delivered for it.</div><div class=\"line\">     */</div><div class=\"line\">    public boolean hasHadResponseDelivered() &#123;</div><div class=\"line\">        return mResponseDelivered;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Subclasses must implement this to parse the raw network response</div><div class=\"line\">     * and return an appropriate response type. This method will be</div><div class=\"line\">     * called from a worker thread.  The response will not be delivered</div><div class=\"line\">     * if you return null.</div><div class=\"line\">     * 子类必须要实现这个方法来解析network response并返回一个合适的返回类型</div><div class=\"line\">     * </div><div class=\"line\">     * @param response Response from the network</div><div class=\"line\">     * @return The parsed response, or null in the case of an error</div><div class=\"line\">     */</div><div class=\"line\">    abstract protected Response&lt;T&gt; parseNetworkResponse(NetworkResponse response);</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Subclasses can override this method to parse &apos;networkError&apos; and return a more specific error.</div><div class=\"line\">     * 子类重写这个方法，来解析networkError</div><div class=\"line\">     * &lt;p&gt;The default implementation just returns the passed &apos;networkError&apos;.&lt;/p&gt;</div><div class=\"line\">     *</div><div class=\"line\">     * @param volleyError the error retrieved from the network</div><div class=\"line\">     * @return an NetworkError augmented with additional information</div><div class=\"line\">     */</div><div class=\"line\">    protected VolleyError parseNetworkError(VolleyError volleyError) &#123;</div><div class=\"line\">        return volleyError;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Subclasses must implement this to perform delivery of the parsed</div><div class=\"line\">     * response to their listeners.  The given response is guaranteed to</div><div class=\"line\">     * be non-null; responses that fail to parse are not delivered.</div><div class=\"line\">     *</div><div class=\"line\">     * 子类必须实现这个方法来传递一个解析好了的response</div><div class=\"line\">     *</div><div class=\"line\">     * @param response The parsed response returned by</div><div class=\"line\">     * &#123;@link #parseNetworkResponse(NetworkResponse)&#125;</div><div class=\"line\">     */</div><div class=\"line\">    abstract protected void deliverResponse(T response);</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Delivers error message to the ErrorListener that the Request was</div><div class=\"line\">     * initialized with.</div><div class=\"line\">     *</div><div class=\"line\">     * @param error Error details</div><div class=\"line\">     */</div><div class=\"line\">    public void deliverError(VolleyError error) &#123;</div><div class=\"line\">        if (mErrorListener != null) &#123;</div><div class=\"line\">            mErrorListener.onErrorResponse(error);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Our comparator sorts from high to low priority, and secondarily by</div><div class=\"line\">     * sequence number to provide FIFO ordering.</div><div class=\"line\">     * Request类实现了Comparable类</div><div class=\"line\">     * 需要重写compareTo()方法</div><div class=\"line\">     * 来达到能够将两个request相互比较的目的</div><div class=\"line\">     * 这里面的比较策略是通过看两request的优先级大小</div><div class=\"line\">     * 高优先级的排在前面，相等的优先级就按照排队时候发放的序列号来比较</div><div class=\"line\">     * (在RequestQueue.java中的add()函数里会给每个加入到队列中的request发放一个sequence)</div><div class=\"line\">     */</div><div class=\"line\">    @Override</div><div class=\"line\">    public int compareTo(Request&lt;T&gt; other) &#123;</div><div class=\"line\">        Priority left = this.getPriority();</div><div class=\"line\">        Priority right = other.getPriority();</div><div class=\"line\"></div><div class=\"line\">        // High-priority requests are &quot;lesser&quot; so they are sorted to the front.</div><div class=\"line\">        // Equal priorities are sorted by sequence number to provide FIFO ordering.</div><div class=\"line\">        return left == right ?</div><div class=\"line\">                this.mSequence - other.mSequence :</div><div class=\"line\">                right.ordinal() - left.ordinal();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * 重写toString()方法</div><div class=\"line\">     * 提供在打印request的时候的一些数据</div><div class=\"line\">     * 也方便序列化</div><div class=\"line\">     */</div><div class=\"line\">    @Override</div><div class=\"line\">    public String toString() &#123;</div><div class=\"line\">        String trafficStatsTag = &quot;0x&quot; + Integer.toHexString(getTrafficStatsTag());</div><div class=\"line\">        return (mCanceled ? &quot;[X] &quot; : &quot;[ ] &quot;) + getUrl() + &quot; &quot; + trafficStatsTag + &quot; &quot;</div><div class=\"line\">                + getPriority() + &quot; &quot; + mSequence;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    private static long sCounter;</div><div class=\"line\">    /**</div><div class=\"line\">     *  sha1(Request:method:url:timestamp:counter)</div><div class=\"line\">     *</div><div class=\"line\">     * @param method http method</div><div class=\"line\">     * @param url               http request url</div><div class=\"line\">     * @return sha1 hash string</div><div class=\"line\">     */</div><div class=\"line\">    private static String createIdentifier(final int method, final String url) &#123;</div><div class=\"line\">        return InternalUtils.sha1Hash(&quot;Request:&quot; + method + &quot;:&quot; + url +</div><div class=\"line\">                &quot;:&quot; + System.currentTimeMillis() + &quot;:&quot; + (sCounter++));</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在<code>Request.java</code>的基础上，Volley示范性的扩展了<code>StringReuqest.java</code>以及<code>JSONArrayRequest.java</code>等等，在这里就不分析源代码了。</p>"},{"title":"Volley框架解析(三)Dispatcher解析","date":"2017-03-01T15:53:47.000Z","_content":"\n## Volley框架解析(三)-----Dispatcher解析\n\n</header>\n\n<div class=\"article-entry\" itemprop=\"articleBody\">\n\n### [](#u9898_u5916_u8BDD_28_u53EF_u76F4_u63A5_u65E0_u89C6_uFF0C_u8DF3_u8FC7_7E \"题外话(可直接无视，跳过~\")题外话(可直接无视，跳过~\n\n在上一篇博客中结合volley源代码分析了`Volley.java`和`RequestQueue.java`这两个类，不知道代码全贴上去了，会不会看着很烦的嗯= =，当时看源代码的时候心里就有些不淡定，满屏幕看不懂的东西，但是个人觉得源代码和注释一起看才方便，一段代码一段解释会感觉有点摸不着头脑= =。前面的博客中一直提到了`Dispatcher`这种的东西，有`mNetworkDispatcher`和`mCacheDispatcher`之类的，这篇博客就开始进一步的介绍Volley中的Dispatcher。\n\n<!--more-->\n\n***\n\n<a id=\"more\"></a>\n\n### [](#1-__u7B80_u4ECB \"1\\. 简介\")1\\. 简介\n\n在Volley中涉及到了两类的Dispatcher,一类是涉及到缓存的`CacheDispatcher.java`，另外一类是用来处理网络方面request的`NetworkDispatcher.java`，最开始出现这两个Dispatcher是在`RequestQueue#start()`中，再来回顾一下start方法中的代码：\n\n```\npublic void start() {\n    stop();  // Make sure any currently running dispatchers are stopped.\n    // Create the cache dispatcher and start it.\n    mCacheDispatcher = new CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);\n    mCacheDispatcher.start();\n\n    // Create network dispatchers (and corresponding threads) up to the pool size.\n    for (int i = 0; i < mDispatchers.length; i++) {\n        NetworkDispatcher networkDispatcher = new NetworkDispatcher(mNetworkQueue, mNetwork,\n                mCache, mDelivery);\n        mDispatchers[i] = networkDispatcher;\n        networkDispatcher.start();\n    }\n}\n\n```\n\n先暂停了所有的dispatcher，然后又新建了dispatcher并start()。让dispatcher开始工作，实际上这些dispatcher继承了Thread类，是独立于主线程之外的工作线程，这样可以使RequestQueue中request的加入和处理同时进行。下面就结合CacheDispatcher和NetworkDispatcher两个类的代码来分析,Volley中是如何对request来进行调度和处理的。\n\n### [](#2-_CacheDispatcher-java \"2\\. CacheDispatcher.java\")2\\. CacheDispatcher.java\n\n```\npackage com.android.volley;\n\nimport android.os.Process;\n\nimport java.util.concurrent.BlockingQueue;\n\n/**\n * Provides a thread for performing cache triage on a queue of requests.\n * 提供一个用来处理涉及到缓存的requests的线程\n * \n * Requests added to the specified cache queue are resolved from cache.\n * Any deliverable response is posted back to the caller via a\n * {@link ResponseDelivery}.  Cache misses and responses that require\n * refresh are enqueued on the specified network queue for processing\n * by a {@link NetworkDispatcher}.\n * CacheDispatcher用来处理缓存队列里面(mCacheQueue)中的request\n * 任何符合delivery要求的response都会被通过ResponseDelivery的接口传递给caller\n * 有些cache丢失了或者是cache中的数据需要更新的，都将会交给NetworkDispatcher去处理\n * 交给NetworkDispatcher处理的方法就是直接放到mNetworkQueue中去\n * 因为NetworkDispatcher总是从mNetworkQueue中取出request来进行处理的\n */\n\npublic class CacheDispatcher extends Thread {\n\n    private static final boolean DEBUG = VolleyLog.DEBUG;\n\n    /** \n     * The queue of requests coming in for triage. \n     * 将要被处理的涉及到缓存的Request存放在这个阻塞队列里\n     * 等着咯，这个mCacheQueue和RequestQueue中的mCacheQueue指向的队列是同一个\n     * 也就是说整个Volley在运行的时候只有一个mCacheQueue\n     */\n    private final BlockingQueue<Request<?>> mCacheQueue;\n\n    /** \n     * The queue of requests going out to the network. \n     * 这个阻塞队里里面存着的可是要去进行网络访问的request\n     * 开始还不明白这里不应该是涉及到访问缓存的request\n     * 怎么有个这东西出来了，其实看到后面了就会发现，缓存里面有两个过期时间\n     * 在后面会介绍到Cache.java类，Cache.Entry类中涉及到了\n     * ttl 和 softTtl这两个long型的数据，用来标识缓存是否已经过期了\n     * 或者是否需要去检查是否要更新缓存的两个间隔时间\n     */\n    private final BlockingQueue<Request<?>> mNetworkQueue;\n\n    /** \n     * The cache to read from. \n     * 用于读写缓存的接口\n     * 这个接口也是在Volley中只有一个\n     * mCacheDispatcher和mNetworkDispatcher公用的\n     */\n    private final Cache mCache;\n\n    /** \n     * For posting responses. \n     * ResponseDelivery对象引用，用来将request的结果传递给caller\n     * 在NetworkDispatcher里面也有出现\n     * 这个也是从RequestQueue中传递过来的，公用\n     */\n    private final ResponseDelivery mDelivery;\n\n    /** \n     * Used for telling us to die. \n     * 直译 ： 用来告诉我们去死= = (shit)\n     * 然而 ： 这个变量用来标志这个dispatcher是否要继续工作下去\n     * 如果为true就结束本线程中的死循环\n     */\n    private volatile boolean mQuit = false;\n\n    /**\n     * Creates a new cache triage dispatcher thread.  You must call {@link #start()}\n     * in order to begin processing.\n     * 构造函数咯，创建一个存放需要访问缓存的request的调度线程\n     * 在创建之后需要将其用start()启动\n     * \n     * @param cacheQueue Queue of incoming requests for triage\n     * 存放request的缓存队列\n     * @param networkQueue Queue to post requests that require network to\n     * 存放涉及network的网络队列\n     * @param cache Cache interface to use for resolution\n     * 用来处理缓存读写问题的接口\n     * @param delivery Delivery interface to use for posting responses\n     * 用来反馈结果的接口\n     */\n    public CacheDispatcher(\n            BlockingQueue<Request<?>> cacheQueue, BlockingQueue<Request<?>> networkQueue,\n            Cache cache, ResponseDelivery delivery) {\n        mCacheQueue = cacheQueue;\n        mNetworkQueue = networkQueue;\n        mCache = cache;\n        mDelivery = delivery;\n    }\n\n    /**\n     * Forces this dispatcher to quit immediately.  If any requests are still in\n     * the queue, they are not guaranteed to be processed.\n     * 将标志位mQuit置为true,在每次死循环的最后会判断该标志位\n     */\n    public void quit() {\n        mQuit = true;\n        interrupt();\n    }\n\n    /**\n     * 前面提到了CacheDispatcher继承了Thread类\n     * 这里就重写了run()方法\n     * 当外面调用了mCacheDispatcher.start()之后\n     * run()里面的方法就开始执行了\n     */\n    @Override\n    public void run() {\n\n        if (DEBUG) VolleyLog.v(\"start new dispatcher\");\n        /**\n         * 给自己设置了线程的优先级\n         * THREAD_PRIORITY_BACKGROUND的优先级是0x0000000a(也就是10)\n         * 还有其他的很多种优先级，该优先级处于较高的位置\n         */\n        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);\n\n        /**\n         * Make a blocking call to initialize the cache.\n         * 在读写缓存之前做一些初始化工作，例如扫描缓存目录是否存在等\n         * 这个暂时先不用管里面的内容，等介绍到Cache.java的时候就会明白\n         */\n        mCache.initialize();\n\n        /**\n         * 从这里开始就进入了死循环的状态\n         * 除非出现了什么没有catch的exception\n         * 或者是mQuit标志位被置成了true\n         * 这个死循环将一直进行下去= =\n         * 总感觉有什么不妥的地方，感觉死循环怪怪的噢\n         */\n        while (true) {\n            /**\n             * 和NetworkDispatcher里面的流程没有什么太大的变化\n             * 还是一个死循环不停的从CacheQueue中取出Request\n             */\n            try {\n                /**\n                 * Get a request from the cache triage queue, blocking until\n                 * at least one is available.\n                 * 从缓存request队列里面取出等待处理的request\n                 * 如果没有可取出的request，则会在这里阻塞\n                 * 这个是PriorityBlockingQueue#take()函数的作用\n                 * \n                 */\n                final Request<?> request = mCacheQueue.take();\n\n                /**\n                 * 给每个request添加上一个打log的标志\n                 * 为了debug的需要\n                 */\n                request.addMarker(\"cache-queue-take\");\n\n                /**\n                 * If the request has been canceled, don't bother dispatching it.\n                 * 如果正在处理的这个请求被取消了\n                 * 中断对该request的处理，continue去处理下一个request的调度\n                 * 调用Request#finish()方法，传入的参数是为了debug方便，打出request调度进度的log\n                 */\n                if (request.isCanceled()) {\n                    request.finish(\"cache-discard-canceled\");\n                    continue;\n                }\n\n                /**\n                 * 在这里NetworkDispatcher和CacheDispatcher出现了一点差异\n                 * NetworkDispatcher.java在这一步就直接开始网络请求了\n                 * \n                 * 由于是CacheDispatcher.java，肯定是主要以Cahce为主的\n                 * CacheDispatcher在这里先看看有没有缓存\n                 * 如果没有缓存则马上将这个request加入到NetworkQueue中\n                 * (意思好像就是= =兄弟你排错队了)\n                 * 然后继续喊下一个request来被处理\n                 */\n                // Attempt to retrieve this item from cache.\n                Cache.Entry entry = mCache.get(request.getCacheKey());\n                if (entry == null) {\n                    request.addMarker(\"cache-miss\");\n                    // Cache miss; send off to the network dispatcher.\n                    mNetworkQueue.put(request);\n                    continue;\n                }\n\n                /**\n                 * 能到这一步的request不简单了\n                 * 肯定是被上面的mCache.get(cacheKey)查到了有缓存的(毕竟有靠山的伤不起)\n                 * 有缓存还不能太大意= =，万一缓存尼玛是个过期的就惨了= =\n                 * 先用entry.isExpired()函数检查一番\n                 * 过期了照样还是给我滚到NetworkQueue中去排队\n                 *\n                 * 继续喊下一个request来\n                 */\n                // If it is completely expired, just send it to the network.\n                if (entry.isExpired()) {\n                    request.addMarker(\"cache-hit-expired\");\n                    request.setCacheEntry(entry);\n                    mNetworkQueue.put(request);\n                    continue;\n                }\n\n                /**\n                 * 哎哟，能到这一步的request更加不简单了，不仅仅有缓存\n                 * 而且还是能用的缓存，没有过期的诶，这才是有真的靠山= =\n                 *\n                 * 将缓存的信息都拿出来，组成一个NetworkResponse\n                 * 就像是刚刚从网络上获取出来的一样，再形成一个Response.java对象\n                 * 但是不要着急把这个response直接传回caller，这个response还没确定是否需要refresh\n                 */\n\n                // We have a cache hit; parse its data for delivery back to the request.\n                request.addMarker(\"cache-hit\");\n\n                /**\n                 * 将一个由缓存中的数据创建的NetworkResponse.java对象\n                 * 通过Request#parseNetworkResponse()方法\n                 * 来解析成一个Response.java对象\n                 */\n                Response<?> response = request.parseNetworkResponse(\n                        new NetworkResponse(entry.data, entry.responseHeaders));\n\n                //为了方便debug，对request每一个时期的状态都需要添加不同的log信息\n                request.addMarker(\"cache-hit-parsed\");\n\n                if (!entry.refreshNeeded()) {\n                    // Completely unexpired cache hit. Just deliver the response.\n                    /**\n                     * 如果缓存不需要刷新的话，直接传回给caller\n                     */\n                    mDelivery.postResponse(request, response);\n                } else {\n                    // Soft-expired cache hit. We can deliver the cached response,\n                    // but we need to also send the request to the network for\n                    // refreshing.\n                    /**\n                     * 如果需要刷新的话，将这个response中的intermediate参数置为true\n                     * 然后再传递给caller，\n                     * 随后将请求发送到服务器进行刷新\n                     */\n                    request.addMarker(\"cache-hit-refresh-needed\");\n                    request.setCacheEntry(entry);\n\n                    /**\n                     * Mark the response as intermediate.\n                     * 将这个response标记成中间产物，也就不是最终的response\n                     * \n                     */\n                    response.intermediate = true;\n\n                    /** \n                     * Post the intermediate response back to the user and have\n                     * the delivery then forward the request along to the network.\n                     * poseResponse()方法中的Runnable是在response被传递给caller了之后\n                     * 再执行的，在ResponseDelivery.java中有注释\n                     * \n                     */\n                    mDelivery.postResponse(request, response, new Runnable() {\n                        @Override\n                        public void run() {\n                            try {\n                                //将request加入到网络请求队列中去\n                                mNetworkQueue.put(request);\n                            } catch (InterruptedException e) {\n                                // Not much we can do about this.\n                            }\n                        }\n                    });\n                }\n\n            } catch (InterruptedException e) {\n                //当cacheQueue中没有request之后就会捕捉到异常\n                // We may have been interrupted because it was time to quit.\n                if (mQuit) {\n                    return;\n                }\n                continue;\n            }\n        }\n    }\n}\n\n```\n\n### [](#3-_NetworkDispatcher-java \"3\\. NetworkDispatcher.java\")3\\. NetworkDispatcher.java\n\n```\npackage com.android.volley;\n\nimport android.annotation.TargetApi;\nimport android.net.TrafficStats;\nimport android.os.Build;\nimport android.os.Process;\nimport android.os.SystemClock;\n\nimport java.util.concurrent.BlockingQueue;\n\n/**\n * Provides a thread for performing network dispatch from a queue of requests.\n * 提供一个线程专门用来从请求队列(NetworkQueue)里面调度网络请求\n * \n * Requests added to the specified queue are processed from the network via a\n * specified {@link Network} interface. Responses are committed to cache, if\n * eligible, using a specified {@link Cache} interface. Valid responses and\n * errors are posted back to the caller via a {@link ResponseDelivery}.\n *\n * 被加入到RequestQueue中的request会被NetWork的接口进一步加工处理.\n * 如果从网络返回的response是符合条件的，则会被添加到缓存中去。\n * 有效的response将通过ResponseDelivery返回给调用者\n */\npublic class NetworkDispatcher extends Thread {\n    /** \n     * The queue of requests to service. \n     * 这个queue就是RequestQueue.java中的mNetworkQueue\n     */\n    private final BlockingQueue<Request<?>> mQueue;\n\n    /** \n     * The network interface for processing requests. \n     * 处理request的接口，其中的方法是performRequest()\n     */\n    private final Network mNetwork;     \n\n    /** \n     * The cache to write to. \n     * 处理缓存的接口\n     */\n    private final Cache mCache;\n\n    /** \n     * For posting responses and errors. \n     * 用来传递response和error的deliver.\n     */\n    private final ResponseDelivery mDelivery;\n\n    /** \n     * Used for telling us to die. 、\n     * 这里使用到了volatile变量\n     * 这个volatile类似于final之类的修饰词\n     * 是用来保证每次mQuit被读取的时候都是最新的\n     * 避免了读取的值和实际变量的值不同的情况\n     * 可以参考这篇博客，讲解的比较详细：\n     * http://www.cnblogs.com/aigongsi/archive/2012/04/01/2429166.html\n     */\n    private volatile boolean mQuit = false;\n\n    /**\n     * Creates a new network dispatcher thread.  You must call {@link #start()}\n     * in order to begin processing.\n     * 构造器，用于创建一个新的网络调度线程，必须要调用call来开始处理request\n     * \n     * @param queue Queue of incoming requests for triage\n     * 等待处理的request队列\n     * @param network Network interface to use for performing requests\n     * @param cache Cache interface to use for writing responses to cache\n     * @param delivery Delivery interface to use for posting responses\n     */\n    public NetworkDispatcher(BlockingQueue<Request<?>> queue,\n            Network network, Cache cache,\n            ResponseDelivery delivery) {\n        mQueue = queue;\n        mNetwork = network;\n        mCache = cache;\n        mDelivery = delivery;\n    }\n\n    /**\n     * Forces this dispatcher to quit immediately.  If any requests are still in\n     * the queue, they are not guaranteed to be processed.\n     * 强制调度器立刻退出，不再调度request。\n     * \n     */\n    public void quit() {\n        mQuit = true;\n        interrupt();\n    }\n\n    /**\n     * 这里涉及到了TrafficStats类，官方解释如下：\n     * Class that provides network traffic statistics. \n     * 这个类提供网络流量统计的服务。\n     * These statistics include bytes transmitted and received and network packets transmitted and received, \n     * over all interfaces, over the mobile interface, and on a per-UID basis.\n     * 这些被统计的流量包括传输的字节数和收到的字节数以及网络数据包\n     * These statistics may not be available on all platforms. \n     * If the statistics are not supported by this device, UNSUPPORTED will be returned.\n     * 这些数据并不是在所有的平台上都可以用\n     * 如果不可用，则会返回UNSPPORTED\n     * 貌似是每个request都统计一下网络流量= =\n     */\n    @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)\n    private void addTrafficStatsTag(Request<?> request) {\n        // Tag the request (if API >= 14)\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.ICE_CREAM_SANDWICH) {\n            TrafficStats.setThreadStatsTag(request.getTrafficStatsTag());\n        }\n    }\n\n    /**\n     * 由于NetworkDispatcher继承自Thread，重写了run()方法\n     * 里面的内容都会在另启动一个线程来执行\n     * 在CacheDispatcher中有很多相似的地方\n     */\n    @Override\n    public void run() {\n        /**\n         * 给自己设置了线程的优先级\n         * THREAD_PRIORITY_BACKGROUND的优先级是0x0000000a(也就是10)\n         * 还有其他的很多种优先级，该优先级处于较高的位置\n         */\n        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);\n\n        Request<?> request;\n\n        /**\n         * 进入了一个死循环状态\n         * 开始不停的工作\n         */\n        while (true) {\n\n            /**\n             * elapsedRealtime()函数返回的是线程从启动到现在的总时间\n             * 也包括线程睡眠时间在内\n             * 单看这一句看不出什么门道，结合在后面的异常处理时会用到startTimeMs\n             * 这里是记录一个request开始的时刻点，到后面再次调用elapsedRealtime()\n             * 两个变量相减得到了request花费了多长的时间\n             */\n            long startTimeMs = SystemClock.elapsedRealtime();\n            /**\n             * release previous request object to avoid leaking request object when mQueue is drained.\n             * 释放前面的一个Request对象，以免因为Request对象不停的申请而导致内存泄漏\n             */\n            request = null;\n\n            /**\n             * 尝试着从RequestQueue中取出一个Request，对其进行处理\n             * 可能会因为某些原因(可能是队列中没有元素了)会抛出异常\n             * 这个时候就捕捉异常并检验是否要退出了，需要退出则return\n             * 不需要退出则继续下一次循环，看有没有Request可以拿到\n             */\n            try {\n                // Take a request from the queue.\n                request = mQueue.take();\n            } catch (InterruptedException e) {\n                // We may have been interrupted because it was time to quit.\n                if (mQuit) {\n                    return;\n                }\n                continue;\n            }\n\n            /**\n             * 到这一步的时候，request应该是指向了一个Request\n             * 下面开始向服务器发送这个Request\n             */\n\n            try {\n                request.addMarker(\"network-queue-take\");\n\n                // If the request was cancelled already, do not perform the\n                // network request.\n                if (request.isCanceled()) {\n                    request.finish(\"network-discard-cancelled\");\n                    continue;\n                }\n\n                addTrafficStatsTag(request);\n\n                /**\n                 * Perform the network request.\n                 * 直接调用mNetwork的接口，发送request并获得NetworkResponse\n                 */\n                NetworkResponse networkResponse = mNetwork.performRequest(request);\n                request.addMarker(\"network-http-complete\");\n\n                // If the server returned 304 AND we delivered a response already,\n                // we're done -- don't deliver a second identical response.\n                if (networkResponse.notModified && request.hasHadResponseDelivered()) {\n                    request.finish(\"not-modified\");\n                    continue;\n                }\n\n                /**\n                 * Parse the response here on the worker thread.\n                 * 在工作线程上面直接解析结果\n                 * 并且封装成一个Response对象\n                 */\n                Response<?> response = request.parseNetworkResponse(networkResponse);\n                request.addMarker(\"network-parse-complete\");\n\n                /** Write to cache if applicable.\n                 *  如果符合要求，能写入缓存的话，就写到缓存里面\n                 */\n                // TODO: Only update cache metadata instead of entire record for 304s.\n\n                /**\n                 * 在这里看到作者的TODO了，还能改进的地方就是在出现了返回码是\n                 * 304的情况时，只更新缓存中的元数据(也就是response的主体)\n                 * 而不是整个cache的记录下来,有些重复的数据可以不用理会.\n                 */\n                if (request.shouldCache() && response.cacheEntry != null) {\n                    mCache.put(request.getCacheKey(), response.cacheEntry);\n                    request.addMarker(\"network-cache-written\");\n                }\n\n                /**\n                 * 将Request.java中的变量mResponseDelivered置成true\n                 * 标志着这个request的结果已经传回给了caller\n                 */\n\n                request.markDelivered();\n\n                /**\n                 * 通过ResponseDelivery的接口将包装好了的Response返回给调用者\n                 */\n                mDelivery.postResponse(request, response);\n\n            } catch (VolleyError volleyError) {\n                /**\n                 * 设置了request从队列中取出到服务器出现异常反应\n                 * 所花费的时间\n                 */\n                volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);\n\n                /**\n                 * 将网络请求的错误通过ResponseDelivery传递给调用者\n                 * 告诉它这.....不幸的一切\n                 */\n                parseAndDeliverNetworkError(request, volleyError);\n\n            } catch (Exception e) {\n                VolleyLog.e(e, \"Unhandled exception %s\", e.toString());\n                VolleyError volleyError = new VolleyError(e);\n                volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);\n                mDelivery.postError(request, volleyError);\n            }\n        }\n    }\n\n    private void parseAndDeliverNetworkError(Request<?> request, VolleyError error) {\n        error = request.parseNetworkError(error);\n        mDelivery.postError(request, error);\n    }\n}\n\n```\n\n当时看完了CacheDispatcher.java之后，再看NetworkDispatcher.java的时候，就会觉得这两个类非常的相似，run()函数里面的东西有些都差不多，都是进行一个死循环，从阻塞队列里面取出request，针对不同的情况做出不同的处理。\n\n从Volley.java暴露给外部的api开始，一直到现在，已经慢慢的了解了Volley中有一个RequestQueue对象，所有的request都在里面排着队等待被处理，RequestQueue里面还有一个CacheDispatcher和几个NetworkDispatcher,分别负责着不同种类的request。接下来要介绍的就是Volley中`Network.java`接口以及其默认实现类`BasicNetwork.java`,还有涉及缓存读写的接口`Cache.java`以及其默认实现类`DiskBasedCache.java`。","source":"_posts/Volley框架解析-三-Dispatcher解析.md","raw":"---\ntitle: Volley框架解析(三)Dispatcher解析\ndate: 2017-03-01 23:53:47\ntags: volley\n\n---\n\n## Volley框架解析(三)-----Dispatcher解析\n\n</header>\n\n<div class=\"article-entry\" itemprop=\"articleBody\">\n\n### [](#u9898_u5916_u8BDD_28_u53EF_u76F4_u63A5_u65E0_u89C6_uFF0C_u8DF3_u8FC7_7E \"题外话(可直接无视，跳过~\")题外话(可直接无视，跳过~\n\n在上一篇博客中结合volley源代码分析了`Volley.java`和`RequestQueue.java`这两个类，不知道代码全贴上去了，会不会看着很烦的嗯= =，当时看源代码的时候心里就有些不淡定，满屏幕看不懂的东西，但是个人觉得源代码和注释一起看才方便，一段代码一段解释会感觉有点摸不着头脑= =。前面的博客中一直提到了`Dispatcher`这种的东西，有`mNetworkDispatcher`和`mCacheDispatcher`之类的，这篇博客就开始进一步的介绍Volley中的Dispatcher。\n\n<!--more-->\n\n***\n\n<a id=\"more\"></a>\n\n### [](#1-__u7B80_u4ECB \"1\\. 简介\")1\\. 简介\n\n在Volley中涉及到了两类的Dispatcher,一类是涉及到缓存的`CacheDispatcher.java`，另外一类是用来处理网络方面request的`NetworkDispatcher.java`，最开始出现这两个Dispatcher是在`RequestQueue#start()`中，再来回顾一下start方法中的代码：\n\n```\npublic void start() {\n    stop();  // Make sure any currently running dispatchers are stopped.\n    // Create the cache dispatcher and start it.\n    mCacheDispatcher = new CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);\n    mCacheDispatcher.start();\n\n    // Create network dispatchers (and corresponding threads) up to the pool size.\n    for (int i = 0; i < mDispatchers.length; i++) {\n        NetworkDispatcher networkDispatcher = new NetworkDispatcher(mNetworkQueue, mNetwork,\n                mCache, mDelivery);\n        mDispatchers[i] = networkDispatcher;\n        networkDispatcher.start();\n    }\n}\n\n```\n\n先暂停了所有的dispatcher，然后又新建了dispatcher并start()。让dispatcher开始工作，实际上这些dispatcher继承了Thread类，是独立于主线程之外的工作线程，这样可以使RequestQueue中request的加入和处理同时进行。下面就结合CacheDispatcher和NetworkDispatcher两个类的代码来分析,Volley中是如何对request来进行调度和处理的。\n\n### [](#2-_CacheDispatcher-java \"2\\. CacheDispatcher.java\")2\\. CacheDispatcher.java\n\n```\npackage com.android.volley;\n\nimport android.os.Process;\n\nimport java.util.concurrent.BlockingQueue;\n\n/**\n * Provides a thread for performing cache triage on a queue of requests.\n * 提供一个用来处理涉及到缓存的requests的线程\n * \n * Requests added to the specified cache queue are resolved from cache.\n * Any deliverable response is posted back to the caller via a\n * {@link ResponseDelivery}.  Cache misses and responses that require\n * refresh are enqueued on the specified network queue for processing\n * by a {@link NetworkDispatcher}.\n * CacheDispatcher用来处理缓存队列里面(mCacheQueue)中的request\n * 任何符合delivery要求的response都会被通过ResponseDelivery的接口传递给caller\n * 有些cache丢失了或者是cache中的数据需要更新的，都将会交给NetworkDispatcher去处理\n * 交给NetworkDispatcher处理的方法就是直接放到mNetworkQueue中去\n * 因为NetworkDispatcher总是从mNetworkQueue中取出request来进行处理的\n */\n\npublic class CacheDispatcher extends Thread {\n\n    private static final boolean DEBUG = VolleyLog.DEBUG;\n\n    /** \n     * The queue of requests coming in for triage. \n     * 将要被处理的涉及到缓存的Request存放在这个阻塞队列里\n     * 等着咯，这个mCacheQueue和RequestQueue中的mCacheQueue指向的队列是同一个\n     * 也就是说整个Volley在运行的时候只有一个mCacheQueue\n     */\n    private final BlockingQueue<Request<?>> mCacheQueue;\n\n    /** \n     * The queue of requests going out to the network. \n     * 这个阻塞队里里面存着的可是要去进行网络访问的request\n     * 开始还不明白这里不应该是涉及到访问缓存的request\n     * 怎么有个这东西出来了，其实看到后面了就会发现，缓存里面有两个过期时间\n     * 在后面会介绍到Cache.java类，Cache.Entry类中涉及到了\n     * ttl 和 softTtl这两个long型的数据，用来标识缓存是否已经过期了\n     * 或者是否需要去检查是否要更新缓存的两个间隔时间\n     */\n    private final BlockingQueue<Request<?>> mNetworkQueue;\n\n    /** \n     * The cache to read from. \n     * 用于读写缓存的接口\n     * 这个接口也是在Volley中只有一个\n     * mCacheDispatcher和mNetworkDispatcher公用的\n     */\n    private final Cache mCache;\n\n    /** \n     * For posting responses. \n     * ResponseDelivery对象引用，用来将request的结果传递给caller\n     * 在NetworkDispatcher里面也有出现\n     * 这个也是从RequestQueue中传递过来的，公用\n     */\n    private final ResponseDelivery mDelivery;\n\n    /** \n     * Used for telling us to die. \n     * 直译 ： 用来告诉我们去死= = (shit)\n     * 然而 ： 这个变量用来标志这个dispatcher是否要继续工作下去\n     * 如果为true就结束本线程中的死循环\n     */\n    private volatile boolean mQuit = false;\n\n    /**\n     * Creates a new cache triage dispatcher thread.  You must call {@link #start()}\n     * in order to begin processing.\n     * 构造函数咯，创建一个存放需要访问缓存的request的调度线程\n     * 在创建之后需要将其用start()启动\n     * \n     * @param cacheQueue Queue of incoming requests for triage\n     * 存放request的缓存队列\n     * @param networkQueue Queue to post requests that require network to\n     * 存放涉及network的网络队列\n     * @param cache Cache interface to use for resolution\n     * 用来处理缓存读写问题的接口\n     * @param delivery Delivery interface to use for posting responses\n     * 用来反馈结果的接口\n     */\n    public CacheDispatcher(\n            BlockingQueue<Request<?>> cacheQueue, BlockingQueue<Request<?>> networkQueue,\n            Cache cache, ResponseDelivery delivery) {\n        mCacheQueue = cacheQueue;\n        mNetworkQueue = networkQueue;\n        mCache = cache;\n        mDelivery = delivery;\n    }\n\n    /**\n     * Forces this dispatcher to quit immediately.  If any requests are still in\n     * the queue, they are not guaranteed to be processed.\n     * 将标志位mQuit置为true,在每次死循环的最后会判断该标志位\n     */\n    public void quit() {\n        mQuit = true;\n        interrupt();\n    }\n\n    /**\n     * 前面提到了CacheDispatcher继承了Thread类\n     * 这里就重写了run()方法\n     * 当外面调用了mCacheDispatcher.start()之后\n     * run()里面的方法就开始执行了\n     */\n    @Override\n    public void run() {\n\n        if (DEBUG) VolleyLog.v(\"start new dispatcher\");\n        /**\n         * 给自己设置了线程的优先级\n         * THREAD_PRIORITY_BACKGROUND的优先级是0x0000000a(也就是10)\n         * 还有其他的很多种优先级，该优先级处于较高的位置\n         */\n        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);\n\n        /**\n         * Make a blocking call to initialize the cache.\n         * 在读写缓存之前做一些初始化工作，例如扫描缓存目录是否存在等\n         * 这个暂时先不用管里面的内容，等介绍到Cache.java的时候就会明白\n         */\n        mCache.initialize();\n\n        /**\n         * 从这里开始就进入了死循环的状态\n         * 除非出现了什么没有catch的exception\n         * 或者是mQuit标志位被置成了true\n         * 这个死循环将一直进行下去= =\n         * 总感觉有什么不妥的地方，感觉死循环怪怪的噢\n         */\n        while (true) {\n            /**\n             * 和NetworkDispatcher里面的流程没有什么太大的变化\n             * 还是一个死循环不停的从CacheQueue中取出Request\n             */\n            try {\n                /**\n                 * Get a request from the cache triage queue, blocking until\n                 * at least one is available.\n                 * 从缓存request队列里面取出等待处理的request\n                 * 如果没有可取出的request，则会在这里阻塞\n                 * 这个是PriorityBlockingQueue#take()函数的作用\n                 * \n                 */\n                final Request<?> request = mCacheQueue.take();\n\n                /**\n                 * 给每个request添加上一个打log的标志\n                 * 为了debug的需要\n                 */\n                request.addMarker(\"cache-queue-take\");\n\n                /**\n                 * If the request has been canceled, don't bother dispatching it.\n                 * 如果正在处理的这个请求被取消了\n                 * 中断对该request的处理，continue去处理下一个request的调度\n                 * 调用Request#finish()方法，传入的参数是为了debug方便，打出request调度进度的log\n                 */\n                if (request.isCanceled()) {\n                    request.finish(\"cache-discard-canceled\");\n                    continue;\n                }\n\n                /**\n                 * 在这里NetworkDispatcher和CacheDispatcher出现了一点差异\n                 * NetworkDispatcher.java在这一步就直接开始网络请求了\n                 * \n                 * 由于是CacheDispatcher.java，肯定是主要以Cahce为主的\n                 * CacheDispatcher在这里先看看有没有缓存\n                 * 如果没有缓存则马上将这个request加入到NetworkQueue中\n                 * (意思好像就是= =兄弟你排错队了)\n                 * 然后继续喊下一个request来被处理\n                 */\n                // Attempt to retrieve this item from cache.\n                Cache.Entry entry = mCache.get(request.getCacheKey());\n                if (entry == null) {\n                    request.addMarker(\"cache-miss\");\n                    // Cache miss; send off to the network dispatcher.\n                    mNetworkQueue.put(request);\n                    continue;\n                }\n\n                /**\n                 * 能到这一步的request不简单了\n                 * 肯定是被上面的mCache.get(cacheKey)查到了有缓存的(毕竟有靠山的伤不起)\n                 * 有缓存还不能太大意= =，万一缓存尼玛是个过期的就惨了= =\n                 * 先用entry.isExpired()函数检查一番\n                 * 过期了照样还是给我滚到NetworkQueue中去排队\n                 *\n                 * 继续喊下一个request来\n                 */\n                // If it is completely expired, just send it to the network.\n                if (entry.isExpired()) {\n                    request.addMarker(\"cache-hit-expired\");\n                    request.setCacheEntry(entry);\n                    mNetworkQueue.put(request);\n                    continue;\n                }\n\n                /**\n                 * 哎哟，能到这一步的request更加不简单了，不仅仅有缓存\n                 * 而且还是能用的缓存，没有过期的诶，这才是有真的靠山= =\n                 *\n                 * 将缓存的信息都拿出来，组成一个NetworkResponse\n                 * 就像是刚刚从网络上获取出来的一样，再形成一个Response.java对象\n                 * 但是不要着急把这个response直接传回caller，这个response还没确定是否需要refresh\n                 */\n\n                // We have a cache hit; parse its data for delivery back to the request.\n                request.addMarker(\"cache-hit\");\n\n                /**\n                 * 将一个由缓存中的数据创建的NetworkResponse.java对象\n                 * 通过Request#parseNetworkResponse()方法\n                 * 来解析成一个Response.java对象\n                 */\n                Response<?> response = request.parseNetworkResponse(\n                        new NetworkResponse(entry.data, entry.responseHeaders));\n\n                //为了方便debug，对request每一个时期的状态都需要添加不同的log信息\n                request.addMarker(\"cache-hit-parsed\");\n\n                if (!entry.refreshNeeded()) {\n                    // Completely unexpired cache hit. Just deliver the response.\n                    /**\n                     * 如果缓存不需要刷新的话，直接传回给caller\n                     */\n                    mDelivery.postResponse(request, response);\n                } else {\n                    // Soft-expired cache hit. We can deliver the cached response,\n                    // but we need to also send the request to the network for\n                    // refreshing.\n                    /**\n                     * 如果需要刷新的话，将这个response中的intermediate参数置为true\n                     * 然后再传递给caller，\n                     * 随后将请求发送到服务器进行刷新\n                     */\n                    request.addMarker(\"cache-hit-refresh-needed\");\n                    request.setCacheEntry(entry);\n\n                    /**\n                     * Mark the response as intermediate.\n                     * 将这个response标记成中间产物，也就不是最终的response\n                     * \n                     */\n                    response.intermediate = true;\n\n                    /** \n                     * Post the intermediate response back to the user and have\n                     * the delivery then forward the request along to the network.\n                     * poseResponse()方法中的Runnable是在response被传递给caller了之后\n                     * 再执行的，在ResponseDelivery.java中有注释\n                     * \n                     */\n                    mDelivery.postResponse(request, response, new Runnable() {\n                        @Override\n                        public void run() {\n                            try {\n                                //将request加入到网络请求队列中去\n                                mNetworkQueue.put(request);\n                            } catch (InterruptedException e) {\n                                // Not much we can do about this.\n                            }\n                        }\n                    });\n                }\n\n            } catch (InterruptedException e) {\n                //当cacheQueue中没有request之后就会捕捉到异常\n                // We may have been interrupted because it was time to quit.\n                if (mQuit) {\n                    return;\n                }\n                continue;\n            }\n        }\n    }\n}\n\n```\n\n### [](#3-_NetworkDispatcher-java \"3\\. NetworkDispatcher.java\")3\\. NetworkDispatcher.java\n\n```\npackage com.android.volley;\n\nimport android.annotation.TargetApi;\nimport android.net.TrafficStats;\nimport android.os.Build;\nimport android.os.Process;\nimport android.os.SystemClock;\n\nimport java.util.concurrent.BlockingQueue;\n\n/**\n * Provides a thread for performing network dispatch from a queue of requests.\n * 提供一个线程专门用来从请求队列(NetworkQueue)里面调度网络请求\n * \n * Requests added to the specified queue are processed from the network via a\n * specified {@link Network} interface. Responses are committed to cache, if\n * eligible, using a specified {@link Cache} interface. Valid responses and\n * errors are posted back to the caller via a {@link ResponseDelivery}.\n *\n * 被加入到RequestQueue中的request会被NetWork的接口进一步加工处理.\n * 如果从网络返回的response是符合条件的，则会被添加到缓存中去。\n * 有效的response将通过ResponseDelivery返回给调用者\n */\npublic class NetworkDispatcher extends Thread {\n    /** \n     * The queue of requests to service. \n     * 这个queue就是RequestQueue.java中的mNetworkQueue\n     */\n    private final BlockingQueue<Request<?>> mQueue;\n\n    /** \n     * The network interface for processing requests. \n     * 处理request的接口，其中的方法是performRequest()\n     */\n    private final Network mNetwork;     \n\n    /** \n     * The cache to write to. \n     * 处理缓存的接口\n     */\n    private final Cache mCache;\n\n    /** \n     * For posting responses and errors. \n     * 用来传递response和error的deliver.\n     */\n    private final ResponseDelivery mDelivery;\n\n    /** \n     * Used for telling us to die. 、\n     * 这里使用到了volatile变量\n     * 这个volatile类似于final之类的修饰词\n     * 是用来保证每次mQuit被读取的时候都是最新的\n     * 避免了读取的值和实际变量的值不同的情况\n     * 可以参考这篇博客，讲解的比较详细：\n     * http://www.cnblogs.com/aigongsi/archive/2012/04/01/2429166.html\n     */\n    private volatile boolean mQuit = false;\n\n    /**\n     * Creates a new network dispatcher thread.  You must call {@link #start()}\n     * in order to begin processing.\n     * 构造器，用于创建一个新的网络调度线程，必须要调用call来开始处理request\n     * \n     * @param queue Queue of incoming requests for triage\n     * 等待处理的request队列\n     * @param network Network interface to use for performing requests\n     * @param cache Cache interface to use for writing responses to cache\n     * @param delivery Delivery interface to use for posting responses\n     */\n    public NetworkDispatcher(BlockingQueue<Request<?>> queue,\n            Network network, Cache cache,\n            ResponseDelivery delivery) {\n        mQueue = queue;\n        mNetwork = network;\n        mCache = cache;\n        mDelivery = delivery;\n    }\n\n    /**\n     * Forces this dispatcher to quit immediately.  If any requests are still in\n     * the queue, they are not guaranteed to be processed.\n     * 强制调度器立刻退出，不再调度request。\n     * \n     */\n    public void quit() {\n        mQuit = true;\n        interrupt();\n    }\n\n    /**\n     * 这里涉及到了TrafficStats类，官方解释如下：\n     * Class that provides network traffic statistics. \n     * 这个类提供网络流量统计的服务。\n     * These statistics include bytes transmitted and received and network packets transmitted and received, \n     * over all interfaces, over the mobile interface, and on a per-UID basis.\n     * 这些被统计的流量包括传输的字节数和收到的字节数以及网络数据包\n     * These statistics may not be available on all platforms. \n     * If the statistics are not supported by this device, UNSUPPORTED will be returned.\n     * 这些数据并不是在所有的平台上都可以用\n     * 如果不可用，则会返回UNSPPORTED\n     * 貌似是每个request都统计一下网络流量= =\n     */\n    @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)\n    private void addTrafficStatsTag(Request<?> request) {\n        // Tag the request (if API >= 14)\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.ICE_CREAM_SANDWICH) {\n            TrafficStats.setThreadStatsTag(request.getTrafficStatsTag());\n        }\n    }\n\n    /**\n     * 由于NetworkDispatcher继承自Thread，重写了run()方法\n     * 里面的内容都会在另启动一个线程来执行\n     * 在CacheDispatcher中有很多相似的地方\n     */\n    @Override\n    public void run() {\n        /**\n         * 给自己设置了线程的优先级\n         * THREAD_PRIORITY_BACKGROUND的优先级是0x0000000a(也就是10)\n         * 还有其他的很多种优先级，该优先级处于较高的位置\n         */\n        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);\n\n        Request<?> request;\n\n        /**\n         * 进入了一个死循环状态\n         * 开始不停的工作\n         */\n        while (true) {\n\n            /**\n             * elapsedRealtime()函数返回的是线程从启动到现在的总时间\n             * 也包括线程睡眠时间在内\n             * 单看这一句看不出什么门道，结合在后面的异常处理时会用到startTimeMs\n             * 这里是记录一个request开始的时刻点，到后面再次调用elapsedRealtime()\n             * 两个变量相减得到了request花费了多长的时间\n             */\n            long startTimeMs = SystemClock.elapsedRealtime();\n            /**\n             * release previous request object to avoid leaking request object when mQueue is drained.\n             * 释放前面的一个Request对象，以免因为Request对象不停的申请而导致内存泄漏\n             */\n            request = null;\n\n            /**\n             * 尝试着从RequestQueue中取出一个Request，对其进行处理\n             * 可能会因为某些原因(可能是队列中没有元素了)会抛出异常\n             * 这个时候就捕捉异常并检验是否要退出了，需要退出则return\n             * 不需要退出则继续下一次循环，看有没有Request可以拿到\n             */\n            try {\n                // Take a request from the queue.\n                request = mQueue.take();\n            } catch (InterruptedException e) {\n                // We may have been interrupted because it was time to quit.\n                if (mQuit) {\n                    return;\n                }\n                continue;\n            }\n\n            /**\n             * 到这一步的时候，request应该是指向了一个Request\n             * 下面开始向服务器发送这个Request\n             */\n\n            try {\n                request.addMarker(\"network-queue-take\");\n\n                // If the request was cancelled already, do not perform the\n                // network request.\n                if (request.isCanceled()) {\n                    request.finish(\"network-discard-cancelled\");\n                    continue;\n                }\n\n                addTrafficStatsTag(request);\n\n                /**\n                 * Perform the network request.\n                 * 直接调用mNetwork的接口，发送request并获得NetworkResponse\n                 */\n                NetworkResponse networkResponse = mNetwork.performRequest(request);\n                request.addMarker(\"network-http-complete\");\n\n                // If the server returned 304 AND we delivered a response already,\n                // we're done -- don't deliver a second identical response.\n                if (networkResponse.notModified && request.hasHadResponseDelivered()) {\n                    request.finish(\"not-modified\");\n                    continue;\n                }\n\n                /**\n                 * Parse the response here on the worker thread.\n                 * 在工作线程上面直接解析结果\n                 * 并且封装成一个Response对象\n                 */\n                Response<?> response = request.parseNetworkResponse(networkResponse);\n                request.addMarker(\"network-parse-complete\");\n\n                /** Write to cache if applicable.\n                 *  如果符合要求，能写入缓存的话，就写到缓存里面\n                 */\n                // TODO: Only update cache metadata instead of entire record for 304s.\n\n                /**\n                 * 在这里看到作者的TODO了，还能改进的地方就是在出现了返回码是\n                 * 304的情况时，只更新缓存中的元数据(也就是response的主体)\n                 * 而不是整个cache的记录下来,有些重复的数据可以不用理会.\n                 */\n                if (request.shouldCache() && response.cacheEntry != null) {\n                    mCache.put(request.getCacheKey(), response.cacheEntry);\n                    request.addMarker(\"network-cache-written\");\n                }\n\n                /**\n                 * 将Request.java中的变量mResponseDelivered置成true\n                 * 标志着这个request的结果已经传回给了caller\n                 */\n\n                request.markDelivered();\n\n                /**\n                 * 通过ResponseDelivery的接口将包装好了的Response返回给调用者\n                 */\n                mDelivery.postResponse(request, response);\n\n            } catch (VolleyError volleyError) {\n                /**\n                 * 设置了request从队列中取出到服务器出现异常反应\n                 * 所花费的时间\n                 */\n                volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);\n\n                /**\n                 * 将网络请求的错误通过ResponseDelivery传递给调用者\n                 * 告诉它这.....不幸的一切\n                 */\n                parseAndDeliverNetworkError(request, volleyError);\n\n            } catch (Exception e) {\n                VolleyLog.e(e, \"Unhandled exception %s\", e.toString());\n                VolleyError volleyError = new VolleyError(e);\n                volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);\n                mDelivery.postError(request, volleyError);\n            }\n        }\n    }\n\n    private void parseAndDeliverNetworkError(Request<?> request, VolleyError error) {\n        error = request.parseNetworkError(error);\n        mDelivery.postError(request, error);\n    }\n}\n\n```\n\n当时看完了CacheDispatcher.java之后，再看NetworkDispatcher.java的时候，就会觉得这两个类非常的相似，run()函数里面的东西有些都差不多，都是进行一个死循环，从阻塞队列里面取出request，针对不同的情况做出不同的处理。\n\n从Volley.java暴露给外部的api开始，一直到现在，已经慢慢的了解了Volley中有一个RequestQueue对象，所有的request都在里面排着队等待被处理，RequestQueue里面还有一个CacheDispatcher和几个NetworkDispatcher,分别负责着不同种类的request。接下来要介绍的就是Volley中`Network.java`接口以及其默认实现类`BasicNetwork.java`,还有涉及缓存读写的接口`Cache.java`以及其默认实现类`DiskBasedCache.java`。","slug":"Volley框架解析-三-Dispatcher解析","published":1,"updated":"2020-07-03T02:40:48.121Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc5n2qh7000jw8r1xyrf6pze","content":"<h2 id=\"Volley框架解析-三-—–Dispatcher解析\"><a href=\"#Volley框架解析-三-—–Dispatcher解析\" class=\"headerlink\" title=\"Volley框架解析(三)—–Dispatcher解析\"></a>Volley框架解析(三)—–Dispatcher解析</h2><p></p>\n<div class=\"article-entry\" itemprop=\"articleBody\">\n\n<h3 id=\"题外话-可直接无视，跳过\"><a href=\"#题外话-可直接无视，跳过\" class=\"headerlink\" title=\"题外话(可直接无视，跳过~\"></a><a href=\"#u9898_u5916_u8BDD_28_u53EF_u76F4_u63A5_u65E0_u89C6_uFF0C_u8DF3_u8FC7_7E\" title=\"题外话(可直接无视，跳过~\"></a>题外话(可直接无视，跳过~</h3><p>在上一篇博客中结合volley源代码分析了<code>Volley.java</code>和<code>RequestQueue.java</code>这两个类，不知道代码全贴上去了，会不会看着很烦的嗯= =，当时看源代码的时候心里就有些不淡定，满屏幕看不懂的东西，但是个人觉得源代码和注释一起看才方便，一段代码一段解释会感觉有点摸不着头脑= =。前面的博客中一直提到了<code>Dispatcher</code>这种的东西，有<code>mNetworkDispatcher</code>和<code>mCacheDispatcher</code>之类的，这篇博客就开始进一步的介绍Volley中的Dispatcher。</p>\n<a id=\"more\"></a>\n<hr>\n<p><a id=\"more\"></a></p>\n<h3 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1. 简介\"></a><a href=\"#1-__u7B80_u4ECB\" title=\"1\\. 简介\"></a>1. 简介</h3><p>在Volley中涉及到了两类的Dispatcher,一类是涉及到缓存的<code>CacheDispatcher.java</code>，另外一类是用来处理网络方面request的<code>NetworkDispatcher.java</code>，最开始出现这两个Dispatcher是在<code>RequestQueue#start()</code>中，再来回顾一下start方法中的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void start() &#123;</div><div class=\"line\">    stop();  // Make sure any currently running dispatchers are stopped.</div><div class=\"line\">    // Create the cache dispatcher and start it.</div><div class=\"line\">    mCacheDispatcher = new CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);</div><div class=\"line\">    mCacheDispatcher.start();</div><div class=\"line\"></div><div class=\"line\">    // Create network dispatchers (and corresponding threads) up to the pool size.</div><div class=\"line\">    for (int i = 0; i &lt; mDispatchers.length; i++) &#123;</div><div class=\"line\">        NetworkDispatcher networkDispatcher = new NetworkDispatcher(mNetworkQueue, mNetwork,</div><div class=\"line\">                mCache, mDelivery);</div><div class=\"line\">        mDispatchers[i] = networkDispatcher;</div><div class=\"line\">        networkDispatcher.start();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>先暂停了所有的dispatcher，然后又新建了dispatcher并start()。让dispatcher开始工作，实际上这些dispatcher继承了Thread类，是独立于主线程之外的工作线程，这样可以使RequestQueue中request的加入和处理同时进行。下面就结合CacheDispatcher和NetworkDispatcher两个类的代码来分析,Volley中是如何对request来进行调度和处理的。</p>\n<h3 id=\"2-CacheDispatcher-java\"><a href=\"#2-CacheDispatcher-java\" class=\"headerlink\" title=\"2. CacheDispatcher.java\"></a><a href=\"#2-_CacheDispatcher-java\" title=\"2\\. CacheDispatcher.java\"></a>2. CacheDispatcher.java</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div><div class=\"line\">204</div><div class=\"line\">205</div><div class=\"line\">206</div><div class=\"line\">207</div><div class=\"line\">208</div><div class=\"line\">209</div><div class=\"line\">210</div><div class=\"line\">211</div><div class=\"line\">212</div><div class=\"line\">213</div><div class=\"line\">214</div><div class=\"line\">215</div><div class=\"line\">216</div><div class=\"line\">217</div><div class=\"line\">218</div><div class=\"line\">219</div><div class=\"line\">220</div><div class=\"line\">221</div><div class=\"line\">222</div><div class=\"line\">223</div><div class=\"line\">224</div><div class=\"line\">225</div><div class=\"line\">226</div><div class=\"line\">227</div><div class=\"line\">228</div><div class=\"line\">229</div><div class=\"line\">230</div><div class=\"line\">231</div><div class=\"line\">232</div><div class=\"line\">233</div><div class=\"line\">234</div><div class=\"line\">235</div><div class=\"line\">236</div><div class=\"line\">237</div><div class=\"line\">238</div><div class=\"line\">239</div><div class=\"line\">240</div><div class=\"line\">241</div><div class=\"line\">242</div><div class=\"line\">243</div><div class=\"line\">244</div><div class=\"line\">245</div><div class=\"line\">246</div><div class=\"line\">247</div><div class=\"line\">248</div><div class=\"line\">249</div><div class=\"line\">250</div><div class=\"line\">251</div><div class=\"line\">252</div><div class=\"line\">253</div><div class=\"line\">254</div><div class=\"line\">255</div><div class=\"line\">256</div><div class=\"line\">257</div><div class=\"line\">258</div><div class=\"line\">259</div><div class=\"line\">260</div><div class=\"line\">261</div><div class=\"line\">262</div><div class=\"line\">263</div><div class=\"line\">264</div><div class=\"line\">265</div><div class=\"line\">266</div><div class=\"line\">267</div><div class=\"line\">268</div><div class=\"line\">269</div><div class=\"line\">270</div><div class=\"line\">271</div><div class=\"line\">272</div><div class=\"line\">273</div><div class=\"line\">274</div><div class=\"line\">275</div><div class=\"line\">276</div><div class=\"line\">277</div><div class=\"line\">278</div><div class=\"line\">279</div><div class=\"line\">280</div><div class=\"line\">281</div><div class=\"line\">282</div></pre></td><td class=\"code\"><pre><div class=\"line\">package com.android.volley;</div><div class=\"line\"></div><div class=\"line\">import android.os.Process;</div><div class=\"line\"></div><div class=\"line\">import java.util.concurrent.BlockingQueue;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\"> * Provides a thread for performing cache triage on a queue of requests.</div><div class=\"line\"> * 提供一个用来处理涉及到缓存的requests的线程</div><div class=\"line\"> * </div><div class=\"line\"> * Requests added to the specified cache queue are resolved from cache.</div><div class=\"line\"> * Any deliverable response is posted back to the caller via a</div><div class=\"line\"> * &#123;@link ResponseDelivery&#125;.  Cache misses and responses that require</div><div class=\"line\"> * refresh are enqueued on the specified network queue for processing</div><div class=\"line\"> * by a &#123;@link NetworkDispatcher&#125;.</div><div class=\"line\"> * CacheDispatcher用来处理缓存队列里面(mCacheQueue)中的request</div><div class=\"line\"> * 任何符合delivery要求的response都会被通过ResponseDelivery的接口传递给caller</div><div class=\"line\"> * 有些cache丢失了或者是cache中的数据需要更新的，都将会交给NetworkDispatcher去处理</div><div class=\"line\"> * 交给NetworkDispatcher处理的方法就是直接放到mNetworkQueue中去</div><div class=\"line\"> * 因为NetworkDispatcher总是从mNetworkQueue中取出request来进行处理的</div><div class=\"line\"> */</div><div class=\"line\"></div><div class=\"line\">public class CacheDispatcher extends Thread &#123;</div><div class=\"line\"></div><div class=\"line\">    private static final boolean DEBUG = VolleyLog.DEBUG;</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * The queue of requests coming in for triage. </div><div class=\"line\">     * 将要被处理的涉及到缓存的Request存放在这个阻塞队列里</div><div class=\"line\">     * 等着咯，这个mCacheQueue和RequestQueue中的mCacheQueue指向的队列是同一个</div><div class=\"line\">     * 也就是说整个Volley在运行的时候只有一个mCacheQueue</div><div class=\"line\">     */</div><div class=\"line\">    private final BlockingQueue&lt;Request&lt;?&gt;&gt; mCacheQueue;</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * The queue of requests going out to the network. </div><div class=\"line\">     * 这个阻塞队里里面存着的可是要去进行网络访问的request</div><div class=\"line\">     * 开始还不明白这里不应该是涉及到访问缓存的request</div><div class=\"line\">     * 怎么有个这东西出来了，其实看到后面了就会发现，缓存里面有两个过期时间</div><div class=\"line\">     * 在后面会介绍到Cache.java类，Cache.Entry类中涉及到了</div><div class=\"line\">     * ttl 和 softTtl这两个long型的数据，用来标识缓存是否已经过期了</div><div class=\"line\">     * 或者是否需要去检查是否要更新缓存的两个间隔时间</div><div class=\"line\">     */</div><div class=\"line\">    private final BlockingQueue&lt;Request&lt;?&gt;&gt; mNetworkQueue;</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * The cache to read from. </div><div class=\"line\">     * 用于读写缓存的接口</div><div class=\"line\">     * 这个接口也是在Volley中只有一个</div><div class=\"line\">     * mCacheDispatcher和mNetworkDispatcher公用的</div><div class=\"line\">     */</div><div class=\"line\">    private final Cache mCache;</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * For posting responses. </div><div class=\"line\">     * ResponseDelivery对象引用，用来将request的结果传递给caller</div><div class=\"line\">     * 在NetworkDispatcher里面也有出现</div><div class=\"line\">     * 这个也是从RequestQueue中传递过来的，公用</div><div class=\"line\">     */</div><div class=\"line\">    private final ResponseDelivery mDelivery;</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * Used for telling us to die. </div><div class=\"line\">     * 直译 ： 用来告诉我们去死= = (shit)</div><div class=\"line\">     * 然而 ： 这个变量用来标志这个dispatcher是否要继续工作下去</div><div class=\"line\">     * 如果为true就结束本线程中的死循环</div><div class=\"line\">     */</div><div class=\"line\">    private volatile boolean mQuit = false;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Creates a new cache triage dispatcher thread.  You must call &#123;@link #start()&#125;</div><div class=\"line\">     * in order to begin processing.</div><div class=\"line\">     * 构造函数咯，创建一个存放需要访问缓存的request的调度线程</div><div class=\"line\">     * 在创建之后需要将其用start()启动</div><div class=\"line\">     * </div><div class=\"line\">     * @param cacheQueue Queue of incoming requests for triage</div><div class=\"line\">     * 存放request的缓存队列</div><div class=\"line\">     * @param networkQueue Queue to post requests that require network to</div><div class=\"line\">     * 存放涉及network的网络队列</div><div class=\"line\">     * @param cache Cache interface to use for resolution</div><div class=\"line\">     * 用来处理缓存读写问题的接口</div><div class=\"line\">     * @param delivery Delivery interface to use for posting responses</div><div class=\"line\">     * 用来反馈结果的接口</div><div class=\"line\">     */</div><div class=\"line\">    public CacheDispatcher(</div><div class=\"line\">            BlockingQueue&lt;Request&lt;?&gt;&gt; cacheQueue, BlockingQueue&lt;Request&lt;?&gt;&gt; networkQueue,</div><div class=\"line\">            Cache cache, ResponseDelivery delivery) &#123;</div><div class=\"line\">        mCacheQueue = cacheQueue;</div><div class=\"line\">        mNetworkQueue = networkQueue;</div><div class=\"line\">        mCache = cache;</div><div class=\"line\">        mDelivery = delivery;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Forces this dispatcher to quit immediately.  If any requests are still in</div><div class=\"line\">     * the queue, they are not guaranteed to be processed.</div><div class=\"line\">     * 将标志位mQuit置为true,在每次死循环的最后会判断该标志位</div><div class=\"line\">     */</div><div class=\"line\">    public void quit() &#123;</div><div class=\"line\">        mQuit = true;</div><div class=\"line\">        interrupt();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * 前面提到了CacheDispatcher继承了Thread类</div><div class=\"line\">     * 这里就重写了run()方法</div><div class=\"line\">     * 当外面调用了mCacheDispatcher.start()之后</div><div class=\"line\">     * run()里面的方法就开始执行了</div><div class=\"line\">     */</div><div class=\"line\">    @Override</div><div class=\"line\">    public void run() &#123;</div><div class=\"line\"></div><div class=\"line\">        if (DEBUG) VolleyLog.v(&quot;start new dispatcher&quot;);</div><div class=\"line\">        /**</div><div class=\"line\">         * 给自己设置了线程的优先级</div><div class=\"line\">         * THREAD_PRIORITY_BACKGROUND的优先级是0x0000000a(也就是10)</div><div class=\"line\">         * 还有其他的很多种优先级，该优先级处于较高的位置</div><div class=\"line\">         */</div><div class=\"line\">        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * Make a blocking call to initialize the cache.</div><div class=\"line\">         * 在读写缓存之前做一些初始化工作，例如扫描缓存目录是否存在等</div><div class=\"line\">         * 这个暂时先不用管里面的内容，等介绍到Cache.java的时候就会明白</div><div class=\"line\">         */</div><div class=\"line\">        mCache.initialize();</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * 从这里开始就进入了死循环的状态</div><div class=\"line\">         * 除非出现了什么没有catch的exception</div><div class=\"line\">         * 或者是mQuit标志位被置成了true</div><div class=\"line\">         * 这个死循环将一直进行下去= =</div><div class=\"line\">         * 总感觉有什么不妥的地方，感觉死循环怪怪的噢</div><div class=\"line\">         */</div><div class=\"line\">        while (true) &#123;</div><div class=\"line\">            /**</div><div class=\"line\">             * 和NetworkDispatcher里面的流程没有什么太大的变化</div><div class=\"line\">             * 还是一个死循环不停的从CacheQueue中取出Request</div><div class=\"line\">             */</div><div class=\"line\">            try &#123;</div><div class=\"line\">                /**</div><div class=\"line\">                 * Get a request from the cache triage queue, blocking until</div><div class=\"line\">                 * at least one is available.</div><div class=\"line\">                 * 从缓存request队列里面取出等待处理的request</div><div class=\"line\">                 * 如果没有可取出的request，则会在这里阻塞</div><div class=\"line\">                 * 这个是PriorityBlockingQueue#take()函数的作用</div><div class=\"line\">                 * </div><div class=\"line\">                 */</div><div class=\"line\">                final Request&lt;?&gt; request = mCacheQueue.take();</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * 给每个request添加上一个打log的标志</div><div class=\"line\">                 * 为了debug的需要</div><div class=\"line\">                 */</div><div class=\"line\">                request.addMarker(&quot;cache-queue-take&quot;);</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * If the request has been canceled, don&apos;t bother dispatching it.</div><div class=\"line\">                 * 如果正在处理的这个请求被取消了</div><div class=\"line\">                 * 中断对该request的处理，continue去处理下一个request的调度</div><div class=\"line\">                 * 调用Request#finish()方法，传入的参数是为了debug方便，打出request调度进度的log</div><div class=\"line\">                 */</div><div class=\"line\">                if (request.isCanceled()) &#123;</div><div class=\"line\">                    request.finish(&quot;cache-discard-canceled&quot;);</div><div class=\"line\">                    continue;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * 在这里NetworkDispatcher和CacheDispatcher出现了一点差异</div><div class=\"line\">                 * NetworkDispatcher.java在这一步就直接开始网络请求了</div><div class=\"line\">                 * </div><div class=\"line\">                 * 由于是CacheDispatcher.java，肯定是主要以Cahce为主的</div><div class=\"line\">                 * CacheDispatcher在这里先看看有没有缓存</div><div class=\"line\">                 * 如果没有缓存则马上将这个request加入到NetworkQueue中</div><div class=\"line\">                 * (意思好像就是= =兄弟你排错队了)</div><div class=\"line\">                 * 然后继续喊下一个request来被处理</div><div class=\"line\">                 */</div><div class=\"line\">                // Attempt to retrieve this item from cache.</div><div class=\"line\">                Cache.Entry entry = mCache.get(request.getCacheKey());</div><div class=\"line\">                if (entry == null) &#123;</div><div class=\"line\">                    request.addMarker(&quot;cache-miss&quot;);</div><div class=\"line\">                    // Cache miss; send off to the network dispatcher.</div><div class=\"line\">                    mNetworkQueue.put(request);</div><div class=\"line\">                    continue;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * 能到这一步的request不简单了</div><div class=\"line\">                 * 肯定是被上面的mCache.get(cacheKey)查到了有缓存的(毕竟有靠山的伤不起)</div><div class=\"line\">                 * 有缓存还不能太大意= =，万一缓存尼玛是个过期的就惨了= =</div><div class=\"line\">                 * 先用entry.isExpired()函数检查一番</div><div class=\"line\">                 * 过期了照样还是给我滚到NetworkQueue中去排队</div><div class=\"line\">                 *</div><div class=\"line\">                 * 继续喊下一个request来</div><div class=\"line\">                 */</div><div class=\"line\">                // If it is completely expired, just send it to the network.</div><div class=\"line\">                if (entry.isExpired()) &#123;</div><div class=\"line\">                    request.addMarker(&quot;cache-hit-expired&quot;);</div><div class=\"line\">                    request.setCacheEntry(entry);</div><div class=\"line\">                    mNetworkQueue.put(request);</div><div class=\"line\">                    continue;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * 哎哟，能到这一步的request更加不简单了，不仅仅有缓存</div><div class=\"line\">                 * 而且还是能用的缓存，没有过期的诶，这才是有真的靠山= =</div><div class=\"line\">                 *</div><div class=\"line\">                 * 将缓存的信息都拿出来，组成一个NetworkResponse</div><div class=\"line\">                 * 就像是刚刚从网络上获取出来的一样，再形成一个Response.java对象</div><div class=\"line\">                 * 但是不要着急把这个response直接传回caller，这个response还没确定是否需要refresh</div><div class=\"line\">                 */</div><div class=\"line\"></div><div class=\"line\">                // We have a cache hit; parse its data for delivery back to the request.</div><div class=\"line\">                request.addMarker(&quot;cache-hit&quot;);</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * 将一个由缓存中的数据创建的NetworkResponse.java对象</div><div class=\"line\">                 * 通过Request#parseNetworkResponse()方法</div><div class=\"line\">                 * 来解析成一个Response.java对象</div><div class=\"line\">                 */</div><div class=\"line\">                Response&lt;?&gt; response = request.parseNetworkResponse(</div><div class=\"line\">                        new NetworkResponse(entry.data, entry.responseHeaders));</div><div class=\"line\"></div><div class=\"line\">                //为了方便debug，对request每一个时期的状态都需要添加不同的log信息</div><div class=\"line\">                request.addMarker(&quot;cache-hit-parsed&quot;);</div><div class=\"line\"></div><div class=\"line\">                if (!entry.refreshNeeded()) &#123;</div><div class=\"line\">                    // Completely unexpired cache hit. Just deliver the response.</div><div class=\"line\">                    /**</div><div class=\"line\">                     * 如果缓存不需要刷新的话，直接传回给caller</div><div class=\"line\">                     */</div><div class=\"line\">                    mDelivery.postResponse(request, response);</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    // Soft-expired cache hit. We can deliver the cached response,</div><div class=\"line\">                    // but we need to also send the request to the network for</div><div class=\"line\">                    // refreshing.</div><div class=\"line\">                    /**</div><div class=\"line\">                     * 如果需要刷新的话，将这个response中的intermediate参数置为true</div><div class=\"line\">                     * 然后再传递给caller，</div><div class=\"line\">                     * 随后将请求发送到服务器进行刷新</div><div class=\"line\">                     */</div><div class=\"line\">                    request.addMarker(&quot;cache-hit-refresh-needed&quot;);</div><div class=\"line\">                    request.setCacheEntry(entry);</div><div class=\"line\"></div><div class=\"line\">                    /**</div><div class=\"line\">                     * Mark the response as intermediate.</div><div class=\"line\">                     * 将这个response标记成中间产物，也就不是最终的response</div><div class=\"line\">                     * </div><div class=\"line\">                     */</div><div class=\"line\">                    response.intermediate = true;</div><div class=\"line\"></div><div class=\"line\">                    /** </div><div class=\"line\">                     * Post the intermediate response back to the user and have</div><div class=\"line\">                     * the delivery then forward the request along to the network.</div><div class=\"line\">                     * poseResponse()方法中的Runnable是在response被传递给caller了之后</div><div class=\"line\">                     * 再执行的，在ResponseDelivery.java中有注释</div><div class=\"line\">                     * </div><div class=\"line\">                     */</div><div class=\"line\">                    mDelivery.postResponse(request, response, new Runnable() &#123;</div><div class=\"line\">                        @Override</div><div class=\"line\">                        public void run() &#123;</div><div class=\"line\">                            try &#123;</div><div class=\"line\">                                //将request加入到网络请求队列中去</div><div class=\"line\">                                mNetworkQueue.put(request);</div><div class=\"line\">                            &#125; catch (InterruptedException e) &#123;</div><div class=\"line\">                                // Not much we can do about this.</div><div class=\"line\">                            &#125;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;);</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">            &#125; catch (InterruptedException e) &#123;</div><div class=\"line\">                //当cacheQueue中没有request之后就会捕捉到异常</div><div class=\"line\">                // We may have been interrupted because it was time to quit.</div><div class=\"line\">                if (mQuit) &#123;</div><div class=\"line\">                    return;</div><div class=\"line\">                &#125;</div><div class=\"line\">                continue;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"3-NetworkDispatcher-java\"><a href=\"#3-NetworkDispatcher-java\" class=\"headerlink\" title=\"3. NetworkDispatcher.java\"></a><a href=\"#3-_NetworkDispatcher-java\" title=\"3\\. NetworkDispatcher.java\"></a>3. NetworkDispatcher.java</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div><div class=\"line\">204</div><div class=\"line\">205</div><div class=\"line\">206</div><div class=\"line\">207</div><div class=\"line\">208</div><div class=\"line\">209</div><div class=\"line\">210</div><div class=\"line\">211</div><div class=\"line\">212</div><div class=\"line\">213</div><div class=\"line\">214</div><div class=\"line\">215</div><div class=\"line\">216</div><div class=\"line\">217</div><div class=\"line\">218</div><div class=\"line\">219</div><div class=\"line\">220</div><div class=\"line\">221</div><div class=\"line\">222</div><div class=\"line\">223</div><div class=\"line\">224</div><div class=\"line\">225</div><div class=\"line\">226</div><div class=\"line\">227</div><div class=\"line\">228</div><div class=\"line\">229</div><div class=\"line\">230</div><div class=\"line\">231</div><div class=\"line\">232</div><div class=\"line\">233</div><div class=\"line\">234</div><div class=\"line\">235</div><div class=\"line\">236</div><div class=\"line\">237</div><div class=\"line\">238</div><div class=\"line\">239</div><div class=\"line\">240</div><div class=\"line\">241</div><div class=\"line\">242</div><div class=\"line\">243</div><div class=\"line\">244</div><div class=\"line\">245</div><div class=\"line\">246</div><div class=\"line\">247</div><div class=\"line\">248</div><div class=\"line\">249</div><div class=\"line\">250</div><div class=\"line\">251</div><div class=\"line\">252</div><div class=\"line\">253</div><div class=\"line\">254</div><div class=\"line\">255</div><div class=\"line\">256</div><div class=\"line\">257</div></pre></td><td class=\"code\"><pre><div class=\"line\">package com.android.volley;</div><div class=\"line\"></div><div class=\"line\">import android.annotation.TargetApi;</div><div class=\"line\">import android.net.TrafficStats;</div><div class=\"line\">import android.os.Build;</div><div class=\"line\">import android.os.Process;</div><div class=\"line\">import android.os.SystemClock;</div><div class=\"line\"></div><div class=\"line\">import java.util.concurrent.BlockingQueue;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\"> * Provides a thread for performing network dispatch from a queue of requests.</div><div class=\"line\"> * 提供一个线程专门用来从请求队列(NetworkQueue)里面调度网络请求</div><div class=\"line\"> * </div><div class=\"line\"> * Requests added to the specified queue are processed from the network via a</div><div class=\"line\"> * specified &#123;@link Network&#125; interface. Responses are committed to cache, if</div><div class=\"line\"> * eligible, using a specified &#123;@link Cache&#125; interface. Valid responses and</div><div class=\"line\"> * errors are posted back to the caller via a &#123;@link ResponseDelivery&#125;.</div><div class=\"line\"> *</div><div class=\"line\"> * 被加入到RequestQueue中的request会被NetWork的接口进一步加工处理.</div><div class=\"line\"> * 如果从网络返回的response是符合条件的，则会被添加到缓存中去。</div><div class=\"line\"> * 有效的response将通过ResponseDelivery返回给调用者</div><div class=\"line\"> */</div><div class=\"line\">public class NetworkDispatcher extends Thread &#123;</div><div class=\"line\">    /** </div><div class=\"line\">     * The queue of requests to service. </div><div class=\"line\">     * 这个queue就是RequestQueue.java中的mNetworkQueue</div><div class=\"line\">     */</div><div class=\"line\">    private final BlockingQueue&lt;Request&lt;?&gt;&gt; mQueue;</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * The network interface for processing requests. </div><div class=\"line\">     * 处理request的接口，其中的方法是performRequest()</div><div class=\"line\">     */</div><div class=\"line\">    private final Network mNetwork;     </div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * The cache to write to. </div><div class=\"line\">     * 处理缓存的接口</div><div class=\"line\">     */</div><div class=\"line\">    private final Cache mCache;</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * For posting responses and errors. </div><div class=\"line\">     * 用来传递response和error的deliver.</div><div class=\"line\">     */</div><div class=\"line\">    private final ResponseDelivery mDelivery;</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * Used for telling us to die. 、</div><div class=\"line\">     * 这里使用到了volatile变量</div><div class=\"line\">     * 这个volatile类似于final之类的修饰词</div><div class=\"line\">     * 是用来保证每次mQuit被读取的时候都是最新的</div><div class=\"line\">     * 避免了读取的值和实际变量的值不同的情况</div><div class=\"line\">     * 可以参考这篇博客，讲解的比较详细：</div><div class=\"line\">     * http://www.cnblogs.com/aigongsi/archive/2012/04/01/2429166.html</div><div class=\"line\">     */</div><div class=\"line\">    private volatile boolean mQuit = false;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Creates a new network dispatcher thread.  You must call &#123;@link #start()&#125;</div><div class=\"line\">     * in order to begin processing.</div><div class=\"line\">     * 构造器，用于创建一个新的网络调度线程，必须要调用call来开始处理request</div><div class=\"line\">     * </div><div class=\"line\">     * @param queue Queue of incoming requests for triage</div><div class=\"line\">     * 等待处理的request队列</div><div class=\"line\">     * @param network Network interface to use for performing requests</div><div class=\"line\">     * @param cache Cache interface to use for writing responses to cache</div><div class=\"line\">     * @param delivery Delivery interface to use for posting responses</div><div class=\"line\">     */</div><div class=\"line\">    public NetworkDispatcher(BlockingQueue&lt;Request&lt;?&gt;&gt; queue,</div><div class=\"line\">            Network network, Cache cache,</div><div class=\"line\">            ResponseDelivery delivery) &#123;</div><div class=\"line\">        mQueue = queue;</div><div class=\"line\">        mNetwork = network;</div><div class=\"line\">        mCache = cache;</div><div class=\"line\">        mDelivery = delivery;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Forces this dispatcher to quit immediately.  If any requests are still in</div><div class=\"line\">     * the queue, they are not guaranteed to be processed.</div><div class=\"line\">     * 强制调度器立刻退出，不再调度request。</div><div class=\"line\">     * </div><div class=\"line\">     */</div><div class=\"line\">    public void quit() &#123;</div><div class=\"line\">        mQuit = true;</div><div class=\"line\">        interrupt();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * 这里涉及到了TrafficStats类，官方解释如下：</div><div class=\"line\">     * Class that provides network traffic statistics. </div><div class=\"line\">     * 这个类提供网络流量统计的服务。</div><div class=\"line\">     * These statistics include bytes transmitted and received and network packets transmitted and received, </div><div class=\"line\">     * over all interfaces, over the mobile interface, and on a per-UID basis.</div><div class=\"line\">     * 这些被统计的流量包括传输的字节数和收到的字节数以及网络数据包</div><div class=\"line\">     * These statistics may not be available on all platforms. </div><div class=\"line\">     * If the statistics are not supported by this device, UNSUPPORTED will be returned.</div><div class=\"line\">     * 这些数据并不是在所有的平台上都可以用</div><div class=\"line\">     * 如果不可用，则会返回UNSPPORTED</div><div class=\"line\">     * 貌似是每个request都统计一下网络流量= =</div><div class=\"line\">     */</div><div class=\"line\">    @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)</div><div class=\"line\">    private void addTrafficStatsTag(Request&lt;?&gt; request) &#123;</div><div class=\"line\">        // Tag the request (if API &gt;= 14)</div><div class=\"line\">        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.ICE_CREAM_SANDWICH) &#123;</div><div class=\"line\">            TrafficStats.setThreadStatsTag(request.getTrafficStatsTag());</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * 由于NetworkDispatcher继承自Thread，重写了run()方法</div><div class=\"line\">     * 里面的内容都会在另启动一个线程来执行</div><div class=\"line\">     * 在CacheDispatcher中有很多相似的地方</div><div class=\"line\">     */</div><div class=\"line\">    @Override</div><div class=\"line\">    public void run() &#123;</div><div class=\"line\">        /**</div><div class=\"line\">         * 给自己设置了线程的优先级</div><div class=\"line\">         * THREAD_PRIORITY_BACKGROUND的优先级是0x0000000a(也就是10)</div><div class=\"line\">         * 还有其他的很多种优先级，该优先级处于较高的位置</div><div class=\"line\">         */</div><div class=\"line\">        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class=\"line\"></div><div class=\"line\">        Request&lt;?&gt; request;</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * 进入了一个死循环状态</div><div class=\"line\">         * 开始不停的工作</div><div class=\"line\">         */</div><div class=\"line\">        while (true) &#123;</div><div class=\"line\"></div><div class=\"line\">            /**</div><div class=\"line\">             * elapsedRealtime()函数返回的是线程从启动到现在的总时间</div><div class=\"line\">             * 也包括线程睡眠时间在内</div><div class=\"line\">             * 单看这一句看不出什么门道，结合在后面的异常处理时会用到startTimeMs</div><div class=\"line\">             * 这里是记录一个request开始的时刻点，到后面再次调用elapsedRealtime()</div><div class=\"line\">             * 两个变量相减得到了request花费了多长的时间</div><div class=\"line\">             */</div><div class=\"line\">            long startTimeMs = SystemClock.elapsedRealtime();</div><div class=\"line\">            /**</div><div class=\"line\">             * release previous request object to avoid leaking request object when mQueue is drained.</div><div class=\"line\">             * 释放前面的一个Request对象，以免因为Request对象不停的申请而导致内存泄漏</div><div class=\"line\">             */</div><div class=\"line\">            request = null;</div><div class=\"line\"></div><div class=\"line\">            /**</div><div class=\"line\">             * 尝试着从RequestQueue中取出一个Request，对其进行处理</div><div class=\"line\">             * 可能会因为某些原因(可能是队列中没有元素了)会抛出异常</div><div class=\"line\">             * 这个时候就捕捉异常并检验是否要退出了，需要退出则return</div><div class=\"line\">             * 不需要退出则继续下一次循环，看有没有Request可以拿到</div><div class=\"line\">             */</div><div class=\"line\">            try &#123;</div><div class=\"line\">                // Take a request from the queue.</div><div class=\"line\">                request = mQueue.take();</div><div class=\"line\">            &#125; catch (InterruptedException e) &#123;</div><div class=\"line\">                // We may have been interrupted because it was time to quit.</div><div class=\"line\">                if (mQuit) &#123;</div><div class=\"line\">                    return;</div><div class=\"line\">                &#125;</div><div class=\"line\">                continue;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            /**</div><div class=\"line\">             * 到这一步的时候，request应该是指向了一个Request</div><div class=\"line\">             * 下面开始向服务器发送这个Request</div><div class=\"line\">             */</div><div class=\"line\"></div><div class=\"line\">            try &#123;</div><div class=\"line\">                request.addMarker(&quot;network-queue-take&quot;);</div><div class=\"line\"></div><div class=\"line\">                // If the request was cancelled already, do not perform the</div><div class=\"line\">                // network request.</div><div class=\"line\">                if (request.isCanceled()) &#123;</div><div class=\"line\">                    request.finish(&quot;network-discard-cancelled&quot;);</div><div class=\"line\">                    continue;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                addTrafficStatsTag(request);</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * Perform the network request.</div><div class=\"line\">                 * 直接调用mNetwork的接口，发送request并获得NetworkResponse</div><div class=\"line\">                 */</div><div class=\"line\">                NetworkResponse networkResponse = mNetwork.performRequest(request);</div><div class=\"line\">                request.addMarker(&quot;network-http-complete&quot;);</div><div class=\"line\"></div><div class=\"line\">                // If the server returned 304 AND we delivered a response already,</div><div class=\"line\">                // we&apos;re done -- don&apos;t deliver a second identical response.</div><div class=\"line\">                if (networkResponse.notModified &amp;&amp; request.hasHadResponseDelivered()) &#123;</div><div class=\"line\">                    request.finish(&quot;not-modified&quot;);</div><div class=\"line\">                    continue;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * Parse the response here on the worker thread.</div><div class=\"line\">                 * 在工作线程上面直接解析结果</div><div class=\"line\">                 * 并且封装成一个Response对象</div><div class=\"line\">                 */</div><div class=\"line\">                Response&lt;?&gt; response = request.parseNetworkResponse(networkResponse);</div><div class=\"line\">                request.addMarker(&quot;network-parse-complete&quot;);</div><div class=\"line\"></div><div class=\"line\">                /** Write to cache if applicable.</div><div class=\"line\">                 *  如果符合要求，能写入缓存的话，就写到缓存里面</div><div class=\"line\">                 */</div><div class=\"line\">                // TODO: Only update cache metadata instead of entire record for 304s.</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * 在这里看到作者的TODO了，还能改进的地方就是在出现了返回码是</div><div class=\"line\">                 * 304的情况时，只更新缓存中的元数据(也就是response的主体)</div><div class=\"line\">                 * 而不是整个cache的记录下来,有些重复的数据可以不用理会.</div><div class=\"line\">                 */</div><div class=\"line\">                if (request.shouldCache() &amp;&amp; response.cacheEntry != null) &#123;</div><div class=\"line\">                    mCache.put(request.getCacheKey(), response.cacheEntry);</div><div class=\"line\">                    request.addMarker(&quot;network-cache-written&quot;);</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * 将Request.java中的变量mResponseDelivered置成true</div><div class=\"line\">                 * 标志着这个request的结果已经传回给了caller</div><div class=\"line\">                 */</div><div class=\"line\"></div><div class=\"line\">                request.markDelivered();</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * 通过ResponseDelivery的接口将包装好了的Response返回给调用者</div><div class=\"line\">                 */</div><div class=\"line\">                mDelivery.postResponse(request, response);</div><div class=\"line\"></div><div class=\"line\">            &#125; catch (VolleyError volleyError) &#123;</div><div class=\"line\">                /**</div><div class=\"line\">                 * 设置了request从队列中取出到服务器出现异常反应</div><div class=\"line\">                 * 所花费的时间</div><div class=\"line\">                 */</div><div class=\"line\">                volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * 将网络请求的错误通过ResponseDelivery传递给调用者</div><div class=\"line\">                 * 告诉它这.....不幸的一切</div><div class=\"line\">                 */</div><div class=\"line\">                parseAndDeliverNetworkError(request, volleyError);</div><div class=\"line\"></div><div class=\"line\">            &#125; catch (Exception e) &#123;</div><div class=\"line\">                VolleyLog.e(e, &quot;Unhandled exception %s&quot;, e.toString());</div><div class=\"line\">                VolleyError volleyError = new VolleyError(e);</div><div class=\"line\">                volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);</div><div class=\"line\">                mDelivery.postError(request, volleyError);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    private void parseAndDeliverNetworkError(Request&lt;?&gt; request, VolleyError error) &#123;</div><div class=\"line\">        error = request.parseNetworkError(error);</div><div class=\"line\">        mDelivery.postError(request, error);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当时看完了CacheDispatcher.java之后，再看NetworkDispatcher.java的时候，就会觉得这两个类非常的相似，run()函数里面的东西有些都差不多，都是进行一个死循环，从阻塞队列里面取出request，针对不同的情况做出不同的处理。</p>\n<p>从Volley.java暴露给外部的api开始，一直到现在，已经慢慢的了解了Volley中有一个RequestQueue对象，所有的request都在里面排着队等待被处理，RequestQueue里面还有一个CacheDispatcher和几个NetworkDispatcher,分别负责着不同种类的request。接下来要介绍的就是Volley中<code>Network.java</code>接口以及其默认实现类<code>BasicNetwork.java</code>,还有涉及缓存读写的接口<code>Cache.java</code>以及其默认实现类<code>DiskBasedCache.java</code>。</p>\n</div>","site":{"data":{}},"excerpt":"<h2 id=\"Volley框架解析-三-—–Dispatcher解析\"><a href=\"#Volley框架解析-三-—–Dispatcher解析\" class=\"headerlink\" title=\"Volley框架解析(三)—–Dispatcher解析\"></a>Volley框架解析(三)—–Dispatcher解析</h2><p></p>\n<div class=\"article-entry\" itemprop=\"articleBody\">\n\n<h3 id=\"题外话-可直接无视，跳过\"><a href=\"#题外话-可直接无视，跳过\" class=\"headerlink\" title=\"题外话(可直接无视，跳过~\"></a><a href=\"#u9898_u5916_u8BDD_28_u53EF_u76F4_u63A5_u65E0_u89C6_uFF0C_u8DF3_u8FC7_7E\" title=\"题外话(可直接无视，跳过~\"></a>题外话(可直接无视，跳过~</h3><p>在上一篇博客中结合volley源代码分析了<code>Volley.java</code>和<code>RequestQueue.java</code>这两个类，不知道代码全贴上去了，会不会看着很烦的嗯= =，当时看源代码的时候心里就有些不淡定，满屏幕看不懂的东西，但是个人觉得源代码和注释一起看才方便，一段代码一段解释会感觉有点摸不着头脑= =。前面的博客中一直提到了<code>Dispatcher</code>这种的东西，有<code>mNetworkDispatcher</code>和<code>mCacheDispatcher</code>之类的，这篇博客就开始进一步的介绍Volley中的Dispatcher。</p>","more":"<hr>\n<p><a id=\"more\"></a></p>\n<h3 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1. 简介\"></a><a href=\"#1-__u7B80_u4ECB\" title=\"1\\. 简介\"></a>1. 简介</h3><p>在Volley中涉及到了两类的Dispatcher,一类是涉及到缓存的<code>CacheDispatcher.java</code>，另外一类是用来处理网络方面request的<code>NetworkDispatcher.java</code>，最开始出现这两个Dispatcher是在<code>RequestQueue#start()</code>中，再来回顾一下start方法中的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void start() &#123;</div><div class=\"line\">    stop();  // Make sure any currently running dispatchers are stopped.</div><div class=\"line\">    // Create the cache dispatcher and start it.</div><div class=\"line\">    mCacheDispatcher = new CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);</div><div class=\"line\">    mCacheDispatcher.start();</div><div class=\"line\"></div><div class=\"line\">    // Create network dispatchers (and corresponding threads) up to the pool size.</div><div class=\"line\">    for (int i = 0; i &lt; mDispatchers.length; i++) &#123;</div><div class=\"line\">        NetworkDispatcher networkDispatcher = new NetworkDispatcher(mNetworkQueue, mNetwork,</div><div class=\"line\">                mCache, mDelivery);</div><div class=\"line\">        mDispatchers[i] = networkDispatcher;</div><div class=\"line\">        networkDispatcher.start();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>先暂停了所有的dispatcher，然后又新建了dispatcher并start()。让dispatcher开始工作，实际上这些dispatcher继承了Thread类，是独立于主线程之外的工作线程，这样可以使RequestQueue中request的加入和处理同时进行。下面就结合CacheDispatcher和NetworkDispatcher两个类的代码来分析,Volley中是如何对request来进行调度和处理的。</p>\n<h3 id=\"2-CacheDispatcher-java\"><a href=\"#2-CacheDispatcher-java\" class=\"headerlink\" title=\"2. CacheDispatcher.java\"></a><a href=\"#2-_CacheDispatcher-java\" title=\"2\\. CacheDispatcher.java\"></a>2. CacheDispatcher.java</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div><div class=\"line\">204</div><div class=\"line\">205</div><div class=\"line\">206</div><div class=\"line\">207</div><div class=\"line\">208</div><div class=\"line\">209</div><div class=\"line\">210</div><div class=\"line\">211</div><div class=\"line\">212</div><div class=\"line\">213</div><div class=\"line\">214</div><div class=\"line\">215</div><div class=\"line\">216</div><div class=\"line\">217</div><div class=\"line\">218</div><div class=\"line\">219</div><div class=\"line\">220</div><div class=\"line\">221</div><div class=\"line\">222</div><div class=\"line\">223</div><div class=\"line\">224</div><div class=\"line\">225</div><div class=\"line\">226</div><div class=\"line\">227</div><div class=\"line\">228</div><div class=\"line\">229</div><div class=\"line\">230</div><div class=\"line\">231</div><div class=\"line\">232</div><div class=\"line\">233</div><div class=\"line\">234</div><div class=\"line\">235</div><div class=\"line\">236</div><div class=\"line\">237</div><div class=\"line\">238</div><div class=\"line\">239</div><div class=\"line\">240</div><div class=\"line\">241</div><div class=\"line\">242</div><div class=\"line\">243</div><div class=\"line\">244</div><div class=\"line\">245</div><div class=\"line\">246</div><div class=\"line\">247</div><div class=\"line\">248</div><div class=\"line\">249</div><div class=\"line\">250</div><div class=\"line\">251</div><div class=\"line\">252</div><div class=\"line\">253</div><div class=\"line\">254</div><div class=\"line\">255</div><div class=\"line\">256</div><div class=\"line\">257</div><div class=\"line\">258</div><div class=\"line\">259</div><div class=\"line\">260</div><div class=\"line\">261</div><div class=\"line\">262</div><div class=\"line\">263</div><div class=\"line\">264</div><div class=\"line\">265</div><div class=\"line\">266</div><div class=\"line\">267</div><div class=\"line\">268</div><div class=\"line\">269</div><div class=\"line\">270</div><div class=\"line\">271</div><div class=\"line\">272</div><div class=\"line\">273</div><div class=\"line\">274</div><div class=\"line\">275</div><div class=\"line\">276</div><div class=\"line\">277</div><div class=\"line\">278</div><div class=\"line\">279</div><div class=\"line\">280</div><div class=\"line\">281</div><div class=\"line\">282</div></pre></td><td class=\"code\"><pre><div class=\"line\">package com.android.volley;</div><div class=\"line\"></div><div class=\"line\">import android.os.Process;</div><div class=\"line\"></div><div class=\"line\">import java.util.concurrent.BlockingQueue;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\"> * Provides a thread for performing cache triage on a queue of requests.</div><div class=\"line\"> * 提供一个用来处理涉及到缓存的requests的线程</div><div class=\"line\"> * </div><div class=\"line\"> * Requests added to the specified cache queue are resolved from cache.</div><div class=\"line\"> * Any deliverable response is posted back to the caller via a</div><div class=\"line\"> * &#123;@link ResponseDelivery&#125;.  Cache misses and responses that require</div><div class=\"line\"> * refresh are enqueued on the specified network queue for processing</div><div class=\"line\"> * by a &#123;@link NetworkDispatcher&#125;.</div><div class=\"line\"> * CacheDispatcher用来处理缓存队列里面(mCacheQueue)中的request</div><div class=\"line\"> * 任何符合delivery要求的response都会被通过ResponseDelivery的接口传递给caller</div><div class=\"line\"> * 有些cache丢失了或者是cache中的数据需要更新的，都将会交给NetworkDispatcher去处理</div><div class=\"line\"> * 交给NetworkDispatcher处理的方法就是直接放到mNetworkQueue中去</div><div class=\"line\"> * 因为NetworkDispatcher总是从mNetworkQueue中取出request来进行处理的</div><div class=\"line\"> */</div><div class=\"line\"></div><div class=\"line\">public class CacheDispatcher extends Thread &#123;</div><div class=\"line\"></div><div class=\"line\">    private static final boolean DEBUG = VolleyLog.DEBUG;</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * The queue of requests coming in for triage. </div><div class=\"line\">     * 将要被处理的涉及到缓存的Request存放在这个阻塞队列里</div><div class=\"line\">     * 等着咯，这个mCacheQueue和RequestQueue中的mCacheQueue指向的队列是同一个</div><div class=\"line\">     * 也就是说整个Volley在运行的时候只有一个mCacheQueue</div><div class=\"line\">     */</div><div class=\"line\">    private final BlockingQueue&lt;Request&lt;?&gt;&gt; mCacheQueue;</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * The queue of requests going out to the network. </div><div class=\"line\">     * 这个阻塞队里里面存着的可是要去进行网络访问的request</div><div class=\"line\">     * 开始还不明白这里不应该是涉及到访问缓存的request</div><div class=\"line\">     * 怎么有个这东西出来了，其实看到后面了就会发现，缓存里面有两个过期时间</div><div class=\"line\">     * 在后面会介绍到Cache.java类，Cache.Entry类中涉及到了</div><div class=\"line\">     * ttl 和 softTtl这两个long型的数据，用来标识缓存是否已经过期了</div><div class=\"line\">     * 或者是否需要去检查是否要更新缓存的两个间隔时间</div><div class=\"line\">     */</div><div class=\"line\">    private final BlockingQueue&lt;Request&lt;?&gt;&gt; mNetworkQueue;</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * The cache to read from. </div><div class=\"line\">     * 用于读写缓存的接口</div><div class=\"line\">     * 这个接口也是在Volley中只有一个</div><div class=\"line\">     * mCacheDispatcher和mNetworkDispatcher公用的</div><div class=\"line\">     */</div><div class=\"line\">    private final Cache mCache;</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * For posting responses. </div><div class=\"line\">     * ResponseDelivery对象引用，用来将request的结果传递给caller</div><div class=\"line\">     * 在NetworkDispatcher里面也有出现</div><div class=\"line\">     * 这个也是从RequestQueue中传递过来的，公用</div><div class=\"line\">     */</div><div class=\"line\">    private final ResponseDelivery mDelivery;</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * Used for telling us to die. </div><div class=\"line\">     * 直译 ： 用来告诉我们去死= = (shit)</div><div class=\"line\">     * 然而 ： 这个变量用来标志这个dispatcher是否要继续工作下去</div><div class=\"line\">     * 如果为true就结束本线程中的死循环</div><div class=\"line\">     */</div><div class=\"line\">    private volatile boolean mQuit = false;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Creates a new cache triage dispatcher thread.  You must call &#123;@link #start()&#125;</div><div class=\"line\">     * in order to begin processing.</div><div class=\"line\">     * 构造函数咯，创建一个存放需要访问缓存的request的调度线程</div><div class=\"line\">     * 在创建之后需要将其用start()启动</div><div class=\"line\">     * </div><div class=\"line\">     * @param cacheQueue Queue of incoming requests for triage</div><div class=\"line\">     * 存放request的缓存队列</div><div class=\"line\">     * @param networkQueue Queue to post requests that require network to</div><div class=\"line\">     * 存放涉及network的网络队列</div><div class=\"line\">     * @param cache Cache interface to use for resolution</div><div class=\"line\">     * 用来处理缓存读写问题的接口</div><div class=\"line\">     * @param delivery Delivery interface to use for posting responses</div><div class=\"line\">     * 用来反馈结果的接口</div><div class=\"line\">     */</div><div class=\"line\">    public CacheDispatcher(</div><div class=\"line\">            BlockingQueue&lt;Request&lt;?&gt;&gt; cacheQueue, BlockingQueue&lt;Request&lt;?&gt;&gt; networkQueue,</div><div class=\"line\">            Cache cache, ResponseDelivery delivery) &#123;</div><div class=\"line\">        mCacheQueue = cacheQueue;</div><div class=\"line\">        mNetworkQueue = networkQueue;</div><div class=\"line\">        mCache = cache;</div><div class=\"line\">        mDelivery = delivery;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Forces this dispatcher to quit immediately.  If any requests are still in</div><div class=\"line\">     * the queue, they are not guaranteed to be processed.</div><div class=\"line\">     * 将标志位mQuit置为true,在每次死循环的最后会判断该标志位</div><div class=\"line\">     */</div><div class=\"line\">    public void quit() &#123;</div><div class=\"line\">        mQuit = true;</div><div class=\"line\">        interrupt();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * 前面提到了CacheDispatcher继承了Thread类</div><div class=\"line\">     * 这里就重写了run()方法</div><div class=\"line\">     * 当外面调用了mCacheDispatcher.start()之后</div><div class=\"line\">     * run()里面的方法就开始执行了</div><div class=\"line\">     */</div><div class=\"line\">    @Override</div><div class=\"line\">    public void run() &#123;</div><div class=\"line\"></div><div class=\"line\">        if (DEBUG) VolleyLog.v(&quot;start new dispatcher&quot;);</div><div class=\"line\">        /**</div><div class=\"line\">         * 给自己设置了线程的优先级</div><div class=\"line\">         * THREAD_PRIORITY_BACKGROUND的优先级是0x0000000a(也就是10)</div><div class=\"line\">         * 还有其他的很多种优先级，该优先级处于较高的位置</div><div class=\"line\">         */</div><div class=\"line\">        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * Make a blocking call to initialize the cache.</div><div class=\"line\">         * 在读写缓存之前做一些初始化工作，例如扫描缓存目录是否存在等</div><div class=\"line\">         * 这个暂时先不用管里面的内容，等介绍到Cache.java的时候就会明白</div><div class=\"line\">         */</div><div class=\"line\">        mCache.initialize();</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * 从这里开始就进入了死循环的状态</div><div class=\"line\">         * 除非出现了什么没有catch的exception</div><div class=\"line\">         * 或者是mQuit标志位被置成了true</div><div class=\"line\">         * 这个死循环将一直进行下去= =</div><div class=\"line\">         * 总感觉有什么不妥的地方，感觉死循环怪怪的噢</div><div class=\"line\">         */</div><div class=\"line\">        while (true) &#123;</div><div class=\"line\">            /**</div><div class=\"line\">             * 和NetworkDispatcher里面的流程没有什么太大的变化</div><div class=\"line\">             * 还是一个死循环不停的从CacheQueue中取出Request</div><div class=\"line\">             */</div><div class=\"line\">            try &#123;</div><div class=\"line\">                /**</div><div class=\"line\">                 * Get a request from the cache triage queue, blocking until</div><div class=\"line\">                 * at least one is available.</div><div class=\"line\">                 * 从缓存request队列里面取出等待处理的request</div><div class=\"line\">                 * 如果没有可取出的request，则会在这里阻塞</div><div class=\"line\">                 * 这个是PriorityBlockingQueue#take()函数的作用</div><div class=\"line\">                 * </div><div class=\"line\">                 */</div><div class=\"line\">                final Request&lt;?&gt; request = mCacheQueue.take();</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * 给每个request添加上一个打log的标志</div><div class=\"line\">                 * 为了debug的需要</div><div class=\"line\">                 */</div><div class=\"line\">                request.addMarker(&quot;cache-queue-take&quot;);</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * If the request has been canceled, don&apos;t bother dispatching it.</div><div class=\"line\">                 * 如果正在处理的这个请求被取消了</div><div class=\"line\">                 * 中断对该request的处理，continue去处理下一个request的调度</div><div class=\"line\">                 * 调用Request#finish()方法，传入的参数是为了debug方便，打出request调度进度的log</div><div class=\"line\">                 */</div><div class=\"line\">                if (request.isCanceled()) &#123;</div><div class=\"line\">                    request.finish(&quot;cache-discard-canceled&quot;);</div><div class=\"line\">                    continue;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * 在这里NetworkDispatcher和CacheDispatcher出现了一点差异</div><div class=\"line\">                 * NetworkDispatcher.java在这一步就直接开始网络请求了</div><div class=\"line\">                 * </div><div class=\"line\">                 * 由于是CacheDispatcher.java，肯定是主要以Cahce为主的</div><div class=\"line\">                 * CacheDispatcher在这里先看看有没有缓存</div><div class=\"line\">                 * 如果没有缓存则马上将这个request加入到NetworkQueue中</div><div class=\"line\">                 * (意思好像就是= =兄弟你排错队了)</div><div class=\"line\">                 * 然后继续喊下一个request来被处理</div><div class=\"line\">                 */</div><div class=\"line\">                // Attempt to retrieve this item from cache.</div><div class=\"line\">                Cache.Entry entry = mCache.get(request.getCacheKey());</div><div class=\"line\">                if (entry == null) &#123;</div><div class=\"line\">                    request.addMarker(&quot;cache-miss&quot;);</div><div class=\"line\">                    // Cache miss; send off to the network dispatcher.</div><div class=\"line\">                    mNetworkQueue.put(request);</div><div class=\"line\">                    continue;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * 能到这一步的request不简单了</div><div class=\"line\">                 * 肯定是被上面的mCache.get(cacheKey)查到了有缓存的(毕竟有靠山的伤不起)</div><div class=\"line\">                 * 有缓存还不能太大意= =，万一缓存尼玛是个过期的就惨了= =</div><div class=\"line\">                 * 先用entry.isExpired()函数检查一番</div><div class=\"line\">                 * 过期了照样还是给我滚到NetworkQueue中去排队</div><div class=\"line\">                 *</div><div class=\"line\">                 * 继续喊下一个request来</div><div class=\"line\">                 */</div><div class=\"line\">                // If it is completely expired, just send it to the network.</div><div class=\"line\">                if (entry.isExpired()) &#123;</div><div class=\"line\">                    request.addMarker(&quot;cache-hit-expired&quot;);</div><div class=\"line\">                    request.setCacheEntry(entry);</div><div class=\"line\">                    mNetworkQueue.put(request);</div><div class=\"line\">                    continue;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * 哎哟，能到这一步的request更加不简单了，不仅仅有缓存</div><div class=\"line\">                 * 而且还是能用的缓存，没有过期的诶，这才是有真的靠山= =</div><div class=\"line\">                 *</div><div class=\"line\">                 * 将缓存的信息都拿出来，组成一个NetworkResponse</div><div class=\"line\">                 * 就像是刚刚从网络上获取出来的一样，再形成一个Response.java对象</div><div class=\"line\">                 * 但是不要着急把这个response直接传回caller，这个response还没确定是否需要refresh</div><div class=\"line\">                 */</div><div class=\"line\"></div><div class=\"line\">                // We have a cache hit; parse its data for delivery back to the request.</div><div class=\"line\">                request.addMarker(&quot;cache-hit&quot;);</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * 将一个由缓存中的数据创建的NetworkResponse.java对象</div><div class=\"line\">                 * 通过Request#parseNetworkResponse()方法</div><div class=\"line\">                 * 来解析成一个Response.java对象</div><div class=\"line\">                 */</div><div class=\"line\">                Response&lt;?&gt; response = request.parseNetworkResponse(</div><div class=\"line\">                        new NetworkResponse(entry.data, entry.responseHeaders));</div><div class=\"line\"></div><div class=\"line\">                //为了方便debug，对request每一个时期的状态都需要添加不同的log信息</div><div class=\"line\">                request.addMarker(&quot;cache-hit-parsed&quot;);</div><div class=\"line\"></div><div class=\"line\">                if (!entry.refreshNeeded()) &#123;</div><div class=\"line\">                    // Completely unexpired cache hit. Just deliver the response.</div><div class=\"line\">                    /**</div><div class=\"line\">                     * 如果缓存不需要刷新的话，直接传回给caller</div><div class=\"line\">                     */</div><div class=\"line\">                    mDelivery.postResponse(request, response);</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    // Soft-expired cache hit. We can deliver the cached response,</div><div class=\"line\">                    // but we need to also send the request to the network for</div><div class=\"line\">                    // refreshing.</div><div class=\"line\">                    /**</div><div class=\"line\">                     * 如果需要刷新的话，将这个response中的intermediate参数置为true</div><div class=\"line\">                     * 然后再传递给caller，</div><div class=\"line\">                     * 随后将请求发送到服务器进行刷新</div><div class=\"line\">                     */</div><div class=\"line\">                    request.addMarker(&quot;cache-hit-refresh-needed&quot;);</div><div class=\"line\">                    request.setCacheEntry(entry);</div><div class=\"line\"></div><div class=\"line\">                    /**</div><div class=\"line\">                     * Mark the response as intermediate.</div><div class=\"line\">                     * 将这个response标记成中间产物，也就不是最终的response</div><div class=\"line\">                     * </div><div class=\"line\">                     */</div><div class=\"line\">                    response.intermediate = true;</div><div class=\"line\"></div><div class=\"line\">                    /** </div><div class=\"line\">                     * Post the intermediate response back to the user and have</div><div class=\"line\">                     * the delivery then forward the request along to the network.</div><div class=\"line\">                     * poseResponse()方法中的Runnable是在response被传递给caller了之后</div><div class=\"line\">                     * 再执行的，在ResponseDelivery.java中有注释</div><div class=\"line\">                     * </div><div class=\"line\">                     */</div><div class=\"line\">                    mDelivery.postResponse(request, response, new Runnable() &#123;</div><div class=\"line\">                        @Override</div><div class=\"line\">                        public void run() &#123;</div><div class=\"line\">                            try &#123;</div><div class=\"line\">                                //将request加入到网络请求队列中去</div><div class=\"line\">                                mNetworkQueue.put(request);</div><div class=\"line\">                            &#125; catch (InterruptedException e) &#123;</div><div class=\"line\">                                // Not much we can do about this.</div><div class=\"line\">                            &#125;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;);</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">            &#125; catch (InterruptedException e) &#123;</div><div class=\"line\">                //当cacheQueue中没有request之后就会捕捉到异常</div><div class=\"line\">                // We may have been interrupted because it was time to quit.</div><div class=\"line\">                if (mQuit) &#123;</div><div class=\"line\">                    return;</div><div class=\"line\">                &#125;</div><div class=\"line\">                continue;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"3-NetworkDispatcher-java\"><a href=\"#3-NetworkDispatcher-java\" class=\"headerlink\" title=\"3. NetworkDispatcher.java\"></a><a href=\"#3-_NetworkDispatcher-java\" title=\"3\\. NetworkDispatcher.java\"></a>3. NetworkDispatcher.java</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div><div class=\"line\">204</div><div class=\"line\">205</div><div class=\"line\">206</div><div class=\"line\">207</div><div class=\"line\">208</div><div class=\"line\">209</div><div class=\"line\">210</div><div class=\"line\">211</div><div class=\"line\">212</div><div class=\"line\">213</div><div class=\"line\">214</div><div class=\"line\">215</div><div class=\"line\">216</div><div class=\"line\">217</div><div class=\"line\">218</div><div class=\"line\">219</div><div class=\"line\">220</div><div class=\"line\">221</div><div class=\"line\">222</div><div class=\"line\">223</div><div class=\"line\">224</div><div class=\"line\">225</div><div class=\"line\">226</div><div class=\"line\">227</div><div class=\"line\">228</div><div class=\"line\">229</div><div class=\"line\">230</div><div class=\"line\">231</div><div class=\"line\">232</div><div class=\"line\">233</div><div class=\"line\">234</div><div class=\"line\">235</div><div class=\"line\">236</div><div class=\"line\">237</div><div class=\"line\">238</div><div class=\"line\">239</div><div class=\"line\">240</div><div class=\"line\">241</div><div class=\"line\">242</div><div class=\"line\">243</div><div class=\"line\">244</div><div class=\"line\">245</div><div class=\"line\">246</div><div class=\"line\">247</div><div class=\"line\">248</div><div class=\"line\">249</div><div class=\"line\">250</div><div class=\"line\">251</div><div class=\"line\">252</div><div class=\"line\">253</div><div class=\"line\">254</div><div class=\"line\">255</div><div class=\"line\">256</div><div class=\"line\">257</div></pre></td><td class=\"code\"><pre><div class=\"line\">package com.android.volley;</div><div class=\"line\"></div><div class=\"line\">import android.annotation.TargetApi;</div><div class=\"line\">import android.net.TrafficStats;</div><div class=\"line\">import android.os.Build;</div><div class=\"line\">import android.os.Process;</div><div class=\"line\">import android.os.SystemClock;</div><div class=\"line\"></div><div class=\"line\">import java.util.concurrent.BlockingQueue;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\"> * Provides a thread for performing network dispatch from a queue of requests.</div><div class=\"line\"> * 提供一个线程专门用来从请求队列(NetworkQueue)里面调度网络请求</div><div class=\"line\"> * </div><div class=\"line\"> * Requests added to the specified queue are processed from the network via a</div><div class=\"line\"> * specified &#123;@link Network&#125; interface. Responses are committed to cache, if</div><div class=\"line\"> * eligible, using a specified &#123;@link Cache&#125; interface. Valid responses and</div><div class=\"line\"> * errors are posted back to the caller via a &#123;@link ResponseDelivery&#125;.</div><div class=\"line\"> *</div><div class=\"line\"> * 被加入到RequestQueue中的request会被NetWork的接口进一步加工处理.</div><div class=\"line\"> * 如果从网络返回的response是符合条件的，则会被添加到缓存中去。</div><div class=\"line\"> * 有效的response将通过ResponseDelivery返回给调用者</div><div class=\"line\"> */</div><div class=\"line\">public class NetworkDispatcher extends Thread &#123;</div><div class=\"line\">    /** </div><div class=\"line\">     * The queue of requests to service. </div><div class=\"line\">     * 这个queue就是RequestQueue.java中的mNetworkQueue</div><div class=\"line\">     */</div><div class=\"line\">    private final BlockingQueue&lt;Request&lt;?&gt;&gt; mQueue;</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * The network interface for processing requests. </div><div class=\"line\">     * 处理request的接口，其中的方法是performRequest()</div><div class=\"line\">     */</div><div class=\"line\">    private final Network mNetwork;     </div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * The cache to write to. </div><div class=\"line\">     * 处理缓存的接口</div><div class=\"line\">     */</div><div class=\"line\">    private final Cache mCache;</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * For posting responses and errors. </div><div class=\"line\">     * 用来传递response和error的deliver.</div><div class=\"line\">     */</div><div class=\"line\">    private final ResponseDelivery mDelivery;</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * Used for telling us to die. 、</div><div class=\"line\">     * 这里使用到了volatile变量</div><div class=\"line\">     * 这个volatile类似于final之类的修饰词</div><div class=\"line\">     * 是用来保证每次mQuit被读取的时候都是最新的</div><div class=\"line\">     * 避免了读取的值和实际变量的值不同的情况</div><div class=\"line\">     * 可以参考这篇博客，讲解的比较详细：</div><div class=\"line\">     * http://www.cnblogs.com/aigongsi/archive/2012/04/01/2429166.html</div><div class=\"line\">     */</div><div class=\"line\">    private volatile boolean mQuit = false;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Creates a new network dispatcher thread.  You must call &#123;@link #start()&#125;</div><div class=\"line\">     * in order to begin processing.</div><div class=\"line\">     * 构造器，用于创建一个新的网络调度线程，必须要调用call来开始处理request</div><div class=\"line\">     * </div><div class=\"line\">     * @param queue Queue of incoming requests for triage</div><div class=\"line\">     * 等待处理的request队列</div><div class=\"line\">     * @param network Network interface to use for performing requests</div><div class=\"line\">     * @param cache Cache interface to use for writing responses to cache</div><div class=\"line\">     * @param delivery Delivery interface to use for posting responses</div><div class=\"line\">     */</div><div class=\"line\">    public NetworkDispatcher(BlockingQueue&lt;Request&lt;?&gt;&gt; queue,</div><div class=\"line\">            Network network, Cache cache,</div><div class=\"line\">            ResponseDelivery delivery) &#123;</div><div class=\"line\">        mQueue = queue;</div><div class=\"line\">        mNetwork = network;</div><div class=\"line\">        mCache = cache;</div><div class=\"line\">        mDelivery = delivery;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Forces this dispatcher to quit immediately.  If any requests are still in</div><div class=\"line\">     * the queue, they are not guaranteed to be processed.</div><div class=\"line\">     * 强制调度器立刻退出，不再调度request。</div><div class=\"line\">     * </div><div class=\"line\">     */</div><div class=\"line\">    public void quit() &#123;</div><div class=\"line\">        mQuit = true;</div><div class=\"line\">        interrupt();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * 这里涉及到了TrafficStats类，官方解释如下：</div><div class=\"line\">     * Class that provides network traffic statistics. </div><div class=\"line\">     * 这个类提供网络流量统计的服务。</div><div class=\"line\">     * These statistics include bytes transmitted and received and network packets transmitted and received, </div><div class=\"line\">     * over all interfaces, over the mobile interface, and on a per-UID basis.</div><div class=\"line\">     * 这些被统计的流量包括传输的字节数和收到的字节数以及网络数据包</div><div class=\"line\">     * These statistics may not be available on all platforms. </div><div class=\"line\">     * If the statistics are not supported by this device, UNSUPPORTED will be returned.</div><div class=\"line\">     * 这些数据并不是在所有的平台上都可以用</div><div class=\"line\">     * 如果不可用，则会返回UNSPPORTED</div><div class=\"line\">     * 貌似是每个request都统计一下网络流量= =</div><div class=\"line\">     */</div><div class=\"line\">    @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)</div><div class=\"line\">    private void addTrafficStatsTag(Request&lt;?&gt; request) &#123;</div><div class=\"line\">        // Tag the request (if API &gt;= 14)</div><div class=\"line\">        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.ICE_CREAM_SANDWICH) &#123;</div><div class=\"line\">            TrafficStats.setThreadStatsTag(request.getTrafficStatsTag());</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * 由于NetworkDispatcher继承自Thread，重写了run()方法</div><div class=\"line\">     * 里面的内容都会在另启动一个线程来执行</div><div class=\"line\">     * 在CacheDispatcher中有很多相似的地方</div><div class=\"line\">     */</div><div class=\"line\">    @Override</div><div class=\"line\">    public void run() &#123;</div><div class=\"line\">        /**</div><div class=\"line\">         * 给自己设置了线程的优先级</div><div class=\"line\">         * THREAD_PRIORITY_BACKGROUND的优先级是0x0000000a(也就是10)</div><div class=\"line\">         * 还有其他的很多种优先级，该优先级处于较高的位置</div><div class=\"line\">         */</div><div class=\"line\">        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class=\"line\"></div><div class=\"line\">        Request&lt;?&gt; request;</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * 进入了一个死循环状态</div><div class=\"line\">         * 开始不停的工作</div><div class=\"line\">         */</div><div class=\"line\">        while (true) &#123;</div><div class=\"line\"></div><div class=\"line\">            /**</div><div class=\"line\">             * elapsedRealtime()函数返回的是线程从启动到现在的总时间</div><div class=\"line\">             * 也包括线程睡眠时间在内</div><div class=\"line\">             * 单看这一句看不出什么门道，结合在后面的异常处理时会用到startTimeMs</div><div class=\"line\">             * 这里是记录一个request开始的时刻点，到后面再次调用elapsedRealtime()</div><div class=\"line\">             * 两个变量相减得到了request花费了多长的时间</div><div class=\"line\">             */</div><div class=\"line\">            long startTimeMs = SystemClock.elapsedRealtime();</div><div class=\"line\">            /**</div><div class=\"line\">             * release previous request object to avoid leaking request object when mQueue is drained.</div><div class=\"line\">             * 释放前面的一个Request对象，以免因为Request对象不停的申请而导致内存泄漏</div><div class=\"line\">             */</div><div class=\"line\">            request = null;</div><div class=\"line\"></div><div class=\"line\">            /**</div><div class=\"line\">             * 尝试着从RequestQueue中取出一个Request，对其进行处理</div><div class=\"line\">             * 可能会因为某些原因(可能是队列中没有元素了)会抛出异常</div><div class=\"line\">             * 这个时候就捕捉异常并检验是否要退出了，需要退出则return</div><div class=\"line\">             * 不需要退出则继续下一次循环，看有没有Request可以拿到</div><div class=\"line\">             */</div><div class=\"line\">            try &#123;</div><div class=\"line\">                // Take a request from the queue.</div><div class=\"line\">                request = mQueue.take();</div><div class=\"line\">            &#125; catch (InterruptedException e) &#123;</div><div class=\"line\">                // We may have been interrupted because it was time to quit.</div><div class=\"line\">                if (mQuit) &#123;</div><div class=\"line\">                    return;</div><div class=\"line\">                &#125;</div><div class=\"line\">                continue;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            /**</div><div class=\"line\">             * 到这一步的时候，request应该是指向了一个Request</div><div class=\"line\">             * 下面开始向服务器发送这个Request</div><div class=\"line\">             */</div><div class=\"line\"></div><div class=\"line\">            try &#123;</div><div class=\"line\">                request.addMarker(&quot;network-queue-take&quot;);</div><div class=\"line\"></div><div class=\"line\">                // If the request was cancelled already, do not perform the</div><div class=\"line\">                // network request.</div><div class=\"line\">                if (request.isCanceled()) &#123;</div><div class=\"line\">                    request.finish(&quot;network-discard-cancelled&quot;);</div><div class=\"line\">                    continue;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                addTrafficStatsTag(request);</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * Perform the network request.</div><div class=\"line\">                 * 直接调用mNetwork的接口，发送request并获得NetworkResponse</div><div class=\"line\">                 */</div><div class=\"line\">                NetworkResponse networkResponse = mNetwork.performRequest(request);</div><div class=\"line\">                request.addMarker(&quot;network-http-complete&quot;);</div><div class=\"line\"></div><div class=\"line\">                // If the server returned 304 AND we delivered a response already,</div><div class=\"line\">                // we&apos;re done -- don&apos;t deliver a second identical response.</div><div class=\"line\">                if (networkResponse.notModified &amp;&amp; request.hasHadResponseDelivered()) &#123;</div><div class=\"line\">                    request.finish(&quot;not-modified&quot;);</div><div class=\"line\">                    continue;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * Parse the response here on the worker thread.</div><div class=\"line\">                 * 在工作线程上面直接解析结果</div><div class=\"line\">                 * 并且封装成一个Response对象</div><div class=\"line\">                 */</div><div class=\"line\">                Response&lt;?&gt; response = request.parseNetworkResponse(networkResponse);</div><div class=\"line\">                request.addMarker(&quot;network-parse-complete&quot;);</div><div class=\"line\"></div><div class=\"line\">                /** Write to cache if applicable.</div><div class=\"line\">                 *  如果符合要求，能写入缓存的话，就写到缓存里面</div><div class=\"line\">                 */</div><div class=\"line\">                // TODO: Only update cache metadata instead of entire record for 304s.</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * 在这里看到作者的TODO了，还能改进的地方就是在出现了返回码是</div><div class=\"line\">                 * 304的情况时，只更新缓存中的元数据(也就是response的主体)</div><div class=\"line\">                 * 而不是整个cache的记录下来,有些重复的数据可以不用理会.</div><div class=\"line\">                 */</div><div class=\"line\">                if (request.shouldCache() &amp;&amp; response.cacheEntry != null) &#123;</div><div class=\"line\">                    mCache.put(request.getCacheKey(), response.cacheEntry);</div><div class=\"line\">                    request.addMarker(&quot;network-cache-written&quot;);</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * 将Request.java中的变量mResponseDelivered置成true</div><div class=\"line\">                 * 标志着这个request的结果已经传回给了caller</div><div class=\"line\">                 */</div><div class=\"line\"></div><div class=\"line\">                request.markDelivered();</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * 通过ResponseDelivery的接口将包装好了的Response返回给调用者</div><div class=\"line\">                 */</div><div class=\"line\">                mDelivery.postResponse(request, response);</div><div class=\"line\"></div><div class=\"line\">            &#125; catch (VolleyError volleyError) &#123;</div><div class=\"line\">                /**</div><div class=\"line\">                 * 设置了request从队列中取出到服务器出现异常反应</div><div class=\"line\">                 * 所花费的时间</div><div class=\"line\">                 */</div><div class=\"line\">                volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * 将网络请求的错误通过ResponseDelivery传递给调用者</div><div class=\"line\">                 * 告诉它这.....不幸的一切</div><div class=\"line\">                 */</div><div class=\"line\">                parseAndDeliverNetworkError(request, volleyError);</div><div class=\"line\"></div><div class=\"line\">            &#125; catch (Exception e) &#123;</div><div class=\"line\">                VolleyLog.e(e, &quot;Unhandled exception %s&quot;, e.toString());</div><div class=\"line\">                VolleyError volleyError = new VolleyError(e);</div><div class=\"line\">                volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);</div><div class=\"line\">                mDelivery.postError(request, volleyError);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    private void parseAndDeliverNetworkError(Request&lt;?&gt; request, VolleyError error) &#123;</div><div class=\"line\">        error = request.parseNetworkError(error);</div><div class=\"line\">        mDelivery.postError(request, error);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当时看完了CacheDispatcher.java之后，再看NetworkDispatcher.java的时候，就会觉得这两个类非常的相似，run()函数里面的东西有些都差不多，都是进行一个死循环，从阻塞队列里面取出request，针对不同的情况做出不同的处理。</p>\n<p>从Volley.java暴露给外部的api开始，一直到现在，已经慢慢的了解了Volley中有一个RequestQueue对象，所有的request都在里面排着队等待被处理，RequestQueue里面还有一个CacheDispatcher和几个NetworkDispatcher,分别负责着不同种类的request。接下来要介绍的就是Volley中<code>Network.java</code>接口以及其默认实现类<code>BasicNetwork.java</code>,还有涉及缓存读写的接口<code>Cache.java</code>以及其默认实现类<code>DiskBasedCache.java</code>。</p>\n</div>"},{"title":"Volley框架解析(二)Volley以及RequestQueue解析","date":"2017-02-28T08:43:26.000Z","_content":"\n## Volley框架解析(二)-----Volley及RequestQueue解析\n\n\n### [](#u9898_u5916_u8BDD_28_u53EF_u76F4_u63A5_u65E0_u89C6_u8DF3_u8FC7 \"题外话(可直接无视跳过\")题外话(可直接无视跳过\n\n是第一次比较完整的去阅读一个框架的源码，刚开始看的时候可以说是除了认识几个基本的`public, interface, final`等关键词之外，其他的一律不通orz，而且还不知道从哪里下手。后来磨蹭了好久还是慢慢的静下心来，对照着Java文档和Android文档查阅，刚开始都是陌生的，慢慢的在源码旁边打上注释，多看两遍就会get了。\n\n有些地方在一个.java文件里面是无法理解用处的，这样的先直接跳过不要纠结，看到对应用的地方就会恍然大悟了。还总结出了一个小技巧就是从框架暴露给外面的接口开始阅读，因为框架里面是一层一层往上的，底层是为了上层服务的，所以从接口开始阅读能很好的向下展开。\n\n前面一篇对Volley做了一个初步的介绍以及从整体上的一个解析，只是简单的描述了Request在Volley中是如何被处理的。从这篇博客开始将从最顶层一步一步的向下挖掘每一行代码，从最开始调用的地方`RequestQueue mQueue = Volley.newRequestQueue(mContext)`开始。\n\n<!--more-->\n\n***\n\n### [](#1-_Volley-java \"1\\. Volley.java\")1\\. Volley.java\n\nVolley.java是Volley整个框架对外暴露的接口，里面有四个重载的同名静态函数，方便直接使用。下面结合源代码来分析，主要是代码里面的注释。\n\n```\n\n    package com.android.volley.toolbox;\n\n\timport android.content.Context;\n\timport android.content.pm.PackageInfo;\n\timport android.content.pm.PackageManager.NameNotFoundException;\n\timport android.net.http.AndroidHttpClient;\n\timport android.os.Build;\n\n\timport com.android.volley.Network;\n\timport com.android.volley.RequestQueue;\n\n\timport java.io.File;\n\n\tpublic class Volley {\n\n\t    /** Default on-disk cache directory. */\n\t    private static final String DEFAULT_CACHE_DIR = \"volley\";\n\n\t    /**\n\t     * Creates a default instance of the worker pool and calls {@link RequestQueue#start()} on it.\n\t     * You may set a maximum size of the disk cache in bytes.\n\t     * 创建一个默认的线程池，并将其启动\n\t     * 还能通过构造函数来设置缓存的最大容量，默认的是5*1024*1024个字节\n\t     *\n\t     * @param context A {@link Context} to use for creating the cache dir.\n\t     * 用于创建缓存目录的context\n\t     * @param stack An {@link HttpStack} to use for the network, or null for default.\n\t     * HttpStack可以通过外面自定义之后传入，也可以不管直接用默认的\n\t     * @param maxDiskCacheBytes the maximum size of the disk cache, in bytes. Use -1 for default size.\n\t     * 最大缓存的字节数\n\t     * @return A started {@link RequestQueue} instance.\n\t     */\n\t    public static RequestQueue newRequestQueue(Context context, HttpStack stack, int maxDiskCacheBytes) {\n\n\t    \t//通过context，创建用于缓存文件的目录\n\t        File cacheDir = new File(context.getCacheDir(), DEFAULT_CACHE_DIR);\n\n\t        String userAgent = \"volley/0\";\n\n\t        try {\n\t            String packageName = context.getPackageName();\n\n\t            /**\n\t             * 关于PackageInfo，官方文档的解释如下：\n\t             * Overall information about the contents of a package.\n\t             * This corresponds to all of the information collected from AndroidManifest.xml.\n\t             * 该类作为Package信息的基类，还有很多子类例如：ApplicationInfo、 ComponentInfo等。\n\t             * 这些类包含了一些关于安装包的信息，icon,label等\n\t             */\n\t            PackageInfo info = context.getPackageManager().getPackageInfo(packageName, 0);\n\t            //获取到了Package的版本号\n\t            userAgent = packageName + \"/\" + info.versionCode;\n\n\t        } catch (NameNotFoundException e) {\n\t        }\n\n\t        /**\n\t         * HttpStack是一个用于网络请求的接口\n\t         * 如果传入的stack为空，则根据当前系统的版本号，来选择不同的实现了HttpStack(Volley自己的一个接口)的类对象\n\t         * 高于android2.3就用HurlStack(实现了HttpStack接口，基于HttpsURLConnection)\n\t         * 低于android2.3就用HttpClientStack(实现了HttpStack接口，基于HttpClient)\n\t         */\n\t        if (stack == null) {\n\t            if (Build.VERSION.SDK_INT >= 9) {\n\t                stack = new HurlStack();\n\t            } else {\n\t                // Prior to Gingerbread, HttpUrlConnection was unreliable.\n\t                // See: http://android-developers.blogspot.com/2011/09/androids-http-clients.html\n\t                stack = new HttpClientStack(AndroidHttpClient.newInstance(userAgent));\n\t            }\n\t        }\n\n\t        /**\n\t         * 创建了一个用于发送特定请求的Network类对象\n\t         * 该接口中有一个与HttpStack接口中同名的方法(performRequest)\n\t         * 但是参数的内容不同， 返回的类型也有所区别\n\t         * Network的返回类型是自定义的一个NetworkResponse类\n\t         * 而HttpStack返回的是HttpResponse\n\t         * (HttpResponse是java.apache.http中的一个类，里面包含了服务器返回的一些数据)\n\t         * \n\t         * 将stack传入到了已经实现了Network接口的一个BasicNetwork类中\n\t         * 在后面发送Request请求的时候会调用Network.performRequest()\n\t         * 然后在Network.performRequest()函数中会继续调用HttpStack.performRequest()\n\t         * 真正的网络请求发出是在HttpStack.performRequest()中进行的\n\t         */\n\n\t        Network network = new BasicNetwork(stack);\n\n\t        /**\n\t         * 创建一个RequestQueue引用\n\t         * RequestQueue是volley实现的一个请求调度队列\n\t         * 用来分发处理request\n\t         * 后面会分析RequestQueue.java\n\t         */\n\t        RequestQueue queue;\n\n\t        /**\n\t         * 根据是否设置了最大缓存字节数\n\t         * 来用不同的构造器生成RequestQueue对象\n\t         * 其中第一个构造参数为一个实现了Cache.java接口的默认缓存读写类DiskBasedCache.java\n\t         * 现在只需要知道它是用来专门处理缓存的就可以了，后面也会对源码做出分析\n\t         * 第二个参数是接口Network.java类的引用，在上面两排不远处可以看到BasicNetwork.java\n\t         * 它是用来实现网络请求的一个类。\n\t         */\n```\n\n简单的说，Volley.java的用处就只有一个，创建并启动一个RequestQueue对象，可以有四个构造器供我们选择，可以通过继承其接口衍生出自己的一套网络请求部分的实现(继承HttpStack接口),还可以定义缓存大小的限制。对于框架的使用者来说自由度还是很大的，不是固定死只能通过默认实现来使用Volley,提供接口能使框架的灵活性大大提升，在自己写代码的过程中也要注意这个问题。\n\n* * *\n\n###2. RequestQueue.java\nRequestQueue可以说是Volley中最核心的部分了，所有的request都要从这边进来，等待工作线程的调度，调度完成之后从里面的ResponseDelivery返回给caller。下面是RequestQueue.java的所有代码以及每行代码的用途，读了几遍才弄清楚了这个东西的作用，之前都迷糊的不行orz。\n\n```\n\n    package com.android.volley;\n\n\timport android.os.Handler;\n\timport android.os.Looper;\n\n\timport java.util.ArrayList;\n\timport java.util.HashMap;\n\timport java.util.HashSet;\n\timport java.util.LinkedList;\n\timport java.util.List;\n\timport java.util.Map;\n\timport java.util.Queue;\n\timport java.util.Set;\n\timport java.util.concurrent.PriorityBlockingQueue;\n\timport java.util.concurrent.atomic.AtomicInteger;\n\n\t/**\n\t * A request dispatch queue with a thread pool of dispatchers.\n\t * \n\t *\n\t * Calling {@link #add(Request)} will enqueue the given Request for dispatch,\n\t * resolving from either cache or network on a worker thread, and then delivering\n\t * a parsed response on the main thread.\n\t * 调用mQueue.add(Request)函数将一个request放入请求调度队列中排队，将在工作线程中，\n\t * 从网络或者缓存两个方面对request进行分类并处理，将response返回给主线程中。\n\t */\n\tpublic class RequestQueue {\n\n\t    /** \n\t     * Callback interface for completed requests. \n\t     * request完成之后的回掉接口\n\t     * 其中的T用到了java的泛型，是Request调用者所期待返回的数据类型\n\t     * 例如String或者是Integer\n\t     */\n\t    public static interface RequestFinishedListener {\n\t        /**\n\t         * Called when a request has finished processing. \n\t         * 当一个Request被处理完成时来调用\n\t         * = =其实从方法的名字来看也能看出来\n\t         */\n\t        public void onRequestFinished(Request request);\n\t    }\n\n\t    /**\n\t     * Used for generating monotonically-increasing sequence numbers for requests. \n\t     * 用来为request生成单调递增的有序数字，刚才是不知道这里是干什么用的= =\n\t     * 在这里纠结了一小段时间就继续看了下去，直到在add()函数里面看到了这个的用处\n\t     * 在request被add()进来的时候会给每个request发一个类似于排队的序号一样的数字，就是用这个类来实现的\n\t     * \n\t     * 官方的解释是：An int value that may be updated atomically. \n\t     * An AtomicInteger is used in applications such as atomically incremented counters, and cannot be used as a replacement for an Integer.\n\t     * However, this class does extend Number to allow uniform access by tools and utilities that deal with numerically-based classes.\n\t     * 这个类是在需要自动递增计数器的应用中使用的，但是不能作为一个Integer的替代品。\n\t     * 但是这个类确实是继承自Number类的，其允许处理数字的一些工具来统一访问= =。。\n\t     */\n\t    private AtomicInteger mSequenceGenerator = new AtomicInteger();\n\n\t    /**\n\t     * Staging area for requests that already have a duplicate request in flight.\n\t     * 用HashMap来形成一个筹备区域，这个筹备区域是为重复的request准备的。\n\t     * 每个对应的cacheKey都有一个Queue来存储，因为相同的请求有时不止一个。\n\t     * 这些重复的request已经有一个在被处理了，其他的不用重复处理，在这个HashMap里面等着拿结果就可以了\n\t     * \n\t     *     containsKey(cacheKey) indicates that there is a request in flight for the given cache\n\t     *          key.\n\t     *         用containsKey(String cacheKey)可以判定一个已经发送出去的请求是否有重复的请求。\n\t     *     \n\t     *     get(cacheKey) returns waiting requests for the given cache key. The in flight request\n\t     *          is not contained in that list. Is null if no requests are staged.\n\t     *         get()方法会返回一个queue，这个queue有可能是空的，也有可能里面存放着具有相同cacheKey的一系列request\n\t     * \n\t     */\n\t    private final Map>> mWaitingRequests =\n\t            new HashMap>>();\n\n\t    /**\n\t     * The set of all requests currently being processed by this RequestQueue. A Request\n\t     * will be in this set if it is waiting in any queue or currently being processed by\n\t     * any dispatcher.\n\t     *\n\t     * 一个容纳着所有request的HashSet。\n\t     * 如果一个request正在被调度或者正处于等待状态，该request就在这个集合之中。\n\t     * 这么说的话，RequestQueue里面主要存储request的集合就是这个了。\n\t     * 在外面调用add(Request request)的时候，也就是加入到了这个HashSet之中。\n\t     */\n\t    private final Set> mCurrentRequests = new HashSet>();\n\n\t    /** \n\t     * The cache triage queue. \n\t     * 运用到了优先队列\n\t     * 也就是里面的每个元素都会有一个优先级，优先级高的比优先级低的要先调度。\n\t     * 这个队列里面存放着需要访问缓存的一些Request，等待着调度器(dispatcher)的处理\n\t     * 后面慢慢的会介绍到dispatcher\n\t     */\n\t    private final PriorityBlockingQueue> mCacheQueue =\n\t        new PriorityBlockingQueue>();\n\n\t    /** \n\t     * The queue of requests that are actually going out to the network.\n\t     * 网络请求队列\n\t     * 要通过网络在服务器上请求数据的request\n\t     * 还包括一些缓存出了点小问题的request也会被加入到这里\n\t     * 在后面的代码中能够看到\n\t     */\n\t    private final PriorityBlockingQueue> mNetworkQueue =\n\t        new PriorityBlockingQueue>();\n\n\t    /** \n\t     * Number of network request dispatcher threads to start. \n\t     * 网络请求调度线程池中线程的默认数量。\n\t     */\n\t    private static final int DEFAULT_NETWORK_THREAD_POOL_SIZE = 4;\n\n\t    /** \n\t     * Cache interface for retrieving and storing responses. \n\t     * 缓存的接口，用来从缓存中取出response或者存储response到缓存中。\n\t     */\n\t    private final Cache mCache;\n\n\t    /** \n\t     * Network interface for performing requests. \n\t     * 网络接口，用来进行网络请求。\n\t     */\n\t    private final Network mNetwork;\n\n\t    /**\n\t     * Response delivery mechanism. \n\t     * 响应交付机制\n\t     * 请求最后的结果(Response.java实例)通过mDelivery中的方法传回\n\t     * 这个过程需要在工作线程中才能看到，也就是在介绍dispatcher里面能看到\n\t     */\n\t    private final ResponseDelivery mDelivery;\n\n\t    /**\n\t     * The network dispatchers. \n\t     * 网络调度线程池\n\t     * 因为是涉及到网络的一个框架，工作的效率不能低\n\t     * 多开几个网络调度器线程来一起工作\n\t     */\n\t    private NetworkDispatcher[] mDispatchers;\n\n\t    /** \n\t     * The cache dispatcher. \n\t     * 缓存调度线程(和上面的差不多吧= =，但是不是线程池了)\n\t     * 处理了涉及到缓存的request\n\t     */\n\t    private CacheDispatcher mCacheDispatcher;\n\n\t    /**\n\t     * 这个貌似是和listener差不多的用处\n\t     * 每个request结束之后，就会通知所有已经注册过的listener(所谓注册无非就是实现了RequestFinishedListener.java这个接口\n\t     * 然后再将自己传入，加入到这个ArrayList里面来)\n\t     * 在{@link #finish()}里面会用到这个ArrayList\n\t     */\n\t    private List mFinishedListeners =\n\t            new ArrayList();\n\n\t    /**\n\t     * Creates the worker pool. Processing will not begin until {@link #start()} is called.\n\t     * 创建工作线程，在start()调用之后开始不停的工作\n\t     *\n\t     * @param cache A Cache to use for persisting responses to disk\n\t     * 涉及到内存访问的接口\n\t     * @param network A Network interface for performing HTTP requests\n\t     * 用来进行HTTP请求的网络接口\n\t     * @param threadPoolSize Number of network dispatcher threads to create\n\t     * 网络请求线程池，里面放着很多个线程，可以同时处理多个需要网络访问的request\n\t     * @param delivery A ResponseDelivery interface for posting responses and errors\n\t     * 一个用来传递resposne和error的接口\n\t     */\n\t    public RequestQueue(Cache cache, Network network, int threadPoolSize,\n\t            ResponseDelivery delivery) {\n\t        mCache = cache;\n\t        mNetwork = network;\n\t        mDispatchers = new NetworkDispatcher[threadPoolSize];\n\t        mDelivery = delivery;\n\t    }\n\n\t    /**\n\t     * Creates the worker pool. Processing will not begin until {@link #start()} is called.\n\t     *\n\t     * @param cache A Cache to use for persisting responses to disk\n\t     * @param network A Network interface for performing HTTP requests\n\t     * @param threadPoolSize Number of network dispatcher threads to create\n\t     */\n\t    public RequestQueue(Cache cache, Network network, int threadPoolSize) {\n\t        this(cache, network, threadPoolSize,\n\t                new ExecutorDelivery(new Handler(Looper.getMainLooper())));\n\t    }\n\n\t    /**\n\t     * Creates the worker pool. Processing will not begin until {@link #start()} is called.\n\t     *\n\t     * @param cache A Cache to use for persisting responses to disk\n\t     * @param network A Network interface for performing HTTP requests\n\t     */\n\t    public RequestQueue(Cache cache, Network network) {\n\t        this(cache, network, DEFAULT_NETWORK_THREAD_POOL_SIZE);\n\t    }\n\n\t    /**\n\t     * Starts the dispatchers in this queue.\n\t     * 先将所有的调度线程都停止\n\t     * 再重新创建并启动\n\t     * 将mNetworkQueue和mCacheQueue传入到dispatcher中\n\t     * 方便从queue中取出request来进行处理\n\t     * 将mDelivery接口传入，方便将请求结果返回\n\t     * \n\t     * cacheDispatcher创建一个就够了，networkDispatcher创建了多个\n\t     * network花费时间比较长，需要开多个线程来工作\n\t     */\n\t    public void start() {\n\t        stop();  // Make sure any currently running dispatchers are stopped.\n\t        // Create the cache dispatcher and start it.\n\t        mCacheDispatcher = new CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);\n\t        mCacheDispatcher.start();\n\n\t        // Create network dispatchers (and corresponding threads) up to the pool size.\n\t        for (int i = 0; i < mDispatchers.length; i++) {\n\t            NetworkDispatcher networkDispatcher = new NetworkDispatcher(mNetworkQueue, mNetwork,\n\t                    mCache, mDelivery);\n\t            mDispatchers[i] = networkDispatcher;\n\t            networkDispatcher.start();\n\t        }\n\t    }\n\n\t    /**\n\t     * Stops the cache and network dispatchers.\n\t     * 将所有正在工作状态的dispatcher挨个退出\n\t     */\n\t    public void stop() {\n\t        if (mCacheDispatcher != null) {\n\t            mCacheDispatcher.quit();\n\t        }\n\t        for (int i = 0; i < mDispatchers.length; i++) {\n\t            if (mDispatchers[i] != null) {\n\t                mDispatchers[i].quit();\n\t            }\n\t        }\n\t    }\n\n\t    /**\n\t     * Gets a sequence number.\n\t     *\n\t     * incrementAndGet() : Atomically increments by one the current value.\n\t     * 自动向上涨一个单位然后返回当前值\n\t     * 在后面的{@link RequestQueue#add(Request)}函数中能看到这个的作用\n\t     * 用到了在前面提到过的AtomicInteger类\n\t     */\n\t    public int getSequenceNumber() {\n\t        return mSequenceGenerator.incrementAndGet();\n\t    }\n\n\t    /**\n\t     * Gets the {@link Cache} instance being used.\n\t     * 返回当前正在使用的cache引用\n\t     */\n\t    public Cache getCache() {\n\t        return mCache;\n\t    }\n\n\t    /**\n\t     * A simple predicate or filter interface for Requests, for use by\n\t     * {@link RequestQueue#cancelAll(RequestFilter)}.\n\t     * 一个request的过滤器\n\t     * 上面说是给cancelAll用的，应该是设置一个RequestFilter之后\n\t     * 将一类的request全都取消掉，至于具体的规则就需要重写里面的函数\n\t     * 定义规则了\n\t     */\n\t    public interface RequestFilter {\n\t        public boolean apply(Request request);\n\t    }\n\n\t    /**\n\t     * Cancels all requests in this queue for which the given filter applies.\n\t     * 从外面传入一个RequestFilter\n\t     * 按照传入的规则取消所有符合规则的request\n\t     * @param filter The filtering function to use\n\t     */\n\t    public void cancelAll(RequestFilter filter) {\n\t        synchronized (mCurrentRequests) {\n\t            for (Request request : mCurrentRequests) {\n\t                if (filter.apply(request)) {\n\t                    request.cancel();\n\t                }\n\t            }\n\t        }\n\t    }\n\n\t    /**\n\t     * Cancels all requests in this queue with the given tag. Tag must be non-null\n\t     * 依据request上面的tag来取消\n\t     * and equality is by identity.\n\t     */\n\t    public void cancelAll(final Object tag) {\n\t        if (tag == null) {\n\t            throw new IllegalArgumentException(\"Cannot cancelAll with a null tag\");\n\t        }\n\t        cancelAll(new RequestFilter() {\n\t            @Override\n\t            public boolean apply(Request request) {\n\t                return request.getTag() == tag;\n\t            }\n\t        });\n\t    }\n\n\t    /**\n\t     * Adds a Request to the dispatch queue.\n\t     * 将新的request加入到总的等待队列中去\n\t     * 一个request被处理之前都要待的地方\n\t     * mCurrentRequests里面存放着所有的request \n\t     *\n\t     * @param request The request to service\n\t     * 被传入的request，等待被处理\n\t     * @return The passed-in request\n\t     * 将加入的request返回回去\n\t     */\n\t    public  Request add(Request request) {\n\t        // Tag the request as belonging to this queue and add it to the set of current requests.\n\t        request.setRequestQueue(this);\n\n\t        /**\n\t         * 在向mCurrentRequest中添加request的时候\n\t         * 锁住不允许其他的线程进行访问操作\n\t         * 对于synchronized:可用来给对象和方法或者代码块加锁，\n\t         * 当它锁定一个方法或者一个代码块的时候，同一时刻最多只有一个线程执行这段代码。\n\t         * 当两个并发线程访问同一个对象object中的这个加锁同步代码块时，一个时间内只能有一个线程得到执行。\n\t         * 另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。\n\t         * \n\t         */\n\t        synchronized (mCurrentRequests) {\n\t            mCurrentRequests.add(request);\n\t        }\n\n\t        /**\n\t         * Process requests in the order they are added.\n\t         * 在加入到mCurrentQueue中排队的时候\n\t         * 就像我们排队一样会给我们一个对应的号码牌\n\t         * 只是这里用了getSequenceNumber()函数来自动的发放号码牌\n\t         */\n\t        request.setSequence(getSequenceNumber());\n\t        request.addMarker(\"add-to-queue\");\n\n\t        /** \n\t         * If the request is uncacheable, skip the cache queue and go straight to the network.\n\t         * 检查这个request是否是不可缓存的\n\t         * 也就是这个request所返回的response是否需要缓存下来\n\t         */\n\t        if (!request.shouldCache()) {\n\n\t            /**\n\t             * 如果不需要缓存的话\n\t             * 直接将这个request加入到网络队列中去\n\t             * 并且返回该request\n\t             */\n\t            mNetworkQueue.add(request);\n\t            return request;\n\t        }\n\n\t        /**\n\t         * Insert request into stage if there's already a request with the same cache key in flight.\n\t         * = =尼玛我这是什么记性，看见这个mWaittingRequests居然不认识了\n\t         * 向前翻到变量声明的地方，清清楚楚的写着专门存放重复请求的地方\n\t         * 根据需要缓存的request生成的特殊标记cacheKey\n\t         * 当然不涉及到缓存的request在上面几行代码被过滤处理了\n\t         */\n\t        synchronized (mWaitingRequests) {\n\n\t            /**\n\t             * 先获取到这个request的cacheKey\n\t             * 看看有没有和它相同的request已经处于天上飞的状态了\n\t             * (我觉得这里的in flight应该说的是已经发送过了的)\n\t             * 在后面会说明\n\t             */\n\t            String cacheKey = request.getCacheKey();\n\n\t            if (mWaitingRequests.containsKey(cacheKey)) {\n\n\t                /**\n\t                 * There is already a request in flight. Queue up.\n\t                 * 如果在等待的队列里面存在着cacheKey对应的一个Queue\n\t                 * 则说明在这个request之前，已经有相同的request发送出去过了\n\t                 * 那么现在需要做的就是将这个request加入到cacheKey对应的Queue存起来\n\t                 * 如果对应的Queue是null,就自己创建一个新的，再把request放入\n\t                 * \n\t                 * 这个request就不再会被放入到mCacheQueue中去了\n\t                 * 就是坐等数据的意思= =\n\t                 */\n\t                Queue> stagedRequests = mWaitingRequests.get(cacheKey);\n\t                if (stagedRequests == null) {\n\t                    stagedRequests = new LinkedList>();\n\t                }\n\t                stagedRequests.add(request);\n\t                mWaitingRequests.put(cacheKey, stagedRequests);\n\t                if (VolleyLog.DEBUG) {\n\t                    VolleyLog.v(\"Request for cacheKey=%s is in flight, putting on hold.\", cacheKey);\n\t                }\n\t            } else {\n\t                /**\n\t                 * Insert 'null' queue for this cacheKey, indicating there is now a request in flight.\n\t                 * 如果这个涉及到cache的request在它之前根本就没有和他相同的request\n\t                 * 直接以这个cacheKey为key，放一个null进去\n\t                 * 表示这是第一个么= =\n\t                 * 搞不懂为什么要这个样子设计，为什么不直接新建一个Queue进去呢\n\t                 */\n\t                mWaitingRequests.put(cacheKey, null);\n\t                mCacheQueue.add(request);\n\t            }\n\t            return request;\n\t        }\n\t    }\n\n\t    /**\n\t     * Called from {@link Request#finish(String)}, indicating that processing of the given request\n\t     * has finished.\n\t     * 从Request中的finish()方法调用开始，预示着给出的request已经结束\n\t     * Releases waiting requests for request.getCacheKey() if\n\t     *      request.shouldCache().\n\t     * 将处于mWaittingQueue中具有相同cacheKey的一组request全部释放\n\t     * 也就是把上面那些坐等数据的request全部取出来，response发送回去\n\t     */\n\t     void finish(Request request) {\n\t        // Remove from the set of requests currently being processed.\n\t        /**\n\t         * 将mCurrentRequests锁住\n\t         * 一个时间段内只有一个线程可以访问该对象\n\t         * 将已经结束的request从队列中移除\n\t         */\n\t        synchronized (mCurrentRequests) {\n\t            mCurrentRequests.remove(request);\n\t        }\n\n\t        /**\n\t         * 通知所有注册过的监听器\n\t         * 告诉它们，request已经finish了\n\t         */\n\t        synchronized (mFinishedListeners) {\n\t          for (RequestFinishedListener listener : mFinishedListeners) {\n\t            listener.onRequestFinished(request);\n\t          }\n\t        }\n\n\t        /**\n\t         * 如果该request涉及到需要缓存\n\t         * 则将mWaitingRequests中具有相同cacheKey的request\n\t         * 全部取出放入到缓存队列中等待CacheDispatcher的调度\n\t         */\n\t        if (request.shouldCache()) {\n\t            synchronized (mWaitingRequests) {\n\t                String cacheKey = request.getCacheKey();\n\t                Queue> waitingRequests = mWaitingRequests.remove(cacheKey);\n\t                if (waitingRequests != null) {\n\t                    if (VolleyLog.DEBUG) {\n\t                        VolleyLog.v(\"Releasing %d waiting requests for cacheKey=%s.\",\n\t                                waitingRequests.size(), cacheKey);\n\t                    }\n\t                    // Process all queued up requests. They won't be considered as in flight, but\n\t                    // that's not a problem as the cache has been primed by 'request'.\n\t                    mCacheQueue.addAll(waitingRequests);\n\t                }\n\t            }\n\t        }\n\t    }\n\n\t    /**\n\t     * 下面两个方法就是所谓注册监听器和取消注册的函数\n\t     */\n\t    public   void addRequestFinishedListener(RequestFinishedListener listener) {\n\t      synchronized (mFinishedListeners) {\n\t        mFinishedListeners.add(listener);\n\t      }\n\t    }\n\n\t    /**\n\t     * Remove a RequestFinishedListener. Has no effect if listener was not previously added.\n\t     */\n\t    public   void removeRequestFinishedListener(RequestFinishedListener listener) {\n\t      synchronized (mFinishedListeners) {\n\t        mFinishedListeners.remove(listener);\n\t      }\n\t    }\n\t}\n\n```\n\n上面介绍了Volley.java和RequestQueue.java两大类，Volley是对外的入口，而RequestQueue是Volley框架中最核心的部分了。如果注释上面有写错了或者有疑问的地方，还请各位直接指出在下一篇博客中将继续向下深入，结合源代码分析什么是Dispatcher。","source":"_posts/Volley框架解析-二-Volley以及RequestQueue解析.md","raw":"---\ntitle: Volley框架解析(二)Volley以及RequestQueue解析\ndate: 2017-02-28 16:43:26\ntags: volley\n\n---\n\n## Volley框架解析(二)-----Volley及RequestQueue解析\n\n\n### [](#u9898_u5916_u8BDD_28_u53EF_u76F4_u63A5_u65E0_u89C6_u8DF3_u8FC7 \"题外话(可直接无视跳过\")题外话(可直接无视跳过\n\n是第一次比较完整的去阅读一个框架的源码，刚开始看的时候可以说是除了认识几个基本的`public, interface, final`等关键词之外，其他的一律不通orz，而且还不知道从哪里下手。后来磨蹭了好久还是慢慢的静下心来，对照着Java文档和Android文档查阅，刚开始都是陌生的，慢慢的在源码旁边打上注释，多看两遍就会get了。\n\n有些地方在一个.java文件里面是无法理解用处的，这样的先直接跳过不要纠结，看到对应用的地方就会恍然大悟了。还总结出了一个小技巧就是从框架暴露给外面的接口开始阅读，因为框架里面是一层一层往上的，底层是为了上层服务的，所以从接口开始阅读能很好的向下展开。\n\n前面一篇对Volley做了一个初步的介绍以及从整体上的一个解析，只是简单的描述了Request在Volley中是如何被处理的。从这篇博客开始将从最顶层一步一步的向下挖掘每一行代码，从最开始调用的地方`RequestQueue mQueue = Volley.newRequestQueue(mContext)`开始。\n\n<!--more-->\n\n***\n\n### [](#1-_Volley-java \"1\\. Volley.java\")1\\. Volley.java\n\nVolley.java是Volley整个框架对外暴露的接口，里面有四个重载的同名静态函数，方便直接使用。下面结合源代码来分析，主要是代码里面的注释。\n\n```\n\n    package com.android.volley.toolbox;\n\n\timport android.content.Context;\n\timport android.content.pm.PackageInfo;\n\timport android.content.pm.PackageManager.NameNotFoundException;\n\timport android.net.http.AndroidHttpClient;\n\timport android.os.Build;\n\n\timport com.android.volley.Network;\n\timport com.android.volley.RequestQueue;\n\n\timport java.io.File;\n\n\tpublic class Volley {\n\n\t    /** Default on-disk cache directory. */\n\t    private static final String DEFAULT_CACHE_DIR = \"volley\";\n\n\t    /**\n\t     * Creates a default instance of the worker pool and calls {@link RequestQueue#start()} on it.\n\t     * You may set a maximum size of the disk cache in bytes.\n\t     * 创建一个默认的线程池，并将其启动\n\t     * 还能通过构造函数来设置缓存的最大容量，默认的是5*1024*1024个字节\n\t     *\n\t     * @param context A {@link Context} to use for creating the cache dir.\n\t     * 用于创建缓存目录的context\n\t     * @param stack An {@link HttpStack} to use for the network, or null for default.\n\t     * HttpStack可以通过外面自定义之后传入，也可以不管直接用默认的\n\t     * @param maxDiskCacheBytes the maximum size of the disk cache, in bytes. Use -1 for default size.\n\t     * 最大缓存的字节数\n\t     * @return A started {@link RequestQueue} instance.\n\t     */\n\t    public static RequestQueue newRequestQueue(Context context, HttpStack stack, int maxDiskCacheBytes) {\n\n\t    \t//通过context，创建用于缓存文件的目录\n\t        File cacheDir = new File(context.getCacheDir(), DEFAULT_CACHE_DIR);\n\n\t        String userAgent = \"volley/0\";\n\n\t        try {\n\t            String packageName = context.getPackageName();\n\n\t            /**\n\t             * 关于PackageInfo，官方文档的解释如下：\n\t             * Overall information about the contents of a package.\n\t             * This corresponds to all of the information collected from AndroidManifest.xml.\n\t             * 该类作为Package信息的基类，还有很多子类例如：ApplicationInfo、 ComponentInfo等。\n\t             * 这些类包含了一些关于安装包的信息，icon,label等\n\t             */\n\t            PackageInfo info = context.getPackageManager().getPackageInfo(packageName, 0);\n\t            //获取到了Package的版本号\n\t            userAgent = packageName + \"/\" + info.versionCode;\n\n\t        } catch (NameNotFoundException e) {\n\t        }\n\n\t        /**\n\t         * HttpStack是一个用于网络请求的接口\n\t         * 如果传入的stack为空，则根据当前系统的版本号，来选择不同的实现了HttpStack(Volley自己的一个接口)的类对象\n\t         * 高于android2.3就用HurlStack(实现了HttpStack接口，基于HttpsURLConnection)\n\t         * 低于android2.3就用HttpClientStack(实现了HttpStack接口，基于HttpClient)\n\t         */\n\t        if (stack == null) {\n\t            if (Build.VERSION.SDK_INT >= 9) {\n\t                stack = new HurlStack();\n\t            } else {\n\t                // Prior to Gingerbread, HttpUrlConnection was unreliable.\n\t                // See: http://android-developers.blogspot.com/2011/09/androids-http-clients.html\n\t                stack = new HttpClientStack(AndroidHttpClient.newInstance(userAgent));\n\t            }\n\t        }\n\n\t        /**\n\t         * 创建了一个用于发送特定请求的Network类对象\n\t         * 该接口中有一个与HttpStack接口中同名的方法(performRequest)\n\t         * 但是参数的内容不同， 返回的类型也有所区别\n\t         * Network的返回类型是自定义的一个NetworkResponse类\n\t         * 而HttpStack返回的是HttpResponse\n\t         * (HttpResponse是java.apache.http中的一个类，里面包含了服务器返回的一些数据)\n\t         * \n\t         * 将stack传入到了已经实现了Network接口的一个BasicNetwork类中\n\t         * 在后面发送Request请求的时候会调用Network.performRequest()\n\t         * 然后在Network.performRequest()函数中会继续调用HttpStack.performRequest()\n\t         * 真正的网络请求发出是在HttpStack.performRequest()中进行的\n\t         */\n\n\t        Network network = new BasicNetwork(stack);\n\n\t        /**\n\t         * 创建一个RequestQueue引用\n\t         * RequestQueue是volley实现的一个请求调度队列\n\t         * 用来分发处理request\n\t         * 后面会分析RequestQueue.java\n\t         */\n\t        RequestQueue queue;\n\n\t        /**\n\t         * 根据是否设置了最大缓存字节数\n\t         * 来用不同的构造器生成RequestQueue对象\n\t         * 其中第一个构造参数为一个实现了Cache.java接口的默认缓存读写类DiskBasedCache.java\n\t         * 现在只需要知道它是用来专门处理缓存的就可以了，后面也会对源码做出分析\n\t         * 第二个参数是接口Network.java类的引用，在上面两排不远处可以看到BasicNetwork.java\n\t         * 它是用来实现网络请求的一个类。\n\t         */\n```\n\n简单的说，Volley.java的用处就只有一个，创建并启动一个RequestQueue对象，可以有四个构造器供我们选择，可以通过继承其接口衍生出自己的一套网络请求部分的实现(继承HttpStack接口),还可以定义缓存大小的限制。对于框架的使用者来说自由度还是很大的，不是固定死只能通过默认实现来使用Volley,提供接口能使框架的灵活性大大提升，在自己写代码的过程中也要注意这个问题。\n\n* * *\n\n###2. RequestQueue.java\nRequestQueue可以说是Volley中最核心的部分了，所有的request都要从这边进来，等待工作线程的调度，调度完成之后从里面的ResponseDelivery返回给caller。下面是RequestQueue.java的所有代码以及每行代码的用途，读了几遍才弄清楚了这个东西的作用，之前都迷糊的不行orz。\n\n```\n\n    package com.android.volley;\n\n\timport android.os.Handler;\n\timport android.os.Looper;\n\n\timport java.util.ArrayList;\n\timport java.util.HashMap;\n\timport java.util.HashSet;\n\timport java.util.LinkedList;\n\timport java.util.List;\n\timport java.util.Map;\n\timport java.util.Queue;\n\timport java.util.Set;\n\timport java.util.concurrent.PriorityBlockingQueue;\n\timport java.util.concurrent.atomic.AtomicInteger;\n\n\t/**\n\t * A request dispatch queue with a thread pool of dispatchers.\n\t * \n\t *\n\t * Calling {@link #add(Request)} will enqueue the given Request for dispatch,\n\t * resolving from either cache or network on a worker thread, and then delivering\n\t * a parsed response on the main thread.\n\t * 调用mQueue.add(Request)函数将一个request放入请求调度队列中排队，将在工作线程中，\n\t * 从网络或者缓存两个方面对request进行分类并处理，将response返回给主线程中。\n\t */\n\tpublic class RequestQueue {\n\n\t    /** \n\t     * Callback interface for completed requests. \n\t     * request完成之后的回掉接口\n\t     * 其中的T用到了java的泛型，是Request调用者所期待返回的数据类型\n\t     * 例如String或者是Integer\n\t     */\n\t    public static interface RequestFinishedListener {\n\t        /**\n\t         * Called when a request has finished processing. \n\t         * 当一个Request被处理完成时来调用\n\t         * = =其实从方法的名字来看也能看出来\n\t         */\n\t        public void onRequestFinished(Request request);\n\t    }\n\n\t    /**\n\t     * Used for generating monotonically-increasing sequence numbers for requests. \n\t     * 用来为request生成单调递增的有序数字，刚才是不知道这里是干什么用的= =\n\t     * 在这里纠结了一小段时间就继续看了下去，直到在add()函数里面看到了这个的用处\n\t     * 在request被add()进来的时候会给每个request发一个类似于排队的序号一样的数字，就是用这个类来实现的\n\t     * \n\t     * 官方的解释是：An int value that may be updated atomically. \n\t     * An AtomicInteger is used in applications such as atomically incremented counters, and cannot be used as a replacement for an Integer.\n\t     * However, this class does extend Number to allow uniform access by tools and utilities that deal with numerically-based classes.\n\t     * 这个类是在需要自动递增计数器的应用中使用的，但是不能作为一个Integer的替代品。\n\t     * 但是这个类确实是继承自Number类的，其允许处理数字的一些工具来统一访问= =。。\n\t     */\n\t    private AtomicInteger mSequenceGenerator = new AtomicInteger();\n\n\t    /**\n\t     * Staging area for requests that already have a duplicate request in flight.\n\t     * 用HashMap来形成一个筹备区域，这个筹备区域是为重复的request准备的。\n\t     * 每个对应的cacheKey都有一个Queue来存储，因为相同的请求有时不止一个。\n\t     * 这些重复的request已经有一个在被处理了，其他的不用重复处理，在这个HashMap里面等着拿结果就可以了\n\t     * \n\t     *     containsKey(cacheKey) indicates that there is a request in flight for the given cache\n\t     *          key.\n\t     *         用containsKey(String cacheKey)可以判定一个已经发送出去的请求是否有重复的请求。\n\t     *     \n\t     *     get(cacheKey) returns waiting requests for the given cache key. The in flight request\n\t     *          is not contained in that list. Is null if no requests are staged.\n\t     *         get()方法会返回一个queue，这个queue有可能是空的，也有可能里面存放着具有相同cacheKey的一系列request\n\t     * \n\t     */\n\t    private final Map>> mWaitingRequests =\n\t            new HashMap>>();\n\n\t    /**\n\t     * The set of all requests currently being processed by this RequestQueue. A Request\n\t     * will be in this set if it is waiting in any queue or currently being processed by\n\t     * any dispatcher.\n\t     *\n\t     * 一个容纳着所有request的HashSet。\n\t     * 如果一个request正在被调度或者正处于等待状态，该request就在这个集合之中。\n\t     * 这么说的话，RequestQueue里面主要存储request的集合就是这个了。\n\t     * 在外面调用add(Request request)的时候，也就是加入到了这个HashSet之中。\n\t     */\n\t    private final Set> mCurrentRequests = new HashSet>();\n\n\t    /** \n\t     * The cache triage queue. \n\t     * 运用到了优先队列\n\t     * 也就是里面的每个元素都会有一个优先级，优先级高的比优先级低的要先调度。\n\t     * 这个队列里面存放着需要访问缓存的一些Request，等待着调度器(dispatcher)的处理\n\t     * 后面慢慢的会介绍到dispatcher\n\t     */\n\t    private final PriorityBlockingQueue> mCacheQueue =\n\t        new PriorityBlockingQueue>();\n\n\t    /** \n\t     * The queue of requests that are actually going out to the network.\n\t     * 网络请求队列\n\t     * 要通过网络在服务器上请求数据的request\n\t     * 还包括一些缓存出了点小问题的request也会被加入到这里\n\t     * 在后面的代码中能够看到\n\t     */\n\t    private final PriorityBlockingQueue> mNetworkQueue =\n\t        new PriorityBlockingQueue>();\n\n\t    /** \n\t     * Number of network request dispatcher threads to start. \n\t     * 网络请求调度线程池中线程的默认数量。\n\t     */\n\t    private static final int DEFAULT_NETWORK_THREAD_POOL_SIZE = 4;\n\n\t    /** \n\t     * Cache interface for retrieving and storing responses. \n\t     * 缓存的接口，用来从缓存中取出response或者存储response到缓存中。\n\t     */\n\t    private final Cache mCache;\n\n\t    /** \n\t     * Network interface for performing requests. \n\t     * 网络接口，用来进行网络请求。\n\t     */\n\t    private final Network mNetwork;\n\n\t    /**\n\t     * Response delivery mechanism. \n\t     * 响应交付机制\n\t     * 请求最后的结果(Response.java实例)通过mDelivery中的方法传回\n\t     * 这个过程需要在工作线程中才能看到，也就是在介绍dispatcher里面能看到\n\t     */\n\t    private final ResponseDelivery mDelivery;\n\n\t    /**\n\t     * The network dispatchers. \n\t     * 网络调度线程池\n\t     * 因为是涉及到网络的一个框架，工作的效率不能低\n\t     * 多开几个网络调度器线程来一起工作\n\t     */\n\t    private NetworkDispatcher[] mDispatchers;\n\n\t    /** \n\t     * The cache dispatcher. \n\t     * 缓存调度线程(和上面的差不多吧= =，但是不是线程池了)\n\t     * 处理了涉及到缓存的request\n\t     */\n\t    private CacheDispatcher mCacheDispatcher;\n\n\t    /**\n\t     * 这个貌似是和listener差不多的用处\n\t     * 每个request结束之后，就会通知所有已经注册过的listener(所谓注册无非就是实现了RequestFinishedListener.java这个接口\n\t     * 然后再将自己传入，加入到这个ArrayList里面来)\n\t     * 在{@link #finish()}里面会用到这个ArrayList\n\t     */\n\t    private List mFinishedListeners =\n\t            new ArrayList();\n\n\t    /**\n\t     * Creates the worker pool. Processing will not begin until {@link #start()} is called.\n\t     * 创建工作线程，在start()调用之后开始不停的工作\n\t     *\n\t     * @param cache A Cache to use for persisting responses to disk\n\t     * 涉及到内存访问的接口\n\t     * @param network A Network interface for performing HTTP requests\n\t     * 用来进行HTTP请求的网络接口\n\t     * @param threadPoolSize Number of network dispatcher threads to create\n\t     * 网络请求线程池，里面放着很多个线程，可以同时处理多个需要网络访问的request\n\t     * @param delivery A ResponseDelivery interface for posting responses and errors\n\t     * 一个用来传递resposne和error的接口\n\t     */\n\t    public RequestQueue(Cache cache, Network network, int threadPoolSize,\n\t            ResponseDelivery delivery) {\n\t        mCache = cache;\n\t        mNetwork = network;\n\t        mDispatchers = new NetworkDispatcher[threadPoolSize];\n\t        mDelivery = delivery;\n\t    }\n\n\t    /**\n\t     * Creates the worker pool. Processing will not begin until {@link #start()} is called.\n\t     *\n\t     * @param cache A Cache to use for persisting responses to disk\n\t     * @param network A Network interface for performing HTTP requests\n\t     * @param threadPoolSize Number of network dispatcher threads to create\n\t     */\n\t    public RequestQueue(Cache cache, Network network, int threadPoolSize) {\n\t        this(cache, network, threadPoolSize,\n\t                new ExecutorDelivery(new Handler(Looper.getMainLooper())));\n\t    }\n\n\t    /**\n\t     * Creates the worker pool. Processing will not begin until {@link #start()} is called.\n\t     *\n\t     * @param cache A Cache to use for persisting responses to disk\n\t     * @param network A Network interface for performing HTTP requests\n\t     */\n\t    public RequestQueue(Cache cache, Network network) {\n\t        this(cache, network, DEFAULT_NETWORK_THREAD_POOL_SIZE);\n\t    }\n\n\t    /**\n\t     * Starts the dispatchers in this queue.\n\t     * 先将所有的调度线程都停止\n\t     * 再重新创建并启动\n\t     * 将mNetworkQueue和mCacheQueue传入到dispatcher中\n\t     * 方便从queue中取出request来进行处理\n\t     * 将mDelivery接口传入，方便将请求结果返回\n\t     * \n\t     * cacheDispatcher创建一个就够了，networkDispatcher创建了多个\n\t     * network花费时间比较长，需要开多个线程来工作\n\t     */\n\t    public void start() {\n\t        stop();  // Make sure any currently running dispatchers are stopped.\n\t        // Create the cache dispatcher and start it.\n\t        mCacheDispatcher = new CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);\n\t        mCacheDispatcher.start();\n\n\t        // Create network dispatchers (and corresponding threads) up to the pool size.\n\t        for (int i = 0; i < mDispatchers.length; i++) {\n\t            NetworkDispatcher networkDispatcher = new NetworkDispatcher(mNetworkQueue, mNetwork,\n\t                    mCache, mDelivery);\n\t            mDispatchers[i] = networkDispatcher;\n\t            networkDispatcher.start();\n\t        }\n\t    }\n\n\t    /**\n\t     * Stops the cache and network dispatchers.\n\t     * 将所有正在工作状态的dispatcher挨个退出\n\t     */\n\t    public void stop() {\n\t        if (mCacheDispatcher != null) {\n\t            mCacheDispatcher.quit();\n\t        }\n\t        for (int i = 0; i < mDispatchers.length; i++) {\n\t            if (mDispatchers[i] != null) {\n\t                mDispatchers[i].quit();\n\t            }\n\t        }\n\t    }\n\n\t    /**\n\t     * Gets a sequence number.\n\t     *\n\t     * incrementAndGet() : Atomically increments by one the current value.\n\t     * 自动向上涨一个单位然后返回当前值\n\t     * 在后面的{@link RequestQueue#add(Request)}函数中能看到这个的作用\n\t     * 用到了在前面提到过的AtomicInteger类\n\t     */\n\t    public int getSequenceNumber() {\n\t        return mSequenceGenerator.incrementAndGet();\n\t    }\n\n\t    /**\n\t     * Gets the {@link Cache} instance being used.\n\t     * 返回当前正在使用的cache引用\n\t     */\n\t    public Cache getCache() {\n\t        return mCache;\n\t    }\n\n\t    /**\n\t     * A simple predicate or filter interface for Requests, for use by\n\t     * {@link RequestQueue#cancelAll(RequestFilter)}.\n\t     * 一个request的过滤器\n\t     * 上面说是给cancelAll用的，应该是设置一个RequestFilter之后\n\t     * 将一类的request全都取消掉，至于具体的规则就需要重写里面的函数\n\t     * 定义规则了\n\t     */\n\t    public interface RequestFilter {\n\t        public boolean apply(Request request);\n\t    }\n\n\t    /**\n\t     * Cancels all requests in this queue for which the given filter applies.\n\t     * 从外面传入一个RequestFilter\n\t     * 按照传入的规则取消所有符合规则的request\n\t     * @param filter The filtering function to use\n\t     */\n\t    public void cancelAll(RequestFilter filter) {\n\t        synchronized (mCurrentRequests) {\n\t            for (Request request : mCurrentRequests) {\n\t                if (filter.apply(request)) {\n\t                    request.cancel();\n\t                }\n\t            }\n\t        }\n\t    }\n\n\t    /**\n\t     * Cancels all requests in this queue with the given tag. Tag must be non-null\n\t     * 依据request上面的tag来取消\n\t     * and equality is by identity.\n\t     */\n\t    public void cancelAll(final Object tag) {\n\t        if (tag == null) {\n\t            throw new IllegalArgumentException(\"Cannot cancelAll with a null tag\");\n\t        }\n\t        cancelAll(new RequestFilter() {\n\t            @Override\n\t            public boolean apply(Request request) {\n\t                return request.getTag() == tag;\n\t            }\n\t        });\n\t    }\n\n\t    /**\n\t     * Adds a Request to the dispatch queue.\n\t     * 将新的request加入到总的等待队列中去\n\t     * 一个request被处理之前都要待的地方\n\t     * mCurrentRequests里面存放着所有的request \n\t     *\n\t     * @param request The request to service\n\t     * 被传入的request，等待被处理\n\t     * @return The passed-in request\n\t     * 将加入的request返回回去\n\t     */\n\t    public  Request add(Request request) {\n\t        // Tag the request as belonging to this queue and add it to the set of current requests.\n\t        request.setRequestQueue(this);\n\n\t        /**\n\t         * 在向mCurrentRequest中添加request的时候\n\t         * 锁住不允许其他的线程进行访问操作\n\t         * 对于synchronized:可用来给对象和方法或者代码块加锁，\n\t         * 当它锁定一个方法或者一个代码块的时候，同一时刻最多只有一个线程执行这段代码。\n\t         * 当两个并发线程访问同一个对象object中的这个加锁同步代码块时，一个时间内只能有一个线程得到执行。\n\t         * 另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。\n\t         * \n\t         */\n\t        synchronized (mCurrentRequests) {\n\t            mCurrentRequests.add(request);\n\t        }\n\n\t        /**\n\t         * Process requests in the order they are added.\n\t         * 在加入到mCurrentQueue中排队的时候\n\t         * 就像我们排队一样会给我们一个对应的号码牌\n\t         * 只是这里用了getSequenceNumber()函数来自动的发放号码牌\n\t         */\n\t        request.setSequence(getSequenceNumber());\n\t        request.addMarker(\"add-to-queue\");\n\n\t        /** \n\t         * If the request is uncacheable, skip the cache queue and go straight to the network.\n\t         * 检查这个request是否是不可缓存的\n\t         * 也就是这个request所返回的response是否需要缓存下来\n\t         */\n\t        if (!request.shouldCache()) {\n\n\t            /**\n\t             * 如果不需要缓存的话\n\t             * 直接将这个request加入到网络队列中去\n\t             * 并且返回该request\n\t             */\n\t            mNetworkQueue.add(request);\n\t            return request;\n\t        }\n\n\t        /**\n\t         * Insert request into stage if there's already a request with the same cache key in flight.\n\t         * = =尼玛我这是什么记性，看见这个mWaittingRequests居然不认识了\n\t         * 向前翻到变量声明的地方，清清楚楚的写着专门存放重复请求的地方\n\t         * 根据需要缓存的request生成的特殊标记cacheKey\n\t         * 当然不涉及到缓存的request在上面几行代码被过滤处理了\n\t         */\n\t        synchronized (mWaitingRequests) {\n\n\t            /**\n\t             * 先获取到这个request的cacheKey\n\t             * 看看有没有和它相同的request已经处于天上飞的状态了\n\t             * (我觉得这里的in flight应该说的是已经发送过了的)\n\t             * 在后面会说明\n\t             */\n\t            String cacheKey = request.getCacheKey();\n\n\t            if (mWaitingRequests.containsKey(cacheKey)) {\n\n\t                /**\n\t                 * There is already a request in flight. Queue up.\n\t                 * 如果在等待的队列里面存在着cacheKey对应的一个Queue\n\t                 * 则说明在这个request之前，已经有相同的request发送出去过了\n\t                 * 那么现在需要做的就是将这个request加入到cacheKey对应的Queue存起来\n\t                 * 如果对应的Queue是null,就自己创建一个新的，再把request放入\n\t                 * \n\t                 * 这个request就不再会被放入到mCacheQueue中去了\n\t                 * 就是坐等数据的意思= =\n\t                 */\n\t                Queue> stagedRequests = mWaitingRequests.get(cacheKey);\n\t                if (stagedRequests == null) {\n\t                    stagedRequests = new LinkedList>();\n\t                }\n\t                stagedRequests.add(request);\n\t                mWaitingRequests.put(cacheKey, stagedRequests);\n\t                if (VolleyLog.DEBUG) {\n\t                    VolleyLog.v(\"Request for cacheKey=%s is in flight, putting on hold.\", cacheKey);\n\t                }\n\t            } else {\n\t                /**\n\t                 * Insert 'null' queue for this cacheKey, indicating there is now a request in flight.\n\t                 * 如果这个涉及到cache的request在它之前根本就没有和他相同的request\n\t                 * 直接以这个cacheKey为key，放一个null进去\n\t                 * 表示这是第一个么= =\n\t                 * 搞不懂为什么要这个样子设计，为什么不直接新建一个Queue进去呢\n\t                 */\n\t                mWaitingRequests.put(cacheKey, null);\n\t                mCacheQueue.add(request);\n\t            }\n\t            return request;\n\t        }\n\t    }\n\n\t    /**\n\t     * Called from {@link Request#finish(String)}, indicating that processing of the given request\n\t     * has finished.\n\t     * 从Request中的finish()方法调用开始，预示着给出的request已经结束\n\t     * Releases waiting requests for request.getCacheKey() if\n\t     *      request.shouldCache().\n\t     * 将处于mWaittingQueue中具有相同cacheKey的一组request全部释放\n\t     * 也就是把上面那些坐等数据的request全部取出来，response发送回去\n\t     */\n\t     void finish(Request request) {\n\t        // Remove from the set of requests currently being processed.\n\t        /**\n\t         * 将mCurrentRequests锁住\n\t         * 一个时间段内只有一个线程可以访问该对象\n\t         * 将已经结束的request从队列中移除\n\t         */\n\t        synchronized (mCurrentRequests) {\n\t            mCurrentRequests.remove(request);\n\t        }\n\n\t        /**\n\t         * 通知所有注册过的监听器\n\t         * 告诉它们，request已经finish了\n\t         */\n\t        synchronized (mFinishedListeners) {\n\t          for (RequestFinishedListener listener : mFinishedListeners) {\n\t            listener.onRequestFinished(request);\n\t          }\n\t        }\n\n\t        /**\n\t         * 如果该request涉及到需要缓存\n\t         * 则将mWaitingRequests中具有相同cacheKey的request\n\t         * 全部取出放入到缓存队列中等待CacheDispatcher的调度\n\t         */\n\t        if (request.shouldCache()) {\n\t            synchronized (mWaitingRequests) {\n\t                String cacheKey = request.getCacheKey();\n\t                Queue> waitingRequests = mWaitingRequests.remove(cacheKey);\n\t                if (waitingRequests != null) {\n\t                    if (VolleyLog.DEBUG) {\n\t                        VolleyLog.v(\"Releasing %d waiting requests for cacheKey=%s.\",\n\t                                waitingRequests.size(), cacheKey);\n\t                    }\n\t                    // Process all queued up requests. They won't be considered as in flight, but\n\t                    // that's not a problem as the cache has been primed by 'request'.\n\t                    mCacheQueue.addAll(waitingRequests);\n\t                }\n\t            }\n\t        }\n\t    }\n\n\t    /**\n\t     * 下面两个方法就是所谓注册监听器和取消注册的函数\n\t     */\n\t    public   void addRequestFinishedListener(RequestFinishedListener listener) {\n\t      synchronized (mFinishedListeners) {\n\t        mFinishedListeners.add(listener);\n\t      }\n\t    }\n\n\t    /**\n\t     * Remove a RequestFinishedListener. Has no effect if listener was not previously added.\n\t     */\n\t    public   void removeRequestFinishedListener(RequestFinishedListener listener) {\n\t      synchronized (mFinishedListeners) {\n\t        mFinishedListeners.remove(listener);\n\t      }\n\t    }\n\t}\n\n```\n\n上面介绍了Volley.java和RequestQueue.java两大类，Volley是对外的入口，而RequestQueue是Volley框架中最核心的部分了。如果注释上面有写错了或者有疑问的地方，还请各位直接指出在下一篇博客中将继续向下深入，结合源代码分析什么是Dispatcher。","slug":"Volley框架解析-二-Volley以及RequestQueue解析","published":1,"updated":"2020-07-03T02:40:48.121Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc5n2qh8000lw8r1ykhwncn3","content":"<h2 id=\"Volley框架解析-二-—–Volley及RequestQueue解析\"><a href=\"#Volley框架解析-二-—–Volley及RequestQueue解析\" class=\"headerlink\" title=\"Volley框架解析(二)—–Volley及RequestQueue解析\"></a>Volley框架解析(二)—–Volley及RequestQueue解析</h2><h3 id=\"题外话-可直接无视跳过\"><a href=\"#题外话-可直接无视跳过\" class=\"headerlink\" title=\"题外话(可直接无视跳过\"></a><a href=\"#u9898_u5916_u8BDD_28_u53EF_u76F4_u63A5_u65E0_u89C6_u8DF3_u8FC7\" title=\"题外话(可直接无视跳过\"></a>题外话(可直接无视跳过</h3><p>是第一次比较完整的去阅读一个框架的源码，刚开始看的时候可以说是除了认识几个基本的<code>public, interface, final</code>等关键词之外，其他的一律不通orz，而且还不知道从哪里下手。后来磨蹭了好久还是慢慢的静下心来，对照着Java文档和Android文档查阅，刚开始都是陌生的，慢慢的在源码旁边打上注释，多看两遍就会get了。</p>\n<p>有些地方在一个.java文件里面是无法理解用处的，这样的先直接跳过不要纠结，看到对应用的地方就会恍然大悟了。还总结出了一个小技巧就是从框架暴露给外面的接口开始阅读，因为框架里面是一层一层往上的，底层是为了上层服务的，所以从接口开始阅读能很好的向下展开。</p>\n<p>前面一篇对Volley做了一个初步的介绍以及从整体上的一个解析，只是简单的描述了Request在Volley中是如何被处理的。从这篇博客开始将从最顶层一步一步的向下挖掘每一行代码，从最开始调用的地方<code>RequestQueue mQueue = Volley.newRequestQueue(mContext)</code>开始。</p>\n<a id=\"more\"></a>\n<hr>\n<h3 id=\"1-Volley-java\"><a href=\"#1-Volley-java\" class=\"headerlink\" title=\"1. Volley.java\"></a><a href=\"#1-_Volley-java\" title=\"1\\. Volley.java\"></a>1. Volley.java</h3><p>Volley.java是Volley整个框架对外暴露的接口，里面有四个重载的同名静态函数，方便直接使用。下面结合源代码来分析，主要是代码里面的注释。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">   package com.android.volley.toolbox;</div><div class=\"line\"></div><div class=\"line\">import android.content.Context;</div><div class=\"line\">import android.content.pm.PackageInfo;</div><div class=\"line\">import android.content.pm.PackageManager.NameNotFoundException;</div><div class=\"line\">import android.net.http.AndroidHttpClient;</div><div class=\"line\">import android.os.Build;</div><div class=\"line\"></div><div class=\"line\">import com.android.volley.Network;</div><div class=\"line\">import com.android.volley.RequestQueue;</div><div class=\"line\"></div><div class=\"line\">import java.io.File;</div><div class=\"line\"></div><div class=\"line\">public class Volley &#123;</div><div class=\"line\"></div><div class=\"line\">    /** Default on-disk cache directory. */</div><div class=\"line\">    private static final String DEFAULT_CACHE_DIR = &quot;volley&quot;;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Creates a default instance of the worker pool and calls &#123;@link RequestQueue#start()&#125; on it.</div><div class=\"line\">     * You may set a maximum size of the disk cache in bytes.</div><div class=\"line\">     * 创建一个默认的线程池，并将其启动</div><div class=\"line\">     * 还能通过构造函数来设置缓存的最大容量，默认的是5*1024*1024个字节</div><div class=\"line\">     *</div><div class=\"line\">     * @param context A &#123;@link Context&#125; to use for creating the cache dir.</div><div class=\"line\">     * 用于创建缓存目录的context</div><div class=\"line\">     * @param stack An &#123;@link HttpStack&#125; to use for the network, or null for default.</div><div class=\"line\">     * HttpStack可以通过外面自定义之后传入，也可以不管直接用默认的</div><div class=\"line\">     * @param maxDiskCacheBytes the maximum size of the disk cache, in bytes. Use -1 for default size.</div><div class=\"line\">     * 最大缓存的字节数</div><div class=\"line\">     * @return A started &#123;@link RequestQueue&#125; instance.</div><div class=\"line\">     */</div><div class=\"line\">    public static RequestQueue newRequestQueue(Context context, HttpStack stack, int maxDiskCacheBytes) &#123;</div><div class=\"line\"></div><div class=\"line\">    \t//通过context，创建用于缓存文件的目录</div><div class=\"line\">        File cacheDir = new File(context.getCacheDir(), DEFAULT_CACHE_DIR);</div><div class=\"line\"></div><div class=\"line\">        String userAgent = &quot;volley/0&quot;;</div><div class=\"line\"></div><div class=\"line\">        try &#123;</div><div class=\"line\">            String packageName = context.getPackageName();</div><div class=\"line\"></div><div class=\"line\">            /**</div><div class=\"line\">             * 关于PackageInfo，官方文档的解释如下：</div><div class=\"line\">             * Overall information about the contents of a package.</div><div class=\"line\">             * This corresponds to all of the information collected from AndroidManifest.xml.</div><div class=\"line\">             * 该类作为Package信息的基类，还有很多子类例如：ApplicationInfo、 ComponentInfo等。</div><div class=\"line\">             * 这些类包含了一些关于安装包的信息，icon,label等</div><div class=\"line\">             */</div><div class=\"line\">            PackageInfo info = context.getPackageManager().getPackageInfo(packageName, 0);</div><div class=\"line\">            //获取到了Package的版本号</div><div class=\"line\">            userAgent = packageName + &quot;/&quot; + info.versionCode;</div><div class=\"line\"></div><div class=\"line\">        &#125; catch (NameNotFoundException e) &#123;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * HttpStack是一个用于网络请求的接口</div><div class=\"line\">         * 如果传入的stack为空，则根据当前系统的版本号，来选择不同的实现了HttpStack(Volley自己的一个接口)的类对象</div><div class=\"line\">         * 高于android2.3就用HurlStack(实现了HttpStack接口，基于HttpsURLConnection)</div><div class=\"line\">         * 低于android2.3就用HttpClientStack(实现了HttpStack接口，基于HttpClient)</div><div class=\"line\">         */</div><div class=\"line\">        if (stack == null) &#123;</div><div class=\"line\">            if (Build.VERSION.SDK_INT &gt;= 9) &#123;</div><div class=\"line\">                stack = new HurlStack();</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                // Prior to Gingerbread, HttpUrlConnection was unreliable.</div><div class=\"line\">                // See: http://android-developers.blogspot.com/2011/09/androids-http-clients.html</div><div class=\"line\">                stack = new HttpClientStack(AndroidHttpClient.newInstance(userAgent));</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * 创建了一个用于发送特定请求的Network类对象</div><div class=\"line\">         * 该接口中有一个与HttpStack接口中同名的方法(performRequest)</div><div class=\"line\">         * 但是参数的内容不同， 返回的类型也有所区别</div><div class=\"line\">         * Network的返回类型是自定义的一个NetworkResponse类</div><div class=\"line\">         * 而HttpStack返回的是HttpResponse</div><div class=\"line\">         * (HttpResponse是java.apache.http中的一个类，里面包含了服务器返回的一些数据)</div><div class=\"line\">         * </div><div class=\"line\">         * 将stack传入到了已经实现了Network接口的一个BasicNetwork类中</div><div class=\"line\">         * 在后面发送Request请求的时候会调用Network.performRequest()</div><div class=\"line\">         * 然后在Network.performRequest()函数中会继续调用HttpStack.performRequest()</div><div class=\"line\">         * 真正的网络请求发出是在HttpStack.performRequest()中进行的</div><div class=\"line\">         */</div><div class=\"line\"></div><div class=\"line\">        Network network = new BasicNetwork(stack);</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * 创建一个RequestQueue引用</div><div class=\"line\">         * RequestQueue是volley实现的一个请求调度队列</div><div class=\"line\">         * 用来分发处理request</div><div class=\"line\">         * 后面会分析RequestQueue.java</div><div class=\"line\">         */</div><div class=\"line\">        RequestQueue queue;</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * 根据是否设置了最大缓存字节数</div><div class=\"line\">         * 来用不同的构造器生成RequestQueue对象</div><div class=\"line\">         * 其中第一个构造参数为一个实现了Cache.java接口的默认缓存读写类DiskBasedCache.java</div><div class=\"line\">         * 现在只需要知道它是用来专门处理缓存的就可以了，后面也会对源码做出分析</div><div class=\"line\">         * 第二个参数是接口Network.java类的引用，在上面两排不远处可以看到BasicNetwork.java</div><div class=\"line\">         * 它是用来实现网络请求的一个类。</div><div class=\"line\">         */</div></pre></td></tr></table></figure>\n<p>简单的说，Volley.java的用处就只有一个，创建并启动一个RequestQueue对象，可以有四个构造器供我们选择，可以通过继承其接口衍生出自己的一套网络请求部分的实现(继承HttpStack接口),还可以定义缓存大小的限制。对于框架的使用者来说自由度还是很大的，不是固定死只能通过默认实现来使用Volley,提供接口能使框架的灵活性大大提升，在自己写代码的过程中也要注意这个问题。</p>\n<hr>\n<p>###2. RequestQueue.java<br>RequestQueue可以说是Volley中最核心的部分了，所有的request都要从这边进来，等待工作线程的调度，调度完成之后从里面的ResponseDelivery返回给caller。下面是RequestQueue.java的所有代码以及每行代码的用途，读了几遍才弄清楚了这个东西的作用，之前都迷糊的不行orz。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div><div class=\"line\">204</div><div class=\"line\">205</div><div class=\"line\">206</div><div class=\"line\">207</div><div class=\"line\">208</div><div class=\"line\">209</div><div class=\"line\">210</div><div class=\"line\">211</div><div class=\"line\">212</div><div class=\"line\">213</div><div class=\"line\">214</div><div class=\"line\">215</div><div class=\"line\">216</div><div class=\"line\">217</div><div class=\"line\">218</div><div class=\"line\">219</div><div class=\"line\">220</div><div class=\"line\">221</div><div class=\"line\">222</div><div class=\"line\">223</div><div class=\"line\">224</div><div class=\"line\">225</div><div class=\"line\">226</div><div class=\"line\">227</div><div class=\"line\">228</div><div class=\"line\">229</div><div class=\"line\">230</div><div class=\"line\">231</div><div class=\"line\">232</div><div class=\"line\">233</div><div class=\"line\">234</div><div class=\"line\">235</div><div class=\"line\">236</div><div class=\"line\">237</div><div class=\"line\">238</div><div class=\"line\">239</div><div class=\"line\">240</div><div class=\"line\">241</div><div class=\"line\">242</div><div class=\"line\">243</div><div class=\"line\">244</div><div class=\"line\">245</div><div class=\"line\">246</div><div class=\"line\">247</div><div class=\"line\">248</div><div class=\"line\">249</div><div class=\"line\">250</div><div class=\"line\">251</div><div class=\"line\">252</div><div class=\"line\">253</div><div class=\"line\">254</div><div class=\"line\">255</div><div class=\"line\">256</div><div class=\"line\">257</div><div class=\"line\">258</div><div class=\"line\">259</div><div class=\"line\">260</div><div class=\"line\">261</div><div class=\"line\">262</div><div class=\"line\">263</div><div class=\"line\">264</div><div class=\"line\">265</div><div class=\"line\">266</div><div class=\"line\">267</div><div class=\"line\">268</div><div class=\"line\">269</div><div class=\"line\">270</div><div class=\"line\">271</div><div class=\"line\">272</div><div class=\"line\">273</div><div class=\"line\">274</div><div class=\"line\">275</div><div class=\"line\">276</div><div class=\"line\">277</div><div class=\"line\">278</div><div class=\"line\">279</div><div class=\"line\">280</div><div class=\"line\">281</div><div class=\"line\">282</div><div class=\"line\">283</div><div class=\"line\">284</div><div class=\"line\">285</div><div class=\"line\">286</div><div class=\"line\">287</div><div class=\"line\">288</div><div class=\"line\">289</div><div class=\"line\">290</div><div class=\"line\">291</div><div class=\"line\">292</div><div class=\"line\">293</div><div class=\"line\">294</div><div class=\"line\">295</div><div class=\"line\">296</div><div class=\"line\">297</div><div class=\"line\">298</div><div class=\"line\">299</div><div class=\"line\">300</div><div class=\"line\">301</div><div class=\"line\">302</div><div class=\"line\">303</div><div class=\"line\">304</div><div class=\"line\">305</div><div class=\"line\">306</div><div class=\"line\">307</div><div class=\"line\">308</div><div class=\"line\">309</div><div class=\"line\">310</div><div class=\"line\">311</div><div class=\"line\">312</div><div class=\"line\">313</div><div class=\"line\">314</div><div class=\"line\">315</div><div class=\"line\">316</div><div class=\"line\">317</div><div class=\"line\">318</div><div class=\"line\">319</div><div class=\"line\">320</div><div class=\"line\">321</div><div class=\"line\">322</div><div class=\"line\">323</div><div class=\"line\">324</div><div class=\"line\">325</div><div class=\"line\">326</div><div class=\"line\">327</div><div class=\"line\">328</div><div class=\"line\">329</div><div class=\"line\">330</div><div class=\"line\">331</div><div class=\"line\">332</div><div class=\"line\">333</div><div class=\"line\">334</div><div class=\"line\">335</div><div class=\"line\">336</div><div class=\"line\">337</div><div class=\"line\">338</div><div class=\"line\">339</div><div class=\"line\">340</div><div class=\"line\">341</div><div class=\"line\">342</div><div class=\"line\">343</div><div class=\"line\">344</div><div class=\"line\">345</div><div class=\"line\">346</div><div class=\"line\">347</div><div class=\"line\">348</div><div class=\"line\">349</div><div class=\"line\">350</div><div class=\"line\">351</div><div class=\"line\">352</div><div class=\"line\">353</div><div class=\"line\">354</div><div class=\"line\">355</div><div class=\"line\">356</div><div class=\"line\">357</div><div class=\"line\">358</div><div class=\"line\">359</div><div class=\"line\">360</div><div class=\"line\">361</div><div class=\"line\">362</div><div class=\"line\">363</div><div class=\"line\">364</div><div class=\"line\">365</div><div class=\"line\">366</div><div class=\"line\">367</div><div class=\"line\">368</div><div class=\"line\">369</div><div class=\"line\">370</div><div class=\"line\">371</div><div class=\"line\">372</div><div class=\"line\">373</div><div class=\"line\">374</div><div class=\"line\">375</div><div class=\"line\">376</div><div class=\"line\">377</div><div class=\"line\">378</div><div class=\"line\">379</div><div class=\"line\">380</div><div class=\"line\">381</div><div class=\"line\">382</div><div class=\"line\">383</div><div class=\"line\">384</div><div class=\"line\">385</div><div class=\"line\">386</div><div class=\"line\">387</div><div class=\"line\">388</div><div class=\"line\">389</div><div class=\"line\">390</div><div class=\"line\">391</div><div class=\"line\">392</div><div class=\"line\">393</div><div class=\"line\">394</div><div class=\"line\">395</div><div class=\"line\">396</div><div class=\"line\">397</div><div class=\"line\">398</div><div class=\"line\">399</div><div class=\"line\">400</div><div class=\"line\">401</div><div class=\"line\">402</div><div class=\"line\">403</div><div class=\"line\">404</div><div class=\"line\">405</div><div class=\"line\">406</div><div class=\"line\">407</div><div class=\"line\">408</div><div class=\"line\">409</div><div class=\"line\">410</div><div class=\"line\">411</div><div class=\"line\">412</div><div class=\"line\">413</div><div class=\"line\">414</div><div class=\"line\">415</div><div class=\"line\">416</div><div class=\"line\">417</div><div class=\"line\">418</div><div class=\"line\">419</div><div class=\"line\">420</div><div class=\"line\">421</div><div class=\"line\">422</div><div class=\"line\">423</div><div class=\"line\">424</div><div class=\"line\">425</div><div class=\"line\">426</div><div class=\"line\">427</div><div class=\"line\">428</div><div class=\"line\">429</div><div class=\"line\">430</div><div class=\"line\">431</div><div class=\"line\">432</div><div class=\"line\">433</div><div class=\"line\">434</div><div class=\"line\">435</div><div class=\"line\">436</div><div class=\"line\">437</div><div class=\"line\">438</div><div class=\"line\">439</div><div class=\"line\">440</div><div class=\"line\">441</div><div class=\"line\">442</div><div class=\"line\">443</div><div class=\"line\">444</div><div class=\"line\">445</div><div class=\"line\">446</div><div class=\"line\">447</div><div class=\"line\">448</div><div class=\"line\">449</div><div class=\"line\">450</div><div class=\"line\">451</div><div class=\"line\">452</div><div class=\"line\">453</div><div class=\"line\">454</div><div class=\"line\">455</div><div class=\"line\">456</div><div class=\"line\">457</div><div class=\"line\">458</div><div class=\"line\">459</div><div class=\"line\">460</div><div class=\"line\">461</div><div class=\"line\">462</div><div class=\"line\">463</div><div class=\"line\">464</div><div class=\"line\">465</div><div class=\"line\">466</div><div class=\"line\">467</div><div class=\"line\">468</div><div class=\"line\">469</div><div class=\"line\">470</div><div class=\"line\">471</div><div class=\"line\">472</div><div class=\"line\">473</div><div class=\"line\">474</div><div class=\"line\">475</div><div class=\"line\">476</div><div class=\"line\">477</div><div class=\"line\">478</div><div class=\"line\">479</div><div class=\"line\">480</div><div class=\"line\">481</div><div class=\"line\">482</div><div class=\"line\">483</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">   package com.android.volley;</div><div class=\"line\"></div><div class=\"line\">import android.os.Handler;</div><div class=\"line\">import android.os.Looper;</div><div class=\"line\"></div><div class=\"line\">import java.util.ArrayList;</div><div class=\"line\">import java.util.HashMap;</div><div class=\"line\">import java.util.HashSet;</div><div class=\"line\">import java.util.LinkedList;</div><div class=\"line\">import java.util.List;</div><div class=\"line\">import java.util.Map;</div><div class=\"line\">import java.util.Queue;</div><div class=\"line\">import java.util.Set;</div><div class=\"line\">import java.util.concurrent.PriorityBlockingQueue;</div><div class=\"line\">import java.util.concurrent.atomic.AtomicInteger;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\"> * A request dispatch queue with a thread pool of dispatchers.</div><div class=\"line\"> * </div><div class=\"line\"> *</div><div class=\"line\"> * Calling &#123;@link #add(Request)&#125; will enqueue the given Request for dispatch,</div><div class=\"line\"> * resolving from either cache or network on a worker thread, and then delivering</div><div class=\"line\"> * a parsed response on the main thread.</div><div class=\"line\"> * 调用mQueue.add(Request)函数将一个request放入请求调度队列中排队，将在工作线程中，</div><div class=\"line\"> * 从网络或者缓存两个方面对request进行分类并处理，将response返回给主线程中。</div><div class=\"line\"> */</div><div class=\"line\">public class RequestQueue &#123;</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * Callback interface for completed requests. </div><div class=\"line\">     * request完成之后的回掉接口</div><div class=\"line\">     * 其中的T用到了java的泛型，是Request调用者所期待返回的数据类型</div><div class=\"line\">     * 例如String或者是Integer</div><div class=\"line\">     */</div><div class=\"line\">    public static interface RequestFinishedListener &#123;</div><div class=\"line\">        /**</div><div class=\"line\">         * Called when a request has finished processing. </div><div class=\"line\">         * 当一个Request被处理完成时来调用</div><div class=\"line\">         * = =其实从方法的名字来看也能看出来</div><div class=\"line\">         */</div><div class=\"line\">        public void onRequestFinished(Request request);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Used for generating monotonically-increasing sequence numbers for requests. </div><div class=\"line\">     * 用来为request生成单调递增的有序数字，刚才是不知道这里是干什么用的= =</div><div class=\"line\">     * 在这里纠结了一小段时间就继续看了下去，直到在add()函数里面看到了这个的用处</div><div class=\"line\">     * 在request被add()进来的时候会给每个request发一个类似于排队的序号一样的数字，就是用这个类来实现的</div><div class=\"line\">     * </div><div class=\"line\">     * 官方的解释是：An int value that may be updated atomically. </div><div class=\"line\">     * An AtomicInteger is used in applications such as atomically incremented counters, and cannot be used as a replacement for an Integer.</div><div class=\"line\">     * However, this class does extend Number to allow uniform access by tools and utilities that deal with numerically-based classes.</div><div class=\"line\">     * 这个类是在需要自动递增计数器的应用中使用的，但是不能作为一个Integer的替代品。</div><div class=\"line\">     * 但是这个类确实是继承自Number类的，其允许处理数字的一些工具来统一访问= =。。</div><div class=\"line\">     */</div><div class=\"line\">    private AtomicInteger mSequenceGenerator = new AtomicInteger();</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Staging area for requests that already have a duplicate request in flight.</div><div class=\"line\">     * 用HashMap来形成一个筹备区域，这个筹备区域是为重复的request准备的。</div><div class=\"line\">     * 每个对应的cacheKey都有一个Queue来存储，因为相同的请求有时不止一个。</div><div class=\"line\">     * 这些重复的request已经有一个在被处理了，其他的不用重复处理，在这个HashMap里面等着拿结果就可以了</div><div class=\"line\">     * </div><div class=\"line\">     *     containsKey(cacheKey) indicates that there is a request in flight for the given cache</div><div class=\"line\">     *          key.</div><div class=\"line\">     *         用containsKey(String cacheKey)可以判定一个已经发送出去的请求是否有重复的请求。</div><div class=\"line\">     *     </div><div class=\"line\">     *     get(cacheKey) returns waiting requests for the given cache key. The in flight request</div><div class=\"line\">     *          is not contained in that list. Is null if no requests are staged.</div><div class=\"line\">     *         get()方法会返回一个queue，这个queue有可能是空的，也有可能里面存放着具有相同cacheKey的一系列request</div><div class=\"line\">     * </div><div class=\"line\">     */</div><div class=\"line\">    private final Map&gt;&gt; mWaitingRequests =</div><div class=\"line\">            new HashMap&gt;&gt;();</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * The set of all requests currently being processed by this RequestQueue. A Request</div><div class=\"line\">     * will be in this set if it is waiting in any queue or currently being processed by</div><div class=\"line\">     * any dispatcher.</div><div class=\"line\">     *</div><div class=\"line\">     * 一个容纳着所有request的HashSet。</div><div class=\"line\">     * 如果一个request正在被调度或者正处于等待状态，该request就在这个集合之中。</div><div class=\"line\">     * 这么说的话，RequestQueue里面主要存储request的集合就是这个了。</div><div class=\"line\">     * 在外面调用add(Request request)的时候，也就是加入到了这个HashSet之中。</div><div class=\"line\">     */</div><div class=\"line\">    private final Set&gt; mCurrentRequests = new HashSet&gt;();</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * The cache triage queue. </div><div class=\"line\">     * 运用到了优先队列</div><div class=\"line\">     * 也就是里面的每个元素都会有一个优先级，优先级高的比优先级低的要先调度。</div><div class=\"line\">     * 这个队列里面存放着需要访问缓存的一些Request，等待着调度器(dispatcher)的处理</div><div class=\"line\">     * 后面慢慢的会介绍到dispatcher</div><div class=\"line\">     */</div><div class=\"line\">    private final PriorityBlockingQueue&gt; mCacheQueue =</div><div class=\"line\">        new PriorityBlockingQueue&gt;();</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * The queue of requests that are actually going out to the network.</div><div class=\"line\">     * 网络请求队列</div><div class=\"line\">     * 要通过网络在服务器上请求数据的request</div><div class=\"line\">     * 还包括一些缓存出了点小问题的request也会被加入到这里</div><div class=\"line\">     * 在后面的代码中能够看到</div><div class=\"line\">     */</div><div class=\"line\">    private final PriorityBlockingQueue&gt; mNetworkQueue =</div><div class=\"line\">        new PriorityBlockingQueue&gt;();</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * Number of network request dispatcher threads to start. </div><div class=\"line\">     * 网络请求调度线程池中线程的默认数量。</div><div class=\"line\">     */</div><div class=\"line\">    private static final int DEFAULT_NETWORK_THREAD_POOL_SIZE = 4;</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * Cache interface for retrieving and storing responses. </div><div class=\"line\">     * 缓存的接口，用来从缓存中取出response或者存储response到缓存中。</div><div class=\"line\">     */</div><div class=\"line\">    private final Cache mCache;</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * Network interface for performing requests. </div><div class=\"line\">     * 网络接口，用来进行网络请求。</div><div class=\"line\">     */</div><div class=\"line\">    private final Network mNetwork;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Response delivery mechanism. </div><div class=\"line\">     * 响应交付机制</div><div class=\"line\">     * 请求最后的结果(Response.java实例)通过mDelivery中的方法传回</div><div class=\"line\">     * 这个过程需要在工作线程中才能看到，也就是在介绍dispatcher里面能看到</div><div class=\"line\">     */</div><div class=\"line\">    private final ResponseDelivery mDelivery;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * The network dispatchers. </div><div class=\"line\">     * 网络调度线程池</div><div class=\"line\">     * 因为是涉及到网络的一个框架，工作的效率不能低</div><div class=\"line\">     * 多开几个网络调度器线程来一起工作</div><div class=\"line\">     */</div><div class=\"line\">    private NetworkDispatcher[] mDispatchers;</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * The cache dispatcher. </div><div class=\"line\">     * 缓存调度线程(和上面的差不多吧= =，但是不是线程池了)</div><div class=\"line\">     * 处理了涉及到缓存的request</div><div class=\"line\">     */</div><div class=\"line\">    private CacheDispatcher mCacheDispatcher;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * 这个貌似是和listener差不多的用处</div><div class=\"line\">     * 每个request结束之后，就会通知所有已经注册过的listener(所谓注册无非就是实现了RequestFinishedListener.java这个接口</div><div class=\"line\">     * 然后再将自己传入，加入到这个ArrayList里面来)</div><div class=\"line\">     * 在&#123;@link #finish()&#125;里面会用到这个ArrayList</div><div class=\"line\">     */</div><div class=\"line\">    private List mFinishedListeners =</div><div class=\"line\">            new ArrayList();</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Creates the worker pool. Processing will not begin until &#123;@link #start()&#125; is called.</div><div class=\"line\">     * 创建工作线程，在start()调用之后开始不停的工作</div><div class=\"line\">     *</div><div class=\"line\">     * @param cache A Cache to use for persisting responses to disk</div><div class=\"line\">     * 涉及到内存访问的接口</div><div class=\"line\">     * @param network A Network interface for performing HTTP requests</div><div class=\"line\">     * 用来进行HTTP请求的网络接口</div><div class=\"line\">     * @param threadPoolSize Number of network dispatcher threads to create</div><div class=\"line\">     * 网络请求线程池，里面放着很多个线程，可以同时处理多个需要网络访问的request</div><div class=\"line\">     * @param delivery A ResponseDelivery interface for posting responses and errors</div><div class=\"line\">     * 一个用来传递resposne和error的接口</div><div class=\"line\">     */</div><div class=\"line\">    public RequestQueue(Cache cache, Network network, int threadPoolSize,</div><div class=\"line\">            ResponseDelivery delivery) &#123;</div><div class=\"line\">        mCache = cache;</div><div class=\"line\">        mNetwork = network;</div><div class=\"line\">        mDispatchers = new NetworkDispatcher[threadPoolSize];</div><div class=\"line\">        mDelivery = delivery;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Creates the worker pool. Processing will not begin until &#123;@link #start()&#125; is called.</div><div class=\"line\">     *</div><div class=\"line\">     * @param cache A Cache to use for persisting responses to disk</div><div class=\"line\">     * @param network A Network interface for performing HTTP requests</div><div class=\"line\">     * @param threadPoolSize Number of network dispatcher threads to create</div><div class=\"line\">     */</div><div class=\"line\">    public RequestQueue(Cache cache, Network network, int threadPoolSize) &#123;</div><div class=\"line\">        this(cache, network, threadPoolSize,</div><div class=\"line\">                new ExecutorDelivery(new Handler(Looper.getMainLooper())));</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Creates the worker pool. Processing will not begin until &#123;@link #start()&#125; is called.</div><div class=\"line\">     *</div><div class=\"line\">     * @param cache A Cache to use for persisting responses to disk</div><div class=\"line\">     * @param network A Network interface for performing HTTP requests</div><div class=\"line\">     */</div><div class=\"line\">    public RequestQueue(Cache cache, Network network) &#123;</div><div class=\"line\">        this(cache, network, DEFAULT_NETWORK_THREAD_POOL_SIZE);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Starts the dispatchers in this queue.</div><div class=\"line\">     * 先将所有的调度线程都停止</div><div class=\"line\">     * 再重新创建并启动</div><div class=\"line\">     * 将mNetworkQueue和mCacheQueue传入到dispatcher中</div><div class=\"line\">     * 方便从queue中取出request来进行处理</div><div class=\"line\">     * 将mDelivery接口传入，方便将请求结果返回</div><div class=\"line\">     * </div><div class=\"line\">     * cacheDispatcher创建一个就够了，networkDispatcher创建了多个</div><div class=\"line\">     * network花费时间比较长，需要开多个线程来工作</div><div class=\"line\">     */</div><div class=\"line\">    public void start() &#123;</div><div class=\"line\">        stop();  // Make sure any currently running dispatchers are stopped.</div><div class=\"line\">        // Create the cache dispatcher and start it.</div><div class=\"line\">        mCacheDispatcher = new CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);</div><div class=\"line\">        mCacheDispatcher.start();</div><div class=\"line\"></div><div class=\"line\">        // Create network dispatchers (and corresponding threads) up to the pool size.</div><div class=\"line\">        for (int i = 0; i &lt; mDispatchers.length; i++) &#123;</div><div class=\"line\">            NetworkDispatcher networkDispatcher = new NetworkDispatcher(mNetworkQueue, mNetwork,</div><div class=\"line\">                    mCache, mDelivery);</div><div class=\"line\">            mDispatchers[i] = networkDispatcher;</div><div class=\"line\">            networkDispatcher.start();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Stops the cache and network dispatchers.</div><div class=\"line\">     * 将所有正在工作状态的dispatcher挨个退出</div><div class=\"line\">     */</div><div class=\"line\">    public void stop() &#123;</div><div class=\"line\">        if (mCacheDispatcher != null) &#123;</div><div class=\"line\">            mCacheDispatcher.quit();</div><div class=\"line\">        &#125;</div><div class=\"line\">        for (int i = 0; i &lt; mDispatchers.length; i++) &#123;</div><div class=\"line\">            if (mDispatchers[i] != null) &#123;</div><div class=\"line\">                mDispatchers[i].quit();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Gets a sequence number.</div><div class=\"line\">     *</div><div class=\"line\">     * incrementAndGet() : Atomically increments by one the current value.</div><div class=\"line\">     * 自动向上涨一个单位然后返回当前值</div><div class=\"line\">     * 在后面的&#123;@link RequestQueue#add(Request)&#125;函数中能看到这个的作用</div><div class=\"line\">     * 用到了在前面提到过的AtomicInteger类</div><div class=\"line\">     */</div><div class=\"line\">    public int getSequenceNumber() &#123;</div><div class=\"line\">        return mSequenceGenerator.incrementAndGet();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Gets the &#123;@link Cache&#125; instance being used.</div><div class=\"line\">     * 返回当前正在使用的cache引用</div><div class=\"line\">     */</div><div class=\"line\">    public Cache getCache() &#123;</div><div class=\"line\">        return mCache;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * A simple predicate or filter interface for Requests, for use by</div><div class=\"line\">     * &#123;@link RequestQueue#cancelAll(RequestFilter)&#125;.</div><div class=\"line\">     * 一个request的过滤器</div><div class=\"line\">     * 上面说是给cancelAll用的，应该是设置一个RequestFilter之后</div><div class=\"line\">     * 将一类的request全都取消掉，至于具体的规则就需要重写里面的函数</div><div class=\"line\">     * 定义规则了</div><div class=\"line\">     */</div><div class=\"line\">    public interface RequestFilter &#123;</div><div class=\"line\">        public boolean apply(Request request);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Cancels all requests in this queue for which the given filter applies.</div><div class=\"line\">     * 从外面传入一个RequestFilter</div><div class=\"line\">     * 按照传入的规则取消所有符合规则的request</div><div class=\"line\">     * @param filter The filtering function to use</div><div class=\"line\">     */</div><div class=\"line\">    public void cancelAll(RequestFilter filter) &#123;</div><div class=\"line\">        synchronized (mCurrentRequests) &#123;</div><div class=\"line\">            for (Request request : mCurrentRequests) &#123;</div><div class=\"line\">                if (filter.apply(request)) &#123;</div><div class=\"line\">                    request.cancel();</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Cancels all requests in this queue with the given tag. Tag must be non-null</div><div class=\"line\">     * 依据request上面的tag来取消</div><div class=\"line\">     * and equality is by identity.</div><div class=\"line\">     */</div><div class=\"line\">    public void cancelAll(final Object tag) &#123;</div><div class=\"line\">        if (tag == null) &#123;</div><div class=\"line\">            throw new IllegalArgumentException(&quot;Cannot cancelAll with a null tag&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        cancelAll(new RequestFilter() &#123;</div><div class=\"line\">            @Override</div><div class=\"line\">            public boolean apply(Request request) &#123;</div><div class=\"line\">                return request.getTag() == tag;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Adds a Request to the dispatch queue.</div><div class=\"line\">     * 将新的request加入到总的等待队列中去</div><div class=\"line\">     * 一个request被处理之前都要待的地方</div><div class=\"line\">     * mCurrentRequests里面存放着所有的request </div><div class=\"line\">     *</div><div class=\"line\">     * @param request The request to service</div><div class=\"line\">     * 被传入的request，等待被处理</div><div class=\"line\">     * @return The passed-in request</div><div class=\"line\">     * 将加入的request返回回去</div><div class=\"line\">     */</div><div class=\"line\">    public  Request add(Request request) &#123;</div><div class=\"line\">        // Tag the request as belonging to this queue and add it to the set of current requests.</div><div class=\"line\">        request.setRequestQueue(this);</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * 在向mCurrentRequest中添加request的时候</div><div class=\"line\">         * 锁住不允许其他的线程进行访问操作</div><div class=\"line\">         * 对于synchronized:可用来给对象和方法或者代码块加锁，</div><div class=\"line\">         * 当它锁定一个方法或者一个代码块的时候，同一时刻最多只有一个线程执行这段代码。</div><div class=\"line\">         * 当两个并发线程访问同一个对象object中的这个加锁同步代码块时，一个时间内只能有一个线程得到执行。</div><div class=\"line\">         * 另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。</div><div class=\"line\">         * </div><div class=\"line\">         */</div><div class=\"line\">        synchronized (mCurrentRequests) &#123;</div><div class=\"line\">            mCurrentRequests.add(request);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * Process requests in the order they are added.</div><div class=\"line\">         * 在加入到mCurrentQueue中排队的时候</div><div class=\"line\">         * 就像我们排队一样会给我们一个对应的号码牌</div><div class=\"line\">         * 只是这里用了getSequenceNumber()函数来自动的发放号码牌</div><div class=\"line\">         */</div><div class=\"line\">        request.setSequence(getSequenceNumber());</div><div class=\"line\">        request.addMarker(&quot;add-to-queue&quot;);</div><div class=\"line\"></div><div class=\"line\">        /** </div><div class=\"line\">         * If the request is uncacheable, skip the cache queue and go straight to the network.</div><div class=\"line\">         * 检查这个request是否是不可缓存的</div><div class=\"line\">         * 也就是这个request所返回的response是否需要缓存下来</div><div class=\"line\">         */</div><div class=\"line\">        if (!request.shouldCache()) &#123;</div><div class=\"line\"></div><div class=\"line\">            /**</div><div class=\"line\">             * 如果不需要缓存的话</div><div class=\"line\">             * 直接将这个request加入到网络队列中去</div><div class=\"line\">             * 并且返回该request</div><div class=\"line\">             */</div><div class=\"line\">            mNetworkQueue.add(request);</div><div class=\"line\">            return request;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * Insert request into stage if there&apos;s already a request with the same cache key in flight.</div><div class=\"line\">         * = =尼玛我这是什么记性，看见这个mWaittingRequests居然不认识了</div><div class=\"line\">         * 向前翻到变量声明的地方，清清楚楚的写着专门存放重复请求的地方</div><div class=\"line\">         * 根据需要缓存的request生成的特殊标记cacheKey</div><div class=\"line\">         * 当然不涉及到缓存的request在上面几行代码被过滤处理了</div><div class=\"line\">         */</div><div class=\"line\">        synchronized (mWaitingRequests) &#123;</div><div class=\"line\"></div><div class=\"line\">            /**</div><div class=\"line\">             * 先获取到这个request的cacheKey</div><div class=\"line\">             * 看看有没有和它相同的request已经处于天上飞的状态了</div><div class=\"line\">             * (我觉得这里的in flight应该说的是已经发送过了的)</div><div class=\"line\">             * 在后面会说明</div><div class=\"line\">             */</div><div class=\"line\">            String cacheKey = request.getCacheKey();</div><div class=\"line\"></div><div class=\"line\">            if (mWaitingRequests.containsKey(cacheKey)) &#123;</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * There is already a request in flight. Queue up.</div><div class=\"line\">                 * 如果在等待的队列里面存在着cacheKey对应的一个Queue</div><div class=\"line\">                 * 则说明在这个request之前，已经有相同的request发送出去过了</div><div class=\"line\">                 * 那么现在需要做的就是将这个request加入到cacheKey对应的Queue存起来</div><div class=\"line\">                 * 如果对应的Queue是null,就自己创建一个新的，再把request放入</div><div class=\"line\">                 * </div><div class=\"line\">                 * 这个request就不再会被放入到mCacheQueue中去了</div><div class=\"line\">                 * 就是坐等数据的意思= =</div><div class=\"line\">                 */</div><div class=\"line\">                Queue&gt; stagedRequests = mWaitingRequests.get(cacheKey);</div><div class=\"line\">                if (stagedRequests == null) &#123;</div><div class=\"line\">                    stagedRequests = new LinkedList&gt;();</div><div class=\"line\">                &#125;</div><div class=\"line\">                stagedRequests.add(request);</div><div class=\"line\">                mWaitingRequests.put(cacheKey, stagedRequests);</div><div class=\"line\">                if (VolleyLog.DEBUG) &#123;</div><div class=\"line\">                    VolleyLog.v(&quot;Request for cacheKey=%s is in flight, putting on hold.&quot;, cacheKey);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                /**</div><div class=\"line\">                 * Insert &apos;null&apos; queue for this cacheKey, indicating there is now a request in flight.</div><div class=\"line\">                 * 如果这个涉及到cache的request在它之前根本就没有和他相同的request</div><div class=\"line\">                 * 直接以这个cacheKey为key，放一个null进去</div><div class=\"line\">                 * 表示这是第一个么= =</div><div class=\"line\">                 * 搞不懂为什么要这个样子设计，为什么不直接新建一个Queue进去呢</div><div class=\"line\">                 */</div><div class=\"line\">                mWaitingRequests.put(cacheKey, null);</div><div class=\"line\">                mCacheQueue.add(request);</div><div class=\"line\">            &#125;</div><div class=\"line\">            return request;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Called from &#123;@link Request#finish(String)&#125;, indicating that processing of the given request</div><div class=\"line\">     * has finished.</div><div class=\"line\">     * 从Request中的finish()方法调用开始，预示着给出的request已经结束</div><div class=\"line\">     * Releases waiting requests for request.getCacheKey() if</div><div class=\"line\">     *      request.shouldCache().</div><div class=\"line\">     * 将处于mWaittingQueue中具有相同cacheKey的一组request全部释放</div><div class=\"line\">     * 也就是把上面那些坐等数据的request全部取出来，response发送回去</div><div class=\"line\">     */</div><div class=\"line\">     void finish(Request request) &#123;</div><div class=\"line\">        // Remove from the set of requests currently being processed.</div><div class=\"line\">        /**</div><div class=\"line\">         * 将mCurrentRequests锁住</div><div class=\"line\">         * 一个时间段内只有一个线程可以访问该对象</div><div class=\"line\">         * 将已经结束的request从队列中移除</div><div class=\"line\">         */</div><div class=\"line\">        synchronized (mCurrentRequests) &#123;</div><div class=\"line\">            mCurrentRequests.remove(request);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * 通知所有注册过的监听器</div><div class=\"line\">         * 告诉它们，request已经finish了</div><div class=\"line\">         */</div><div class=\"line\">        synchronized (mFinishedListeners) &#123;</div><div class=\"line\">          for (RequestFinishedListener listener : mFinishedListeners) &#123;</div><div class=\"line\">            listener.onRequestFinished(request);</div><div class=\"line\">          &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * 如果该request涉及到需要缓存</div><div class=\"line\">         * 则将mWaitingRequests中具有相同cacheKey的request</div><div class=\"line\">         * 全部取出放入到缓存队列中等待CacheDispatcher的调度</div><div class=\"line\">         */</div><div class=\"line\">        if (request.shouldCache()) &#123;</div><div class=\"line\">            synchronized (mWaitingRequests) &#123;</div><div class=\"line\">                String cacheKey = request.getCacheKey();</div><div class=\"line\">                Queue&gt; waitingRequests = mWaitingRequests.remove(cacheKey);</div><div class=\"line\">                if (waitingRequests != null) &#123;</div><div class=\"line\">                    if (VolleyLog.DEBUG) &#123;</div><div class=\"line\">                        VolleyLog.v(&quot;Releasing %d waiting requests for cacheKey=%s.&quot;,</div><div class=\"line\">                                waitingRequests.size(), cacheKey);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    // Process all queued up requests. They won&apos;t be considered as in flight, but</div><div class=\"line\">                    // that&apos;s not a problem as the cache has been primed by &apos;request&apos;.</div><div class=\"line\">                    mCacheQueue.addAll(waitingRequests);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * 下面两个方法就是所谓注册监听器和取消注册的函数</div><div class=\"line\">     */</div><div class=\"line\">    public   void addRequestFinishedListener(RequestFinishedListener listener) &#123;</div><div class=\"line\">      synchronized (mFinishedListeners) &#123;</div><div class=\"line\">        mFinishedListeners.add(listener);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Remove a RequestFinishedListener. Has no effect if listener was not previously added.</div><div class=\"line\">     */</div><div class=\"line\">    public   void removeRequestFinishedListener(RequestFinishedListener listener) &#123;</div><div class=\"line\">      synchronized (mFinishedListeners) &#123;</div><div class=\"line\">        mFinishedListeners.remove(listener);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面介绍了Volley.java和RequestQueue.java两大类，Volley是对外的入口，而RequestQueue是Volley框架中最核心的部分了。如果注释上面有写错了或者有疑问的地方，还请各位直接指出在下一篇博客中将继续向下深入，结合源代码分析什么是Dispatcher。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"Volley框架解析-二-—–Volley及RequestQueue解析\"><a href=\"#Volley框架解析-二-—–Volley及RequestQueue解析\" class=\"headerlink\" title=\"Volley框架解析(二)—–Volley及RequestQueue解析\"></a>Volley框架解析(二)—–Volley及RequestQueue解析</h2><h3 id=\"题外话-可直接无视跳过\"><a href=\"#题外话-可直接无视跳过\" class=\"headerlink\" title=\"题外话(可直接无视跳过\"></a><a href=\"#u9898_u5916_u8BDD_28_u53EF_u76F4_u63A5_u65E0_u89C6_u8DF3_u8FC7\" title=\"题外话(可直接无视跳过\"></a>题外话(可直接无视跳过</h3><p>是第一次比较完整的去阅读一个框架的源码，刚开始看的时候可以说是除了认识几个基本的<code>public, interface, final</code>等关键词之外，其他的一律不通orz，而且还不知道从哪里下手。后来磨蹭了好久还是慢慢的静下心来，对照着Java文档和Android文档查阅，刚开始都是陌生的，慢慢的在源码旁边打上注释，多看两遍就会get了。</p>\n<p>有些地方在一个.java文件里面是无法理解用处的，这样的先直接跳过不要纠结，看到对应用的地方就会恍然大悟了。还总结出了一个小技巧就是从框架暴露给外面的接口开始阅读，因为框架里面是一层一层往上的，底层是为了上层服务的，所以从接口开始阅读能很好的向下展开。</p>\n<p>前面一篇对Volley做了一个初步的介绍以及从整体上的一个解析，只是简单的描述了Request在Volley中是如何被处理的。从这篇博客开始将从最顶层一步一步的向下挖掘每一行代码，从最开始调用的地方<code>RequestQueue mQueue = Volley.newRequestQueue(mContext)</code>开始。</p>","more":"<hr>\n<h3 id=\"1-Volley-java\"><a href=\"#1-Volley-java\" class=\"headerlink\" title=\"1. Volley.java\"></a><a href=\"#1-_Volley-java\" title=\"1\\. Volley.java\"></a>1. Volley.java</h3><p>Volley.java是Volley整个框架对外暴露的接口，里面有四个重载的同名静态函数，方便直接使用。下面结合源代码来分析，主要是代码里面的注释。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">   package com.android.volley.toolbox;</div><div class=\"line\"></div><div class=\"line\">import android.content.Context;</div><div class=\"line\">import android.content.pm.PackageInfo;</div><div class=\"line\">import android.content.pm.PackageManager.NameNotFoundException;</div><div class=\"line\">import android.net.http.AndroidHttpClient;</div><div class=\"line\">import android.os.Build;</div><div class=\"line\"></div><div class=\"line\">import com.android.volley.Network;</div><div class=\"line\">import com.android.volley.RequestQueue;</div><div class=\"line\"></div><div class=\"line\">import java.io.File;</div><div class=\"line\"></div><div class=\"line\">public class Volley &#123;</div><div class=\"line\"></div><div class=\"line\">    /** Default on-disk cache directory. */</div><div class=\"line\">    private static final String DEFAULT_CACHE_DIR = &quot;volley&quot;;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Creates a default instance of the worker pool and calls &#123;@link RequestQueue#start()&#125; on it.</div><div class=\"line\">     * You may set a maximum size of the disk cache in bytes.</div><div class=\"line\">     * 创建一个默认的线程池，并将其启动</div><div class=\"line\">     * 还能通过构造函数来设置缓存的最大容量，默认的是5*1024*1024个字节</div><div class=\"line\">     *</div><div class=\"line\">     * @param context A &#123;@link Context&#125; to use for creating the cache dir.</div><div class=\"line\">     * 用于创建缓存目录的context</div><div class=\"line\">     * @param stack An &#123;@link HttpStack&#125; to use for the network, or null for default.</div><div class=\"line\">     * HttpStack可以通过外面自定义之后传入，也可以不管直接用默认的</div><div class=\"line\">     * @param maxDiskCacheBytes the maximum size of the disk cache, in bytes. Use -1 for default size.</div><div class=\"line\">     * 最大缓存的字节数</div><div class=\"line\">     * @return A started &#123;@link RequestQueue&#125; instance.</div><div class=\"line\">     */</div><div class=\"line\">    public static RequestQueue newRequestQueue(Context context, HttpStack stack, int maxDiskCacheBytes) &#123;</div><div class=\"line\"></div><div class=\"line\">    \t//通过context，创建用于缓存文件的目录</div><div class=\"line\">        File cacheDir = new File(context.getCacheDir(), DEFAULT_CACHE_DIR);</div><div class=\"line\"></div><div class=\"line\">        String userAgent = &quot;volley/0&quot;;</div><div class=\"line\"></div><div class=\"line\">        try &#123;</div><div class=\"line\">            String packageName = context.getPackageName();</div><div class=\"line\"></div><div class=\"line\">            /**</div><div class=\"line\">             * 关于PackageInfo，官方文档的解释如下：</div><div class=\"line\">             * Overall information about the contents of a package.</div><div class=\"line\">             * This corresponds to all of the information collected from AndroidManifest.xml.</div><div class=\"line\">             * 该类作为Package信息的基类，还有很多子类例如：ApplicationInfo、 ComponentInfo等。</div><div class=\"line\">             * 这些类包含了一些关于安装包的信息，icon,label等</div><div class=\"line\">             */</div><div class=\"line\">            PackageInfo info = context.getPackageManager().getPackageInfo(packageName, 0);</div><div class=\"line\">            //获取到了Package的版本号</div><div class=\"line\">            userAgent = packageName + &quot;/&quot; + info.versionCode;</div><div class=\"line\"></div><div class=\"line\">        &#125; catch (NameNotFoundException e) &#123;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * HttpStack是一个用于网络请求的接口</div><div class=\"line\">         * 如果传入的stack为空，则根据当前系统的版本号，来选择不同的实现了HttpStack(Volley自己的一个接口)的类对象</div><div class=\"line\">         * 高于android2.3就用HurlStack(实现了HttpStack接口，基于HttpsURLConnection)</div><div class=\"line\">         * 低于android2.3就用HttpClientStack(实现了HttpStack接口，基于HttpClient)</div><div class=\"line\">         */</div><div class=\"line\">        if (stack == null) &#123;</div><div class=\"line\">            if (Build.VERSION.SDK_INT &gt;= 9) &#123;</div><div class=\"line\">                stack = new HurlStack();</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                // Prior to Gingerbread, HttpUrlConnection was unreliable.</div><div class=\"line\">                // See: http://android-developers.blogspot.com/2011/09/androids-http-clients.html</div><div class=\"line\">                stack = new HttpClientStack(AndroidHttpClient.newInstance(userAgent));</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * 创建了一个用于发送特定请求的Network类对象</div><div class=\"line\">         * 该接口中有一个与HttpStack接口中同名的方法(performRequest)</div><div class=\"line\">         * 但是参数的内容不同， 返回的类型也有所区别</div><div class=\"line\">         * Network的返回类型是自定义的一个NetworkResponse类</div><div class=\"line\">         * 而HttpStack返回的是HttpResponse</div><div class=\"line\">         * (HttpResponse是java.apache.http中的一个类，里面包含了服务器返回的一些数据)</div><div class=\"line\">         * </div><div class=\"line\">         * 将stack传入到了已经实现了Network接口的一个BasicNetwork类中</div><div class=\"line\">         * 在后面发送Request请求的时候会调用Network.performRequest()</div><div class=\"line\">         * 然后在Network.performRequest()函数中会继续调用HttpStack.performRequest()</div><div class=\"line\">         * 真正的网络请求发出是在HttpStack.performRequest()中进行的</div><div class=\"line\">         */</div><div class=\"line\"></div><div class=\"line\">        Network network = new BasicNetwork(stack);</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * 创建一个RequestQueue引用</div><div class=\"line\">         * RequestQueue是volley实现的一个请求调度队列</div><div class=\"line\">         * 用来分发处理request</div><div class=\"line\">         * 后面会分析RequestQueue.java</div><div class=\"line\">         */</div><div class=\"line\">        RequestQueue queue;</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * 根据是否设置了最大缓存字节数</div><div class=\"line\">         * 来用不同的构造器生成RequestQueue对象</div><div class=\"line\">         * 其中第一个构造参数为一个实现了Cache.java接口的默认缓存读写类DiskBasedCache.java</div><div class=\"line\">         * 现在只需要知道它是用来专门处理缓存的就可以了，后面也会对源码做出分析</div><div class=\"line\">         * 第二个参数是接口Network.java类的引用，在上面两排不远处可以看到BasicNetwork.java</div><div class=\"line\">         * 它是用来实现网络请求的一个类。</div><div class=\"line\">         */</div></pre></td></tr></table></figure>\n<p>简单的说，Volley.java的用处就只有一个，创建并启动一个RequestQueue对象，可以有四个构造器供我们选择，可以通过继承其接口衍生出自己的一套网络请求部分的实现(继承HttpStack接口),还可以定义缓存大小的限制。对于框架的使用者来说自由度还是很大的，不是固定死只能通过默认实现来使用Volley,提供接口能使框架的灵活性大大提升，在自己写代码的过程中也要注意这个问题。</p>\n<hr>\n<p>###2. RequestQueue.java<br>RequestQueue可以说是Volley中最核心的部分了，所有的request都要从这边进来，等待工作线程的调度，调度完成之后从里面的ResponseDelivery返回给caller。下面是RequestQueue.java的所有代码以及每行代码的用途，读了几遍才弄清楚了这个东西的作用，之前都迷糊的不行orz。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div><div class=\"line\">204</div><div class=\"line\">205</div><div class=\"line\">206</div><div class=\"line\">207</div><div class=\"line\">208</div><div class=\"line\">209</div><div class=\"line\">210</div><div class=\"line\">211</div><div class=\"line\">212</div><div class=\"line\">213</div><div class=\"line\">214</div><div class=\"line\">215</div><div class=\"line\">216</div><div class=\"line\">217</div><div class=\"line\">218</div><div class=\"line\">219</div><div class=\"line\">220</div><div class=\"line\">221</div><div class=\"line\">222</div><div class=\"line\">223</div><div class=\"line\">224</div><div class=\"line\">225</div><div class=\"line\">226</div><div class=\"line\">227</div><div class=\"line\">228</div><div class=\"line\">229</div><div class=\"line\">230</div><div class=\"line\">231</div><div class=\"line\">232</div><div class=\"line\">233</div><div class=\"line\">234</div><div class=\"line\">235</div><div class=\"line\">236</div><div class=\"line\">237</div><div class=\"line\">238</div><div class=\"line\">239</div><div class=\"line\">240</div><div class=\"line\">241</div><div class=\"line\">242</div><div class=\"line\">243</div><div class=\"line\">244</div><div class=\"line\">245</div><div class=\"line\">246</div><div class=\"line\">247</div><div class=\"line\">248</div><div class=\"line\">249</div><div class=\"line\">250</div><div class=\"line\">251</div><div class=\"line\">252</div><div class=\"line\">253</div><div class=\"line\">254</div><div class=\"line\">255</div><div class=\"line\">256</div><div class=\"line\">257</div><div class=\"line\">258</div><div class=\"line\">259</div><div class=\"line\">260</div><div class=\"line\">261</div><div class=\"line\">262</div><div class=\"line\">263</div><div class=\"line\">264</div><div class=\"line\">265</div><div class=\"line\">266</div><div class=\"line\">267</div><div class=\"line\">268</div><div class=\"line\">269</div><div class=\"line\">270</div><div class=\"line\">271</div><div class=\"line\">272</div><div class=\"line\">273</div><div class=\"line\">274</div><div class=\"line\">275</div><div class=\"line\">276</div><div class=\"line\">277</div><div class=\"line\">278</div><div class=\"line\">279</div><div class=\"line\">280</div><div class=\"line\">281</div><div class=\"line\">282</div><div class=\"line\">283</div><div class=\"line\">284</div><div class=\"line\">285</div><div class=\"line\">286</div><div class=\"line\">287</div><div class=\"line\">288</div><div class=\"line\">289</div><div class=\"line\">290</div><div class=\"line\">291</div><div class=\"line\">292</div><div class=\"line\">293</div><div class=\"line\">294</div><div class=\"line\">295</div><div class=\"line\">296</div><div class=\"line\">297</div><div class=\"line\">298</div><div class=\"line\">299</div><div class=\"line\">300</div><div class=\"line\">301</div><div class=\"line\">302</div><div class=\"line\">303</div><div class=\"line\">304</div><div class=\"line\">305</div><div class=\"line\">306</div><div class=\"line\">307</div><div class=\"line\">308</div><div class=\"line\">309</div><div class=\"line\">310</div><div class=\"line\">311</div><div class=\"line\">312</div><div class=\"line\">313</div><div class=\"line\">314</div><div class=\"line\">315</div><div class=\"line\">316</div><div class=\"line\">317</div><div class=\"line\">318</div><div class=\"line\">319</div><div class=\"line\">320</div><div class=\"line\">321</div><div class=\"line\">322</div><div class=\"line\">323</div><div class=\"line\">324</div><div class=\"line\">325</div><div class=\"line\">326</div><div class=\"line\">327</div><div class=\"line\">328</div><div class=\"line\">329</div><div class=\"line\">330</div><div class=\"line\">331</div><div class=\"line\">332</div><div class=\"line\">333</div><div class=\"line\">334</div><div class=\"line\">335</div><div class=\"line\">336</div><div class=\"line\">337</div><div class=\"line\">338</div><div class=\"line\">339</div><div class=\"line\">340</div><div class=\"line\">341</div><div class=\"line\">342</div><div class=\"line\">343</div><div class=\"line\">344</div><div class=\"line\">345</div><div class=\"line\">346</div><div class=\"line\">347</div><div class=\"line\">348</div><div class=\"line\">349</div><div class=\"line\">350</div><div class=\"line\">351</div><div class=\"line\">352</div><div class=\"line\">353</div><div class=\"line\">354</div><div class=\"line\">355</div><div class=\"line\">356</div><div class=\"line\">357</div><div class=\"line\">358</div><div class=\"line\">359</div><div class=\"line\">360</div><div class=\"line\">361</div><div class=\"line\">362</div><div class=\"line\">363</div><div class=\"line\">364</div><div class=\"line\">365</div><div class=\"line\">366</div><div class=\"line\">367</div><div class=\"line\">368</div><div class=\"line\">369</div><div class=\"line\">370</div><div class=\"line\">371</div><div class=\"line\">372</div><div class=\"line\">373</div><div class=\"line\">374</div><div class=\"line\">375</div><div class=\"line\">376</div><div class=\"line\">377</div><div class=\"line\">378</div><div class=\"line\">379</div><div class=\"line\">380</div><div class=\"line\">381</div><div class=\"line\">382</div><div class=\"line\">383</div><div class=\"line\">384</div><div class=\"line\">385</div><div class=\"line\">386</div><div class=\"line\">387</div><div class=\"line\">388</div><div class=\"line\">389</div><div class=\"line\">390</div><div class=\"line\">391</div><div class=\"line\">392</div><div class=\"line\">393</div><div class=\"line\">394</div><div class=\"line\">395</div><div class=\"line\">396</div><div class=\"line\">397</div><div class=\"line\">398</div><div class=\"line\">399</div><div class=\"line\">400</div><div class=\"line\">401</div><div class=\"line\">402</div><div class=\"line\">403</div><div class=\"line\">404</div><div class=\"line\">405</div><div class=\"line\">406</div><div class=\"line\">407</div><div class=\"line\">408</div><div class=\"line\">409</div><div class=\"line\">410</div><div class=\"line\">411</div><div class=\"line\">412</div><div class=\"line\">413</div><div class=\"line\">414</div><div class=\"line\">415</div><div class=\"line\">416</div><div class=\"line\">417</div><div class=\"line\">418</div><div class=\"line\">419</div><div class=\"line\">420</div><div class=\"line\">421</div><div class=\"line\">422</div><div class=\"line\">423</div><div class=\"line\">424</div><div class=\"line\">425</div><div class=\"line\">426</div><div class=\"line\">427</div><div class=\"line\">428</div><div class=\"line\">429</div><div class=\"line\">430</div><div class=\"line\">431</div><div class=\"line\">432</div><div class=\"line\">433</div><div class=\"line\">434</div><div class=\"line\">435</div><div class=\"line\">436</div><div class=\"line\">437</div><div class=\"line\">438</div><div class=\"line\">439</div><div class=\"line\">440</div><div class=\"line\">441</div><div class=\"line\">442</div><div class=\"line\">443</div><div class=\"line\">444</div><div class=\"line\">445</div><div class=\"line\">446</div><div class=\"line\">447</div><div class=\"line\">448</div><div class=\"line\">449</div><div class=\"line\">450</div><div class=\"line\">451</div><div class=\"line\">452</div><div class=\"line\">453</div><div class=\"line\">454</div><div class=\"line\">455</div><div class=\"line\">456</div><div class=\"line\">457</div><div class=\"line\">458</div><div class=\"line\">459</div><div class=\"line\">460</div><div class=\"line\">461</div><div class=\"line\">462</div><div class=\"line\">463</div><div class=\"line\">464</div><div class=\"line\">465</div><div class=\"line\">466</div><div class=\"line\">467</div><div class=\"line\">468</div><div class=\"line\">469</div><div class=\"line\">470</div><div class=\"line\">471</div><div class=\"line\">472</div><div class=\"line\">473</div><div class=\"line\">474</div><div class=\"line\">475</div><div class=\"line\">476</div><div class=\"line\">477</div><div class=\"line\">478</div><div class=\"line\">479</div><div class=\"line\">480</div><div class=\"line\">481</div><div class=\"line\">482</div><div class=\"line\">483</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">   package com.android.volley;</div><div class=\"line\"></div><div class=\"line\">import android.os.Handler;</div><div class=\"line\">import android.os.Looper;</div><div class=\"line\"></div><div class=\"line\">import java.util.ArrayList;</div><div class=\"line\">import java.util.HashMap;</div><div class=\"line\">import java.util.HashSet;</div><div class=\"line\">import java.util.LinkedList;</div><div class=\"line\">import java.util.List;</div><div class=\"line\">import java.util.Map;</div><div class=\"line\">import java.util.Queue;</div><div class=\"line\">import java.util.Set;</div><div class=\"line\">import java.util.concurrent.PriorityBlockingQueue;</div><div class=\"line\">import java.util.concurrent.atomic.AtomicInteger;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\"> * A request dispatch queue with a thread pool of dispatchers.</div><div class=\"line\"> * </div><div class=\"line\"> *</div><div class=\"line\"> * Calling &#123;@link #add(Request)&#125; will enqueue the given Request for dispatch,</div><div class=\"line\"> * resolving from either cache or network on a worker thread, and then delivering</div><div class=\"line\"> * a parsed response on the main thread.</div><div class=\"line\"> * 调用mQueue.add(Request)函数将一个request放入请求调度队列中排队，将在工作线程中，</div><div class=\"line\"> * 从网络或者缓存两个方面对request进行分类并处理，将response返回给主线程中。</div><div class=\"line\"> */</div><div class=\"line\">public class RequestQueue &#123;</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * Callback interface for completed requests. </div><div class=\"line\">     * request完成之后的回掉接口</div><div class=\"line\">     * 其中的T用到了java的泛型，是Request调用者所期待返回的数据类型</div><div class=\"line\">     * 例如String或者是Integer</div><div class=\"line\">     */</div><div class=\"line\">    public static interface RequestFinishedListener &#123;</div><div class=\"line\">        /**</div><div class=\"line\">         * Called when a request has finished processing. </div><div class=\"line\">         * 当一个Request被处理完成时来调用</div><div class=\"line\">         * = =其实从方法的名字来看也能看出来</div><div class=\"line\">         */</div><div class=\"line\">        public void onRequestFinished(Request request);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Used for generating monotonically-increasing sequence numbers for requests. </div><div class=\"line\">     * 用来为request生成单调递增的有序数字，刚才是不知道这里是干什么用的= =</div><div class=\"line\">     * 在这里纠结了一小段时间就继续看了下去，直到在add()函数里面看到了这个的用处</div><div class=\"line\">     * 在request被add()进来的时候会给每个request发一个类似于排队的序号一样的数字，就是用这个类来实现的</div><div class=\"line\">     * </div><div class=\"line\">     * 官方的解释是：An int value that may be updated atomically. </div><div class=\"line\">     * An AtomicInteger is used in applications such as atomically incremented counters, and cannot be used as a replacement for an Integer.</div><div class=\"line\">     * However, this class does extend Number to allow uniform access by tools and utilities that deal with numerically-based classes.</div><div class=\"line\">     * 这个类是在需要自动递增计数器的应用中使用的，但是不能作为一个Integer的替代品。</div><div class=\"line\">     * 但是这个类确实是继承自Number类的，其允许处理数字的一些工具来统一访问= =。。</div><div class=\"line\">     */</div><div class=\"line\">    private AtomicInteger mSequenceGenerator = new AtomicInteger();</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Staging area for requests that already have a duplicate request in flight.</div><div class=\"line\">     * 用HashMap来形成一个筹备区域，这个筹备区域是为重复的request准备的。</div><div class=\"line\">     * 每个对应的cacheKey都有一个Queue来存储，因为相同的请求有时不止一个。</div><div class=\"line\">     * 这些重复的request已经有一个在被处理了，其他的不用重复处理，在这个HashMap里面等着拿结果就可以了</div><div class=\"line\">     * </div><div class=\"line\">     *     containsKey(cacheKey) indicates that there is a request in flight for the given cache</div><div class=\"line\">     *          key.</div><div class=\"line\">     *         用containsKey(String cacheKey)可以判定一个已经发送出去的请求是否有重复的请求。</div><div class=\"line\">     *     </div><div class=\"line\">     *     get(cacheKey) returns waiting requests for the given cache key. The in flight request</div><div class=\"line\">     *          is not contained in that list. Is null if no requests are staged.</div><div class=\"line\">     *         get()方法会返回一个queue，这个queue有可能是空的，也有可能里面存放着具有相同cacheKey的一系列request</div><div class=\"line\">     * </div><div class=\"line\">     */</div><div class=\"line\">    private final Map&gt;&gt; mWaitingRequests =</div><div class=\"line\">            new HashMap&gt;&gt;();</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * The set of all requests currently being processed by this RequestQueue. A Request</div><div class=\"line\">     * will be in this set if it is waiting in any queue or currently being processed by</div><div class=\"line\">     * any dispatcher.</div><div class=\"line\">     *</div><div class=\"line\">     * 一个容纳着所有request的HashSet。</div><div class=\"line\">     * 如果一个request正在被调度或者正处于等待状态，该request就在这个集合之中。</div><div class=\"line\">     * 这么说的话，RequestQueue里面主要存储request的集合就是这个了。</div><div class=\"line\">     * 在外面调用add(Request request)的时候，也就是加入到了这个HashSet之中。</div><div class=\"line\">     */</div><div class=\"line\">    private final Set&gt; mCurrentRequests = new HashSet&gt;();</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * The cache triage queue. </div><div class=\"line\">     * 运用到了优先队列</div><div class=\"line\">     * 也就是里面的每个元素都会有一个优先级，优先级高的比优先级低的要先调度。</div><div class=\"line\">     * 这个队列里面存放着需要访问缓存的一些Request，等待着调度器(dispatcher)的处理</div><div class=\"line\">     * 后面慢慢的会介绍到dispatcher</div><div class=\"line\">     */</div><div class=\"line\">    private final PriorityBlockingQueue&gt; mCacheQueue =</div><div class=\"line\">        new PriorityBlockingQueue&gt;();</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * The queue of requests that are actually going out to the network.</div><div class=\"line\">     * 网络请求队列</div><div class=\"line\">     * 要通过网络在服务器上请求数据的request</div><div class=\"line\">     * 还包括一些缓存出了点小问题的request也会被加入到这里</div><div class=\"line\">     * 在后面的代码中能够看到</div><div class=\"line\">     */</div><div class=\"line\">    private final PriorityBlockingQueue&gt; mNetworkQueue =</div><div class=\"line\">        new PriorityBlockingQueue&gt;();</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * Number of network request dispatcher threads to start. </div><div class=\"line\">     * 网络请求调度线程池中线程的默认数量。</div><div class=\"line\">     */</div><div class=\"line\">    private static final int DEFAULT_NETWORK_THREAD_POOL_SIZE = 4;</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * Cache interface for retrieving and storing responses. </div><div class=\"line\">     * 缓存的接口，用来从缓存中取出response或者存储response到缓存中。</div><div class=\"line\">     */</div><div class=\"line\">    private final Cache mCache;</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * Network interface for performing requests. </div><div class=\"line\">     * 网络接口，用来进行网络请求。</div><div class=\"line\">     */</div><div class=\"line\">    private final Network mNetwork;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Response delivery mechanism. </div><div class=\"line\">     * 响应交付机制</div><div class=\"line\">     * 请求最后的结果(Response.java实例)通过mDelivery中的方法传回</div><div class=\"line\">     * 这个过程需要在工作线程中才能看到，也就是在介绍dispatcher里面能看到</div><div class=\"line\">     */</div><div class=\"line\">    private final ResponseDelivery mDelivery;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * The network dispatchers. </div><div class=\"line\">     * 网络调度线程池</div><div class=\"line\">     * 因为是涉及到网络的一个框架，工作的效率不能低</div><div class=\"line\">     * 多开几个网络调度器线程来一起工作</div><div class=\"line\">     */</div><div class=\"line\">    private NetworkDispatcher[] mDispatchers;</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * The cache dispatcher. </div><div class=\"line\">     * 缓存调度线程(和上面的差不多吧= =，但是不是线程池了)</div><div class=\"line\">     * 处理了涉及到缓存的request</div><div class=\"line\">     */</div><div class=\"line\">    private CacheDispatcher mCacheDispatcher;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * 这个貌似是和listener差不多的用处</div><div class=\"line\">     * 每个request结束之后，就会通知所有已经注册过的listener(所谓注册无非就是实现了RequestFinishedListener.java这个接口</div><div class=\"line\">     * 然后再将自己传入，加入到这个ArrayList里面来)</div><div class=\"line\">     * 在&#123;@link #finish()&#125;里面会用到这个ArrayList</div><div class=\"line\">     */</div><div class=\"line\">    private List mFinishedListeners =</div><div class=\"line\">            new ArrayList();</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Creates the worker pool. Processing will not begin until &#123;@link #start()&#125; is called.</div><div class=\"line\">     * 创建工作线程，在start()调用之后开始不停的工作</div><div class=\"line\">     *</div><div class=\"line\">     * @param cache A Cache to use for persisting responses to disk</div><div class=\"line\">     * 涉及到内存访问的接口</div><div class=\"line\">     * @param network A Network interface for performing HTTP requests</div><div class=\"line\">     * 用来进行HTTP请求的网络接口</div><div class=\"line\">     * @param threadPoolSize Number of network dispatcher threads to create</div><div class=\"line\">     * 网络请求线程池，里面放着很多个线程，可以同时处理多个需要网络访问的request</div><div class=\"line\">     * @param delivery A ResponseDelivery interface for posting responses and errors</div><div class=\"line\">     * 一个用来传递resposne和error的接口</div><div class=\"line\">     */</div><div class=\"line\">    public RequestQueue(Cache cache, Network network, int threadPoolSize,</div><div class=\"line\">            ResponseDelivery delivery) &#123;</div><div class=\"line\">        mCache = cache;</div><div class=\"line\">        mNetwork = network;</div><div class=\"line\">        mDispatchers = new NetworkDispatcher[threadPoolSize];</div><div class=\"line\">        mDelivery = delivery;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Creates the worker pool. Processing will not begin until &#123;@link #start()&#125; is called.</div><div class=\"line\">     *</div><div class=\"line\">     * @param cache A Cache to use for persisting responses to disk</div><div class=\"line\">     * @param network A Network interface for performing HTTP requests</div><div class=\"line\">     * @param threadPoolSize Number of network dispatcher threads to create</div><div class=\"line\">     */</div><div class=\"line\">    public RequestQueue(Cache cache, Network network, int threadPoolSize) &#123;</div><div class=\"line\">        this(cache, network, threadPoolSize,</div><div class=\"line\">                new ExecutorDelivery(new Handler(Looper.getMainLooper())));</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Creates the worker pool. Processing will not begin until &#123;@link #start()&#125; is called.</div><div class=\"line\">     *</div><div class=\"line\">     * @param cache A Cache to use for persisting responses to disk</div><div class=\"line\">     * @param network A Network interface for performing HTTP requests</div><div class=\"line\">     */</div><div class=\"line\">    public RequestQueue(Cache cache, Network network) &#123;</div><div class=\"line\">        this(cache, network, DEFAULT_NETWORK_THREAD_POOL_SIZE);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Starts the dispatchers in this queue.</div><div class=\"line\">     * 先将所有的调度线程都停止</div><div class=\"line\">     * 再重新创建并启动</div><div class=\"line\">     * 将mNetworkQueue和mCacheQueue传入到dispatcher中</div><div class=\"line\">     * 方便从queue中取出request来进行处理</div><div class=\"line\">     * 将mDelivery接口传入，方便将请求结果返回</div><div class=\"line\">     * </div><div class=\"line\">     * cacheDispatcher创建一个就够了，networkDispatcher创建了多个</div><div class=\"line\">     * network花费时间比较长，需要开多个线程来工作</div><div class=\"line\">     */</div><div class=\"line\">    public void start() &#123;</div><div class=\"line\">        stop();  // Make sure any currently running dispatchers are stopped.</div><div class=\"line\">        // Create the cache dispatcher and start it.</div><div class=\"line\">        mCacheDispatcher = new CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);</div><div class=\"line\">        mCacheDispatcher.start();</div><div class=\"line\"></div><div class=\"line\">        // Create network dispatchers (and corresponding threads) up to the pool size.</div><div class=\"line\">        for (int i = 0; i &lt; mDispatchers.length; i++) &#123;</div><div class=\"line\">            NetworkDispatcher networkDispatcher = new NetworkDispatcher(mNetworkQueue, mNetwork,</div><div class=\"line\">                    mCache, mDelivery);</div><div class=\"line\">            mDispatchers[i] = networkDispatcher;</div><div class=\"line\">            networkDispatcher.start();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Stops the cache and network dispatchers.</div><div class=\"line\">     * 将所有正在工作状态的dispatcher挨个退出</div><div class=\"line\">     */</div><div class=\"line\">    public void stop() &#123;</div><div class=\"line\">        if (mCacheDispatcher != null) &#123;</div><div class=\"line\">            mCacheDispatcher.quit();</div><div class=\"line\">        &#125;</div><div class=\"line\">        for (int i = 0; i &lt; mDispatchers.length; i++) &#123;</div><div class=\"line\">            if (mDispatchers[i] != null) &#123;</div><div class=\"line\">                mDispatchers[i].quit();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Gets a sequence number.</div><div class=\"line\">     *</div><div class=\"line\">     * incrementAndGet() : Atomically increments by one the current value.</div><div class=\"line\">     * 自动向上涨一个单位然后返回当前值</div><div class=\"line\">     * 在后面的&#123;@link RequestQueue#add(Request)&#125;函数中能看到这个的作用</div><div class=\"line\">     * 用到了在前面提到过的AtomicInteger类</div><div class=\"line\">     */</div><div class=\"line\">    public int getSequenceNumber() &#123;</div><div class=\"line\">        return mSequenceGenerator.incrementAndGet();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Gets the &#123;@link Cache&#125; instance being used.</div><div class=\"line\">     * 返回当前正在使用的cache引用</div><div class=\"line\">     */</div><div class=\"line\">    public Cache getCache() &#123;</div><div class=\"line\">        return mCache;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * A simple predicate or filter interface for Requests, for use by</div><div class=\"line\">     * &#123;@link RequestQueue#cancelAll(RequestFilter)&#125;.</div><div class=\"line\">     * 一个request的过滤器</div><div class=\"line\">     * 上面说是给cancelAll用的，应该是设置一个RequestFilter之后</div><div class=\"line\">     * 将一类的request全都取消掉，至于具体的规则就需要重写里面的函数</div><div class=\"line\">     * 定义规则了</div><div class=\"line\">     */</div><div class=\"line\">    public interface RequestFilter &#123;</div><div class=\"line\">        public boolean apply(Request request);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Cancels all requests in this queue for which the given filter applies.</div><div class=\"line\">     * 从外面传入一个RequestFilter</div><div class=\"line\">     * 按照传入的规则取消所有符合规则的request</div><div class=\"line\">     * @param filter The filtering function to use</div><div class=\"line\">     */</div><div class=\"line\">    public void cancelAll(RequestFilter filter) &#123;</div><div class=\"line\">        synchronized (mCurrentRequests) &#123;</div><div class=\"line\">            for (Request request : mCurrentRequests) &#123;</div><div class=\"line\">                if (filter.apply(request)) &#123;</div><div class=\"line\">                    request.cancel();</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Cancels all requests in this queue with the given tag. Tag must be non-null</div><div class=\"line\">     * 依据request上面的tag来取消</div><div class=\"line\">     * and equality is by identity.</div><div class=\"line\">     */</div><div class=\"line\">    public void cancelAll(final Object tag) &#123;</div><div class=\"line\">        if (tag == null) &#123;</div><div class=\"line\">            throw new IllegalArgumentException(&quot;Cannot cancelAll with a null tag&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        cancelAll(new RequestFilter() &#123;</div><div class=\"line\">            @Override</div><div class=\"line\">            public boolean apply(Request request) &#123;</div><div class=\"line\">                return request.getTag() == tag;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Adds a Request to the dispatch queue.</div><div class=\"line\">     * 将新的request加入到总的等待队列中去</div><div class=\"line\">     * 一个request被处理之前都要待的地方</div><div class=\"line\">     * mCurrentRequests里面存放着所有的request </div><div class=\"line\">     *</div><div class=\"line\">     * @param request The request to service</div><div class=\"line\">     * 被传入的request，等待被处理</div><div class=\"line\">     * @return The passed-in request</div><div class=\"line\">     * 将加入的request返回回去</div><div class=\"line\">     */</div><div class=\"line\">    public  Request add(Request request) &#123;</div><div class=\"line\">        // Tag the request as belonging to this queue and add it to the set of current requests.</div><div class=\"line\">        request.setRequestQueue(this);</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * 在向mCurrentRequest中添加request的时候</div><div class=\"line\">         * 锁住不允许其他的线程进行访问操作</div><div class=\"line\">         * 对于synchronized:可用来给对象和方法或者代码块加锁，</div><div class=\"line\">         * 当它锁定一个方法或者一个代码块的时候，同一时刻最多只有一个线程执行这段代码。</div><div class=\"line\">         * 当两个并发线程访问同一个对象object中的这个加锁同步代码块时，一个时间内只能有一个线程得到执行。</div><div class=\"line\">         * 另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。</div><div class=\"line\">         * </div><div class=\"line\">         */</div><div class=\"line\">        synchronized (mCurrentRequests) &#123;</div><div class=\"line\">            mCurrentRequests.add(request);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * Process requests in the order they are added.</div><div class=\"line\">         * 在加入到mCurrentQueue中排队的时候</div><div class=\"line\">         * 就像我们排队一样会给我们一个对应的号码牌</div><div class=\"line\">         * 只是这里用了getSequenceNumber()函数来自动的发放号码牌</div><div class=\"line\">         */</div><div class=\"line\">        request.setSequence(getSequenceNumber());</div><div class=\"line\">        request.addMarker(&quot;add-to-queue&quot;);</div><div class=\"line\"></div><div class=\"line\">        /** </div><div class=\"line\">         * If the request is uncacheable, skip the cache queue and go straight to the network.</div><div class=\"line\">         * 检查这个request是否是不可缓存的</div><div class=\"line\">         * 也就是这个request所返回的response是否需要缓存下来</div><div class=\"line\">         */</div><div class=\"line\">        if (!request.shouldCache()) &#123;</div><div class=\"line\"></div><div class=\"line\">            /**</div><div class=\"line\">             * 如果不需要缓存的话</div><div class=\"line\">             * 直接将这个request加入到网络队列中去</div><div class=\"line\">             * 并且返回该request</div><div class=\"line\">             */</div><div class=\"line\">            mNetworkQueue.add(request);</div><div class=\"line\">            return request;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * Insert request into stage if there&apos;s already a request with the same cache key in flight.</div><div class=\"line\">         * = =尼玛我这是什么记性，看见这个mWaittingRequests居然不认识了</div><div class=\"line\">         * 向前翻到变量声明的地方，清清楚楚的写着专门存放重复请求的地方</div><div class=\"line\">         * 根据需要缓存的request生成的特殊标记cacheKey</div><div class=\"line\">         * 当然不涉及到缓存的request在上面几行代码被过滤处理了</div><div class=\"line\">         */</div><div class=\"line\">        synchronized (mWaitingRequests) &#123;</div><div class=\"line\"></div><div class=\"line\">            /**</div><div class=\"line\">             * 先获取到这个request的cacheKey</div><div class=\"line\">             * 看看有没有和它相同的request已经处于天上飞的状态了</div><div class=\"line\">             * (我觉得这里的in flight应该说的是已经发送过了的)</div><div class=\"line\">             * 在后面会说明</div><div class=\"line\">             */</div><div class=\"line\">            String cacheKey = request.getCacheKey();</div><div class=\"line\"></div><div class=\"line\">            if (mWaitingRequests.containsKey(cacheKey)) &#123;</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * There is already a request in flight. Queue up.</div><div class=\"line\">                 * 如果在等待的队列里面存在着cacheKey对应的一个Queue</div><div class=\"line\">                 * 则说明在这个request之前，已经有相同的request发送出去过了</div><div class=\"line\">                 * 那么现在需要做的就是将这个request加入到cacheKey对应的Queue存起来</div><div class=\"line\">                 * 如果对应的Queue是null,就自己创建一个新的，再把request放入</div><div class=\"line\">                 * </div><div class=\"line\">                 * 这个request就不再会被放入到mCacheQueue中去了</div><div class=\"line\">                 * 就是坐等数据的意思= =</div><div class=\"line\">                 */</div><div class=\"line\">                Queue&gt; stagedRequests = mWaitingRequests.get(cacheKey);</div><div class=\"line\">                if (stagedRequests == null) &#123;</div><div class=\"line\">                    stagedRequests = new LinkedList&gt;();</div><div class=\"line\">                &#125;</div><div class=\"line\">                stagedRequests.add(request);</div><div class=\"line\">                mWaitingRequests.put(cacheKey, stagedRequests);</div><div class=\"line\">                if (VolleyLog.DEBUG) &#123;</div><div class=\"line\">                    VolleyLog.v(&quot;Request for cacheKey=%s is in flight, putting on hold.&quot;, cacheKey);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                /**</div><div class=\"line\">                 * Insert &apos;null&apos; queue for this cacheKey, indicating there is now a request in flight.</div><div class=\"line\">                 * 如果这个涉及到cache的request在它之前根本就没有和他相同的request</div><div class=\"line\">                 * 直接以这个cacheKey为key，放一个null进去</div><div class=\"line\">                 * 表示这是第一个么= =</div><div class=\"line\">                 * 搞不懂为什么要这个样子设计，为什么不直接新建一个Queue进去呢</div><div class=\"line\">                 */</div><div class=\"line\">                mWaitingRequests.put(cacheKey, null);</div><div class=\"line\">                mCacheQueue.add(request);</div><div class=\"line\">            &#125;</div><div class=\"line\">            return request;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Called from &#123;@link Request#finish(String)&#125;, indicating that processing of the given request</div><div class=\"line\">     * has finished.</div><div class=\"line\">     * 从Request中的finish()方法调用开始，预示着给出的request已经结束</div><div class=\"line\">     * Releases waiting requests for request.getCacheKey() if</div><div class=\"line\">     *      request.shouldCache().</div><div class=\"line\">     * 将处于mWaittingQueue中具有相同cacheKey的一组request全部释放</div><div class=\"line\">     * 也就是把上面那些坐等数据的request全部取出来，response发送回去</div><div class=\"line\">     */</div><div class=\"line\">     void finish(Request request) &#123;</div><div class=\"line\">        // Remove from the set of requests currently being processed.</div><div class=\"line\">        /**</div><div class=\"line\">         * 将mCurrentRequests锁住</div><div class=\"line\">         * 一个时间段内只有一个线程可以访问该对象</div><div class=\"line\">         * 将已经结束的request从队列中移除</div><div class=\"line\">         */</div><div class=\"line\">        synchronized (mCurrentRequests) &#123;</div><div class=\"line\">            mCurrentRequests.remove(request);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * 通知所有注册过的监听器</div><div class=\"line\">         * 告诉它们，request已经finish了</div><div class=\"line\">         */</div><div class=\"line\">        synchronized (mFinishedListeners) &#123;</div><div class=\"line\">          for (RequestFinishedListener listener : mFinishedListeners) &#123;</div><div class=\"line\">            listener.onRequestFinished(request);</div><div class=\"line\">          &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * 如果该request涉及到需要缓存</div><div class=\"line\">         * 则将mWaitingRequests中具有相同cacheKey的request</div><div class=\"line\">         * 全部取出放入到缓存队列中等待CacheDispatcher的调度</div><div class=\"line\">         */</div><div class=\"line\">        if (request.shouldCache()) &#123;</div><div class=\"line\">            synchronized (mWaitingRequests) &#123;</div><div class=\"line\">                String cacheKey = request.getCacheKey();</div><div class=\"line\">                Queue&gt; waitingRequests = mWaitingRequests.remove(cacheKey);</div><div class=\"line\">                if (waitingRequests != null) &#123;</div><div class=\"line\">                    if (VolleyLog.DEBUG) &#123;</div><div class=\"line\">                        VolleyLog.v(&quot;Releasing %d waiting requests for cacheKey=%s.&quot;,</div><div class=\"line\">                                waitingRequests.size(), cacheKey);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    // Process all queued up requests. They won&apos;t be considered as in flight, but</div><div class=\"line\">                    // that&apos;s not a problem as the cache has been primed by &apos;request&apos;.</div><div class=\"line\">                    mCacheQueue.addAll(waitingRequests);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * 下面两个方法就是所谓注册监听器和取消注册的函数</div><div class=\"line\">     */</div><div class=\"line\">    public   void addRequestFinishedListener(RequestFinishedListener listener) &#123;</div><div class=\"line\">      synchronized (mFinishedListeners) &#123;</div><div class=\"line\">        mFinishedListeners.add(listener);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Remove a RequestFinishedListener. Has no effect if listener was not previously added.</div><div class=\"line\">     */</div><div class=\"line\">    public   void removeRequestFinishedListener(RequestFinishedListener listener) &#123;</div><div class=\"line\">      synchronized (mFinishedListeners) &#123;</div><div class=\"line\">        mFinishedListeners.remove(listener);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面介绍了Volley.java和RequestQueue.java两大类，Volley是对外的入口，而RequestQueue是Volley框架中最核心的部分了。如果注释上面有写错了或者有疑问的地方，还请各位直接指出在下一篇博客中将继续向下深入，结合源代码分析什么是Dispatcher。</p>"},{"title":"Volley框架解析-五-HttpStack接口及其默认实现类解析","date":"2017-04-19T05:12:42.000Z","_content":"\n\n### 1. 前言\n前面都在做一些准备工作，以及对request队列调度以及维护工作。之前提到，`httpResponse = mHttpStack.performRequest(request, headers);`这句话是网络请求的核心\n\n### 2. HttpStack.java\n\n接口类，里面包含了一个方法，`performRequest()`。\n\n<!--more-->\n```\n/**\n * An HTTP stack abstraction.\n */\npublic interface HttpStack {\n    /**\n     * Performs an HTTP request with the given parameters.\n     * 用传入给定的参数来模拟Http请求\n     * \n     * A GET request is sent if request.getPostBody() == null. A POST request is sent otherwise,\n     * and the Content-Type header is set to request.getPostBodyContentType().\n     * 如果传入的request.getPostBody()为空，则发送一个Get类型的请求，否则发送一个Post类型请求\n     * \n     * @param request the request to perform\n     * 即将发送的初始请求，也是volley自己写的= =，进去看看\n     * (还需要添加上额外的header\n     * \n     * @param additionalHeaders additional headers to be sent together with\n     *         {@link Request#getHeaders()}\n     * 需要添加到该request上的header的信息\n     *\n     * @return the HTTP response\n     *\n     */\n    public HttpResponse performRequest(Request<?> request, Map<String, String> additionalHeaders)\n        throws IOException, AuthFailureError;\n\n}\n\n```\n\n### [](#3-_HttpClientStack-java \"3\\. HttpClientStack.java\")3\\. HttpClientStack.java\n\n当sdk版本小于2.3时，Volley会选择用HttpClient来实现请求的发送。\n\n```\n/**\n * An HttpStack that performs request over an {@link HttpClient}.\n * 在sdk小于2.3的时候\n * 选用HttpClient来实现网络请求\n */\npublic class HttpClientStack implements HttpStack {\n\n    /**\n     * 官方文档\n     * Interface for an HTTP client. \n     * HTTP clients encapsulate a smorgasbord of objects required to execute HTTP requests while handling cookies, \n     * authentication, connection management, and other features. \n     * HTTP Clients将发送http请求需要需要做出的信息\n     * Thread safety of HTTP clients depends on the implementation and configuration of the specific client. \n     * \n     */\n    protected final HttpClient mClient;\n\n    //Http请求头里面的固定格式\n    private final static String HEADER_CONTENT_TYPE = \"Content-Type\";\n\n    public HttpClientStack(HttpClient client) {\n        mClient = client;\n    }\n\n    //在组合出一个请求的过程中，向请求体中添加Header的方法，Header是以键值对的形式存在的\n    private static void addHeaders(HttpUriRequest httpRequest, Map<String, String> headers) {\n        for (String key : headers.keySet()) {\n            httpRequest.setHeader(key, headers.get(key));\n        }\n    }\n\n    /**\n     * NameValuePair 官方文档\n     * A simple class encapsulating an attribute/value pair. \n     * \n     * 该函数将传入的Map里面存放的值进一步转化成由NameValuePair子类组成的数组中\n     */\n    @SuppressWarnings(\"unused\")\n    private static List<NameValuePair> getPostParameterPairs(Map<String, String> postParams) {\n        List<NameValuePair> result = new ArrayList<NameValuePair>(postParams.size());\n        for (String key : postParams.keySet()) {\n            result.add(new BasicNameValuePair(key, postParams.get(key)));\n        }\n        return result;\n    }\n\n     //该函数也就是实现HttpStack接口需要实现的方法，用来执行Request的方法\n    @Override\n    public HttpResponse performRequest(Request<?> request, Map<String, String> additionalHeaders)\n            throws IOException, AuthFailureError {\n\n        /**\n         * 传入请求体和额外需要添加入的头部\n         * 生成并返回一个HttpUriRequest\n         */\n        HttpUriRequest httpRequest = createHttpRequest(request, additionalHeaders);\n\n        /**\n         * 这个方法在前面实现了，将这些传入的键值对全部添加到httpRequest里面去\n         */\n        addHeaders(httpRequest, additionalHeaders);\n        addHeaders(httpRequest, request.getHeaders());\n\n        /**\n         * 一个protected方法，留给子类可以实现的方法(本类中并没有什么东西)，在这里会调用。\n         */\n        onPrepareRequest(httpRequest);\n\n        /**\n         * HttpParams 官方文档\n         * Represents a collection of HTTP protocol and framework parameters. \n         * 说白了就是Http协议和框架的相关参数\n         */\n        HttpParams httpParams = httpRequest.getParams();\n        int timeoutMs = request.getTimeoutMs();\n\n        /**\n         * HttpConnectionParams 官方文档\n         * An adaptor for accessing connection parameters in HttpParams. \n         * 一个用来访问请求参数的适配器\n         * Note that the implements relation to CoreConnectionPNames is for compatibility with existing application code only. \n         * References to the parameter names should use the interface, not this class. \n         */\n\n        /* Sets the timeout until a connection is established.\n         * 该方法用来设置时间限制，\n         * A value of zero means the timeout is not used. The default value is zero. \n         * 如果timeout设置为0则表示该限时没有启用，默认为0\n         */\n        HttpConnectionParams.setConnectionTimeout(httpParams, 5000);\n\n        /**\n         * Sets the default socket timeout (SO_TIMEOUT) in milliseconds which is the timeout for waiting for data. \n         * 设置请求发出后等待网络响应并返回数据的限时\n         * A timeout value of zero is interpreted as an infinite timeout. \n         * 如果timeout值为0则意味着无限等待，没有等待限时，同时也是默认的值\n         * This value is used when no socket timeout is set in the method parameters. \n         */\n        HttpConnectionParams.setSoTimeout(httpParams, timeoutMs);\n\n        /**\n         * 执行了HttpClient类中的execute方法\n         * 方法描述为 Executes a request using the default context.\n         * 方法结束后将返回一个HttpResponse，也就是请求的结果类\n         */ \n        return mClient.execute(httpRequest);\n    }\n\n    /**\n     * Creates the appropriate subclass of HttpUriRequest for passed in request.\n     * 根据传入的Request种类不同\n     * 创建不同的HttpUriRequest子类(也就是下面的HttpGet等等)\n     * 下面做的工作和HurlStack.java里面做的工作差不多\n     * 设置header,以及是否需要传入请求携带的参数\n     * 只是本类中用HttpClient实现，后者用的是HttpURLConnection实现的\n     */\n    @SuppressWarnings(\"deprecation\")\n    /* protected */ static HttpUriRequest createHttpRequest(Request<?> request,\n            Map<String, String> additionalHeaders) throws AuthFailureError {\n        switch (request.getMethod()) {\n            case Method.DEPRECATED_GET_OR_POST: {\n                // This is the deprecated way that needs to be handled for backwards compatibility.\n                // If the request's post body is null, then the assumption is that the request is\n                // GET.  Otherwise, it is assumed that the request is a POST.\n                byte[] postBody = request.getPostBody();\n                if (postBody != null) {\n                    HttpPost postRequest = new HttpPost(request.getUrl());\n                    postRequest.addHeader(HEADER_CONTENT_TYPE, request.getPostBodyContentType());\n                    HttpEntity entity;\n                    entity = new ByteArrayEntity(postBody);\n                    postRequest.setEntity(entity);\n                    return postRequest;\n                } else {\n                    return new HttpGet(request.getUrl());\n                }\n            }\n            case Method.GET:\n                return new HttpGet(request.getUrl());\n            case Method.DELETE:\n                return new HttpDelete(request.getUrl());\n            case Method.POST: {\n                HttpPost postRequest = new HttpPost(request.getUrl());\n                postRequest.addHeader(HEADER_CONTENT_TYPE, request.getBodyContentType());\n                setEntityIfNonEmptyBody(postRequest, request);\n                return postRequest;\n            }\n            case Method.PUT: {\n                HttpPut putRequest = new HttpPut(request.getUrl());\n                putRequest.addHeader(HEADER_CONTENT_TYPE, request.getBodyContentType());\n                setEntityIfNonEmptyBody(putRequest, request);\n                return putRequest;\n            }\n            case Method.HEAD:\n                return new HttpHead(request.getUrl());\n            case Method.OPTIONS:\n                return new HttpOptions(request.getUrl());\n            case Method.TRACE:\n                return new HttpTrace(request.getUrl());\n            case Method.PATCH: {\n                HttpPatch patchRequest = new HttpPatch(request.getUrl());\n                patchRequest.addHeader(HEADER_CONTENT_TYPE, request.getBodyContentType());\n                setEntityIfNonEmptyBody(patchRequest, request);\n                return patchRequest;\n            }\n            default:\n                throw new IllegalStateException(\"Unknown request method.\");\n        }\n    }\n\n    private static void setEntityIfNonEmptyBody(HttpEntityEnclosingRequestBase httpRequest,\n            Request<?> request) throws AuthFailureError {\n        byte[] body = request.getBody();\n        if (body != null) {\n            HttpEntity entity = new ByteArrayEntity(body);\n            httpRequest.setEntity(entity);\n        }\n    }\n\n    /**\n     * Called before the request is executed using the underlying HttpClient.\n     *\n     * <p>Overwrite in subclasses to augment the request.</p>\n     */\n    protected void onPrepareRequest(HttpUriRequest request) throws IOException {\n        // Nothing.\n    }\n\n    /**\n     * The HttpPatch class does not exist in the Android framework, so this has been defined here.\n     * = =在HttpUriClient的子类中没有支持Patch的请求方法\n     * 在这里volley实现了= =\n     */\n    public static final class HttpPatch extends HttpEntityEnclosingRequestBase {\n\n        public final static String METHOD_NAME = \"PATCH\";\n\n        public HttpPatch() {\n            super();\n        }\n\n        public HttpPatch(final URI uri) {\n            super();\n            setURI(uri);\n        }\n\n        /**\n         * @throws IllegalArgumentException if the uri is invalid.\n         */\n        public HttpPatch(final String uri) {\n            super();\n            setURI(URI.create(uri));\n        }\n\n        @Override\n        public String getMethod() {\n            return METHOD_NAME;\n        }\n\n    }\n}\n\n```\n\n### [](#4-HurlStack-java \"4.HurlStack.java\")4.HurlStack.java\n在sdk大于2.3的android手机上，Volley选择用HttpURLConnection来实现网络请求。\n\n```\n/**\n * An {@link HttpStack} based on {@link HttpURLConnection}.\n */\n\n/**\n * 当os version 版本在2.3以上，也就是sdk >= 9 的时候\n * 选用这个接口作为HttpStack， 用到了HttpURLConnection\n * 关于HttpURLConnection,官方解释为：\n * An URLConnection for HTTP (RFC 2616) used to send and receive data over the web.\n * Data may be of any type and length. \n * This class may be used to send and receive streaming data whose length is not known in advance.\n * 用来发送和接受数据，数据可以为任意的形式及长度\n * 这个类常用来发送和接受数据流里面长度不定的数据.\n */\npublic class HurlStack implements HttpStack {\n\n    /*\n     * 请求header中的一个关键字\n     * content-type代表着被发送的请求中主体内容\n     * 可以设置application/json等格式\n     */\n    private static final String HEADER_CONTENT_TYPE = \"Content-Type\";\n\n    /**\n     * An interface for transforming URLs before use.\n     * 一个用来在使用url之前，将url处理的接口工具\n     * 可能是用来规范url格式的一个工具= =\n     */ \n    public interface UrlRewriter {\n        /**\n         * Returns a URL to use instead of the provided one, or null to indicate\n         * this URL should not be used at all.\n         */\n        public String rewriteUrl(String originalUrl);\n    }\n\n    private final UrlRewriter mUrlRewriter;\n\n    /**\n     * The abstract factory implementation to create SSLSockets.\n     * 是一个抽象工厂类，用来创建SSLSockets（还是不懂是个什么鬼\n     * \n     * 对于SSLSocket，官方的解释是这样的：\n     * The extension of Socket providing secure protocols like SSL (Secure Sockets Layer) or TLS (Transport Layer Security).\n     * 是Socket的子类，并在之基础上新增了类似于SSL或者TLS等等的安全协议.\n     */\n    private final SSLSocketFactory mSslSocketFactory;\n\n    public HurlStack() {\n        this(null);\n    }\n\n    /**\n     * @param urlRewriter Rewriter to use for request URLs\n     */\n    public HurlStack(UrlRewriter urlRewriter) {\n        this(urlRewriter, null);\n    }\n\n    /**\n     * @param urlRewriter Rewriter to use for request URLs\n     * @param sslSocketFactory SSL factory to use for HTTPS connections\n     */\n    public HurlStack(UrlRewriter urlRewriter, SSLSocketFactory sslSocketFactory) {\n        mUrlRewriter = urlRewriter;\n        mSslSocketFactory = sslSocketFactory;\n    }\n\n    /**\n     * 该函数为HttpStack的接口\n     */\n    @Override\n    public HttpResponse performRequest(Request<?> request, Map<String, String> additionalHeaders)\n            throws IOException, AuthFailureError {\n        /**\n         * 得到请求的url\n         */\n        String url = request.getUrl();\n\n        /**\n         * 创建一个新的HashMap\n         * 用来存放请求的header的信息\n         */\n        HashMap<String, String> map = new HashMap<String, String>();\n\n        /**\n         * 将原request(volley自己封装的一个request类)中的header\n         * 和另外需要添加入header的信息都整合起来\n         */\n        map.putAll(request.getHeaders());\n        map.putAll(additionalHeaders);\n\n        if (mUrlRewriter != null) {\n            String rewritten = mUrlRewriter.rewriteUrl(url);\n            if (rewritten == null) {\n                throw new IOException(\"URL blocked by rewriter: \" + url);\n            }\n            url = rewritten;\n        }\n\n        /**\n         * 将url字符串形式规范成一个URL的类对象\n         */\n        URL parsedUrl = new URL(url);\n\n        /**\n         * HurlStack类是在sdk>=2.3的android版本上使用的\n         * 这里面用到了HttpURLConnection类\n         * 在函数里面打开了并返回了一个HttpURLConnection\n         * 设置了HttpURLConnection的响应超时阀值\n         */\n        HttpURLConnection connection = openConnection(parsedUrl, request);\n\n        /**\n         * 开始给HttpURLConnection添加header的信息\n         * 用addRequestProperty()函数将header以键值对的形式填入\n         */\n        for (String headerName : map.keySet()) {\n            connection.addRequestProperty(headerName, map.get(headerName));\n        }\n\n        /**\n         * 根据request种类的不同\n         * 分别用不同的方式来处理其中的参数\n         */\n        setConnectionParametersForRequest(connection, request);\n\n        // Initialize HttpResponse with data from the HttpURLConnection.\n        ProtocolVersion protocolVersion = new ProtocolVersion(\"HTTP\", 1, 1);\n\n        int responseCode = connection.getResponseCode();\n        if (responseCode == -1) {\n            // -1 is returned by getResponseCode() if the response code could not be retrieved.\n            // Signal to the caller that something was wrong with the connection.\n            throw new IOException(\"Could not retrieve response code from HttpUrlConnection.\");\n        }\n        StatusLine responseStatus = new BasicStatusLine(protocolVersion,\n                connection.getResponseCode(), connection.getResponseMessage());\n\n        BasicHttpResponse response = new BasicHttpResponse(responseStatus);\n\n        response.setEntity(entityFromConnection(connection));\n\n        for (Entry<String, List<String>> header : connection.getHeaderFields().entrySet()) {\n            if (header.getKey() != null) {\n                Header h = new BasicHeader(header.getKey(), header.getValue().get(0));\n                response.addHeader(h);\n            }\n        }\n        return response;\n    }\n\n    /**\n     * Initializes an {@link HttpEntity} from the given {@link HttpURLConnection}.\n     * @param connection\n     * @return an HttpEntity populated with data from <code>connection</code>.\n     */\n    private static HttpEntity entityFromConnection(HttpURLConnection connection) {\n        BasicHttpEntity entity = new BasicHttpEntity();\n        InputStream inputStream;\n        try {\n            inputStream = connection.getInputStream();\n        } catch (IOException ioe) {\n            inputStream = connection.getErrorStream();\n        }\n        entity.setContent(inputStream);\n        entity.setContentLength(connection.getContentLength());\n        entity.setContentEncoding(connection.getContentEncoding());\n        entity.setContentType(connection.getContentType());\n        return entity;\n    }\n\n    /**\n     * Create an {@link HttpURLConnection} for the specified {@code url}.\n     */\n    protected HttpURLConnection createConnection(URL url) throws IOException {\n\n        return (HttpURLConnection) url.openConnection();\n    }\n\n    /**\n     * Opens an {@link HttpURLConnection} with parameters.\n     * 通过给的url和参数，打开一个HttpURLConnection\n     * @param url\n     * @return an open connection\n     * @throws IOException\n     */\n    private HttpURLConnection openConnection(URL url, Request<?> request) throws IOException {\n\n        HttpURLConnection connection = createConnection(url);\n\n        /**\n         * 通过Request.java中的函数\n         * 获取到该request上所设置的服务器最大响应时间阀值\n         * 该阀值默认是2500ms，而且可能会随着retry的次数而增大\n         */\n        int timeoutMs = request.getTimeoutMs();\n\n        /**\n         * 给connection设置上请求超时时间\n         */\n        connection.setConnectTimeout(timeoutMs);\n        connection.setReadTimeout(timeoutMs);\n        connection.setUseCaches(false);\n        connection.setDoInput(true);\n\n        /**\n         * use caller-provided custom SslSocketFactory, if any, for HTTPS\n         * 请求方面的安全问题，暂时还不清清楚\n         */\n        if (\"https\".equals(url.getProtocol()) && mSslSocketFactory != null) {\n            ((HttpsURLConnection)connection).setSSLSocketFactory(mSslSocketFactory);\n        }\n\n        return connection;\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    /* package */\n    /**\n     * switch不同的请求方法\n     * 来以不同的方式给HttpURLConnection添加请求参数\n     */ \n    static void setConnectionParametersForRequest(HttpURLConnection connection,\n            Request<?> request) throws IOException, AuthFailureError {\n        switch (request.getMethod()) {\n\n            /**\n             * 在构造Request的时候如果没有指明请求方式\n             * DEPRECATED_GET_OR_POST为其默认值\n             * 通过postBody是否为Null来区别POST和GET\n             * 这两种最常用的请求方式\n             */\n            case Method.DEPRECATED_GET_OR_POST:\n                // This is the deprecated way that needs to be handled for backwards compatibility.\n                // If the request's post body is null, then the assumption is that the request is\n                // GET.  Otherwise, it is assumed that the request is a POST.\n                /**\n                 * 不要用这个参数了= =，因为不能处理什么DELETE之类的\n                 * 该方法已经过时了。\n                 */\n                byte[] postBody = request.getPostBody();\n                if (postBody != null) {\n                    // Prepare output. There is no need to set Content-Length explicitly,\n                    // since this is handled by HttpURLConnection using the size of the prepared\n                    // output stream.\n\n                    /**\n                     * 设置是否输出\n                     */\n                    connection.setDoOutput(true);\n\n                    /**\n                     * 给connection设置请求的方式\n                     */\n                    connection.setRequestMethod(\"POST\");\n\n                    /**\n                     * 设置http请求头中的content-type参数\n                     */\n                    connection.addRequestProperty(HEADER_CONTENT_TYPE,\n                            request.getPostBodyContentType());\n                    DataOutputStream out = new DataOutputStream(connection.getOutputStream());\n                    out.write(0);\n                    out.close();\n                }\n                break;\n            case Method.GET:\n                // Not necessary to set the request method because connection defaults to GET but\n                // being explicit here.\n                connection.setRequestMethod(\"GET\");\n                break;\n            case Method.DELETE:\n                connection.setRequestMethod(\"DELETE\");\n                break;\n            case Method.POST:\n                connection.setRequestMethod(\"POST\");\n                addBodyIfExists(connection, request);\n                break;\n            case Method.PUT:\n                connection.setRequestMethod(\"PUT\");\n                addBodyIfExists(connection, request);\n                break;\n            case Method.HEAD:\n                connection.setRequestMethod(\"HEAD\");\n                break;\n            case Method.OPTIONS:\n                connection.setRequestMethod(\"OPTIONS\");\n                break;\n            case Method.TRACE:\n                connection.setRequestMethod(\"TRACE\");\n                break;\n            case Method.PATCH:\n                connection.setRequestMethod(\"PATCH\");\n                addBodyIfExists(connection, request);\n                break;\n            default:\n                throw new IllegalStateException(\"Unknown method type.\");\n        }\n    }\n\n    /**\n     * 如果存在请求参数的话\n     * 获取到connection的输出流对象\n     * 并创建一个DataOutputStream对象\n     * 用于向服务器写入需要传递的参数\n     */\n    private static void addBodyIfExists(HttpURLConnection connection, Request<?> request)\n            throws IOException, AuthFailureError {\n        byte[] body = request.getBody();\n        if (body != null) {\n            connection.setDoOutput(true);\n            connection.addRequestProperty(HEADER_CONTENT_TYPE, request.getBodyContentType());\n            DataOutputStream out = new DataOutputStream(connection.getOutputStream());\n            out.write(body);\n            out.close();\n        }\n    }\n}\n\n```","source":"_posts/Volley框架解析-五-HttpStack接口及其默认实现类解析.md","raw":"---\ntitle: Volley框架解析-五-HttpStack接口及其默认实现类解析\ndate: 2017-04-19 13:12:42\ntags: volley\n\n---\n\n\n### 1. 前言\n前面都在做一些准备工作，以及对request队列调度以及维护工作。之前提到，`httpResponse = mHttpStack.performRequest(request, headers);`这句话是网络请求的核心\n\n### 2. HttpStack.java\n\n接口类，里面包含了一个方法，`performRequest()`。\n\n<!--more-->\n```\n/**\n * An HTTP stack abstraction.\n */\npublic interface HttpStack {\n    /**\n     * Performs an HTTP request with the given parameters.\n     * 用传入给定的参数来模拟Http请求\n     * \n     * A GET request is sent if request.getPostBody() == null. A POST request is sent otherwise,\n     * and the Content-Type header is set to request.getPostBodyContentType().\n     * 如果传入的request.getPostBody()为空，则发送一个Get类型的请求，否则发送一个Post类型请求\n     * \n     * @param request the request to perform\n     * 即将发送的初始请求，也是volley自己写的= =，进去看看\n     * (还需要添加上额外的header\n     * \n     * @param additionalHeaders additional headers to be sent together with\n     *         {@link Request#getHeaders()}\n     * 需要添加到该request上的header的信息\n     *\n     * @return the HTTP response\n     *\n     */\n    public HttpResponse performRequest(Request<?> request, Map<String, String> additionalHeaders)\n        throws IOException, AuthFailureError;\n\n}\n\n```\n\n### [](#3-_HttpClientStack-java \"3\\. HttpClientStack.java\")3\\. HttpClientStack.java\n\n当sdk版本小于2.3时，Volley会选择用HttpClient来实现请求的发送。\n\n```\n/**\n * An HttpStack that performs request over an {@link HttpClient}.\n * 在sdk小于2.3的时候\n * 选用HttpClient来实现网络请求\n */\npublic class HttpClientStack implements HttpStack {\n\n    /**\n     * 官方文档\n     * Interface for an HTTP client. \n     * HTTP clients encapsulate a smorgasbord of objects required to execute HTTP requests while handling cookies, \n     * authentication, connection management, and other features. \n     * HTTP Clients将发送http请求需要需要做出的信息\n     * Thread safety of HTTP clients depends on the implementation and configuration of the specific client. \n     * \n     */\n    protected final HttpClient mClient;\n\n    //Http请求头里面的固定格式\n    private final static String HEADER_CONTENT_TYPE = \"Content-Type\";\n\n    public HttpClientStack(HttpClient client) {\n        mClient = client;\n    }\n\n    //在组合出一个请求的过程中，向请求体中添加Header的方法，Header是以键值对的形式存在的\n    private static void addHeaders(HttpUriRequest httpRequest, Map<String, String> headers) {\n        for (String key : headers.keySet()) {\n            httpRequest.setHeader(key, headers.get(key));\n        }\n    }\n\n    /**\n     * NameValuePair 官方文档\n     * A simple class encapsulating an attribute/value pair. \n     * \n     * 该函数将传入的Map里面存放的值进一步转化成由NameValuePair子类组成的数组中\n     */\n    @SuppressWarnings(\"unused\")\n    private static List<NameValuePair> getPostParameterPairs(Map<String, String> postParams) {\n        List<NameValuePair> result = new ArrayList<NameValuePair>(postParams.size());\n        for (String key : postParams.keySet()) {\n            result.add(new BasicNameValuePair(key, postParams.get(key)));\n        }\n        return result;\n    }\n\n     //该函数也就是实现HttpStack接口需要实现的方法，用来执行Request的方法\n    @Override\n    public HttpResponse performRequest(Request<?> request, Map<String, String> additionalHeaders)\n            throws IOException, AuthFailureError {\n\n        /**\n         * 传入请求体和额外需要添加入的头部\n         * 生成并返回一个HttpUriRequest\n         */\n        HttpUriRequest httpRequest = createHttpRequest(request, additionalHeaders);\n\n        /**\n         * 这个方法在前面实现了，将这些传入的键值对全部添加到httpRequest里面去\n         */\n        addHeaders(httpRequest, additionalHeaders);\n        addHeaders(httpRequest, request.getHeaders());\n\n        /**\n         * 一个protected方法，留给子类可以实现的方法(本类中并没有什么东西)，在这里会调用。\n         */\n        onPrepareRequest(httpRequest);\n\n        /**\n         * HttpParams 官方文档\n         * Represents a collection of HTTP protocol and framework parameters. \n         * 说白了就是Http协议和框架的相关参数\n         */\n        HttpParams httpParams = httpRequest.getParams();\n        int timeoutMs = request.getTimeoutMs();\n\n        /**\n         * HttpConnectionParams 官方文档\n         * An adaptor for accessing connection parameters in HttpParams. \n         * 一个用来访问请求参数的适配器\n         * Note that the implements relation to CoreConnectionPNames is for compatibility with existing application code only. \n         * References to the parameter names should use the interface, not this class. \n         */\n\n        /* Sets the timeout until a connection is established.\n         * 该方法用来设置时间限制，\n         * A value of zero means the timeout is not used. The default value is zero. \n         * 如果timeout设置为0则表示该限时没有启用，默认为0\n         */\n        HttpConnectionParams.setConnectionTimeout(httpParams, 5000);\n\n        /**\n         * Sets the default socket timeout (SO_TIMEOUT) in milliseconds which is the timeout for waiting for data. \n         * 设置请求发出后等待网络响应并返回数据的限时\n         * A timeout value of zero is interpreted as an infinite timeout. \n         * 如果timeout值为0则意味着无限等待，没有等待限时，同时也是默认的值\n         * This value is used when no socket timeout is set in the method parameters. \n         */\n        HttpConnectionParams.setSoTimeout(httpParams, timeoutMs);\n\n        /**\n         * 执行了HttpClient类中的execute方法\n         * 方法描述为 Executes a request using the default context.\n         * 方法结束后将返回一个HttpResponse，也就是请求的结果类\n         */ \n        return mClient.execute(httpRequest);\n    }\n\n    /**\n     * Creates the appropriate subclass of HttpUriRequest for passed in request.\n     * 根据传入的Request种类不同\n     * 创建不同的HttpUriRequest子类(也就是下面的HttpGet等等)\n     * 下面做的工作和HurlStack.java里面做的工作差不多\n     * 设置header,以及是否需要传入请求携带的参数\n     * 只是本类中用HttpClient实现，后者用的是HttpURLConnection实现的\n     */\n    @SuppressWarnings(\"deprecation\")\n    /* protected */ static HttpUriRequest createHttpRequest(Request<?> request,\n            Map<String, String> additionalHeaders) throws AuthFailureError {\n        switch (request.getMethod()) {\n            case Method.DEPRECATED_GET_OR_POST: {\n                // This is the deprecated way that needs to be handled for backwards compatibility.\n                // If the request's post body is null, then the assumption is that the request is\n                // GET.  Otherwise, it is assumed that the request is a POST.\n                byte[] postBody = request.getPostBody();\n                if (postBody != null) {\n                    HttpPost postRequest = new HttpPost(request.getUrl());\n                    postRequest.addHeader(HEADER_CONTENT_TYPE, request.getPostBodyContentType());\n                    HttpEntity entity;\n                    entity = new ByteArrayEntity(postBody);\n                    postRequest.setEntity(entity);\n                    return postRequest;\n                } else {\n                    return new HttpGet(request.getUrl());\n                }\n            }\n            case Method.GET:\n                return new HttpGet(request.getUrl());\n            case Method.DELETE:\n                return new HttpDelete(request.getUrl());\n            case Method.POST: {\n                HttpPost postRequest = new HttpPost(request.getUrl());\n                postRequest.addHeader(HEADER_CONTENT_TYPE, request.getBodyContentType());\n                setEntityIfNonEmptyBody(postRequest, request);\n                return postRequest;\n            }\n            case Method.PUT: {\n                HttpPut putRequest = new HttpPut(request.getUrl());\n                putRequest.addHeader(HEADER_CONTENT_TYPE, request.getBodyContentType());\n                setEntityIfNonEmptyBody(putRequest, request);\n                return putRequest;\n            }\n            case Method.HEAD:\n                return new HttpHead(request.getUrl());\n            case Method.OPTIONS:\n                return new HttpOptions(request.getUrl());\n            case Method.TRACE:\n                return new HttpTrace(request.getUrl());\n            case Method.PATCH: {\n                HttpPatch patchRequest = new HttpPatch(request.getUrl());\n                patchRequest.addHeader(HEADER_CONTENT_TYPE, request.getBodyContentType());\n                setEntityIfNonEmptyBody(patchRequest, request);\n                return patchRequest;\n            }\n            default:\n                throw new IllegalStateException(\"Unknown request method.\");\n        }\n    }\n\n    private static void setEntityIfNonEmptyBody(HttpEntityEnclosingRequestBase httpRequest,\n            Request<?> request) throws AuthFailureError {\n        byte[] body = request.getBody();\n        if (body != null) {\n            HttpEntity entity = new ByteArrayEntity(body);\n            httpRequest.setEntity(entity);\n        }\n    }\n\n    /**\n     * Called before the request is executed using the underlying HttpClient.\n     *\n     * <p>Overwrite in subclasses to augment the request.</p>\n     */\n    protected void onPrepareRequest(HttpUriRequest request) throws IOException {\n        // Nothing.\n    }\n\n    /**\n     * The HttpPatch class does not exist in the Android framework, so this has been defined here.\n     * = =在HttpUriClient的子类中没有支持Patch的请求方法\n     * 在这里volley实现了= =\n     */\n    public static final class HttpPatch extends HttpEntityEnclosingRequestBase {\n\n        public final static String METHOD_NAME = \"PATCH\";\n\n        public HttpPatch() {\n            super();\n        }\n\n        public HttpPatch(final URI uri) {\n            super();\n            setURI(uri);\n        }\n\n        /**\n         * @throws IllegalArgumentException if the uri is invalid.\n         */\n        public HttpPatch(final String uri) {\n            super();\n            setURI(URI.create(uri));\n        }\n\n        @Override\n        public String getMethod() {\n            return METHOD_NAME;\n        }\n\n    }\n}\n\n```\n\n### [](#4-HurlStack-java \"4.HurlStack.java\")4.HurlStack.java\n在sdk大于2.3的android手机上，Volley选择用HttpURLConnection来实现网络请求。\n\n```\n/**\n * An {@link HttpStack} based on {@link HttpURLConnection}.\n */\n\n/**\n * 当os version 版本在2.3以上，也就是sdk >= 9 的时候\n * 选用这个接口作为HttpStack， 用到了HttpURLConnection\n * 关于HttpURLConnection,官方解释为：\n * An URLConnection for HTTP (RFC 2616) used to send and receive data over the web.\n * Data may be of any type and length. \n * This class may be used to send and receive streaming data whose length is not known in advance.\n * 用来发送和接受数据，数据可以为任意的形式及长度\n * 这个类常用来发送和接受数据流里面长度不定的数据.\n */\npublic class HurlStack implements HttpStack {\n\n    /*\n     * 请求header中的一个关键字\n     * content-type代表着被发送的请求中主体内容\n     * 可以设置application/json等格式\n     */\n    private static final String HEADER_CONTENT_TYPE = \"Content-Type\";\n\n    /**\n     * An interface for transforming URLs before use.\n     * 一个用来在使用url之前，将url处理的接口工具\n     * 可能是用来规范url格式的一个工具= =\n     */ \n    public interface UrlRewriter {\n        /**\n         * Returns a URL to use instead of the provided one, or null to indicate\n         * this URL should not be used at all.\n         */\n        public String rewriteUrl(String originalUrl);\n    }\n\n    private final UrlRewriter mUrlRewriter;\n\n    /**\n     * The abstract factory implementation to create SSLSockets.\n     * 是一个抽象工厂类，用来创建SSLSockets（还是不懂是个什么鬼\n     * \n     * 对于SSLSocket，官方的解释是这样的：\n     * The extension of Socket providing secure protocols like SSL (Secure Sockets Layer) or TLS (Transport Layer Security).\n     * 是Socket的子类，并在之基础上新增了类似于SSL或者TLS等等的安全协议.\n     */\n    private final SSLSocketFactory mSslSocketFactory;\n\n    public HurlStack() {\n        this(null);\n    }\n\n    /**\n     * @param urlRewriter Rewriter to use for request URLs\n     */\n    public HurlStack(UrlRewriter urlRewriter) {\n        this(urlRewriter, null);\n    }\n\n    /**\n     * @param urlRewriter Rewriter to use for request URLs\n     * @param sslSocketFactory SSL factory to use for HTTPS connections\n     */\n    public HurlStack(UrlRewriter urlRewriter, SSLSocketFactory sslSocketFactory) {\n        mUrlRewriter = urlRewriter;\n        mSslSocketFactory = sslSocketFactory;\n    }\n\n    /**\n     * 该函数为HttpStack的接口\n     */\n    @Override\n    public HttpResponse performRequest(Request<?> request, Map<String, String> additionalHeaders)\n            throws IOException, AuthFailureError {\n        /**\n         * 得到请求的url\n         */\n        String url = request.getUrl();\n\n        /**\n         * 创建一个新的HashMap\n         * 用来存放请求的header的信息\n         */\n        HashMap<String, String> map = new HashMap<String, String>();\n\n        /**\n         * 将原request(volley自己封装的一个request类)中的header\n         * 和另外需要添加入header的信息都整合起来\n         */\n        map.putAll(request.getHeaders());\n        map.putAll(additionalHeaders);\n\n        if (mUrlRewriter != null) {\n            String rewritten = mUrlRewriter.rewriteUrl(url);\n            if (rewritten == null) {\n                throw new IOException(\"URL blocked by rewriter: \" + url);\n            }\n            url = rewritten;\n        }\n\n        /**\n         * 将url字符串形式规范成一个URL的类对象\n         */\n        URL parsedUrl = new URL(url);\n\n        /**\n         * HurlStack类是在sdk>=2.3的android版本上使用的\n         * 这里面用到了HttpURLConnection类\n         * 在函数里面打开了并返回了一个HttpURLConnection\n         * 设置了HttpURLConnection的响应超时阀值\n         */\n        HttpURLConnection connection = openConnection(parsedUrl, request);\n\n        /**\n         * 开始给HttpURLConnection添加header的信息\n         * 用addRequestProperty()函数将header以键值对的形式填入\n         */\n        for (String headerName : map.keySet()) {\n            connection.addRequestProperty(headerName, map.get(headerName));\n        }\n\n        /**\n         * 根据request种类的不同\n         * 分别用不同的方式来处理其中的参数\n         */\n        setConnectionParametersForRequest(connection, request);\n\n        // Initialize HttpResponse with data from the HttpURLConnection.\n        ProtocolVersion protocolVersion = new ProtocolVersion(\"HTTP\", 1, 1);\n\n        int responseCode = connection.getResponseCode();\n        if (responseCode == -1) {\n            // -1 is returned by getResponseCode() if the response code could not be retrieved.\n            // Signal to the caller that something was wrong with the connection.\n            throw new IOException(\"Could not retrieve response code from HttpUrlConnection.\");\n        }\n        StatusLine responseStatus = new BasicStatusLine(protocolVersion,\n                connection.getResponseCode(), connection.getResponseMessage());\n\n        BasicHttpResponse response = new BasicHttpResponse(responseStatus);\n\n        response.setEntity(entityFromConnection(connection));\n\n        for (Entry<String, List<String>> header : connection.getHeaderFields().entrySet()) {\n            if (header.getKey() != null) {\n                Header h = new BasicHeader(header.getKey(), header.getValue().get(0));\n                response.addHeader(h);\n            }\n        }\n        return response;\n    }\n\n    /**\n     * Initializes an {@link HttpEntity} from the given {@link HttpURLConnection}.\n     * @param connection\n     * @return an HttpEntity populated with data from <code>connection</code>.\n     */\n    private static HttpEntity entityFromConnection(HttpURLConnection connection) {\n        BasicHttpEntity entity = new BasicHttpEntity();\n        InputStream inputStream;\n        try {\n            inputStream = connection.getInputStream();\n        } catch (IOException ioe) {\n            inputStream = connection.getErrorStream();\n        }\n        entity.setContent(inputStream);\n        entity.setContentLength(connection.getContentLength());\n        entity.setContentEncoding(connection.getContentEncoding());\n        entity.setContentType(connection.getContentType());\n        return entity;\n    }\n\n    /**\n     * Create an {@link HttpURLConnection} for the specified {@code url}.\n     */\n    protected HttpURLConnection createConnection(URL url) throws IOException {\n\n        return (HttpURLConnection) url.openConnection();\n    }\n\n    /**\n     * Opens an {@link HttpURLConnection} with parameters.\n     * 通过给的url和参数，打开一个HttpURLConnection\n     * @param url\n     * @return an open connection\n     * @throws IOException\n     */\n    private HttpURLConnection openConnection(URL url, Request<?> request) throws IOException {\n\n        HttpURLConnection connection = createConnection(url);\n\n        /**\n         * 通过Request.java中的函数\n         * 获取到该request上所设置的服务器最大响应时间阀值\n         * 该阀值默认是2500ms，而且可能会随着retry的次数而增大\n         */\n        int timeoutMs = request.getTimeoutMs();\n\n        /**\n         * 给connection设置上请求超时时间\n         */\n        connection.setConnectTimeout(timeoutMs);\n        connection.setReadTimeout(timeoutMs);\n        connection.setUseCaches(false);\n        connection.setDoInput(true);\n\n        /**\n         * use caller-provided custom SslSocketFactory, if any, for HTTPS\n         * 请求方面的安全问题，暂时还不清清楚\n         */\n        if (\"https\".equals(url.getProtocol()) && mSslSocketFactory != null) {\n            ((HttpsURLConnection)connection).setSSLSocketFactory(mSslSocketFactory);\n        }\n\n        return connection;\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    /* package */\n    /**\n     * switch不同的请求方法\n     * 来以不同的方式给HttpURLConnection添加请求参数\n     */ \n    static void setConnectionParametersForRequest(HttpURLConnection connection,\n            Request<?> request) throws IOException, AuthFailureError {\n        switch (request.getMethod()) {\n\n            /**\n             * 在构造Request的时候如果没有指明请求方式\n             * DEPRECATED_GET_OR_POST为其默认值\n             * 通过postBody是否为Null来区别POST和GET\n             * 这两种最常用的请求方式\n             */\n            case Method.DEPRECATED_GET_OR_POST:\n                // This is the deprecated way that needs to be handled for backwards compatibility.\n                // If the request's post body is null, then the assumption is that the request is\n                // GET.  Otherwise, it is assumed that the request is a POST.\n                /**\n                 * 不要用这个参数了= =，因为不能处理什么DELETE之类的\n                 * 该方法已经过时了。\n                 */\n                byte[] postBody = request.getPostBody();\n                if (postBody != null) {\n                    // Prepare output. There is no need to set Content-Length explicitly,\n                    // since this is handled by HttpURLConnection using the size of the prepared\n                    // output stream.\n\n                    /**\n                     * 设置是否输出\n                     */\n                    connection.setDoOutput(true);\n\n                    /**\n                     * 给connection设置请求的方式\n                     */\n                    connection.setRequestMethod(\"POST\");\n\n                    /**\n                     * 设置http请求头中的content-type参数\n                     */\n                    connection.addRequestProperty(HEADER_CONTENT_TYPE,\n                            request.getPostBodyContentType());\n                    DataOutputStream out = new DataOutputStream(connection.getOutputStream());\n                    out.write(0);\n                    out.close();\n                }\n                break;\n            case Method.GET:\n                // Not necessary to set the request method because connection defaults to GET but\n                // being explicit here.\n                connection.setRequestMethod(\"GET\");\n                break;\n            case Method.DELETE:\n                connection.setRequestMethod(\"DELETE\");\n                break;\n            case Method.POST:\n                connection.setRequestMethod(\"POST\");\n                addBodyIfExists(connection, request);\n                break;\n            case Method.PUT:\n                connection.setRequestMethod(\"PUT\");\n                addBodyIfExists(connection, request);\n                break;\n            case Method.HEAD:\n                connection.setRequestMethod(\"HEAD\");\n                break;\n            case Method.OPTIONS:\n                connection.setRequestMethod(\"OPTIONS\");\n                break;\n            case Method.TRACE:\n                connection.setRequestMethod(\"TRACE\");\n                break;\n            case Method.PATCH:\n                connection.setRequestMethod(\"PATCH\");\n                addBodyIfExists(connection, request);\n                break;\n            default:\n                throw new IllegalStateException(\"Unknown method type.\");\n        }\n    }\n\n    /**\n     * 如果存在请求参数的话\n     * 获取到connection的输出流对象\n     * 并创建一个DataOutputStream对象\n     * 用于向服务器写入需要传递的参数\n     */\n    private static void addBodyIfExists(HttpURLConnection connection, Request<?> request)\n            throws IOException, AuthFailureError {\n        byte[] body = request.getBody();\n        if (body != null) {\n            connection.setDoOutput(true);\n            connection.addRequestProperty(HEADER_CONTENT_TYPE, request.getBodyContentType());\n            DataOutputStream out = new DataOutputStream(connection.getOutputStream());\n            out.write(body);\n            out.close();\n        }\n    }\n}\n\n```","slug":"Volley框架解析-五-HttpStack接口及其默认实现类解析","published":1,"updated":"2020-07-03T02:40:48.121Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc5n2qh9000nw8r1gq7seq1u","content":"<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h3><p>前面都在做一些准备工作，以及对request队列调度以及维护工作。之前提到，<code>httpResponse = mHttpStack.performRequest(request, headers);</code>这句话是网络请求的核心</p>\n<h3 id=\"2-HttpStack-java\"><a href=\"#2-HttpStack-java\" class=\"headerlink\" title=\"2. HttpStack.java\"></a>2. HttpStack.java</h3><p>接口类，里面包含了一个方法，<code>performRequest()</code>。</p>\n<a id=\"more\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * An HTTP stack abstraction.</div><div class=\"line\"> */</div><div class=\"line\">public interface HttpStack &#123;</div><div class=\"line\">    /**</div><div class=\"line\">     * Performs an HTTP request with the given parameters.</div><div class=\"line\">     * 用传入给定的参数来模拟Http请求</div><div class=\"line\">     * </div><div class=\"line\">     * A GET request is sent if request.getPostBody() == null. A POST request is sent otherwise,</div><div class=\"line\">     * and the Content-Type header is set to request.getPostBodyContentType().</div><div class=\"line\">     * 如果传入的request.getPostBody()为空，则发送一个Get类型的请求，否则发送一个Post类型请求</div><div class=\"line\">     * </div><div class=\"line\">     * @param request the request to perform</div><div class=\"line\">     * 即将发送的初始请求，也是volley自己写的= =，进去看看</div><div class=\"line\">     * (还需要添加上额外的header</div><div class=\"line\">     * </div><div class=\"line\">     * @param additionalHeaders additional headers to be sent together with</div><div class=\"line\">     *         &#123;@link Request#getHeaders()&#125;</div><div class=\"line\">     * 需要添加到该request上的header的信息</div><div class=\"line\">     *</div><div class=\"line\">     * @return the HTTP response</div><div class=\"line\">     *</div><div class=\"line\">     */</div><div class=\"line\">    public HttpResponse performRequest(Request&lt;?&gt; request, Map&lt;String, String&gt; additionalHeaders)</div><div class=\"line\">        throws IOException, AuthFailureError;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"3-HttpClientStack-java\"><a href=\"#3-HttpClientStack-java\" class=\"headerlink\" title=\"3. HttpClientStack.java\"></a><a href=\"#3-_HttpClientStack-java\" title=\"3\\. HttpClientStack.java\"></a>3. HttpClientStack.java</h3><p>当sdk版本小于2.3时，Volley会选择用HttpClient来实现请求的发送。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div><div class=\"line\">204</div><div class=\"line\">205</div><div class=\"line\">206</div><div class=\"line\">207</div><div class=\"line\">208</div><div class=\"line\">209</div><div class=\"line\">210</div><div class=\"line\">211</div><div class=\"line\">212</div><div class=\"line\">213</div><div class=\"line\">214</div><div class=\"line\">215</div><div class=\"line\">216</div><div class=\"line\">217</div><div class=\"line\">218</div><div class=\"line\">219</div><div class=\"line\">220</div><div class=\"line\">221</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * An HttpStack that performs request over an &#123;@link HttpClient&#125;.</div><div class=\"line\"> * 在sdk小于2.3的时候</div><div class=\"line\"> * 选用HttpClient来实现网络请求</div><div class=\"line\"> */</div><div class=\"line\">public class HttpClientStack implements HttpStack &#123;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * 官方文档</div><div class=\"line\">     * Interface for an HTTP client. </div><div class=\"line\">     * HTTP clients encapsulate a smorgasbord of objects required to execute HTTP requests while handling cookies, </div><div class=\"line\">     * authentication, connection management, and other features. </div><div class=\"line\">     * HTTP Clients将发送http请求需要需要做出的信息</div><div class=\"line\">     * Thread safety of HTTP clients depends on the implementation and configuration of the specific client. </div><div class=\"line\">     * </div><div class=\"line\">     */</div><div class=\"line\">    protected final HttpClient mClient;</div><div class=\"line\"></div><div class=\"line\">    //Http请求头里面的固定格式</div><div class=\"line\">    private final static String HEADER_CONTENT_TYPE = &quot;Content-Type&quot;;</div><div class=\"line\"></div><div class=\"line\">    public HttpClientStack(HttpClient client) &#123;</div><div class=\"line\">        mClient = client;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    //在组合出一个请求的过程中，向请求体中添加Header的方法，Header是以键值对的形式存在的</div><div class=\"line\">    private static void addHeaders(HttpUriRequest httpRequest, Map&lt;String, String&gt; headers) &#123;</div><div class=\"line\">        for (String key : headers.keySet()) &#123;</div><div class=\"line\">            httpRequest.setHeader(key, headers.get(key));</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * NameValuePair 官方文档</div><div class=\"line\">     * A simple class encapsulating an attribute/value pair. </div><div class=\"line\">     * </div><div class=\"line\">     * 该函数将传入的Map里面存放的值进一步转化成由NameValuePair子类组成的数组中</div><div class=\"line\">     */</div><div class=\"line\">    @SuppressWarnings(&quot;unused&quot;)</div><div class=\"line\">    private static List&lt;NameValuePair&gt; getPostParameterPairs(Map&lt;String, String&gt; postParams) &#123;</div><div class=\"line\">        List&lt;NameValuePair&gt; result = new ArrayList&lt;NameValuePair&gt;(postParams.size());</div><div class=\"line\">        for (String key : postParams.keySet()) &#123;</div><div class=\"line\">            result.add(new BasicNameValuePair(key, postParams.get(key)));</div><div class=\"line\">        &#125;</div><div class=\"line\">        return result;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">     //该函数也就是实现HttpStack接口需要实现的方法，用来执行Request的方法</div><div class=\"line\">    @Override</div><div class=\"line\">    public HttpResponse performRequest(Request&lt;?&gt; request, Map&lt;String, String&gt; additionalHeaders)</div><div class=\"line\">            throws IOException, AuthFailureError &#123;</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * 传入请求体和额外需要添加入的头部</div><div class=\"line\">         * 生成并返回一个HttpUriRequest</div><div class=\"line\">         */</div><div class=\"line\">        HttpUriRequest httpRequest = createHttpRequest(request, additionalHeaders);</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * 这个方法在前面实现了，将这些传入的键值对全部添加到httpRequest里面去</div><div class=\"line\">         */</div><div class=\"line\">        addHeaders(httpRequest, additionalHeaders);</div><div class=\"line\">        addHeaders(httpRequest, request.getHeaders());</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * 一个protected方法，留给子类可以实现的方法(本类中并没有什么东西)，在这里会调用。</div><div class=\"line\">         */</div><div class=\"line\">        onPrepareRequest(httpRequest);</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * HttpParams 官方文档</div><div class=\"line\">         * Represents a collection of HTTP protocol and framework parameters. </div><div class=\"line\">         * 说白了就是Http协议和框架的相关参数</div><div class=\"line\">         */</div><div class=\"line\">        HttpParams httpParams = httpRequest.getParams();</div><div class=\"line\">        int timeoutMs = request.getTimeoutMs();</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * HttpConnectionParams 官方文档</div><div class=\"line\">         * An adaptor for accessing connection parameters in HttpParams. </div><div class=\"line\">         * 一个用来访问请求参数的适配器</div><div class=\"line\">         * Note that the implements relation to CoreConnectionPNames is for compatibility with existing application code only. </div><div class=\"line\">         * References to the parameter names should use the interface, not this class. </div><div class=\"line\">         */</div><div class=\"line\"></div><div class=\"line\">        /* Sets the timeout until a connection is established.</div><div class=\"line\">         * 该方法用来设置时间限制，</div><div class=\"line\">         * A value of zero means the timeout is not used. The default value is zero. </div><div class=\"line\">         * 如果timeout设置为0则表示该限时没有启用，默认为0</div><div class=\"line\">         */</div><div class=\"line\">        HttpConnectionParams.setConnectionTimeout(httpParams, 5000);</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * Sets the default socket timeout (SO_TIMEOUT) in milliseconds which is the timeout for waiting for data. </div><div class=\"line\">         * 设置请求发出后等待网络响应并返回数据的限时</div><div class=\"line\">         * A timeout value of zero is interpreted as an infinite timeout. </div><div class=\"line\">         * 如果timeout值为0则意味着无限等待，没有等待限时，同时也是默认的值</div><div class=\"line\">         * This value is used when no socket timeout is set in the method parameters. </div><div class=\"line\">         */</div><div class=\"line\">        HttpConnectionParams.setSoTimeout(httpParams, timeoutMs);</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * 执行了HttpClient类中的execute方法</div><div class=\"line\">         * 方法描述为 Executes a request using the default context.</div><div class=\"line\">         * 方法结束后将返回一个HttpResponse，也就是请求的结果类</div><div class=\"line\">         */ </div><div class=\"line\">        return mClient.execute(httpRequest);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Creates the appropriate subclass of HttpUriRequest for passed in request.</div><div class=\"line\">     * 根据传入的Request种类不同</div><div class=\"line\">     * 创建不同的HttpUriRequest子类(也就是下面的HttpGet等等)</div><div class=\"line\">     * 下面做的工作和HurlStack.java里面做的工作差不多</div><div class=\"line\">     * 设置header,以及是否需要传入请求携带的参数</div><div class=\"line\">     * 只是本类中用HttpClient实现，后者用的是HttpURLConnection实现的</div><div class=\"line\">     */</div><div class=\"line\">    @SuppressWarnings(&quot;deprecation&quot;)</div><div class=\"line\">    /* protected */ static HttpUriRequest createHttpRequest(Request&lt;?&gt; request,</div><div class=\"line\">            Map&lt;String, String&gt; additionalHeaders) throws AuthFailureError &#123;</div><div class=\"line\">        switch (request.getMethod()) &#123;</div><div class=\"line\">            case Method.DEPRECATED_GET_OR_POST: &#123;</div><div class=\"line\">                // This is the deprecated way that needs to be handled for backwards compatibility.</div><div class=\"line\">                // If the request&apos;s post body is null, then the assumption is that the request is</div><div class=\"line\">                // GET.  Otherwise, it is assumed that the request is a POST.</div><div class=\"line\">                byte[] postBody = request.getPostBody();</div><div class=\"line\">                if (postBody != null) &#123;</div><div class=\"line\">                    HttpPost postRequest = new HttpPost(request.getUrl());</div><div class=\"line\">                    postRequest.addHeader(HEADER_CONTENT_TYPE, request.getPostBodyContentType());</div><div class=\"line\">                    HttpEntity entity;</div><div class=\"line\">                    entity = new ByteArrayEntity(postBody);</div><div class=\"line\">                    postRequest.setEntity(entity);</div><div class=\"line\">                    return postRequest;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    return new HttpGet(request.getUrl());</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            case Method.GET:</div><div class=\"line\">                return new HttpGet(request.getUrl());</div><div class=\"line\">            case Method.DELETE:</div><div class=\"line\">                return new HttpDelete(request.getUrl());</div><div class=\"line\">            case Method.POST: &#123;</div><div class=\"line\">                HttpPost postRequest = new HttpPost(request.getUrl());</div><div class=\"line\">                postRequest.addHeader(HEADER_CONTENT_TYPE, request.getBodyContentType());</div><div class=\"line\">                setEntityIfNonEmptyBody(postRequest, request);</div><div class=\"line\">                return postRequest;</div><div class=\"line\">            &#125;</div><div class=\"line\">            case Method.PUT: &#123;</div><div class=\"line\">                HttpPut putRequest = new HttpPut(request.getUrl());</div><div class=\"line\">                putRequest.addHeader(HEADER_CONTENT_TYPE, request.getBodyContentType());</div><div class=\"line\">                setEntityIfNonEmptyBody(putRequest, request);</div><div class=\"line\">                return putRequest;</div><div class=\"line\">            &#125;</div><div class=\"line\">            case Method.HEAD:</div><div class=\"line\">                return new HttpHead(request.getUrl());</div><div class=\"line\">            case Method.OPTIONS:</div><div class=\"line\">                return new HttpOptions(request.getUrl());</div><div class=\"line\">            case Method.TRACE:</div><div class=\"line\">                return new HttpTrace(request.getUrl());</div><div class=\"line\">            case Method.PATCH: &#123;</div><div class=\"line\">                HttpPatch patchRequest = new HttpPatch(request.getUrl());</div><div class=\"line\">                patchRequest.addHeader(HEADER_CONTENT_TYPE, request.getBodyContentType());</div><div class=\"line\">                setEntityIfNonEmptyBody(patchRequest, request);</div><div class=\"line\">                return patchRequest;</div><div class=\"line\">            &#125;</div><div class=\"line\">            default:</div><div class=\"line\">                throw new IllegalStateException(&quot;Unknown request method.&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    private static void setEntityIfNonEmptyBody(HttpEntityEnclosingRequestBase httpRequest,</div><div class=\"line\">            Request&lt;?&gt; request) throws AuthFailureError &#123;</div><div class=\"line\">        byte[] body = request.getBody();</div><div class=\"line\">        if (body != null) &#123;</div><div class=\"line\">            HttpEntity entity = new ByteArrayEntity(body);</div><div class=\"line\">            httpRequest.setEntity(entity);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Called before the request is executed using the underlying HttpClient.</div><div class=\"line\">     *</div><div class=\"line\">     * &lt;p&gt;Overwrite in subclasses to augment the request.&lt;/p&gt;</div><div class=\"line\">     */</div><div class=\"line\">    protected void onPrepareRequest(HttpUriRequest request) throws IOException &#123;</div><div class=\"line\">        // Nothing.</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * The HttpPatch class does not exist in the Android framework, so this has been defined here.</div><div class=\"line\">     * = =在HttpUriClient的子类中没有支持Patch的请求方法</div><div class=\"line\">     * 在这里volley实现了= =</div><div class=\"line\">     */</div><div class=\"line\">    public static final class HttpPatch extends HttpEntityEnclosingRequestBase &#123;</div><div class=\"line\"></div><div class=\"line\">        public final static String METHOD_NAME = &quot;PATCH&quot;;</div><div class=\"line\"></div><div class=\"line\">        public HttpPatch() &#123;</div><div class=\"line\">            super();</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        public HttpPatch(final URI uri) &#123;</div><div class=\"line\">            super();</div><div class=\"line\">            setURI(uri);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * @throws IllegalArgumentException if the uri is invalid.</div><div class=\"line\">         */</div><div class=\"line\">        public HttpPatch(final String uri) &#123;</div><div class=\"line\">            super();</div><div class=\"line\">            setURI(URI.create(uri));</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        @Override</div><div class=\"line\">        public String getMethod() &#123;</div><div class=\"line\">            return METHOD_NAME;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"4-HurlStack-java\"><a href=\"#4-HurlStack-java\" class=\"headerlink\" title=\"4.HurlStack.java\"></a><a href=\"#4-HurlStack-java\" title=\"4.HurlStack.java\"></a>4.HurlStack.java</h3><p>在sdk大于2.3的android手机上，Volley选择用HttpURLConnection来实现网络请求。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div><div class=\"line\">204</div><div class=\"line\">205</div><div class=\"line\">206</div><div class=\"line\">207</div><div class=\"line\">208</div><div class=\"line\">209</div><div class=\"line\">210</div><div class=\"line\">211</div><div class=\"line\">212</div><div class=\"line\">213</div><div class=\"line\">214</div><div class=\"line\">215</div><div class=\"line\">216</div><div class=\"line\">217</div><div class=\"line\">218</div><div class=\"line\">219</div><div class=\"line\">220</div><div class=\"line\">221</div><div class=\"line\">222</div><div class=\"line\">223</div><div class=\"line\">224</div><div class=\"line\">225</div><div class=\"line\">226</div><div class=\"line\">227</div><div class=\"line\">228</div><div class=\"line\">229</div><div class=\"line\">230</div><div class=\"line\">231</div><div class=\"line\">232</div><div class=\"line\">233</div><div class=\"line\">234</div><div class=\"line\">235</div><div class=\"line\">236</div><div class=\"line\">237</div><div class=\"line\">238</div><div class=\"line\">239</div><div class=\"line\">240</div><div class=\"line\">241</div><div class=\"line\">242</div><div class=\"line\">243</div><div class=\"line\">244</div><div class=\"line\">245</div><div class=\"line\">246</div><div class=\"line\">247</div><div class=\"line\">248</div><div class=\"line\">249</div><div class=\"line\">250</div><div class=\"line\">251</div><div class=\"line\">252</div><div class=\"line\">253</div><div class=\"line\">254</div><div class=\"line\">255</div><div class=\"line\">256</div><div class=\"line\">257</div><div class=\"line\">258</div><div class=\"line\">259</div><div class=\"line\">260</div><div class=\"line\">261</div><div class=\"line\">262</div><div class=\"line\">263</div><div class=\"line\">264</div><div class=\"line\">265</div><div class=\"line\">266</div><div class=\"line\">267</div><div class=\"line\">268</div><div class=\"line\">269</div><div class=\"line\">270</div><div class=\"line\">271</div><div class=\"line\">272</div><div class=\"line\">273</div><div class=\"line\">274</div><div class=\"line\">275</div><div class=\"line\">276</div><div class=\"line\">277</div><div class=\"line\">278</div><div class=\"line\">279</div><div class=\"line\">280</div><div class=\"line\">281</div><div class=\"line\">282</div><div class=\"line\">283</div><div class=\"line\">284</div><div class=\"line\">285</div><div class=\"line\">286</div><div class=\"line\">287</div><div class=\"line\">288</div><div class=\"line\">289</div><div class=\"line\">290</div><div class=\"line\">291</div><div class=\"line\">292</div><div class=\"line\">293</div><div class=\"line\">294</div><div class=\"line\">295</div><div class=\"line\">296</div><div class=\"line\">297</div><div class=\"line\">298</div><div class=\"line\">299</div><div class=\"line\">300</div><div class=\"line\">301</div><div class=\"line\">302</div><div class=\"line\">303</div><div class=\"line\">304</div><div class=\"line\">305</div><div class=\"line\">306</div><div class=\"line\">307</div><div class=\"line\">308</div><div class=\"line\">309</div><div class=\"line\">310</div><div class=\"line\">311</div><div class=\"line\">312</div><div class=\"line\">313</div><div class=\"line\">314</div><div class=\"line\">315</div><div class=\"line\">316</div><div class=\"line\">317</div><div class=\"line\">318</div><div class=\"line\">319</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * An &#123;@link HttpStack&#125; based on &#123;@link HttpURLConnection&#125;.</div><div class=\"line\"> */</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\"> * 当os version 版本在2.3以上，也就是sdk &gt;= 9 的时候</div><div class=\"line\"> * 选用这个接口作为HttpStack， 用到了HttpURLConnection</div><div class=\"line\"> * 关于HttpURLConnection,官方解释为：</div><div class=\"line\"> * An URLConnection for HTTP (RFC 2616) used to send and receive data over the web.</div><div class=\"line\"> * Data may be of any type and length. </div><div class=\"line\"> * This class may be used to send and receive streaming data whose length is not known in advance.</div><div class=\"line\"> * 用来发送和接受数据，数据可以为任意的形式及长度</div><div class=\"line\"> * 这个类常用来发送和接受数据流里面长度不定的数据.</div><div class=\"line\"> */</div><div class=\"line\">public class HurlStack implements HttpStack &#123;</div><div class=\"line\"></div><div class=\"line\">    /*</div><div class=\"line\">     * 请求header中的一个关键字</div><div class=\"line\">     * content-type代表着被发送的请求中主体内容</div><div class=\"line\">     * 可以设置application/json等格式</div><div class=\"line\">     */</div><div class=\"line\">    private static final String HEADER_CONTENT_TYPE = &quot;Content-Type&quot;;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * An interface for transforming URLs before use.</div><div class=\"line\">     * 一个用来在使用url之前，将url处理的接口工具</div><div class=\"line\">     * 可能是用来规范url格式的一个工具= =</div><div class=\"line\">     */ </div><div class=\"line\">    public interface UrlRewriter &#123;</div><div class=\"line\">        /**</div><div class=\"line\">         * Returns a URL to use instead of the provided one, or null to indicate</div><div class=\"line\">         * this URL should not be used at all.</div><div class=\"line\">         */</div><div class=\"line\">        public String rewriteUrl(String originalUrl);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    private final UrlRewriter mUrlRewriter;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * The abstract factory implementation to create SSLSockets.</div><div class=\"line\">     * 是一个抽象工厂类，用来创建SSLSockets（还是不懂是个什么鬼</div><div class=\"line\">     * </div><div class=\"line\">     * 对于SSLSocket，官方的解释是这样的：</div><div class=\"line\">     * The extension of Socket providing secure protocols like SSL (Secure Sockets Layer) or TLS (Transport Layer Security).</div><div class=\"line\">     * 是Socket的子类，并在之基础上新增了类似于SSL或者TLS等等的安全协议.</div><div class=\"line\">     */</div><div class=\"line\">    private final SSLSocketFactory mSslSocketFactory;</div><div class=\"line\"></div><div class=\"line\">    public HurlStack() &#123;</div><div class=\"line\">        this(null);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * @param urlRewriter Rewriter to use for request URLs</div><div class=\"line\">     */</div><div class=\"line\">    public HurlStack(UrlRewriter urlRewriter) &#123;</div><div class=\"line\">        this(urlRewriter, null);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * @param urlRewriter Rewriter to use for request URLs</div><div class=\"line\">     * @param sslSocketFactory SSL factory to use for HTTPS connections</div><div class=\"line\">     */</div><div class=\"line\">    public HurlStack(UrlRewriter urlRewriter, SSLSocketFactory sslSocketFactory) &#123;</div><div class=\"line\">        mUrlRewriter = urlRewriter;</div><div class=\"line\">        mSslSocketFactory = sslSocketFactory;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * 该函数为HttpStack的接口</div><div class=\"line\">     */</div><div class=\"line\">    @Override</div><div class=\"line\">    public HttpResponse performRequest(Request&lt;?&gt; request, Map&lt;String, String&gt; additionalHeaders)</div><div class=\"line\">            throws IOException, AuthFailureError &#123;</div><div class=\"line\">        /**</div><div class=\"line\">         * 得到请求的url</div><div class=\"line\">         */</div><div class=\"line\">        String url = request.getUrl();</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * 创建一个新的HashMap</div><div class=\"line\">         * 用来存放请求的header的信息</div><div class=\"line\">         */</div><div class=\"line\">        HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * 将原request(volley自己封装的一个request类)中的header</div><div class=\"line\">         * 和另外需要添加入header的信息都整合起来</div><div class=\"line\">         */</div><div class=\"line\">        map.putAll(request.getHeaders());</div><div class=\"line\">        map.putAll(additionalHeaders);</div><div class=\"line\"></div><div class=\"line\">        if (mUrlRewriter != null) &#123;</div><div class=\"line\">            String rewritten = mUrlRewriter.rewriteUrl(url);</div><div class=\"line\">            if (rewritten == null) &#123;</div><div class=\"line\">                throw new IOException(&quot;URL blocked by rewriter: &quot; + url);</div><div class=\"line\">            &#125;</div><div class=\"line\">            url = rewritten;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * 将url字符串形式规范成一个URL的类对象</div><div class=\"line\">         */</div><div class=\"line\">        URL parsedUrl = new URL(url);</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * HurlStack类是在sdk&gt;=2.3的android版本上使用的</div><div class=\"line\">         * 这里面用到了HttpURLConnection类</div><div class=\"line\">         * 在函数里面打开了并返回了一个HttpURLConnection</div><div class=\"line\">         * 设置了HttpURLConnection的响应超时阀值</div><div class=\"line\">         */</div><div class=\"line\">        HttpURLConnection connection = openConnection(parsedUrl, request);</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * 开始给HttpURLConnection添加header的信息</div><div class=\"line\">         * 用addRequestProperty()函数将header以键值对的形式填入</div><div class=\"line\">         */</div><div class=\"line\">        for (String headerName : map.keySet()) &#123;</div><div class=\"line\">            connection.addRequestProperty(headerName, map.get(headerName));</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * 根据request种类的不同</div><div class=\"line\">         * 分别用不同的方式来处理其中的参数</div><div class=\"line\">         */</div><div class=\"line\">        setConnectionParametersForRequest(connection, request);</div><div class=\"line\"></div><div class=\"line\">        // Initialize HttpResponse with data from the HttpURLConnection.</div><div class=\"line\">        ProtocolVersion protocolVersion = new ProtocolVersion(&quot;HTTP&quot;, 1, 1);</div><div class=\"line\"></div><div class=\"line\">        int responseCode = connection.getResponseCode();</div><div class=\"line\">        if (responseCode == -1) &#123;</div><div class=\"line\">            // -1 is returned by getResponseCode() if the response code could not be retrieved.</div><div class=\"line\">            // Signal to the caller that something was wrong with the connection.</div><div class=\"line\">            throw new IOException(&quot;Could not retrieve response code from HttpUrlConnection.&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        StatusLine responseStatus = new BasicStatusLine(protocolVersion,</div><div class=\"line\">                connection.getResponseCode(), connection.getResponseMessage());</div><div class=\"line\"></div><div class=\"line\">        BasicHttpResponse response = new BasicHttpResponse(responseStatus);</div><div class=\"line\"></div><div class=\"line\">        response.setEntity(entityFromConnection(connection));</div><div class=\"line\"></div><div class=\"line\">        for (Entry&lt;String, List&lt;String&gt;&gt; header : connection.getHeaderFields().entrySet()) &#123;</div><div class=\"line\">            if (header.getKey() != null) &#123;</div><div class=\"line\">                Header h = new BasicHeader(header.getKey(), header.getValue().get(0));</div><div class=\"line\">                response.addHeader(h);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return response;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Initializes an &#123;@link HttpEntity&#125; from the given &#123;@link HttpURLConnection&#125;.</div><div class=\"line\">     * @param connection</div><div class=\"line\">     * @return an HttpEntity populated with data from &lt;code&gt;connection&lt;/code&gt;.</div><div class=\"line\">     */</div><div class=\"line\">    private static HttpEntity entityFromConnection(HttpURLConnection connection) &#123;</div><div class=\"line\">        BasicHttpEntity entity = new BasicHttpEntity();</div><div class=\"line\">        InputStream inputStream;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            inputStream = connection.getInputStream();</div><div class=\"line\">        &#125; catch (IOException ioe) &#123;</div><div class=\"line\">            inputStream = connection.getErrorStream();</div><div class=\"line\">        &#125;</div><div class=\"line\">        entity.setContent(inputStream);</div><div class=\"line\">        entity.setContentLength(connection.getContentLength());</div><div class=\"line\">        entity.setContentEncoding(connection.getContentEncoding());</div><div class=\"line\">        entity.setContentType(connection.getContentType());</div><div class=\"line\">        return entity;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Create an &#123;@link HttpURLConnection&#125; for the specified &#123;@code url&#125;.</div><div class=\"line\">     */</div><div class=\"line\">    protected HttpURLConnection createConnection(URL url) throws IOException &#123;</div><div class=\"line\"></div><div class=\"line\">        return (HttpURLConnection) url.openConnection();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Opens an &#123;@link HttpURLConnection&#125; with parameters.</div><div class=\"line\">     * 通过给的url和参数，打开一个HttpURLConnection</div><div class=\"line\">     * @param url</div><div class=\"line\">     * @return an open connection</div><div class=\"line\">     * @throws IOException</div><div class=\"line\">     */</div><div class=\"line\">    private HttpURLConnection openConnection(URL url, Request&lt;?&gt; request) throws IOException &#123;</div><div class=\"line\"></div><div class=\"line\">        HttpURLConnection connection = createConnection(url);</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * 通过Request.java中的函数</div><div class=\"line\">         * 获取到该request上所设置的服务器最大响应时间阀值</div><div class=\"line\">         * 该阀值默认是2500ms，而且可能会随着retry的次数而增大</div><div class=\"line\">         */</div><div class=\"line\">        int timeoutMs = request.getTimeoutMs();</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * 给connection设置上请求超时时间</div><div class=\"line\">         */</div><div class=\"line\">        connection.setConnectTimeout(timeoutMs);</div><div class=\"line\">        connection.setReadTimeout(timeoutMs);</div><div class=\"line\">        connection.setUseCaches(false);</div><div class=\"line\">        connection.setDoInput(true);</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * use caller-provided custom SslSocketFactory, if any, for HTTPS</div><div class=\"line\">         * 请求方面的安全问题，暂时还不清清楚</div><div class=\"line\">         */</div><div class=\"line\">        if (&quot;https&quot;.equals(url.getProtocol()) &amp;&amp; mSslSocketFactory != null) &#123;</div><div class=\"line\">            ((HttpsURLConnection)connection).setSSLSocketFactory(mSslSocketFactory);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        return connection;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @SuppressWarnings(&quot;deprecation&quot;)</div><div class=\"line\">    /* package */</div><div class=\"line\">    /**</div><div class=\"line\">     * switch不同的请求方法</div><div class=\"line\">     * 来以不同的方式给HttpURLConnection添加请求参数</div><div class=\"line\">     */ </div><div class=\"line\">    static void setConnectionParametersForRequest(HttpURLConnection connection,</div><div class=\"line\">            Request&lt;?&gt; request) throws IOException, AuthFailureError &#123;</div><div class=\"line\">        switch (request.getMethod()) &#123;</div><div class=\"line\"></div><div class=\"line\">            /**</div><div class=\"line\">             * 在构造Request的时候如果没有指明请求方式</div><div class=\"line\">             * DEPRECATED_GET_OR_POST为其默认值</div><div class=\"line\">             * 通过postBody是否为Null来区别POST和GET</div><div class=\"line\">             * 这两种最常用的请求方式</div><div class=\"line\">             */</div><div class=\"line\">            case Method.DEPRECATED_GET_OR_POST:</div><div class=\"line\">                // This is the deprecated way that needs to be handled for backwards compatibility.</div><div class=\"line\">                // If the request&apos;s post body is null, then the assumption is that the request is</div><div class=\"line\">                // GET.  Otherwise, it is assumed that the request is a POST.</div><div class=\"line\">                /**</div><div class=\"line\">                 * 不要用这个参数了= =，因为不能处理什么DELETE之类的</div><div class=\"line\">                 * 该方法已经过时了。</div><div class=\"line\">                 */</div><div class=\"line\">                byte[] postBody = request.getPostBody();</div><div class=\"line\">                if (postBody != null) &#123;</div><div class=\"line\">                    // Prepare output. There is no need to set Content-Length explicitly,</div><div class=\"line\">                    // since this is handled by HttpURLConnection using the size of the prepared</div><div class=\"line\">                    // output stream.</div><div class=\"line\"></div><div class=\"line\">                    /**</div><div class=\"line\">                     * 设置是否输出</div><div class=\"line\">                     */</div><div class=\"line\">                    connection.setDoOutput(true);</div><div class=\"line\"></div><div class=\"line\">                    /**</div><div class=\"line\">                     * 给connection设置请求的方式</div><div class=\"line\">                     */</div><div class=\"line\">                    connection.setRequestMethod(&quot;POST&quot;);</div><div class=\"line\"></div><div class=\"line\">                    /**</div><div class=\"line\">                     * 设置http请求头中的content-type参数</div><div class=\"line\">                     */</div><div class=\"line\">                    connection.addRequestProperty(HEADER_CONTENT_TYPE,</div><div class=\"line\">                            request.getPostBodyContentType());</div><div class=\"line\">                    DataOutputStream out = new DataOutputStream(connection.getOutputStream());</div><div class=\"line\">                    out.write(0);</div><div class=\"line\">                    out.close();</div><div class=\"line\">                &#125;</div><div class=\"line\">                break;</div><div class=\"line\">            case Method.GET:</div><div class=\"line\">                // Not necessary to set the request method because connection defaults to GET but</div><div class=\"line\">                // being explicit here.</div><div class=\"line\">                connection.setRequestMethod(&quot;GET&quot;);</div><div class=\"line\">                break;</div><div class=\"line\">            case Method.DELETE:</div><div class=\"line\">                connection.setRequestMethod(&quot;DELETE&quot;);</div><div class=\"line\">                break;</div><div class=\"line\">            case Method.POST:</div><div class=\"line\">                connection.setRequestMethod(&quot;POST&quot;);</div><div class=\"line\">                addBodyIfExists(connection, request);</div><div class=\"line\">                break;</div><div class=\"line\">            case Method.PUT:</div><div class=\"line\">                connection.setRequestMethod(&quot;PUT&quot;);</div><div class=\"line\">                addBodyIfExists(connection, request);</div><div class=\"line\">                break;</div><div class=\"line\">            case Method.HEAD:</div><div class=\"line\">                connection.setRequestMethod(&quot;HEAD&quot;);</div><div class=\"line\">                break;</div><div class=\"line\">            case Method.OPTIONS:</div><div class=\"line\">                connection.setRequestMethod(&quot;OPTIONS&quot;);</div><div class=\"line\">                break;</div><div class=\"line\">            case Method.TRACE:</div><div class=\"line\">                connection.setRequestMethod(&quot;TRACE&quot;);</div><div class=\"line\">                break;</div><div class=\"line\">            case Method.PATCH:</div><div class=\"line\">                connection.setRequestMethod(&quot;PATCH&quot;);</div><div class=\"line\">                addBodyIfExists(connection, request);</div><div class=\"line\">                break;</div><div class=\"line\">            default:</div><div class=\"line\">                throw new IllegalStateException(&quot;Unknown method type.&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * 如果存在请求参数的话</div><div class=\"line\">     * 获取到connection的输出流对象</div><div class=\"line\">     * 并创建一个DataOutputStream对象</div><div class=\"line\">     * 用于向服务器写入需要传递的参数</div><div class=\"line\">     */</div><div class=\"line\">    private static void addBodyIfExists(HttpURLConnection connection, Request&lt;?&gt; request)</div><div class=\"line\">            throws IOException, AuthFailureError &#123;</div><div class=\"line\">        byte[] body = request.getBody();</div><div class=\"line\">        if (body != null) &#123;</div><div class=\"line\">            connection.setDoOutput(true);</div><div class=\"line\">            connection.addRequestProperty(HEADER_CONTENT_TYPE, request.getBodyContentType());</div><div class=\"line\">            DataOutputStream out = new DataOutputStream(connection.getOutputStream());</div><div class=\"line\">            out.write(body);</div><div class=\"line\">            out.close();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h3><p>前面都在做一些准备工作，以及对request队列调度以及维护工作。之前提到，<code>httpResponse = mHttpStack.performRequest(request, headers);</code>这句话是网络请求的核心</p>\n<h3 id=\"2-HttpStack-java\"><a href=\"#2-HttpStack-java\" class=\"headerlink\" title=\"2. HttpStack.java\"></a>2. HttpStack.java</h3><p>接口类，里面包含了一个方法，<code>performRequest()</code>。</p>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * An HTTP stack abstraction.</div><div class=\"line\"> */</div><div class=\"line\">public interface HttpStack &#123;</div><div class=\"line\">    /**</div><div class=\"line\">     * Performs an HTTP request with the given parameters.</div><div class=\"line\">     * 用传入给定的参数来模拟Http请求</div><div class=\"line\">     * </div><div class=\"line\">     * A GET request is sent if request.getPostBody() == null. A POST request is sent otherwise,</div><div class=\"line\">     * and the Content-Type header is set to request.getPostBodyContentType().</div><div class=\"line\">     * 如果传入的request.getPostBody()为空，则发送一个Get类型的请求，否则发送一个Post类型请求</div><div class=\"line\">     * </div><div class=\"line\">     * @param request the request to perform</div><div class=\"line\">     * 即将发送的初始请求，也是volley自己写的= =，进去看看</div><div class=\"line\">     * (还需要添加上额外的header</div><div class=\"line\">     * </div><div class=\"line\">     * @param additionalHeaders additional headers to be sent together with</div><div class=\"line\">     *         &#123;@link Request#getHeaders()&#125;</div><div class=\"line\">     * 需要添加到该request上的header的信息</div><div class=\"line\">     *</div><div class=\"line\">     * @return the HTTP response</div><div class=\"line\">     *</div><div class=\"line\">     */</div><div class=\"line\">    public HttpResponse performRequest(Request&lt;?&gt; request, Map&lt;String, String&gt; additionalHeaders)</div><div class=\"line\">        throws IOException, AuthFailureError;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"3-HttpClientStack-java\"><a href=\"#3-HttpClientStack-java\" class=\"headerlink\" title=\"3. HttpClientStack.java\"></a><a href=\"#3-_HttpClientStack-java\" title=\"3\\. HttpClientStack.java\"></a>3. HttpClientStack.java</h3><p>当sdk版本小于2.3时，Volley会选择用HttpClient来实现请求的发送。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div><div class=\"line\">204</div><div class=\"line\">205</div><div class=\"line\">206</div><div class=\"line\">207</div><div class=\"line\">208</div><div class=\"line\">209</div><div class=\"line\">210</div><div class=\"line\">211</div><div class=\"line\">212</div><div class=\"line\">213</div><div class=\"line\">214</div><div class=\"line\">215</div><div class=\"line\">216</div><div class=\"line\">217</div><div class=\"line\">218</div><div class=\"line\">219</div><div class=\"line\">220</div><div class=\"line\">221</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * An HttpStack that performs request over an &#123;@link HttpClient&#125;.</div><div class=\"line\"> * 在sdk小于2.3的时候</div><div class=\"line\"> * 选用HttpClient来实现网络请求</div><div class=\"line\"> */</div><div class=\"line\">public class HttpClientStack implements HttpStack &#123;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * 官方文档</div><div class=\"line\">     * Interface for an HTTP client. </div><div class=\"line\">     * HTTP clients encapsulate a smorgasbord of objects required to execute HTTP requests while handling cookies, </div><div class=\"line\">     * authentication, connection management, and other features. </div><div class=\"line\">     * HTTP Clients将发送http请求需要需要做出的信息</div><div class=\"line\">     * Thread safety of HTTP clients depends on the implementation and configuration of the specific client. </div><div class=\"line\">     * </div><div class=\"line\">     */</div><div class=\"line\">    protected final HttpClient mClient;</div><div class=\"line\"></div><div class=\"line\">    //Http请求头里面的固定格式</div><div class=\"line\">    private final static String HEADER_CONTENT_TYPE = &quot;Content-Type&quot;;</div><div class=\"line\"></div><div class=\"line\">    public HttpClientStack(HttpClient client) &#123;</div><div class=\"line\">        mClient = client;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    //在组合出一个请求的过程中，向请求体中添加Header的方法，Header是以键值对的形式存在的</div><div class=\"line\">    private static void addHeaders(HttpUriRequest httpRequest, Map&lt;String, String&gt; headers) &#123;</div><div class=\"line\">        for (String key : headers.keySet()) &#123;</div><div class=\"line\">            httpRequest.setHeader(key, headers.get(key));</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * NameValuePair 官方文档</div><div class=\"line\">     * A simple class encapsulating an attribute/value pair. </div><div class=\"line\">     * </div><div class=\"line\">     * 该函数将传入的Map里面存放的值进一步转化成由NameValuePair子类组成的数组中</div><div class=\"line\">     */</div><div class=\"line\">    @SuppressWarnings(&quot;unused&quot;)</div><div class=\"line\">    private static List&lt;NameValuePair&gt; getPostParameterPairs(Map&lt;String, String&gt; postParams) &#123;</div><div class=\"line\">        List&lt;NameValuePair&gt; result = new ArrayList&lt;NameValuePair&gt;(postParams.size());</div><div class=\"line\">        for (String key : postParams.keySet()) &#123;</div><div class=\"line\">            result.add(new BasicNameValuePair(key, postParams.get(key)));</div><div class=\"line\">        &#125;</div><div class=\"line\">        return result;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">     //该函数也就是实现HttpStack接口需要实现的方法，用来执行Request的方法</div><div class=\"line\">    @Override</div><div class=\"line\">    public HttpResponse performRequest(Request&lt;?&gt; request, Map&lt;String, String&gt; additionalHeaders)</div><div class=\"line\">            throws IOException, AuthFailureError &#123;</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * 传入请求体和额外需要添加入的头部</div><div class=\"line\">         * 生成并返回一个HttpUriRequest</div><div class=\"line\">         */</div><div class=\"line\">        HttpUriRequest httpRequest = createHttpRequest(request, additionalHeaders);</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * 这个方法在前面实现了，将这些传入的键值对全部添加到httpRequest里面去</div><div class=\"line\">         */</div><div class=\"line\">        addHeaders(httpRequest, additionalHeaders);</div><div class=\"line\">        addHeaders(httpRequest, request.getHeaders());</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * 一个protected方法，留给子类可以实现的方法(本类中并没有什么东西)，在这里会调用。</div><div class=\"line\">         */</div><div class=\"line\">        onPrepareRequest(httpRequest);</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * HttpParams 官方文档</div><div class=\"line\">         * Represents a collection of HTTP protocol and framework parameters. </div><div class=\"line\">         * 说白了就是Http协议和框架的相关参数</div><div class=\"line\">         */</div><div class=\"line\">        HttpParams httpParams = httpRequest.getParams();</div><div class=\"line\">        int timeoutMs = request.getTimeoutMs();</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * HttpConnectionParams 官方文档</div><div class=\"line\">         * An adaptor for accessing connection parameters in HttpParams. </div><div class=\"line\">         * 一个用来访问请求参数的适配器</div><div class=\"line\">         * Note that the implements relation to CoreConnectionPNames is for compatibility with existing application code only. </div><div class=\"line\">         * References to the parameter names should use the interface, not this class. </div><div class=\"line\">         */</div><div class=\"line\"></div><div class=\"line\">        /* Sets the timeout until a connection is established.</div><div class=\"line\">         * 该方法用来设置时间限制，</div><div class=\"line\">         * A value of zero means the timeout is not used. The default value is zero. </div><div class=\"line\">         * 如果timeout设置为0则表示该限时没有启用，默认为0</div><div class=\"line\">         */</div><div class=\"line\">        HttpConnectionParams.setConnectionTimeout(httpParams, 5000);</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * Sets the default socket timeout (SO_TIMEOUT) in milliseconds which is the timeout for waiting for data. </div><div class=\"line\">         * 设置请求发出后等待网络响应并返回数据的限时</div><div class=\"line\">         * A timeout value of zero is interpreted as an infinite timeout. </div><div class=\"line\">         * 如果timeout值为0则意味着无限等待，没有等待限时，同时也是默认的值</div><div class=\"line\">         * This value is used when no socket timeout is set in the method parameters. </div><div class=\"line\">         */</div><div class=\"line\">        HttpConnectionParams.setSoTimeout(httpParams, timeoutMs);</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * 执行了HttpClient类中的execute方法</div><div class=\"line\">         * 方法描述为 Executes a request using the default context.</div><div class=\"line\">         * 方法结束后将返回一个HttpResponse，也就是请求的结果类</div><div class=\"line\">         */ </div><div class=\"line\">        return mClient.execute(httpRequest);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Creates the appropriate subclass of HttpUriRequest for passed in request.</div><div class=\"line\">     * 根据传入的Request种类不同</div><div class=\"line\">     * 创建不同的HttpUriRequest子类(也就是下面的HttpGet等等)</div><div class=\"line\">     * 下面做的工作和HurlStack.java里面做的工作差不多</div><div class=\"line\">     * 设置header,以及是否需要传入请求携带的参数</div><div class=\"line\">     * 只是本类中用HttpClient实现，后者用的是HttpURLConnection实现的</div><div class=\"line\">     */</div><div class=\"line\">    @SuppressWarnings(&quot;deprecation&quot;)</div><div class=\"line\">    /* protected */ static HttpUriRequest createHttpRequest(Request&lt;?&gt; request,</div><div class=\"line\">            Map&lt;String, String&gt; additionalHeaders) throws AuthFailureError &#123;</div><div class=\"line\">        switch (request.getMethod()) &#123;</div><div class=\"line\">            case Method.DEPRECATED_GET_OR_POST: &#123;</div><div class=\"line\">                // This is the deprecated way that needs to be handled for backwards compatibility.</div><div class=\"line\">                // If the request&apos;s post body is null, then the assumption is that the request is</div><div class=\"line\">                // GET.  Otherwise, it is assumed that the request is a POST.</div><div class=\"line\">                byte[] postBody = request.getPostBody();</div><div class=\"line\">                if (postBody != null) &#123;</div><div class=\"line\">                    HttpPost postRequest = new HttpPost(request.getUrl());</div><div class=\"line\">                    postRequest.addHeader(HEADER_CONTENT_TYPE, request.getPostBodyContentType());</div><div class=\"line\">                    HttpEntity entity;</div><div class=\"line\">                    entity = new ByteArrayEntity(postBody);</div><div class=\"line\">                    postRequest.setEntity(entity);</div><div class=\"line\">                    return postRequest;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    return new HttpGet(request.getUrl());</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            case Method.GET:</div><div class=\"line\">                return new HttpGet(request.getUrl());</div><div class=\"line\">            case Method.DELETE:</div><div class=\"line\">                return new HttpDelete(request.getUrl());</div><div class=\"line\">            case Method.POST: &#123;</div><div class=\"line\">                HttpPost postRequest = new HttpPost(request.getUrl());</div><div class=\"line\">                postRequest.addHeader(HEADER_CONTENT_TYPE, request.getBodyContentType());</div><div class=\"line\">                setEntityIfNonEmptyBody(postRequest, request);</div><div class=\"line\">                return postRequest;</div><div class=\"line\">            &#125;</div><div class=\"line\">            case Method.PUT: &#123;</div><div class=\"line\">                HttpPut putRequest = new HttpPut(request.getUrl());</div><div class=\"line\">                putRequest.addHeader(HEADER_CONTENT_TYPE, request.getBodyContentType());</div><div class=\"line\">                setEntityIfNonEmptyBody(putRequest, request);</div><div class=\"line\">                return putRequest;</div><div class=\"line\">            &#125;</div><div class=\"line\">            case Method.HEAD:</div><div class=\"line\">                return new HttpHead(request.getUrl());</div><div class=\"line\">            case Method.OPTIONS:</div><div class=\"line\">                return new HttpOptions(request.getUrl());</div><div class=\"line\">            case Method.TRACE:</div><div class=\"line\">                return new HttpTrace(request.getUrl());</div><div class=\"line\">            case Method.PATCH: &#123;</div><div class=\"line\">                HttpPatch patchRequest = new HttpPatch(request.getUrl());</div><div class=\"line\">                patchRequest.addHeader(HEADER_CONTENT_TYPE, request.getBodyContentType());</div><div class=\"line\">                setEntityIfNonEmptyBody(patchRequest, request);</div><div class=\"line\">                return patchRequest;</div><div class=\"line\">            &#125;</div><div class=\"line\">            default:</div><div class=\"line\">                throw new IllegalStateException(&quot;Unknown request method.&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    private static void setEntityIfNonEmptyBody(HttpEntityEnclosingRequestBase httpRequest,</div><div class=\"line\">            Request&lt;?&gt; request) throws AuthFailureError &#123;</div><div class=\"line\">        byte[] body = request.getBody();</div><div class=\"line\">        if (body != null) &#123;</div><div class=\"line\">            HttpEntity entity = new ByteArrayEntity(body);</div><div class=\"line\">            httpRequest.setEntity(entity);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Called before the request is executed using the underlying HttpClient.</div><div class=\"line\">     *</div><div class=\"line\">     * &lt;p&gt;Overwrite in subclasses to augment the request.&lt;/p&gt;</div><div class=\"line\">     */</div><div class=\"line\">    protected void onPrepareRequest(HttpUriRequest request) throws IOException &#123;</div><div class=\"line\">        // Nothing.</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * The HttpPatch class does not exist in the Android framework, so this has been defined here.</div><div class=\"line\">     * = =在HttpUriClient的子类中没有支持Patch的请求方法</div><div class=\"line\">     * 在这里volley实现了= =</div><div class=\"line\">     */</div><div class=\"line\">    public static final class HttpPatch extends HttpEntityEnclosingRequestBase &#123;</div><div class=\"line\"></div><div class=\"line\">        public final static String METHOD_NAME = &quot;PATCH&quot;;</div><div class=\"line\"></div><div class=\"line\">        public HttpPatch() &#123;</div><div class=\"line\">            super();</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        public HttpPatch(final URI uri) &#123;</div><div class=\"line\">            super();</div><div class=\"line\">            setURI(uri);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * @throws IllegalArgumentException if the uri is invalid.</div><div class=\"line\">         */</div><div class=\"line\">        public HttpPatch(final String uri) &#123;</div><div class=\"line\">            super();</div><div class=\"line\">            setURI(URI.create(uri));</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        @Override</div><div class=\"line\">        public String getMethod() &#123;</div><div class=\"line\">            return METHOD_NAME;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"4-HurlStack-java\"><a href=\"#4-HurlStack-java\" class=\"headerlink\" title=\"4.HurlStack.java\"></a><a href=\"#4-HurlStack-java\" title=\"4.HurlStack.java\"></a>4.HurlStack.java</h3><p>在sdk大于2.3的android手机上，Volley选择用HttpURLConnection来实现网络请求。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div><div class=\"line\">204</div><div class=\"line\">205</div><div class=\"line\">206</div><div class=\"line\">207</div><div class=\"line\">208</div><div class=\"line\">209</div><div class=\"line\">210</div><div class=\"line\">211</div><div class=\"line\">212</div><div class=\"line\">213</div><div class=\"line\">214</div><div class=\"line\">215</div><div class=\"line\">216</div><div class=\"line\">217</div><div class=\"line\">218</div><div class=\"line\">219</div><div class=\"line\">220</div><div class=\"line\">221</div><div class=\"line\">222</div><div class=\"line\">223</div><div class=\"line\">224</div><div class=\"line\">225</div><div class=\"line\">226</div><div class=\"line\">227</div><div class=\"line\">228</div><div class=\"line\">229</div><div class=\"line\">230</div><div class=\"line\">231</div><div class=\"line\">232</div><div class=\"line\">233</div><div class=\"line\">234</div><div class=\"line\">235</div><div class=\"line\">236</div><div class=\"line\">237</div><div class=\"line\">238</div><div class=\"line\">239</div><div class=\"line\">240</div><div class=\"line\">241</div><div class=\"line\">242</div><div class=\"line\">243</div><div class=\"line\">244</div><div class=\"line\">245</div><div class=\"line\">246</div><div class=\"line\">247</div><div class=\"line\">248</div><div class=\"line\">249</div><div class=\"line\">250</div><div class=\"line\">251</div><div class=\"line\">252</div><div class=\"line\">253</div><div class=\"line\">254</div><div class=\"line\">255</div><div class=\"line\">256</div><div class=\"line\">257</div><div class=\"line\">258</div><div class=\"line\">259</div><div class=\"line\">260</div><div class=\"line\">261</div><div class=\"line\">262</div><div class=\"line\">263</div><div class=\"line\">264</div><div class=\"line\">265</div><div class=\"line\">266</div><div class=\"line\">267</div><div class=\"line\">268</div><div class=\"line\">269</div><div class=\"line\">270</div><div class=\"line\">271</div><div class=\"line\">272</div><div class=\"line\">273</div><div class=\"line\">274</div><div class=\"line\">275</div><div class=\"line\">276</div><div class=\"line\">277</div><div class=\"line\">278</div><div class=\"line\">279</div><div class=\"line\">280</div><div class=\"line\">281</div><div class=\"line\">282</div><div class=\"line\">283</div><div class=\"line\">284</div><div class=\"line\">285</div><div class=\"line\">286</div><div class=\"line\">287</div><div class=\"line\">288</div><div class=\"line\">289</div><div class=\"line\">290</div><div class=\"line\">291</div><div class=\"line\">292</div><div class=\"line\">293</div><div class=\"line\">294</div><div class=\"line\">295</div><div class=\"line\">296</div><div class=\"line\">297</div><div class=\"line\">298</div><div class=\"line\">299</div><div class=\"line\">300</div><div class=\"line\">301</div><div class=\"line\">302</div><div class=\"line\">303</div><div class=\"line\">304</div><div class=\"line\">305</div><div class=\"line\">306</div><div class=\"line\">307</div><div class=\"line\">308</div><div class=\"line\">309</div><div class=\"line\">310</div><div class=\"line\">311</div><div class=\"line\">312</div><div class=\"line\">313</div><div class=\"line\">314</div><div class=\"line\">315</div><div class=\"line\">316</div><div class=\"line\">317</div><div class=\"line\">318</div><div class=\"line\">319</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * An &#123;@link HttpStack&#125; based on &#123;@link HttpURLConnection&#125;.</div><div class=\"line\"> */</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\"> * 当os version 版本在2.3以上，也就是sdk &gt;= 9 的时候</div><div class=\"line\"> * 选用这个接口作为HttpStack， 用到了HttpURLConnection</div><div class=\"line\"> * 关于HttpURLConnection,官方解释为：</div><div class=\"line\"> * An URLConnection for HTTP (RFC 2616) used to send and receive data over the web.</div><div class=\"line\"> * Data may be of any type and length. </div><div class=\"line\"> * This class may be used to send and receive streaming data whose length is not known in advance.</div><div class=\"line\"> * 用来发送和接受数据，数据可以为任意的形式及长度</div><div class=\"line\"> * 这个类常用来发送和接受数据流里面长度不定的数据.</div><div class=\"line\"> */</div><div class=\"line\">public class HurlStack implements HttpStack &#123;</div><div class=\"line\"></div><div class=\"line\">    /*</div><div class=\"line\">     * 请求header中的一个关键字</div><div class=\"line\">     * content-type代表着被发送的请求中主体内容</div><div class=\"line\">     * 可以设置application/json等格式</div><div class=\"line\">     */</div><div class=\"line\">    private static final String HEADER_CONTENT_TYPE = &quot;Content-Type&quot;;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * An interface for transforming URLs before use.</div><div class=\"line\">     * 一个用来在使用url之前，将url处理的接口工具</div><div class=\"line\">     * 可能是用来规范url格式的一个工具= =</div><div class=\"line\">     */ </div><div class=\"line\">    public interface UrlRewriter &#123;</div><div class=\"line\">        /**</div><div class=\"line\">         * Returns a URL to use instead of the provided one, or null to indicate</div><div class=\"line\">         * this URL should not be used at all.</div><div class=\"line\">         */</div><div class=\"line\">        public String rewriteUrl(String originalUrl);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    private final UrlRewriter mUrlRewriter;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * The abstract factory implementation to create SSLSockets.</div><div class=\"line\">     * 是一个抽象工厂类，用来创建SSLSockets（还是不懂是个什么鬼</div><div class=\"line\">     * </div><div class=\"line\">     * 对于SSLSocket，官方的解释是这样的：</div><div class=\"line\">     * The extension of Socket providing secure protocols like SSL (Secure Sockets Layer) or TLS (Transport Layer Security).</div><div class=\"line\">     * 是Socket的子类，并在之基础上新增了类似于SSL或者TLS等等的安全协议.</div><div class=\"line\">     */</div><div class=\"line\">    private final SSLSocketFactory mSslSocketFactory;</div><div class=\"line\"></div><div class=\"line\">    public HurlStack() &#123;</div><div class=\"line\">        this(null);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * @param urlRewriter Rewriter to use for request URLs</div><div class=\"line\">     */</div><div class=\"line\">    public HurlStack(UrlRewriter urlRewriter) &#123;</div><div class=\"line\">        this(urlRewriter, null);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * @param urlRewriter Rewriter to use for request URLs</div><div class=\"line\">     * @param sslSocketFactory SSL factory to use for HTTPS connections</div><div class=\"line\">     */</div><div class=\"line\">    public HurlStack(UrlRewriter urlRewriter, SSLSocketFactory sslSocketFactory) &#123;</div><div class=\"line\">        mUrlRewriter = urlRewriter;</div><div class=\"line\">        mSslSocketFactory = sslSocketFactory;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * 该函数为HttpStack的接口</div><div class=\"line\">     */</div><div class=\"line\">    @Override</div><div class=\"line\">    public HttpResponse performRequest(Request&lt;?&gt; request, Map&lt;String, String&gt; additionalHeaders)</div><div class=\"line\">            throws IOException, AuthFailureError &#123;</div><div class=\"line\">        /**</div><div class=\"line\">         * 得到请求的url</div><div class=\"line\">         */</div><div class=\"line\">        String url = request.getUrl();</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * 创建一个新的HashMap</div><div class=\"line\">         * 用来存放请求的header的信息</div><div class=\"line\">         */</div><div class=\"line\">        HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * 将原request(volley自己封装的一个request类)中的header</div><div class=\"line\">         * 和另外需要添加入header的信息都整合起来</div><div class=\"line\">         */</div><div class=\"line\">        map.putAll(request.getHeaders());</div><div class=\"line\">        map.putAll(additionalHeaders);</div><div class=\"line\"></div><div class=\"line\">        if (mUrlRewriter != null) &#123;</div><div class=\"line\">            String rewritten = mUrlRewriter.rewriteUrl(url);</div><div class=\"line\">            if (rewritten == null) &#123;</div><div class=\"line\">                throw new IOException(&quot;URL blocked by rewriter: &quot; + url);</div><div class=\"line\">            &#125;</div><div class=\"line\">            url = rewritten;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * 将url字符串形式规范成一个URL的类对象</div><div class=\"line\">         */</div><div class=\"line\">        URL parsedUrl = new URL(url);</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * HurlStack类是在sdk&gt;=2.3的android版本上使用的</div><div class=\"line\">         * 这里面用到了HttpURLConnection类</div><div class=\"line\">         * 在函数里面打开了并返回了一个HttpURLConnection</div><div class=\"line\">         * 设置了HttpURLConnection的响应超时阀值</div><div class=\"line\">         */</div><div class=\"line\">        HttpURLConnection connection = openConnection(parsedUrl, request);</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * 开始给HttpURLConnection添加header的信息</div><div class=\"line\">         * 用addRequestProperty()函数将header以键值对的形式填入</div><div class=\"line\">         */</div><div class=\"line\">        for (String headerName : map.keySet()) &#123;</div><div class=\"line\">            connection.addRequestProperty(headerName, map.get(headerName));</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * 根据request种类的不同</div><div class=\"line\">         * 分别用不同的方式来处理其中的参数</div><div class=\"line\">         */</div><div class=\"line\">        setConnectionParametersForRequest(connection, request);</div><div class=\"line\"></div><div class=\"line\">        // Initialize HttpResponse with data from the HttpURLConnection.</div><div class=\"line\">        ProtocolVersion protocolVersion = new ProtocolVersion(&quot;HTTP&quot;, 1, 1);</div><div class=\"line\"></div><div class=\"line\">        int responseCode = connection.getResponseCode();</div><div class=\"line\">        if (responseCode == -1) &#123;</div><div class=\"line\">            // -1 is returned by getResponseCode() if the response code could not be retrieved.</div><div class=\"line\">            // Signal to the caller that something was wrong with the connection.</div><div class=\"line\">            throw new IOException(&quot;Could not retrieve response code from HttpUrlConnection.&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        StatusLine responseStatus = new BasicStatusLine(protocolVersion,</div><div class=\"line\">                connection.getResponseCode(), connection.getResponseMessage());</div><div class=\"line\"></div><div class=\"line\">        BasicHttpResponse response = new BasicHttpResponse(responseStatus);</div><div class=\"line\"></div><div class=\"line\">        response.setEntity(entityFromConnection(connection));</div><div class=\"line\"></div><div class=\"line\">        for (Entry&lt;String, List&lt;String&gt;&gt; header : connection.getHeaderFields().entrySet()) &#123;</div><div class=\"line\">            if (header.getKey() != null) &#123;</div><div class=\"line\">                Header h = new BasicHeader(header.getKey(), header.getValue().get(0));</div><div class=\"line\">                response.addHeader(h);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return response;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Initializes an &#123;@link HttpEntity&#125; from the given &#123;@link HttpURLConnection&#125;.</div><div class=\"line\">     * @param connection</div><div class=\"line\">     * @return an HttpEntity populated with data from &lt;code&gt;connection&lt;/code&gt;.</div><div class=\"line\">     */</div><div class=\"line\">    private static HttpEntity entityFromConnection(HttpURLConnection connection) &#123;</div><div class=\"line\">        BasicHttpEntity entity = new BasicHttpEntity();</div><div class=\"line\">        InputStream inputStream;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            inputStream = connection.getInputStream();</div><div class=\"line\">        &#125; catch (IOException ioe) &#123;</div><div class=\"line\">            inputStream = connection.getErrorStream();</div><div class=\"line\">        &#125;</div><div class=\"line\">        entity.setContent(inputStream);</div><div class=\"line\">        entity.setContentLength(connection.getContentLength());</div><div class=\"line\">        entity.setContentEncoding(connection.getContentEncoding());</div><div class=\"line\">        entity.setContentType(connection.getContentType());</div><div class=\"line\">        return entity;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Create an &#123;@link HttpURLConnection&#125; for the specified &#123;@code url&#125;.</div><div class=\"line\">     */</div><div class=\"line\">    protected HttpURLConnection createConnection(URL url) throws IOException &#123;</div><div class=\"line\"></div><div class=\"line\">        return (HttpURLConnection) url.openConnection();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Opens an &#123;@link HttpURLConnection&#125; with parameters.</div><div class=\"line\">     * 通过给的url和参数，打开一个HttpURLConnection</div><div class=\"line\">     * @param url</div><div class=\"line\">     * @return an open connection</div><div class=\"line\">     * @throws IOException</div><div class=\"line\">     */</div><div class=\"line\">    private HttpURLConnection openConnection(URL url, Request&lt;?&gt; request) throws IOException &#123;</div><div class=\"line\"></div><div class=\"line\">        HttpURLConnection connection = createConnection(url);</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * 通过Request.java中的函数</div><div class=\"line\">         * 获取到该request上所设置的服务器最大响应时间阀值</div><div class=\"line\">         * 该阀值默认是2500ms，而且可能会随着retry的次数而增大</div><div class=\"line\">         */</div><div class=\"line\">        int timeoutMs = request.getTimeoutMs();</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * 给connection设置上请求超时时间</div><div class=\"line\">         */</div><div class=\"line\">        connection.setConnectTimeout(timeoutMs);</div><div class=\"line\">        connection.setReadTimeout(timeoutMs);</div><div class=\"line\">        connection.setUseCaches(false);</div><div class=\"line\">        connection.setDoInput(true);</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * use caller-provided custom SslSocketFactory, if any, for HTTPS</div><div class=\"line\">         * 请求方面的安全问题，暂时还不清清楚</div><div class=\"line\">         */</div><div class=\"line\">        if (&quot;https&quot;.equals(url.getProtocol()) &amp;&amp; mSslSocketFactory != null) &#123;</div><div class=\"line\">            ((HttpsURLConnection)connection).setSSLSocketFactory(mSslSocketFactory);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        return connection;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @SuppressWarnings(&quot;deprecation&quot;)</div><div class=\"line\">    /* package */</div><div class=\"line\">    /**</div><div class=\"line\">     * switch不同的请求方法</div><div class=\"line\">     * 来以不同的方式给HttpURLConnection添加请求参数</div><div class=\"line\">     */ </div><div class=\"line\">    static void setConnectionParametersForRequest(HttpURLConnection connection,</div><div class=\"line\">            Request&lt;?&gt; request) throws IOException, AuthFailureError &#123;</div><div class=\"line\">        switch (request.getMethod()) &#123;</div><div class=\"line\"></div><div class=\"line\">            /**</div><div class=\"line\">             * 在构造Request的时候如果没有指明请求方式</div><div class=\"line\">             * DEPRECATED_GET_OR_POST为其默认值</div><div class=\"line\">             * 通过postBody是否为Null来区别POST和GET</div><div class=\"line\">             * 这两种最常用的请求方式</div><div class=\"line\">             */</div><div class=\"line\">            case Method.DEPRECATED_GET_OR_POST:</div><div class=\"line\">                // This is the deprecated way that needs to be handled for backwards compatibility.</div><div class=\"line\">                // If the request&apos;s post body is null, then the assumption is that the request is</div><div class=\"line\">                // GET.  Otherwise, it is assumed that the request is a POST.</div><div class=\"line\">                /**</div><div class=\"line\">                 * 不要用这个参数了= =，因为不能处理什么DELETE之类的</div><div class=\"line\">                 * 该方法已经过时了。</div><div class=\"line\">                 */</div><div class=\"line\">                byte[] postBody = request.getPostBody();</div><div class=\"line\">                if (postBody != null) &#123;</div><div class=\"line\">                    // Prepare output. There is no need to set Content-Length explicitly,</div><div class=\"line\">                    // since this is handled by HttpURLConnection using the size of the prepared</div><div class=\"line\">                    // output stream.</div><div class=\"line\"></div><div class=\"line\">                    /**</div><div class=\"line\">                     * 设置是否输出</div><div class=\"line\">                     */</div><div class=\"line\">                    connection.setDoOutput(true);</div><div class=\"line\"></div><div class=\"line\">                    /**</div><div class=\"line\">                     * 给connection设置请求的方式</div><div class=\"line\">                     */</div><div class=\"line\">                    connection.setRequestMethod(&quot;POST&quot;);</div><div class=\"line\"></div><div class=\"line\">                    /**</div><div class=\"line\">                     * 设置http请求头中的content-type参数</div><div class=\"line\">                     */</div><div class=\"line\">                    connection.addRequestProperty(HEADER_CONTENT_TYPE,</div><div class=\"line\">                            request.getPostBodyContentType());</div><div class=\"line\">                    DataOutputStream out = new DataOutputStream(connection.getOutputStream());</div><div class=\"line\">                    out.write(0);</div><div class=\"line\">                    out.close();</div><div class=\"line\">                &#125;</div><div class=\"line\">                break;</div><div class=\"line\">            case Method.GET:</div><div class=\"line\">                // Not necessary to set the request method because connection defaults to GET but</div><div class=\"line\">                // being explicit here.</div><div class=\"line\">                connection.setRequestMethod(&quot;GET&quot;);</div><div class=\"line\">                break;</div><div class=\"line\">            case Method.DELETE:</div><div class=\"line\">                connection.setRequestMethod(&quot;DELETE&quot;);</div><div class=\"line\">                break;</div><div class=\"line\">            case Method.POST:</div><div class=\"line\">                connection.setRequestMethod(&quot;POST&quot;);</div><div class=\"line\">                addBodyIfExists(connection, request);</div><div class=\"line\">                break;</div><div class=\"line\">            case Method.PUT:</div><div class=\"line\">                connection.setRequestMethod(&quot;PUT&quot;);</div><div class=\"line\">                addBodyIfExists(connection, request);</div><div class=\"line\">                break;</div><div class=\"line\">            case Method.HEAD:</div><div class=\"line\">                connection.setRequestMethod(&quot;HEAD&quot;);</div><div class=\"line\">                break;</div><div class=\"line\">            case Method.OPTIONS:</div><div class=\"line\">                connection.setRequestMethod(&quot;OPTIONS&quot;);</div><div class=\"line\">                break;</div><div class=\"line\">            case Method.TRACE:</div><div class=\"line\">                connection.setRequestMethod(&quot;TRACE&quot;);</div><div class=\"line\">                break;</div><div class=\"line\">            case Method.PATCH:</div><div class=\"line\">                connection.setRequestMethod(&quot;PATCH&quot;);</div><div class=\"line\">                addBodyIfExists(connection, request);</div><div class=\"line\">                break;</div><div class=\"line\">            default:</div><div class=\"line\">                throw new IllegalStateException(&quot;Unknown method type.&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * 如果存在请求参数的话</div><div class=\"line\">     * 获取到connection的输出流对象</div><div class=\"line\">     * 并创建一个DataOutputStream对象</div><div class=\"line\">     * 用于向服务器写入需要传递的参数</div><div class=\"line\">     */</div><div class=\"line\">    private static void addBodyIfExists(HttpURLConnection connection, Request&lt;?&gt; request)</div><div class=\"line\">            throws IOException, AuthFailureError &#123;</div><div class=\"line\">        byte[] body = request.getBody();</div><div class=\"line\">        if (body != null) &#123;</div><div class=\"line\">            connection.setDoOutput(true);</div><div class=\"line\">            connection.addRequestProperty(HEADER_CONTENT_TYPE, request.getBodyContentType());</div><div class=\"line\">            DataOutputStream out = new DataOutputStream(connection.getOutputStream());</div><div class=\"line\">            out.write(body);</div><div class=\"line\">            out.close();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"Volley框架解析-六-Cache接口及其默认实现类解析","date":"2017-04-20T14:39:26.000Z","_content":"\n\n### 1. 前言(可直接无视跳过\n\n前面涉及到网络的部分都介绍完了，在处理网络请求返回的数据时，会根据request结果是否需要缓存来进行不同的处理。如需要缓存结果，就涉及到了`Cache.java`及其默认实现类`DiskBasedCache.java`。\n\n<!--more-->\n\n### 2. Cache.java\n\n用于处理缓存的接口，里面有很多抽象的方法等着被实现，里面还有一个static类`Entry`,里面有些关于缓存的单元信息。(例如，缓存的内容，缓存过期的时间，缓存需要刷新的时间等等）。\n\n```\npackage com.android.volley;\n\n/**\n * An interface for a cache keyed by a String with * a byte array as data.\n * 一个用于缓存的接口\n */\npublic interface Cache {\n    /**\n     * Retrieves an entry from the cache.\n     * 用来获取缓存的入口，通过传入的key\n     * \n     * @param key Cache key\n     * 这个key应该是request对应其缓存的唯一key\n     *\n     * @return An {@link Entry} or null in the event of a cache miss\n     */\n    public Entry get(String key);\n\n    /**\n     * Adds or replaces an entry to the cache.\n     * 添加或者给request更新缓存\n     * @param key Cache key\n     * @param entry Data to store and metadata for cache coherency, TTL, etc.\n     */\n    public void put(String key, Entry entry);\n\n    /**\n     * Performs any potentially long-running actions needed to initialize the cache;\n     * will be called from a worker thread.\n     */\n    public void initialize();\n\n    /**\n     * Invalidates an entry in the cache.\n     * 这个函数是将key对应的缓存置于过期\n     * 分为fully expire和soft expire， 目前还不知道是什么意思 = =\n     * \n     * @param key Cache key\n     * @param fullExpire True to fully expire the entry, false to soft expire\n     */\n    public void invalidate(String key, boolean fullExpire);\n\n    /**\n     * Removes an entry from the cache.\n     * 将key对应的缓存直接移除掉\n     * \n     * @param key Cache key\n     */\n    public void remove(String key);\n\n    /**\n     * Empties the cache.\n     * 清除所有的缓存\n     */\n    public void clear();\n\n    /**\n     * Data and metadata for an entry returned by the cache.\n     */\n    public static class Entry {\n        /** The data returned from cache. */\n        public byte[] data;\n\n        /** ETag for cache coherency. */\n        public String etag;\n\n        /** Date of this response as reported by the server. */\n        public long serverDate;\n\n        /** The last modified date for the requested object. */\n        public long lastModified;\n\n        /** TTL for this record.\n         *  根据后面的isExpired()函数来看\n         *  该条数据的意思应该是缓存过期的时间 \n         */\n        public long ttl;\n\n        /** Soft TTL for this record. \n         *  根据refreshNeeded()函数来看\n         *  意思是需要更新缓存的时间点\n         */\n        public long softTtl;\n\n        /** Immutable response headers as received from server; must be non-null. */\n        public Map<String, String> responseHeaders = Collections.emptyMap();\n\n       /** \n         * True if the entry is expired. \n         * 用来查看缓存是否过期了\n         */\n        public boolean isExpired() {\n            return this.ttl < System.currentTimeMillis();\n        }\n\n        /** True if a refresh is needed from the original data source. */\n        public boolean refreshNeeded() {\n            return this.softTtl < System.currentTimeMillis();\n        }\n    }\n\n}\n\n```\n\n### 3. DiskBasedCache.java\n\n实现了Cache.java接口，专门和本地存储的文件打交道，负责缓存的写入与读取。涉及到了一部分InputStream和OutputStream还有File的知识。\n\n```\n/**\n * Cache implementation that caches files directly onto the hard disk in the specified\n * directory. The default disk usage size is 5MB, but is configurable.\n * 实现了Cache接口\n * 专门用于和本地文件交互的一个类\n * 存入缓存和取出缓存等功能\n */\npublic class DiskBasedCache implements Cache {\n\n    /**\n     * Map of the Key, CacheHeader pairs \n     * CacheHeader.java为本类中的一个static类\n     * 里面存放着一些\n     */\n    private final Map<String, CacheHeader> mEntries =\n            new LinkedHashMap<String, CacheHeader>(16, .75f, true);\n\n    /** \n     * Total amount of space currently used by the cache in bytes. \n     * 当前缓存的总大小\n     */\n    private long mTotalSize = 0;\n\n    /** \n     * The root directory to use for the cache. \n     * 缓存的根目录\n     */\n    private final File mRootDirectory;\n\n    /** \n     * The maximum size of the cache in bytes. \n     * 缓存能接受的最大字节数\n     */\n    private final int mMaxCacheSizeInBytes;\n\n    /** \n     * Default maximum disk usage in bytes.\n     * 默认缓存能使用的最大空间\n     */\n    private static final int DEFAULT_DISK_USAGE_BYTES = 5 * 1024 * 1024;\n\n    /** \n     * High water mark percentage for the cache\n     * 类似于水位警戒线一样的标识\n     */\n    private static final float HYSTERESIS_FACTOR = 0.9f;\n\n    /** \n     * Magic number for current version of cache file format. \n     * \n     */\n    private static final int CACHE_MAGIC = 0x20150306;\n\n    /**\n     * Constructs an instance of the DiskBasedCache at the specified directory.\n     * 在指定的目录下面创建一个DiskBasedCache\n     *\n     * @param rootDirectory The root directory of the cache.\n     * @param maxCacheSizeInBytes The maximum size of the cache in bytes.\n     */\n    public DiskBasedCache(File rootDirectory, int maxCacheSizeInBytes) {\n        mRootDirectory = rootDirectory;\n        mMaxCacheSizeInBytes = maxCacheSizeInBytes;\n    }\n\n    /**\n     * Constructs an instance of the DiskBasedCache at the specified directory using\n     * the default maximum cache size of 5MB.\n     * @param rootDirectory The root directory of the cache.\n     */\n    public DiskBasedCache(File rootDirectory) {\n        this(rootDirectory, DEFAULT_DISK_USAGE_BYTES);\n    }\n\n    /**\n     * Clears the cache. Deletes all cached files from disk.\n     * 清除当前目录下的缓存，删除所有缓存文件 \n     */\n    @Override\n    public synchronized void clear() {\n        File[] files = mRootDirectory.listFiles();\n        if (files != null) {\n            for (File file : files) {\n                file.delete();\n            }\n        }\n        mEntries.clear();\n        mTotalSize = 0;\n        VolleyLog.d(\"Cache cleared.\");\n    }\n\n    /**\n     * Returns the cache entry with the specified key if it exists, null otherwise.\n     * 通过特殊的key，来获取与缓存交流的接口(entry)\n     * 如果没有的话则返回null\n     */\n    @Override\n    public synchronized Entry get(String key) {\n\n        CacheHeader entry = mEntries.get(key);\n        // if the entry does not exist, return.\n        if (entry == null) {\n            return null;\n        }\n\n        //依据key获取缓存的文件，如果不存在则创建一个\n        File file = getFileForKey(key);\n\n        CountingInputStream cis = null;\n\n        try {\n\n            cis = new CountingInputStream(new BufferedInputStream(new FileInputStream(file)));\n            CacheHeader.readHeader(cis); // eat header\n            byte[] data = streamToBytes(cis, (int) (file.length() - cis.bytesRead));\n            return entry.toCacheEntry(data);\n\n        } catch (IOException e) {\n            VolleyLog.d(\"%s: %s\", file.getAbsolutePath(), e.toString());\n            remove(key);\n            return null;\n        }  catch (NegativeArraySizeException e) {\n            VolleyLog.d(\"%s: %s\", file.getAbsolutePath(), e.toString());\n            remove(key);\n            return null;\n        } finally {\n            if (cis != null) {\n                try {\n                    cis.close();\n                } catch (IOException ioe) {\n                    return null;\n                }\n            }\n        }\n    }\n\n    /**\n     * Initializes the DiskBasedCache by scanning for all files currently in the\n     * specified root directory. Creates the root directory if necessary.\n     * 对缓存目录的初始化工作，检查目录是否存在\n     * 如果不存在就给重新创建一个\n     */\n    @Override\n    public synchronized void initialize() {\n        if (!mRootDirectory.exists()) {\n            if (!mRootDirectory.mkdirs()) {\n                VolleyLog.e(\"Unable to create cache dir %s\", mRootDirectory.getAbsolutePath());\n            }\n            return;\n        }\n\n        /**\n         * 如果缓存目录已经存在了\n         * 则将缓存目录下面的文件都扫描一遍\n         * 将关于缓存文件的部分信息加载到内存中来\n         * 方便后面对缓存的查询等工作\n         */\n\n        File[] files = mRootDirectory.listFiles();\n        if (files == null) {\n            return;\n        }\n        for (File file : files) {\n            BufferedInputStream fis = null;\n            try {\n                fis = new BufferedInputStream(new FileInputStream(file));\n                CacheHeader entry = CacheHeader.readHeader(fis);\n                entry.size = file.length();\n                putEntry(entry.key, entry);\n            } catch (IOException e) {\n                if (file != null) {\n                   file.delete();\n                }\n            } finally {\n                try {\n                    if (fis != null) {\n                        fis.close();\n                    }\n                } catch (IOException ignored) { }\n            }\n        }\n    }\n\n    /**\n     * Invalidates an entry in the cache.\n     * 将key对应的缓存作废\n     * 如果fullExpire为true，则将整个entry作废\n     * 如果为false,则只是软作废，也就是将缓存置于需要刷新的状态\n     *\n     * @param key Cache key\n     * @param fullExpire True to fully expire the entry, false to soft expire\n     */\n    @Override\n    public synchronized void invalidate(String key, boolean fullExpire) {\n        Entry entry = get(key);\n        if (entry != null) {\n            entry.softTtl = 0;\n            if (fullExpire) {\n                entry.ttl = 0;\n            }\n            put(key, entry);\n        }\n\n    }\n\n    /**\n     * Puts the entry with the specified key into the cache.\n     * 将entry中包含的信息存放到key对应的缓存文件中去\n     */\n    @Override\n    public synchronized void put(String key, Entry entry) {\n\n        pruneIfNeeded(entry.data.length);\n\n        File file = getFileForKey(key);\n        try {\n            BufferedOutputStream fos = new BufferedOutputStream(new FileOutputStream(file));\n            CacheHeader e = new CacheHeader(key, entry);\n            boolean success = e.writeHeader(fos);\n            if (!success) {\n                fos.close();\n                VolleyLog.d(\"Failed to write header for %s\", file.getAbsolutePath());\n                throw new IOException();\n            }\n            fos.write(entry.data);\n            fos.close();\n            putEntry(key, e);\n            return;\n        } catch (IOException e) {\n        }\n        boolean deleted = file.delete();\n        if (!deleted) {\n            VolleyLog.d(\"Could not clean up file %s\", file.getAbsolutePath());\n        }\n    }\n\n    /**\n     * Removes the specified key from the cache if it exists.\n     */\n    @Override\n    public synchronized void remove(String key) {\n        boolean deleted = getFileForKey(key).delete();\n        removeEntry(key);\n        if (!deleted) {\n            VolleyLog.d(\"Could not delete cache entry for key=%s, filename=%s\",\n                    key, getFilenameForKey(key));\n        }\n    }\n\n    /**\n     * Creates a pseudo-unique filename for the specified cache key.\n     * 通过给定的key，前半段的hashCode和后半段的hashCode连接起来\n     * 作为一个独一无二的文件名\n     * @param key The key to generate a file name for.\n     * @return A pseudo-unique filename.\n     */\n    private String getFilenameForKey(String key) {\n        int firstHalfLength = key.length() / 2;\n        String localFilename = String.valueOf(key.substring(0, firstHalfLength).hashCode());\n        localFilename += String.valueOf(key.substring(firstHalfLength).hashCode());\n        return localFilename;\n    }\n\n    /**\n     * Returns a file object for the given cache key.\n     * 通过调用getFilenameForKey()方法来获取相对路径\n     */\n    public File getFileForKey(String key) {\n        return new File(mRootDirectory, getFilenameForKey(key));\n    }\n\n    /**\n     * Prunes the cache to fit the amount of bytes specified.\n     * 从已有的缓存中清除数据\n     * 直到扫出了一片neededSapce大小的空地为止\n     * @param neededSpace The amount of bytes we are trying to fit into the cache.\n     */\n    private void pruneIfNeeded(int neededSpace) {\n        if ((mTotalSize + neededSpace) < mMaxCacheSizeInBytes) {\n            return;\n        }\n        if (VolleyLog.DEBUG) {\n            VolleyLog.v(\"Pruning old cache entries.\");\n        }\n\n        long before = mTotalSize;\n        int prunedFiles = 0;\n        long startTime = SystemClock.elapsedRealtime();\n\n        Iterator<Map.Entry<String, CacheHeader>> iterator = mEntries.entrySet().iterator();\n\n        while (iterator.hasNext()) {\n\n            Map.Entry<String, CacheHeader> entry = iterator.next();\n\n            CacheHeader e = entry.getValue();\n\n            boolean deleted = getFileForKey(e.key).delete();\n\n            if (deleted) {\n                mTotalSize -= e.size;\n            } else {\n               VolleyLog.d(\"Could not delete cache entry for key=%s, filename=%s\",\n                       e.key, getFilenameForKey(e.key));\n            }\n            iterator.remove();\n            prunedFiles++;\n\n            /**\n             * 一直清除缓存\n             * 直到存入这个neededSapce之后还有一小部分空余的地方\n             */\n            if ((mTotalSize + neededSpace) < mMaxCacheSizeInBytes * HYSTERESIS_FACTOR) {\n                break;\n            }\n        }\n\n        if (VolleyLog.DEBUG) {\n            VolleyLog.v(\"pruned %d files, %d bytes, %d ms\",\n                    prunedFiles, (mTotalSize - before), SystemClock.elapsedRealtime() - startTime);\n        }\n    }\n\n    /**\n     * Puts the entry with the specified key into the cache.\n     * 将目录下指定的缓存加载到mEntries中去\n     * 为了方便之后对缓存的读写操作\n     * 全部读写一遍放在内存里面，对查询什么的都会方便很多\n     *\n     * @param key The key to identify the entry by.\n     * @param entry The entry to cache.\n     */\n    private void putEntry(String key, CacheHeader entry) {\n        if (!mEntries.containsKey(key)) {\n            mTotalSize += entry.size;\n        } else {\n            CacheHeader oldEntry = mEntries.get(key);\n            mTotalSize += (entry.size - oldEntry.size);\n        }\n        mEntries.put(key, entry);\n    }\n\n    /**\n     * Removes the entry identified by 'key' from the cache.\n     */\n    private void removeEntry(String key) {\n        CacheHeader entry = mEntries.get(key);\n        if (entry != null) {\n            mTotalSize -= entry.size;\n            mEntries.remove(key);\n        }\n    }\n\n    /**\n     * Reads the contents of an InputStream into a byte[].\n     * 从InputStream中读取指定长度的数据\n     * \n     */\n    private static byte[] streamToBytes(InputStream in, int length) throws IOException {\n        byte[] bytes = new byte[length];\n        int count;\n        int pos = 0;\n        while (pos < length && ((count = in.read(bytes, pos, length - pos)) != -1)) {\n            pos += count;\n        }\n        if (pos != length) {\n            throw new IOException(\"Expected \" + length + \" bytes, read \" + pos + \" bytes\");\n        }\n        return bytes;\n    }\n\n    /**\n     * Handles holding onto the cache headers for an entry.\n     */\n    // Visible for testing.\n    static class CacheHeader {\n        /** \n         * The size of the data identified by this CacheHeader. (This is not\n         * serialized to disk.\n         * \n         * CacheHeader所表示的数据段的大小 \n         */\n        public long size;\n\n        /** \n         * The key that identifies the cache entry. \n         * 这个key应该是request对应其缓存的唯一key\n         */\n        public String key;\n\n        /** \n         * ETag for cache coherence.\n         *\n         */\n        public String etag;\n\n        /** \n         * Date of this response as reported by the server. \n         * 缓存起来的数据返回的日期\n         */\n        public long serverDate;\n\n        /** \n         * The last modified date for the requested object. \n         * 最后一次更改的时间\n         */\n        public long lastModified;\n\n        /** \n         * TTL for this record. \n         * ping时候返回的TTL=128的概念如下\n         * TTL：生存时间\n         * 指定数据报被路由器丢弃之前允许通过的网段数量。\n         * TTL 是由发送主机设置的，以防止数据包不断在 IP 互联网络上永不终止地循环。转发 IP 数据包时，要求路由器至少将 TTL 减小 1。\n         *  \n         * 但是= =，注意这里的和上面的那种不是一个概念，这里只是模拟了上面的概念，但也是用来标志缓存存活时间的。\n         */\n        public long ttl;\n\n        /** \n         * Soft TTL for this record. \n         * \n         * 根据refreshNeeded()函数来看\n         * 意思是需要更新缓存的时间点\n         */\n        public long softTtl;\n\n        /** \n         * Headers from the response resulting in this cache entry. \n         * 用来指向上一次response的header\n         */\n        public Map<String, String> responseHeaders;\n\n        private CacheHeader() { }\n\n        /**\n         * Instantiates a new CacheHeader object\n         * @param key The key that identifies the cache entry\n         * @param entry The cache entry.\n         */\n        public CacheHeader(String key, Entry entry) {\n            this.key = key;\n            this.size = entry.data.length;\n            this.etag = entry.etag;\n            this.serverDate = entry.serverDate;\n            this.lastModified = entry.lastModified;\n            this.ttl = entry.ttl;\n            this.softTtl = entry.softTtl;\n            this.responseHeaders = entry.responseHeaders;\n        }\n\n        /**\n         * Reads the header off of an InputStream and returns a CacheHeader object.\n         * 从InputStream中读取数据并组建一个CacheHeader对象实例\n         * @param is The InputStream to read from.\n         * @throws IOException\n         */\n        public static CacheHeader readHeader(InputStream is) throws IOException {\n            CacheHeader entry = new CacheHeader();\n            int magic = readInt(is);\n            if (magic != CACHE_MAGIC) {\n                // don't bother deleting, it'll get pruned eventually\n                throw new IOException();\n            }\n            entry.key = readString(is);\n            entry.etag = readString(is);\n            if (entry.etag.equals(\"\")) {\n                entry.etag = null;\n            }\n            entry.serverDate = readLong(is);\n            entry.lastModified = readLong(is);\n            entry.ttl = readLong(is);\n            entry.softTtl = readLong(is);\n            entry.responseHeaders = readStringStringMap(is);\n\n            return entry;\n        }\n\n        /**\n         * Creates a cache entry for the specified data.\n         * 从CacheHeader转换成Entry类的实例\n         */\n        public Entry toCacheEntry(byte[] data) {\n            Entry e = new Entry();\n            e.data = data;\n            e.etag = etag;\n            e.serverDate = serverDate;\n            e.lastModified = lastModified;\n            e.ttl = ttl;\n            e.softTtl = softTtl;\n            e.responseHeaders = responseHeaders;\n            return e;\n        }\n\n        /**\n         * Writes the contents of this CacheHeader to the specified OutputStream.\n         * 将CacheHeader里面的数据写入指定的OutputStream中\n         */\n        public boolean writeHeader(OutputStream os) {\n            try {\n                writeInt(os, CACHE_MAGIC);\n                writeString(os, key);\n                writeString(os, etag == null ? \"\" : etag);\n                writeLong(os, serverDate);\n                writeLong(os, lastModified);\n                writeLong(os, ttl);\n                writeLong(os, softTtl);\n                writeStringStringMap(responseHeaders, os);\n                os.flush();\n                return true;\n            } catch (IOException e) {\n                VolleyLog.d(\"%s\", e.toString());\n                return false;\n            }\n        }\n\n    }\n\n    /**\n     * 继承了FilterInputStream\n     * 没啥特别的= =\n     */\n\n    private static class CountingInputStream extends FilterInputStream {\n\n        private int bytesRead = 0;\n\n        private CountingInputStream(InputStream in) {\n            super(in);\n        }\n\n        @Override\n        public int read() throws IOException {\n            int result = super.read();\n            if (result != -1) {\n                bytesRead++;\n            }\n            return result;\n        }\n\n        @Override\n        public int read(byte[] buffer, int offset, int count) throws IOException {\n            int result = super.read(buffer, offset, count);\n            if (result != -1) {\n                bytesRead += result;\n            }\n            return result;\n        }\n    }\n\n    /*\n     * Homebrewed simple serialization system used for reading and writing cache\n     * headers on disk. Once upon a time, this used the standard Java\n     * Object{Input,Output}Stream, but the default implementation relies heavily\n     * on reflection (even for standard types) and generates a ton of garbage.\n     * \n     */\n\n    /**\n     * Simple wrapper around {@link InputStream#read()} that throws EOFException\n     * instead of returning -1.\n     * 如果文件读到了末尾直接抛出异常\n     */\n    private static int read(InputStream is) throws IOException {\n        int b = is.read();\n        if (b == -1) {\n            throw new EOFException();\n        }\n        return b;\n    }\n\n    /**\n     * 刚开始看到这里的时候没有明白是什么意思= =\n     * 就不明白了，好好的一个int类型的数据\n     * 为什么非要分段写入呢，一个字节一个字节的写入\n     * 后来查了资料才发现，OutputStream及其子类的write()方法\n     * 一次都只能写入一个byte，int类型有4个byte，分四次写入没什么问题咯\n     */\n\n    static void writeInt(OutputStream os, int n) throws IOException {\n        os.write((n >> 0) & 0xff);\n        os.write((n >> 8) & 0xff);\n        os.write((n >> 16) & 0xff);\n        os.write((n >> 24) & 0xff);\n    }\n\n    static int readInt(InputStream is) throws IOException {\n        int n = 0;\n        n |= (read(is) << 0);\n        n |= (read(is) << 8);\n        n |= (read(is) << 16);\n        n |= (read(is) << 24);\n        return n;\n    }\n\n    static void writeLong(OutputStream os, long n) throws IOException {\n        os.write((byte)(n >>> 0));\n        os.write((byte)(n >>> 8));\n        os.write((byte)(n >>> 16));\n        os.write((byte)(n >>> 24));\n        os.write((byte)(n >>> 32));\n        os.write((byte)(n >>> 40));\n        os.write((byte)(n >>> 48));\n        os.write((byte)(n >>> 56));\n    }\n\n    static long readLong(InputStream is) throws IOException {\n        long n = 0;\n        n |= ((read(is) & 0xFFL) << 0);\n        n |= ((read(is) & 0xFFL) << 8);\n        n |= ((read(is) & 0xFFL) << 16);\n        n |= ((read(is) & 0xFFL) << 24);\n        n |= ((read(is) & 0xFFL) << 32);\n        n |= ((read(is) & 0xFFL) << 40);\n        n |= ((read(is) & 0xFFL) << 48);\n        n |= ((read(is) & 0xFFL) << 56);\n        return n;\n    }\n\n    static void writeString(OutputStream os, String s) throws IOException {\n        byte[] b = s.getBytes(\"UTF-8\");\n        writeLong(os, b.length);\n        os.write(b, 0, b.length);\n    }\n\n    static String readString(InputStream is) throws IOException {\n        int n = (int) readLong(is);\n        byte[] b = streamToBytes(is, n);\n        return new String(b, \"UTF-8\");\n    }\n\n    static void writeStringStringMap(Map<String, String> map, OutputStream os) throws IOException {\n        if (map != null) {\n            writeInt(os, map.size());\n            for (Map.Entry<String, String> entry : map.entrySet()) {\n                writeString(os, entry.getKey());\n                writeString(os, entry.getValue());\n            }\n        } else {\n            writeInt(os, 0);\n        }\n    }\n\n    /**\n     * 从InputStream中读取key类型为String，值类型也为String的Map\n     */ \n    static Map<String, String> readStringStringMap(InputStream is) throws IOException {\n        int size = readInt(is);\n        Map<String, String> result = (size == 0)\n                ? Collections.<String, String>emptyMap()\n                : new HashMap<String, String>(size);\n        for (int i = 0; i < size; i++) {\n\n            //将读出来的byte[]转换成String\n\n            String key = readString(is).intern();\n            String value = readString(is).intern();\n            result.put(key, value);\n        }\n        return result;\n    }\n}\n\n```\n\n涉及到缓存读写的这个实现类当时阅读的时候还是花了不少时间的= =，人太笨了没办法orz，有什么不妥的地方还望各位juju多多指教，小达感激不尽0.0。下面还有Request.java等类等着去解析呢，Volley中的主角要登场了╭(╯^╰)╮。","source":"_posts/Volley框架解析-六-Cache接口及其默认实现类解析.md","raw":"---\ntitle: Volley框架解析-六-Cache接口及其默认实现类解析\ndate: 2017-04-20 22:39:26\ntags: volley\n\n---\n\n\n### 1. 前言(可直接无视跳过\n\n前面涉及到网络的部分都介绍完了，在处理网络请求返回的数据时，会根据request结果是否需要缓存来进行不同的处理。如需要缓存结果，就涉及到了`Cache.java`及其默认实现类`DiskBasedCache.java`。\n\n<!--more-->\n\n### 2. Cache.java\n\n用于处理缓存的接口，里面有很多抽象的方法等着被实现，里面还有一个static类`Entry`,里面有些关于缓存的单元信息。(例如，缓存的内容，缓存过期的时间，缓存需要刷新的时间等等）。\n\n```\npackage com.android.volley;\n\n/**\n * An interface for a cache keyed by a String with * a byte array as data.\n * 一个用于缓存的接口\n */\npublic interface Cache {\n    /**\n     * Retrieves an entry from the cache.\n     * 用来获取缓存的入口，通过传入的key\n     * \n     * @param key Cache key\n     * 这个key应该是request对应其缓存的唯一key\n     *\n     * @return An {@link Entry} or null in the event of a cache miss\n     */\n    public Entry get(String key);\n\n    /**\n     * Adds or replaces an entry to the cache.\n     * 添加或者给request更新缓存\n     * @param key Cache key\n     * @param entry Data to store and metadata for cache coherency, TTL, etc.\n     */\n    public void put(String key, Entry entry);\n\n    /**\n     * Performs any potentially long-running actions needed to initialize the cache;\n     * will be called from a worker thread.\n     */\n    public void initialize();\n\n    /**\n     * Invalidates an entry in the cache.\n     * 这个函数是将key对应的缓存置于过期\n     * 分为fully expire和soft expire， 目前还不知道是什么意思 = =\n     * \n     * @param key Cache key\n     * @param fullExpire True to fully expire the entry, false to soft expire\n     */\n    public void invalidate(String key, boolean fullExpire);\n\n    /**\n     * Removes an entry from the cache.\n     * 将key对应的缓存直接移除掉\n     * \n     * @param key Cache key\n     */\n    public void remove(String key);\n\n    /**\n     * Empties the cache.\n     * 清除所有的缓存\n     */\n    public void clear();\n\n    /**\n     * Data and metadata for an entry returned by the cache.\n     */\n    public static class Entry {\n        /** The data returned from cache. */\n        public byte[] data;\n\n        /** ETag for cache coherency. */\n        public String etag;\n\n        /** Date of this response as reported by the server. */\n        public long serverDate;\n\n        /** The last modified date for the requested object. */\n        public long lastModified;\n\n        /** TTL for this record.\n         *  根据后面的isExpired()函数来看\n         *  该条数据的意思应该是缓存过期的时间 \n         */\n        public long ttl;\n\n        /** Soft TTL for this record. \n         *  根据refreshNeeded()函数来看\n         *  意思是需要更新缓存的时间点\n         */\n        public long softTtl;\n\n        /** Immutable response headers as received from server; must be non-null. */\n        public Map<String, String> responseHeaders = Collections.emptyMap();\n\n       /** \n         * True if the entry is expired. \n         * 用来查看缓存是否过期了\n         */\n        public boolean isExpired() {\n            return this.ttl < System.currentTimeMillis();\n        }\n\n        /** True if a refresh is needed from the original data source. */\n        public boolean refreshNeeded() {\n            return this.softTtl < System.currentTimeMillis();\n        }\n    }\n\n}\n\n```\n\n### 3. DiskBasedCache.java\n\n实现了Cache.java接口，专门和本地存储的文件打交道，负责缓存的写入与读取。涉及到了一部分InputStream和OutputStream还有File的知识。\n\n```\n/**\n * Cache implementation that caches files directly onto the hard disk in the specified\n * directory. The default disk usage size is 5MB, but is configurable.\n * 实现了Cache接口\n * 专门用于和本地文件交互的一个类\n * 存入缓存和取出缓存等功能\n */\npublic class DiskBasedCache implements Cache {\n\n    /**\n     * Map of the Key, CacheHeader pairs \n     * CacheHeader.java为本类中的一个static类\n     * 里面存放着一些\n     */\n    private final Map<String, CacheHeader> mEntries =\n            new LinkedHashMap<String, CacheHeader>(16, .75f, true);\n\n    /** \n     * Total amount of space currently used by the cache in bytes. \n     * 当前缓存的总大小\n     */\n    private long mTotalSize = 0;\n\n    /** \n     * The root directory to use for the cache. \n     * 缓存的根目录\n     */\n    private final File mRootDirectory;\n\n    /** \n     * The maximum size of the cache in bytes. \n     * 缓存能接受的最大字节数\n     */\n    private final int mMaxCacheSizeInBytes;\n\n    /** \n     * Default maximum disk usage in bytes.\n     * 默认缓存能使用的最大空间\n     */\n    private static final int DEFAULT_DISK_USAGE_BYTES = 5 * 1024 * 1024;\n\n    /** \n     * High water mark percentage for the cache\n     * 类似于水位警戒线一样的标识\n     */\n    private static final float HYSTERESIS_FACTOR = 0.9f;\n\n    /** \n     * Magic number for current version of cache file format. \n     * \n     */\n    private static final int CACHE_MAGIC = 0x20150306;\n\n    /**\n     * Constructs an instance of the DiskBasedCache at the specified directory.\n     * 在指定的目录下面创建一个DiskBasedCache\n     *\n     * @param rootDirectory The root directory of the cache.\n     * @param maxCacheSizeInBytes The maximum size of the cache in bytes.\n     */\n    public DiskBasedCache(File rootDirectory, int maxCacheSizeInBytes) {\n        mRootDirectory = rootDirectory;\n        mMaxCacheSizeInBytes = maxCacheSizeInBytes;\n    }\n\n    /**\n     * Constructs an instance of the DiskBasedCache at the specified directory using\n     * the default maximum cache size of 5MB.\n     * @param rootDirectory The root directory of the cache.\n     */\n    public DiskBasedCache(File rootDirectory) {\n        this(rootDirectory, DEFAULT_DISK_USAGE_BYTES);\n    }\n\n    /**\n     * Clears the cache. Deletes all cached files from disk.\n     * 清除当前目录下的缓存，删除所有缓存文件 \n     */\n    @Override\n    public synchronized void clear() {\n        File[] files = mRootDirectory.listFiles();\n        if (files != null) {\n            for (File file : files) {\n                file.delete();\n            }\n        }\n        mEntries.clear();\n        mTotalSize = 0;\n        VolleyLog.d(\"Cache cleared.\");\n    }\n\n    /**\n     * Returns the cache entry with the specified key if it exists, null otherwise.\n     * 通过特殊的key，来获取与缓存交流的接口(entry)\n     * 如果没有的话则返回null\n     */\n    @Override\n    public synchronized Entry get(String key) {\n\n        CacheHeader entry = mEntries.get(key);\n        // if the entry does not exist, return.\n        if (entry == null) {\n            return null;\n        }\n\n        //依据key获取缓存的文件，如果不存在则创建一个\n        File file = getFileForKey(key);\n\n        CountingInputStream cis = null;\n\n        try {\n\n            cis = new CountingInputStream(new BufferedInputStream(new FileInputStream(file)));\n            CacheHeader.readHeader(cis); // eat header\n            byte[] data = streamToBytes(cis, (int) (file.length() - cis.bytesRead));\n            return entry.toCacheEntry(data);\n\n        } catch (IOException e) {\n            VolleyLog.d(\"%s: %s\", file.getAbsolutePath(), e.toString());\n            remove(key);\n            return null;\n        }  catch (NegativeArraySizeException e) {\n            VolleyLog.d(\"%s: %s\", file.getAbsolutePath(), e.toString());\n            remove(key);\n            return null;\n        } finally {\n            if (cis != null) {\n                try {\n                    cis.close();\n                } catch (IOException ioe) {\n                    return null;\n                }\n            }\n        }\n    }\n\n    /**\n     * Initializes the DiskBasedCache by scanning for all files currently in the\n     * specified root directory. Creates the root directory if necessary.\n     * 对缓存目录的初始化工作，检查目录是否存在\n     * 如果不存在就给重新创建一个\n     */\n    @Override\n    public synchronized void initialize() {\n        if (!mRootDirectory.exists()) {\n            if (!mRootDirectory.mkdirs()) {\n                VolleyLog.e(\"Unable to create cache dir %s\", mRootDirectory.getAbsolutePath());\n            }\n            return;\n        }\n\n        /**\n         * 如果缓存目录已经存在了\n         * 则将缓存目录下面的文件都扫描一遍\n         * 将关于缓存文件的部分信息加载到内存中来\n         * 方便后面对缓存的查询等工作\n         */\n\n        File[] files = mRootDirectory.listFiles();\n        if (files == null) {\n            return;\n        }\n        for (File file : files) {\n            BufferedInputStream fis = null;\n            try {\n                fis = new BufferedInputStream(new FileInputStream(file));\n                CacheHeader entry = CacheHeader.readHeader(fis);\n                entry.size = file.length();\n                putEntry(entry.key, entry);\n            } catch (IOException e) {\n                if (file != null) {\n                   file.delete();\n                }\n            } finally {\n                try {\n                    if (fis != null) {\n                        fis.close();\n                    }\n                } catch (IOException ignored) { }\n            }\n        }\n    }\n\n    /**\n     * Invalidates an entry in the cache.\n     * 将key对应的缓存作废\n     * 如果fullExpire为true，则将整个entry作废\n     * 如果为false,则只是软作废，也就是将缓存置于需要刷新的状态\n     *\n     * @param key Cache key\n     * @param fullExpire True to fully expire the entry, false to soft expire\n     */\n    @Override\n    public synchronized void invalidate(String key, boolean fullExpire) {\n        Entry entry = get(key);\n        if (entry != null) {\n            entry.softTtl = 0;\n            if (fullExpire) {\n                entry.ttl = 0;\n            }\n            put(key, entry);\n        }\n\n    }\n\n    /**\n     * Puts the entry with the specified key into the cache.\n     * 将entry中包含的信息存放到key对应的缓存文件中去\n     */\n    @Override\n    public synchronized void put(String key, Entry entry) {\n\n        pruneIfNeeded(entry.data.length);\n\n        File file = getFileForKey(key);\n        try {\n            BufferedOutputStream fos = new BufferedOutputStream(new FileOutputStream(file));\n            CacheHeader e = new CacheHeader(key, entry);\n            boolean success = e.writeHeader(fos);\n            if (!success) {\n                fos.close();\n                VolleyLog.d(\"Failed to write header for %s\", file.getAbsolutePath());\n                throw new IOException();\n            }\n            fos.write(entry.data);\n            fos.close();\n            putEntry(key, e);\n            return;\n        } catch (IOException e) {\n        }\n        boolean deleted = file.delete();\n        if (!deleted) {\n            VolleyLog.d(\"Could not clean up file %s\", file.getAbsolutePath());\n        }\n    }\n\n    /**\n     * Removes the specified key from the cache if it exists.\n     */\n    @Override\n    public synchronized void remove(String key) {\n        boolean deleted = getFileForKey(key).delete();\n        removeEntry(key);\n        if (!deleted) {\n            VolleyLog.d(\"Could not delete cache entry for key=%s, filename=%s\",\n                    key, getFilenameForKey(key));\n        }\n    }\n\n    /**\n     * Creates a pseudo-unique filename for the specified cache key.\n     * 通过给定的key，前半段的hashCode和后半段的hashCode连接起来\n     * 作为一个独一无二的文件名\n     * @param key The key to generate a file name for.\n     * @return A pseudo-unique filename.\n     */\n    private String getFilenameForKey(String key) {\n        int firstHalfLength = key.length() / 2;\n        String localFilename = String.valueOf(key.substring(0, firstHalfLength).hashCode());\n        localFilename += String.valueOf(key.substring(firstHalfLength).hashCode());\n        return localFilename;\n    }\n\n    /**\n     * Returns a file object for the given cache key.\n     * 通过调用getFilenameForKey()方法来获取相对路径\n     */\n    public File getFileForKey(String key) {\n        return new File(mRootDirectory, getFilenameForKey(key));\n    }\n\n    /**\n     * Prunes the cache to fit the amount of bytes specified.\n     * 从已有的缓存中清除数据\n     * 直到扫出了一片neededSapce大小的空地为止\n     * @param neededSpace The amount of bytes we are trying to fit into the cache.\n     */\n    private void pruneIfNeeded(int neededSpace) {\n        if ((mTotalSize + neededSpace) < mMaxCacheSizeInBytes) {\n            return;\n        }\n        if (VolleyLog.DEBUG) {\n            VolleyLog.v(\"Pruning old cache entries.\");\n        }\n\n        long before = mTotalSize;\n        int prunedFiles = 0;\n        long startTime = SystemClock.elapsedRealtime();\n\n        Iterator<Map.Entry<String, CacheHeader>> iterator = mEntries.entrySet().iterator();\n\n        while (iterator.hasNext()) {\n\n            Map.Entry<String, CacheHeader> entry = iterator.next();\n\n            CacheHeader e = entry.getValue();\n\n            boolean deleted = getFileForKey(e.key).delete();\n\n            if (deleted) {\n                mTotalSize -= e.size;\n            } else {\n               VolleyLog.d(\"Could not delete cache entry for key=%s, filename=%s\",\n                       e.key, getFilenameForKey(e.key));\n            }\n            iterator.remove();\n            prunedFiles++;\n\n            /**\n             * 一直清除缓存\n             * 直到存入这个neededSapce之后还有一小部分空余的地方\n             */\n            if ((mTotalSize + neededSpace) < mMaxCacheSizeInBytes * HYSTERESIS_FACTOR) {\n                break;\n            }\n        }\n\n        if (VolleyLog.DEBUG) {\n            VolleyLog.v(\"pruned %d files, %d bytes, %d ms\",\n                    prunedFiles, (mTotalSize - before), SystemClock.elapsedRealtime() - startTime);\n        }\n    }\n\n    /**\n     * Puts the entry with the specified key into the cache.\n     * 将目录下指定的缓存加载到mEntries中去\n     * 为了方便之后对缓存的读写操作\n     * 全部读写一遍放在内存里面，对查询什么的都会方便很多\n     *\n     * @param key The key to identify the entry by.\n     * @param entry The entry to cache.\n     */\n    private void putEntry(String key, CacheHeader entry) {\n        if (!mEntries.containsKey(key)) {\n            mTotalSize += entry.size;\n        } else {\n            CacheHeader oldEntry = mEntries.get(key);\n            mTotalSize += (entry.size - oldEntry.size);\n        }\n        mEntries.put(key, entry);\n    }\n\n    /**\n     * Removes the entry identified by 'key' from the cache.\n     */\n    private void removeEntry(String key) {\n        CacheHeader entry = mEntries.get(key);\n        if (entry != null) {\n            mTotalSize -= entry.size;\n            mEntries.remove(key);\n        }\n    }\n\n    /**\n     * Reads the contents of an InputStream into a byte[].\n     * 从InputStream中读取指定长度的数据\n     * \n     */\n    private static byte[] streamToBytes(InputStream in, int length) throws IOException {\n        byte[] bytes = new byte[length];\n        int count;\n        int pos = 0;\n        while (pos < length && ((count = in.read(bytes, pos, length - pos)) != -1)) {\n            pos += count;\n        }\n        if (pos != length) {\n            throw new IOException(\"Expected \" + length + \" bytes, read \" + pos + \" bytes\");\n        }\n        return bytes;\n    }\n\n    /**\n     * Handles holding onto the cache headers for an entry.\n     */\n    // Visible for testing.\n    static class CacheHeader {\n        /** \n         * The size of the data identified by this CacheHeader. (This is not\n         * serialized to disk.\n         * \n         * CacheHeader所表示的数据段的大小 \n         */\n        public long size;\n\n        /** \n         * The key that identifies the cache entry. \n         * 这个key应该是request对应其缓存的唯一key\n         */\n        public String key;\n\n        /** \n         * ETag for cache coherence.\n         *\n         */\n        public String etag;\n\n        /** \n         * Date of this response as reported by the server. \n         * 缓存起来的数据返回的日期\n         */\n        public long serverDate;\n\n        /** \n         * The last modified date for the requested object. \n         * 最后一次更改的时间\n         */\n        public long lastModified;\n\n        /** \n         * TTL for this record. \n         * ping时候返回的TTL=128的概念如下\n         * TTL：生存时间\n         * 指定数据报被路由器丢弃之前允许通过的网段数量。\n         * TTL 是由发送主机设置的，以防止数据包不断在 IP 互联网络上永不终止地循环。转发 IP 数据包时，要求路由器至少将 TTL 减小 1。\n         *  \n         * 但是= =，注意这里的和上面的那种不是一个概念，这里只是模拟了上面的概念，但也是用来标志缓存存活时间的。\n         */\n        public long ttl;\n\n        /** \n         * Soft TTL for this record. \n         * \n         * 根据refreshNeeded()函数来看\n         * 意思是需要更新缓存的时间点\n         */\n        public long softTtl;\n\n        /** \n         * Headers from the response resulting in this cache entry. \n         * 用来指向上一次response的header\n         */\n        public Map<String, String> responseHeaders;\n\n        private CacheHeader() { }\n\n        /**\n         * Instantiates a new CacheHeader object\n         * @param key The key that identifies the cache entry\n         * @param entry The cache entry.\n         */\n        public CacheHeader(String key, Entry entry) {\n            this.key = key;\n            this.size = entry.data.length;\n            this.etag = entry.etag;\n            this.serverDate = entry.serverDate;\n            this.lastModified = entry.lastModified;\n            this.ttl = entry.ttl;\n            this.softTtl = entry.softTtl;\n            this.responseHeaders = entry.responseHeaders;\n        }\n\n        /**\n         * Reads the header off of an InputStream and returns a CacheHeader object.\n         * 从InputStream中读取数据并组建一个CacheHeader对象实例\n         * @param is The InputStream to read from.\n         * @throws IOException\n         */\n        public static CacheHeader readHeader(InputStream is) throws IOException {\n            CacheHeader entry = new CacheHeader();\n            int magic = readInt(is);\n            if (magic != CACHE_MAGIC) {\n                // don't bother deleting, it'll get pruned eventually\n                throw new IOException();\n            }\n            entry.key = readString(is);\n            entry.etag = readString(is);\n            if (entry.etag.equals(\"\")) {\n                entry.etag = null;\n            }\n            entry.serverDate = readLong(is);\n            entry.lastModified = readLong(is);\n            entry.ttl = readLong(is);\n            entry.softTtl = readLong(is);\n            entry.responseHeaders = readStringStringMap(is);\n\n            return entry;\n        }\n\n        /**\n         * Creates a cache entry for the specified data.\n         * 从CacheHeader转换成Entry类的实例\n         */\n        public Entry toCacheEntry(byte[] data) {\n            Entry e = new Entry();\n            e.data = data;\n            e.etag = etag;\n            e.serverDate = serverDate;\n            e.lastModified = lastModified;\n            e.ttl = ttl;\n            e.softTtl = softTtl;\n            e.responseHeaders = responseHeaders;\n            return e;\n        }\n\n        /**\n         * Writes the contents of this CacheHeader to the specified OutputStream.\n         * 将CacheHeader里面的数据写入指定的OutputStream中\n         */\n        public boolean writeHeader(OutputStream os) {\n            try {\n                writeInt(os, CACHE_MAGIC);\n                writeString(os, key);\n                writeString(os, etag == null ? \"\" : etag);\n                writeLong(os, serverDate);\n                writeLong(os, lastModified);\n                writeLong(os, ttl);\n                writeLong(os, softTtl);\n                writeStringStringMap(responseHeaders, os);\n                os.flush();\n                return true;\n            } catch (IOException e) {\n                VolleyLog.d(\"%s\", e.toString());\n                return false;\n            }\n        }\n\n    }\n\n    /**\n     * 继承了FilterInputStream\n     * 没啥特别的= =\n     */\n\n    private static class CountingInputStream extends FilterInputStream {\n\n        private int bytesRead = 0;\n\n        private CountingInputStream(InputStream in) {\n            super(in);\n        }\n\n        @Override\n        public int read() throws IOException {\n            int result = super.read();\n            if (result != -1) {\n                bytesRead++;\n            }\n            return result;\n        }\n\n        @Override\n        public int read(byte[] buffer, int offset, int count) throws IOException {\n            int result = super.read(buffer, offset, count);\n            if (result != -1) {\n                bytesRead += result;\n            }\n            return result;\n        }\n    }\n\n    /*\n     * Homebrewed simple serialization system used for reading and writing cache\n     * headers on disk. Once upon a time, this used the standard Java\n     * Object{Input,Output}Stream, but the default implementation relies heavily\n     * on reflection (even for standard types) and generates a ton of garbage.\n     * \n     */\n\n    /**\n     * Simple wrapper around {@link InputStream#read()} that throws EOFException\n     * instead of returning -1.\n     * 如果文件读到了末尾直接抛出异常\n     */\n    private static int read(InputStream is) throws IOException {\n        int b = is.read();\n        if (b == -1) {\n            throw new EOFException();\n        }\n        return b;\n    }\n\n    /**\n     * 刚开始看到这里的时候没有明白是什么意思= =\n     * 就不明白了，好好的一个int类型的数据\n     * 为什么非要分段写入呢，一个字节一个字节的写入\n     * 后来查了资料才发现，OutputStream及其子类的write()方法\n     * 一次都只能写入一个byte，int类型有4个byte，分四次写入没什么问题咯\n     */\n\n    static void writeInt(OutputStream os, int n) throws IOException {\n        os.write((n >> 0) & 0xff);\n        os.write((n >> 8) & 0xff);\n        os.write((n >> 16) & 0xff);\n        os.write((n >> 24) & 0xff);\n    }\n\n    static int readInt(InputStream is) throws IOException {\n        int n = 0;\n        n |= (read(is) << 0);\n        n |= (read(is) << 8);\n        n |= (read(is) << 16);\n        n |= (read(is) << 24);\n        return n;\n    }\n\n    static void writeLong(OutputStream os, long n) throws IOException {\n        os.write((byte)(n >>> 0));\n        os.write((byte)(n >>> 8));\n        os.write((byte)(n >>> 16));\n        os.write((byte)(n >>> 24));\n        os.write((byte)(n >>> 32));\n        os.write((byte)(n >>> 40));\n        os.write((byte)(n >>> 48));\n        os.write((byte)(n >>> 56));\n    }\n\n    static long readLong(InputStream is) throws IOException {\n        long n = 0;\n        n |= ((read(is) & 0xFFL) << 0);\n        n |= ((read(is) & 0xFFL) << 8);\n        n |= ((read(is) & 0xFFL) << 16);\n        n |= ((read(is) & 0xFFL) << 24);\n        n |= ((read(is) & 0xFFL) << 32);\n        n |= ((read(is) & 0xFFL) << 40);\n        n |= ((read(is) & 0xFFL) << 48);\n        n |= ((read(is) & 0xFFL) << 56);\n        return n;\n    }\n\n    static void writeString(OutputStream os, String s) throws IOException {\n        byte[] b = s.getBytes(\"UTF-8\");\n        writeLong(os, b.length);\n        os.write(b, 0, b.length);\n    }\n\n    static String readString(InputStream is) throws IOException {\n        int n = (int) readLong(is);\n        byte[] b = streamToBytes(is, n);\n        return new String(b, \"UTF-8\");\n    }\n\n    static void writeStringStringMap(Map<String, String> map, OutputStream os) throws IOException {\n        if (map != null) {\n            writeInt(os, map.size());\n            for (Map.Entry<String, String> entry : map.entrySet()) {\n                writeString(os, entry.getKey());\n                writeString(os, entry.getValue());\n            }\n        } else {\n            writeInt(os, 0);\n        }\n    }\n\n    /**\n     * 从InputStream中读取key类型为String，值类型也为String的Map\n     */ \n    static Map<String, String> readStringStringMap(InputStream is) throws IOException {\n        int size = readInt(is);\n        Map<String, String> result = (size == 0)\n                ? Collections.<String, String>emptyMap()\n                : new HashMap<String, String>(size);\n        for (int i = 0; i < size; i++) {\n\n            //将读出来的byte[]转换成String\n\n            String key = readString(is).intern();\n            String value = readString(is).intern();\n            result.put(key, value);\n        }\n        return result;\n    }\n}\n\n```\n\n涉及到缓存读写的这个实现类当时阅读的时候还是花了不少时间的= =，人太笨了没办法orz，有什么不妥的地方还望各位juju多多指教，小达感激不尽0.0。下面还有Request.java等类等着去解析呢，Volley中的主角要登场了╭(╯^╰)╮。","slug":"Volley框架解析-六-Cache接口及其默认实现类解析","published":1,"updated":"2020-07-03T02:40:48.122Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc5n2qha000pw8r1rwj1hpks","content":"<h3 id=\"1-前言-可直接无视跳过\"><a href=\"#1-前言-可直接无视跳过\" class=\"headerlink\" title=\"1. 前言(可直接无视跳过\"></a>1. 前言(可直接无视跳过</h3><p>前面涉及到网络的部分都介绍完了，在处理网络请求返回的数据时，会根据request结果是否需要缓存来进行不同的处理。如需要缓存结果，就涉及到了<code>Cache.java</code>及其默认实现类<code>DiskBasedCache.java</code>。</p>\n<a id=\"more\"></a>\n<h3 id=\"2-Cache-java\"><a href=\"#2-Cache-java\" class=\"headerlink\" title=\"2. Cache.java\"></a>2. Cache.java</h3><p>用于处理缓存的接口，里面有很多抽象的方法等着被实现，里面还有一个static类<code>Entry</code>,里面有些关于缓存的单元信息。(例如，缓存的内容，缓存过期的时间，缓存需要刷新的时间等等）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div></pre></td><td class=\"code\"><pre><div class=\"line\">package com.android.volley;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\"> * An interface for a cache keyed by a String with * a byte array as data.</div><div class=\"line\"> * 一个用于缓存的接口</div><div class=\"line\"> */</div><div class=\"line\">public interface Cache &#123;</div><div class=\"line\">    /**</div><div class=\"line\">     * Retrieves an entry from the cache.</div><div class=\"line\">     * 用来获取缓存的入口，通过传入的key</div><div class=\"line\">     * </div><div class=\"line\">     * @param key Cache key</div><div class=\"line\">     * 这个key应该是request对应其缓存的唯一key</div><div class=\"line\">     *</div><div class=\"line\">     * @return An &#123;@link Entry&#125; or null in the event of a cache miss</div><div class=\"line\">     */</div><div class=\"line\">    public Entry get(String key);</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Adds or replaces an entry to the cache.</div><div class=\"line\">     * 添加或者给request更新缓存</div><div class=\"line\">     * @param key Cache key</div><div class=\"line\">     * @param entry Data to store and metadata for cache coherency, TTL, etc.</div><div class=\"line\">     */</div><div class=\"line\">    public void put(String key, Entry entry);</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Performs any potentially long-running actions needed to initialize the cache;</div><div class=\"line\">     * will be called from a worker thread.</div><div class=\"line\">     */</div><div class=\"line\">    public void initialize();</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Invalidates an entry in the cache.</div><div class=\"line\">     * 这个函数是将key对应的缓存置于过期</div><div class=\"line\">     * 分为fully expire和soft expire， 目前还不知道是什么意思 = =</div><div class=\"line\">     * </div><div class=\"line\">     * @param key Cache key</div><div class=\"line\">     * @param fullExpire True to fully expire the entry, false to soft expire</div><div class=\"line\">     */</div><div class=\"line\">    public void invalidate(String key, boolean fullExpire);</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Removes an entry from the cache.</div><div class=\"line\">     * 将key对应的缓存直接移除掉</div><div class=\"line\">     * </div><div class=\"line\">     * @param key Cache key</div><div class=\"line\">     */</div><div class=\"line\">    public void remove(String key);</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Empties the cache.</div><div class=\"line\">     * 清除所有的缓存</div><div class=\"line\">     */</div><div class=\"line\">    public void clear();</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Data and metadata for an entry returned by the cache.</div><div class=\"line\">     */</div><div class=\"line\">    public static class Entry &#123;</div><div class=\"line\">        /** The data returned from cache. */</div><div class=\"line\">        public byte[] data;</div><div class=\"line\"></div><div class=\"line\">        /** ETag for cache coherency. */</div><div class=\"line\">        public String etag;</div><div class=\"line\"></div><div class=\"line\">        /** Date of this response as reported by the server. */</div><div class=\"line\">        public long serverDate;</div><div class=\"line\"></div><div class=\"line\">        /** The last modified date for the requested object. */</div><div class=\"line\">        public long lastModified;</div><div class=\"line\"></div><div class=\"line\">        /** TTL for this record.</div><div class=\"line\">         *  根据后面的isExpired()函数来看</div><div class=\"line\">         *  该条数据的意思应该是缓存过期的时间 </div><div class=\"line\">         */</div><div class=\"line\">        public long ttl;</div><div class=\"line\"></div><div class=\"line\">        /** Soft TTL for this record. </div><div class=\"line\">         *  根据refreshNeeded()函数来看</div><div class=\"line\">         *  意思是需要更新缓存的时间点</div><div class=\"line\">         */</div><div class=\"line\">        public long softTtl;</div><div class=\"line\"></div><div class=\"line\">        /** Immutable response headers as received from server; must be non-null. */</div><div class=\"line\">        public Map&lt;String, String&gt; responseHeaders = Collections.emptyMap();</div><div class=\"line\"></div><div class=\"line\">       /** </div><div class=\"line\">         * True if the entry is expired. </div><div class=\"line\">         * 用来查看缓存是否过期了</div><div class=\"line\">         */</div><div class=\"line\">        public boolean isExpired() &#123;</div><div class=\"line\">            return this.ttl &lt; System.currentTimeMillis();</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        /** True if a refresh is needed from the original data source. */</div><div class=\"line\">        public boolean refreshNeeded() &#123;</div><div class=\"line\">            return this.softTtl &lt; System.currentTimeMillis();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"3-DiskBasedCache-java\"><a href=\"#3-DiskBasedCache-java\" class=\"headerlink\" title=\"3. DiskBasedCache.java\"></a>3. DiskBasedCache.java</h3><p>实现了Cache.java接口，专门和本地存储的文件打交道，负责缓存的写入与读取。涉及到了一部分InputStream和OutputStream还有File的知识。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div><div class=\"line\">204</div><div class=\"line\">205</div><div class=\"line\">206</div><div class=\"line\">207</div><div class=\"line\">208</div><div class=\"line\">209</div><div class=\"line\">210</div><div class=\"line\">211</div><div class=\"line\">212</div><div class=\"line\">213</div><div class=\"line\">214</div><div class=\"line\">215</div><div class=\"line\">216</div><div class=\"line\">217</div><div class=\"line\">218</div><div class=\"line\">219</div><div class=\"line\">220</div><div class=\"line\">221</div><div class=\"line\">222</div><div class=\"line\">223</div><div class=\"line\">224</div><div class=\"line\">225</div><div class=\"line\">226</div><div class=\"line\">227</div><div class=\"line\">228</div><div class=\"line\">229</div><div class=\"line\">230</div><div class=\"line\">231</div><div class=\"line\">232</div><div class=\"line\">233</div><div class=\"line\">234</div><div class=\"line\">235</div><div class=\"line\">236</div><div class=\"line\">237</div><div class=\"line\">238</div><div class=\"line\">239</div><div class=\"line\">240</div><div class=\"line\">241</div><div class=\"line\">242</div><div class=\"line\">243</div><div class=\"line\">244</div><div class=\"line\">245</div><div class=\"line\">246</div><div class=\"line\">247</div><div class=\"line\">248</div><div class=\"line\">249</div><div class=\"line\">250</div><div class=\"line\">251</div><div class=\"line\">252</div><div class=\"line\">253</div><div class=\"line\">254</div><div class=\"line\">255</div><div class=\"line\">256</div><div class=\"line\">257</div><div class=\"line\">258</div><div class=\"line\">259</div><div class=\"line\">260</div><div class=\"line\">261</div><div class=\"line\">262</div><div class=\"line\">263</div><div class=\"line\">264</div><div class=\"line\">265</div><div class=\"line\">266</div><div class=\"line\">267</div><div class=\"line\">268</div><div class=\"line\">269</div><div class=\"line\">270</div><div class=\"line\">271</div><div class=\"line\">272</div><div class=\"line\">273</div><div class=\"line\">274</div><div class=\"line\">275</div><div class=\"line\">276</div><div class=\"line\">277</div><div class=\"line\">278</div><div class=\"line\">279</div><div class=\"line\">280</div><div class=\"line\">281</div><div class=\"line\">282</div><div class=\"line\">283</div><div class=\"line\">284</div><div class=\"line\">285</div><div class=\"line\">286</div><div class=\"line\">287</div><div class=\"line\">288</div><div class=\"line\">289</div><div class=\"line\">290</div><div class=\"line\">291</div><div class=\"line\">292</div><div class=\"line\">293</div><div class=\"line\">294</div><div class=\"line\">295</div><div class=\"line\">296</div><div class=\"line\">297</div><div class=\"line\">298</div><div class=\"line\">299</div><div class=\"line\">300</div><div class=\"line\">301</div><div class=\"line\">302</div><div class=\"line\">303</div><div class=\"line\">304</div><div class=\"line\">305</div><div class=\"line\">306</div><div class=\"line\">307</div><div class=\"line\">308</div><div class=\"line\">309</div><div class=\"line\">310</div><div class=\"line\">311</div><div class=\"line\">312</div><div class=\"line\">313</div><div class=\"line\">314</div><div class=\"line\">315</div><div class=\"line\">316</div><div class=\"line\">317</div><div class=\"line\">318</div><div class=\"line\">319</div><div class=\"line\">320</div><div class=\"line\">321</div><div class=\"line\">322</div><div class=\"line\">323</div><div class=\"line\">324</div><div class=\"line\">325</div><div class=\"line\">326</div><div class=\"line\">327</div><div class=\"line\">328</div><div class=\"line\">329</div><div class=\"line\">330</div><div class=\"line\">331</div><div class=\"line\">332</div><div class=\"line\">333</div><div class=\"line\">334</div><div class=\"line\">335</div><div class=\"line\">336</div><div class=\"line\">337</div><div class=\"line\">338</div><div class=\"line\">339</div><div class=\"line\">340</div><div class=\"line\">341</div><div class=\"line\">342</div><div class=\"line\">343</div><div class=\"line\">344</div><div class=\"line\">345</div><div class=\"line\">346</div><div class=\"line\">347</div><div class=\"line\">348</div><div class=\"line\">349</div><div class=\"line\">350</div><div class=\"line\">351</div><div class=\"line\">352</div><div class=\"line\">353</div><div class=\"line\">354</div><div class=\"line\">355</div><div class=\"line\">356</div><div class=\"line\">357</div><div class=\"line\">358</div><div class=\"line\">359</div><div class=\"line\">360</div><div class=\"line\">361</div><div class=\"line\">362</div><div class=\"line\">363</div><div class=\"line\">364</div><div class=\"line\">365</div><div class=\"line\">366</div><div class=\"line\">367</div><div class=\"line\">368</div><div class=\"line\">369</div><div class=\"line\">370</div><div class=\"line\">371</div><div class=\"line\">372</div><div class=\"line\">373</div><div class=\"line\">374</div><div class=\"line\">375</div><div class=\"line\">376</div><div class=\"line\">377</div><div class=\"line\">378</div><div class=\"line\">379</div><div class=\"line\">380</div><div class=\"line\">381</div><div class=\"line\">382</div><div class=\"line\">383</div><div class=\"line\">384</div><div class=\"line\">385</div><div class=\"line\">386</div><div class=\"line\">387</div><div class=\"line\">388</div><div class=\"line\">389</div><div class=\"line\">390</div><div class=\"line\">391</div><div class=\"line\">392</div><div class=\"line\">393</div><div class=\"line\">394</div><div class=\"line\">395</div><div class=\"line\">396</div><div class=\"line\">397</div><div class=\"line\">398</div><div class=\"line\">399</div><div class=\"line\">400</div><div class=\"line\">401</div><div class=\"line\">402</div><div class=\"line\">403</div><div class=\"line\">404</div><div class=\"line\">405</div><div class=\"line\">406</div><div class=\"line\">407</div><div class=\"line\">408</div><div class=\"line\">409</div><div class=\"line\">410</div><div class=\"line\">411</div><div class=\"line\">412</div><div class=\"line\">413</div><div class=\"line\">414</div><div class=\"line\">415</div><div class=\"line\">416</div><div class=\"line\">417</div><div class=\"line\">418</div><div class=\"line\">419</div><div class=\"line\">420</div><div class=\"line\">421</div><div class=\"line\">422</div><div class=\"line\">423</div><div class=\"line\">424</div><div class=\"line\">425</div><div class=\"line\">426</div><div class=\"line\">427</div><div class=\"line\">428</div><div class=\"line\">429</div><div class=\"line\">430</div><div class=\"line\">431</div><div class=\"line\">432</div><div class=\"line\">433</div><div class=\"line\">434</div><div class=\"line\">435</div><div class=\"line\">436</div><div class=\"line\">437</div><div class=\"line\">438</div><div class=\"line\">439</div><div class=\"line\">440</div><div class=\"line\">441</div><div class=\"line\">442</div><div class=\"line\">443</div><div class=\"line\">444</div><div class=\"line\">445</div><div class=\"line\">446</div><div class=\"line\">447</div><div class=\"line\">448</div><div class=\"line\">449</div><div class=\"line\">450</div><div class=\"line\">451</div><div class=\"line\">452</div><div class=\"line\">453</div><div class=\"line\">454</div><div class=\"line\">455</div><div class=\"line\">456</div><div class=\"line\">457</div><div class=\"line\">458</div><div class=\"line\">459</div><div class=\"line\">460</div><div class=\"line\">461</div><div class=\"line\">462</div><div class=\"line\">463</div><div class=\"line\">464</div><div class=\"line\">465</div><div class=\"line\">466</div><div class=\"line\">467</div><div class=\"line\">468</div><div class=\"line\">469</div><div class=\"line\">470</div><div class=\"line\">471</div><div class=\"line\">472</div><div class=\"line\">473</div><div class=\"line\">474</div><div class=\"line\">475</div><div class=\"line\">476</div><div class=\"line\">477</div><div class=\"line\">478</div><div class=\"line\">479</div><div class=\"line\">480</div><div class=\"line\">481</div><div class=\"line\">482</div><div class=\"line\">483</div><div class=\"line\">484</div><div class=\"line\">485</div><div class=\"line\">486</div><div class=\"line\">487</div><div class=\"line\">488</div><div class=\"line\">489</div><div class=\"line\">490</div><div class=\"line\">491</div><div class=\"line\">492</div><div class=\"line\">493</div><div class=\"line\">494</div><div class=\"line\">495</div><div class=\"line\">496</div><div class=\"line\">497</div><div class=\"line\">498</div><div class=\"line\">499</div><div class=\"line\">500</div><div class=\"line\">501</div><div class=\"line\">502</div><div class=\"line\">503</div><div class=\"line\">504</div><div class=\"line\">505</div><div class=\"line\">506</div><div class=\"line\">507</div><div class=\"line\">508</div><div class=\"line\">509</div><div class=\"line\">510</div><div class=\"line\">511</div><div class=\"line\">512</div><div class=\"line\">513</div><div class=\"line\">514</div><div class=\"line\">515</div><div class=\"line\">516</div><div class=\"line\">517</div><div class=\"line\">518</div><div class=\"line\">519</div><div class=\"line\">520</div><div class=\"line\">521</div><div class=\"line\">522</div><div class=\"line\">523</div><div class=\"line\">524</div><div class=\"line\">525</div><div class=\"line\">526</div><div class=\"line\">527</div><div class=\"line\">528</div><div class=\"line\">529</div><div class=\"line\">530</div><div class=\"line\">531</div><div class=\"line\">532</div><div class=\"line\">533</div><div class=\"line\">534</div><div class=\"line\">535</div><div class=\"line\">536</div><div class=\"line\">537</div><div class=\"line\">538</div><div class=\"line\">539</div><div class=\"line\">540</div><div class=\"line\">541</div><div class=\"line\">542</div><div class=\"line\">543</div><div class=\"line\">544</div><div class=\"line\">545</div><div class=\"line\">546</div><div class=\"line\">547</div><div class=\"line\">548</div><div class=\"line\">549</div><div class=\"line\">550</div><div class=\"line\">551</div><div class=\"line\">552</div><div class=\"line\">553</div><div class=\"line\">554</div><div class=\"line\">555</div><div class=\"line\">556</div><div class=\"line\">557</div><div class=\"line\">558</div><div class=\"line\">559</div><div class=\"line\">560</div><div class=\"line\">561</div><div class=\"line\">562</div><div class=\"line\">563</div><div class=\"line\">564</div><div class=\"line\">565</div><div class=\"line\">566</div><div class=\"line\">567</div><div class=\"line\">568</div><div class=\"line\">569</div><div class=\"line\">570</div><div class=\"line\">571</div><div class=\"line\">572</div><div class=\"line\">573</div><div class=\"line\">574</div><div class=\"line\">575</div><div class=\"line\">576</div><div class=\"line\">577</div><div class=\"line\">578</div><div class=\"line\">579</div><div class=\"line\">580</div><div class=\"line\">581</div><div class=\"line\">582</div><div class=\"line\">583</div><div class=\"line\">584</div><div class=\"line\">585</div><div class=\"line\">586</div><div class=\"line\">587</div><div class=\"line\">588</div><div class=\"line\">589</div><div class=\"line\">590</div><div class=\"line\">591</div><div class=\"line\">592</div><div class=\"line\">593</div><div class=\"line\">594</div><div class=\"line\">595</div><div class=\"line\">596</div><div class=\"line\">597</div><div class=\"line\">598</div><div class=\"line\">599</div><div class=\"line\">600</div><div class=\"line\">601</div><div class=\"line\">602</div><div class=\"line\">603</div><div class=\"line\">604</div><div class=\"line\">605</div><div class=\"line\">606</div><div class=\"line\">607</div><div class=\"line\">608</div><div class=\"line\">609</div><div class=\"line\">610</div><div class=\"line\">611</div><div class=\"line\">612</div><div class=\"line\">613</div><div class=\"line\">614</div><div class=\"line\">615</div><div class=\"line\">616</div><div class=\"line\">617</div><div class=\"line\">618</div><div class=\"line\">619</div><div class=\"line\">620</div><div class=\"line\">621</div><div class=\"line\">622</div><div class=\"line\">623</div><div class=\"line\">624</div><div class=\"line\">625</div><div class=\"line\">626</div><div class=\"line\">627</div><div class=\"line\">628</div><div class=\"line\">629</div><div class=\"line\">630</div><div class=\"line\">631</div><div class=\"line\">632</div><div class=\"line\">633</div><div class=\"line\">634</div><div class=\"line\">635</div><div class=\"line\">636</div><div class=\"line\">637</div><div class=\"line\">638</div><div class=\"line\">639</div><div class=\"line\">640</div><div class=\"line\">641</div><div class=\"line\">642</div><div class=\"line\">643</div><div class=\"line\">644</div><div class=\"line\">645</div><div class=\"line\">646</div><div class=\"line\">647</div><div class=\"line\">648</div><div class=\"line\">649</div><div class=\"line\">650</div><div class=\"line\">651</div><div class=\"line\">652</div><div class=\"line\">653</div><div class=\"line\">654</div><div class=\"line\">655</div><div class=\"line\">656</div><div class=\"line\">657</div><div class=\"line\">658</div><div class=\"line\">659</div><div class=\"line\">660</div><div class=\"line\">661</div><div class=\"line\">662</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * Cache implementation that caches files directly onto the hard disk in the specified</div><div class=\"line\"> * directory. The default disk usage size is 5MB, but is configurable.</div><div class=\"line\"> * 实现了Cache接口</div><div class=\"line\"> * 专门用于和本地文件交互的一个类</div><div class=\"line\"> * 存入缓存和取出缓存等功能</div><div class=\"line\"> */</div><div class=\"line\">public class DiskBasedCache implements Cache &#123;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Map of the Key, CacheHeader pairs </div><div class=\"line\">     * CacheHeader.java为本类中的一个static类</div><div class=\"line\">     * 里面存放着一些</div><div class=\"line\">     */</div><div class=\"line\">    private final Map&lt;String, CacheHeader&gt; mEntries =</div><div class=\"line\">            new LinkedHashMap&lt;String, CacheHeader&gt;(16, .75f, true);</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * Total amount of space currently used by the cache in bytes. </div><div class=\"line\">     * 当前缓存的总大小</div><div class=\"line\">     */</div><div class=\"line\">    private long mTotalSize = 0;</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * The root directory to use for the cache. </div><div class=\"line\">     * 缓存的根目录</div><div class=\"line\">     */</div><div class=\"line\">    private final File mRootDirectory;</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * The maximum size of the cache in bytes. </div><div class=\"line\">     * 缓存能接受的最大字节数</div><div class=\"line\">     */</div><div class=\"line\">    private final int mMaxCacheSizeInBytes;</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * Default maximum disk usage in bytes.</div><div class=\"line\">     * 默认缓存能使用的最大空间</div><div class=\"line\">     */</div><div class=\"line\">    private static final int DEFAULT_DISK_USAGE_BYTES = 5 * 1024 * 1024;</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * High water mark percentage for the cache</div><div class=\"line\">     * 类似于水位警戒线一样的标识</div><div class=\"line\">     */</div><div class=\"line\">    private static final float HYSTERESIS_FACTOR = 0.9f;</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * Magic number for current version of cache file format. </div><div class=\"line\">     * </div><div class=\"line\">     */</div><div class=\"line\">    private static final int CACHE_MAGIC = 0x20150306;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Constructs an instance of the DiskBasedCache at the specified directory.</div><div class=\"line\">     * 在指定的目录下面创建一个DiskBasedCache</div><div class=\"line\">     *</div><div class=\"line\">     * @param rootDirectory The root directory of the cache.</div><div class=\"line\">     * @param maxCacheSizeInBytes The maximum size of the cache in bytes.</div><div class=\"line\">     */</div><div class=\"line\">    public DiskBasedCache(File rootDirectory, int maxCacheSizeInBytes) &#123;</div><div class=\"line\">        mRootDirectory = rootDirectory;</div><div class=\"line\">        mMaxCacheSizeInBytes = maxCacheSizeInBytes;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Constructs an instance of the DiskBasedCache at the specified directory using</div><div class=\"line\">     * the default maximum cache size of 5MB.</div><div class=\"line\">     * @param rootDirectory The root directory of the cache.</div><div class=\"line\">     */</div><div class=\"line\">    public DiskBasedCache(File rootDirectory) &#123;</div><div class=\"line\">        this(rootDirectory, DEFAULT_DISK_USAGE_BYTES);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Clears the cache. Deletes all cached files from disk.</div><div class=\"line\">     * 清除当前目录下的缓存，删除所有缓存文件 </div><div class=\"line\">     */</div><div class=\"line\">    @Override</div><div class=\"line\">    public synchronized void clear() &#123;</div><div class=\"line\">        File[] files = mRootDirectory.listFiles();</div><div class=\"line\">        if (files != null) &#123;</div><div class=\"line\">            for (File file : files) &#123;</div><div class=\"line\">                file.delete();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        mEntries.clear();</div><div class=\"line\">        mTotalSize = 0;</div><div class=\"line\">        VolleyLog.d(&quot;Cache cleared.&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Returns the cache entry with the specified key if it exists, null otherwise.</div><div class=\"line\">     * 通过特殊的key，来获取与缓存交流的接口(entry)</div><div class=\"line\">     * 如果没有的话则返回null</div><div class=\"line\">     */</div><div class=\"line\">    @Override</div><div class=\"line\">    public synchronized Entry get(String key) &#123;</div><div class=\"line\"></div><div class=\"line\">        CacheHeader entry = mEntries.get(key);</div><div class=\"line\">        // if the entry does not exist, return.</div><div class=\"line\">        if (entry == null) &#123;</div><div class=\"line\">            return null;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        //依据key获取缓存的文件，如果不存在则创建一个</div><div class=\"line\">        File file = getFileForKey(key);</div><div class=\"line\"></div><div class=\"line\">        CountingInputStream cis = null;</div><div class=\"line\"></div><div class=\"line\">        try &#123;</div><div class=\"line\"></div><div class=\"line\">            cis = new CountingInputStream(new BufferedInputStream(new FileInputStream(file)));</div><div class=\"line\">            CacheHeader.readHeader(cis); // eat header</div><div class=\"line\">            byte[] data = streamToBytes(cis, (int) (file.length() - cis.bytesRead));</div><div class=\"line\">            return entry.toCacheEntry(data);</div><div class=\"line\"></div><div class=\"line\">        &#125; catch (IOException e) &#123;</div><div class=\"line\">            VolleyLog.d(&quot;%s: %s&quot;, file.getAbsolutePath(), e.toString());</div><div class=\"line\">            remove(key);</div><div class=\"line\">            return null;</div><div class=\"line\">        &#125;  catch (NegativeArraySizeException e) &#123;</div><div class=\"line\">            VolleyLog.d(&quot;%s: %s&quot;, file.getAbsolutePath(), e.toString());</div><div class=\"line\">            remove(key);</div><div class=\"line\">            return null;</div><div class=\"line\">        &#125; finally &#123;</div><div class=\"line\">            if (cis != null) &#123;</div><div class=\"line\">                try &#123;</div><div class=\"line\">                    cis.close();</div><div class=\"line\">                &#125; catch (IOException ioe) &#123;</div><div class=\"line\">                    return null;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Initializes the DiskBasedCache by scanning for all files currently in the</div><div class=\"line\">     * specified root directory. Creates the root directory if necessary.</div><div class=\"line\">     * 对缓存目录的初始化工作，检查目录是否存在</div><div class=\"line\">     * 如果不存在就给重新创建一个</div><div class=\"line\">     */</div><div class=\"line\">    @Override</div><div class=\"line\">    public synchronized void initialize() &#123;</div><div class=\"line\">        if (!mRootDirectory.exists()) &#123;</div><div class=\"line\">            if (!mRootDirectory.mkdirs()) &#123;</div><div class=\"line\">                VolleyLog.e(&quot;Unable to create cache dir %s&quot;, mRootDirectory.getAbsolutePath());</div><div class=\"line\">            &#125;</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * 如果缓存目录已经存在了</div><div class=\"line\">         * 则将缓存目录下面的文件都扫描一遍</div><div class=\"line\">         * 将关于缓存文件的部分信息加载到内存中来</div><div class=\"line\">         * 方便后面对缓存的查询等工作</div><div class=\"line\">         */</div><div class=\"line\"></div><div class=\"line\">        File[] files = mRootDirectory.listFiles();</div><div class=\"line\">        if (files == null) &#123;</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        for (File file : files) &#123;</div><div class=\"line\">            BufferedInputStream fis = null;</div><div class=\"line\">            try &#123;</div><div class=\"line\">                fis = new BufferedInputStream(new FileInputStream(file));</div><div class=\"line\">                CacheHeader entry = CacheHeader.readHeader(fis);</div><div class=\"line\">                entry.size = file.length();</div><div class=\"line\">                putEntry(entry.key, entry);</div><div class=\"line\">            &#125; catch (IOException e) &#123;</div><div class=\"line\">                if (file != null) &#123;</div><div class=\"line\">                   file.delete();</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; finally &#123;</div><div class=\"line\">                try &#123;</div><div class=\"line\">                    if (fis != null) &#123;</div><div class=\"line\">                        fis.close();</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125; catch (IOException ignored) &#123; &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Invalidates an entry in the cache.</div><div class=\"line\">     * 将key对应的缓存作废</div><div class=\"line\">     * 如果fullExpire为true，则将整个entry作废</div><div class=\"line\">     * 如果为false,则只是软作废，也就是将缓存置于需要刷新的状态</div><div class=\"line\">     *</div><div class=\"line\">     * @param key Cache key</div><div class=\"line\">     * @param fullExpire True to fully expire the entry, false to soft expire</div><div class=\"line\">     */</div><div class=\"line\">    @Override</div><div class=\"line\">    public synchronized void invalidate(String key, boolean fullExpire) &#123;</div><div class=\"line\">        Entry entry = get(key);</div><div class=\"line\">        if (entry != null) &#123;</div><div class=\"line\">            entry.softTtl = 0;</div><div class=\"line\">            if (fullExpire) &#123;</div><div class=\"line\">                entry.ttl = 0;</div><div class=\"line\">            &#125;</div><div class=\"line\">            put(key, entry);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Puts the entry with the specified key into the cache.</div><div class=\"line\">     * 将entry中包含的信息存放到key对应的缓存文件中去</div><div class=\"line\">     */</div><div class=\"line\">    @Override</div><div class=\"line\">    public synchronized void put(String key, Entry entry) &#123;</div><div class=\"line\"></div><div class=\"line\">        pruneIfNeeded(entry.data.length);</div><div class=\"line\"></div><div class=\"line\">        File file = getFileForKey(key);</div><div class=\"line\">        try &#123;</div><div class=\"line\">            BufferedOutputStream fos = new BufferedOutputStream(new FileOutputStream(file));</div><div class=\"line\">            CacheHeader e = new CacheHeader(key, entry);</div><div class=\"line\">            boolean success = e.writeHeader(fos);</div><div class=\"line\">            if (!success) &#123;</div><div class=\"line\">                fos.close();</div><div class=\"line\">                VolleyLog.d(&quot;Failed to write header for %s&quot;, file.getAbsolutePath());</div><div class=\"line\">                throw new IOException();</div><div class=\"line\">            &#125;</div><div class=\"line\">            fos.write(entry.data);</div><div class=\"line\">            fos.close();</div><div class=\"line\">            putEntry(key, e);</div><div class=\"line\">            return;</div><div class=\"line\">        &#125; catch (IOException e) &#123;</div><div class=\"line\">        &#125;</div><div class=\"line\">        boolean deleted = file.delete();</div><div class=\"line\">        if (!deleted) &#123;</div><div class=\"line\">            VolleyLog.d(&quot;Could not clean up file %s&quot;, file.getAbsolutePath());</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Removes the specified key from the cache if it exists.</div><div class=\"line\">     */</div><div class=\"line\">    @Override</div><div class=\"line\">    public synchronized void remove(String key) &#123;</div><div class=\"line\">        boolean deleted = getFileForKey(key).delete();</div><div class=\"line\">        removeEntry(key);</div><div class=\"line\">        if (!deleted) &#123;</div><div class=\"line\">            VolleyLog.d(&quot;Could not delete cache entry for key=%s, filename=%s&quot;,</div><div class=\"line\">                    key, getFilenameForKey(key));</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Creates a pseudo-unique filename for the specified cache key.</div><div class=\"line\">     * 通过给定的key，前半段的hashCode和后半段的hashCode连接起来</div><div class=\"line\">     * 作为一个独一无二的文件名</div><div class=\"line\">     * @param key The key to generate a file name for.</div><div class=\"line\">     * @return A pseudo-unique filename.</div><div class=\"line\">     */</div><div class=\"line\">    private String getFilenameForKey(String key) &#123;</div><div class=\"line\">        int firstHalfLength = key.length() / 2;</div><div class=\"line\">        String localFilename = String.valueOf(key.substring(0, firstHalfLength).hashCode());</div><div class=\"line\">        localFilename += String.valueOf(key.substring(firstHalfLength).hashCode());</div><div class=\"line\">        return localFilename;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Returns a file object for the given cache key.</div><div class=\"line\">     * 通过调用getFilenameForKey()方法来获取相对路径</div><div class=\"line\">     */</div><div class=\"line\">    public File getFileForKey(String key) &#123;</div><div class=\"line\">        return new File(mRootDirectory, getFilenameForKey(key));</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Prunes the cache to fit the amount of bytes specified.</div><div class=\"line\">     * 从已有的缓存中清除数据</div><div class=\"line\">     * 直到扫出了一片neededSapce大小的空地为止</div><div class=\"line\">     * @param neededSpace The amount of bytes we are trying to fit into the cache.</div><div class=\"line\">     */</div><div class=\"line\">    private void pruneIfNeeded(int neededSpace) &#123;</div><div class=\"line\">        if ((mTotalSize + neededSpace) &lt; mMaxCacheSizeInBytes) &#123;</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (VolleyLog.DEBUG) &#123;</div><div class=\"line\">            VolleyLog.v(&quot;Pruning old cache entries.&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        long before = mTotalSize;</div><div class=\"line\">        int prunedFiles = 0;</div><div class=\"line\">        long startTime = SystemClock.elapsedRealtime();</div><div class=\"line\"></div><div class=\"line\">        Iterator&lt;Map.Entry&lt;String, CacheHeader&gt;&gt; iterator = mEntries.entrySet().iterator();</div><div class=\"line\"></div><div class=\"line\">        while (iterator.hasNext()) &#123;</div><div class=\"line\"></div><div class=\"line\">            Map.Entry&lt;String, CacheHeader&gt; entry = iterator.next();</div><div class=\"line\"></div><div class=\"line\">            CacheHeader e = entry.getValue();</div><div class=\"line\"></div><div class=\"line\">            boolean deleted = getFileForKey(e.key).delete();</div><div class=\"line\"></div><div class=\"line\">            if (deleted) &#123;</div><div class=\"line\">                mTotalSize -= e.size;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">               VolleyLog.d(&quot;Could not delete cache entry for key=%s, filename=%s&quot;,</div><div class=\"line\">                       e.key, getFilenameForKey(e.key));</div><div class=\"line\">            &#125;</div><div class=\"line\">            iterator.remove();</div><div class=\"line\">            prunedFiles++;</div><div class=\"line\"></div><div class=\"line\">            /**</div><div class=\"line\">             * 一直清除缓存</div><div class=\"line\">             * 直到存入这个neededSapce之后还有一小部分空余的地方</div><div class=\"line\">             */</div><div class=\"line\">            if ((mTotalSize + neededSpace) &lt; mMaxCacheSizeInBytes * HYSTERESIS_FACTOR) &#123;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (VolleyLog.DEBUG) &#123;</div><div class=\"line\">            VolleyLog.v(&quot;pruned %d files, %d bytes, %d ms&quot;,</div><div class=\"line\">                    prunedFiles, (mTotalSize - before), SystemClock.elapsedRealtime() - startTime);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Puts the entry with the specified key into the cache.</div><div class=\"line\">     * 将目录下指定的缓存加载到mEntries中去</div><div class=\"line\">     * 为了方便之后对缓存的读写操作</div><div class=\"line\">     * 全部读写一遍放在内存里面，对查询什么的都会方便很多</div><div class=\"line\">     *</div><div class=\"line\">     * @param key The key to identify the entry by.</div><div class=\"line\">     * @param entry The entry to cache.</div><div class=\"line\">     */</div><div class=\"line\">    private void putEntry(String key, CacheHeader entry) &#123;</div><div class=\"line\">        if (!mEntries.containsKey(key)) &#123;</div><div class=\"line\">            mTotalSize += entry.size;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            CacheHeader oldEntry = mEntries.get(key);</div><div class=\"line\">            mTotalSize += (entry.size - oldEntry.size);</div><div class=\"line\">        &#125;</div><div class=\"line\">        mEntries.put(key, entry);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Removes the entry identified by &apos;key&apos; from the cache.</div><div class=\"line\">     */</div><div class=\"line\">    private void removeEntry(String key) &#123;</div><div class=\"line\">        CacheHeader entry = mEntries.get(key);</div><div class=\"line\">        if (entry != null) &#123;</div><div class=\"line\">            mTotalSize -= entry.size;</div><div class=\"line\">            mEntries.remove(key);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Reads the contents of an InputStream into a byte[].</div><div class=\"line\">     * 从InputStream中读取指定长度的数据</div><div class=\"line\">     * </div><div class=\"line\">     */</div><div class=\"line\">    private static byte[] streamToBytes(InputStream in, int length) throws IOException &#123;</div><div class=\"line\">        byte[] bytes = new byte[length];</div><div class=\"line\">        int count;</div><div class=\"line\">        int pos = 0;</div><div class=\"line\">        while (pos &lt; length &amp;&amp; ((count = in.read(bytes, pos, length - pos)) != -1)) &#123;</div><div class=\"line\">            pos += count;</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (pos != length) &#123;</div><div class=\"line\">            throw new IOException(&quot;Expected &quot; + length + &quot; bytes, read &quot; + pos + &quot; bytes&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        return bytes;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Handles holding onto the cache headers for an entry.</div><div class=\"line\">     */</div><div class=\"line\">    // Visible for testing.</div><div class=\"line\">    static class CacheHeader &#123;</div><div class=\"line\">        /** </div><div class=\"line\">         * The size of the data identified by this CacheHeader. (This is not</div><div class=\"line\">         * serialized to disk.</div><div class=\"line\">         * </div><div class=\"line\">         * CacheHeader所表示的数据段的大小 </div><div class=\"line\">         */</div><div class=\"line\">        public long size;</div><div class=\"line\"></div><div class=\"line\">        /** </div><div class=\"line\">         * The key that identifies the cache entry. </div><div class=\"line\">         * 这个key应该是request对应其缓存的唯一key</div><div class=\"line\">         */</div><div class=\"line\">        public String key;</div><div class=\"line\"></div><div class=\"line\">        /** </div><div class=\"line\">         * ETag for cache coherence.</div><div class=\"line\">         *</div><div class=\"line\">         */</div><div class=\"line\">        public String etag;</div><div class=\"line\"></div><div class=\"line\">        /** </div><div class=\"line\">         * Date of this response as reported by the server. </div><div class=\"line\">         * 缓存起来的数据返回的日期</div><div class=\"line\">         */</div><div class=\"line\">        public long serverDate;</div><div class=\"line\"></div><div class=\"line\">        /** </div><div class=\"line\">         * The last modified date for the requested object. </div><div class=\"line\">         * 最后一次更改的时间</div><div class=\"line\">         */</div><div class=\"line\">        public long lastModified;</div><div class=\"line\"></div><div class=\"line\">        /** </div><div class=\"line\">         * TTL for this record. </div><div class=\"line\">         * ping时候返回的TTL=128的概念如下</div><div class=\"line\">         * TTL：生存时间</div><div class=\"line\">         * 指定数据报被路由器丢弃之前允许通过的网段数量。</div><div class=\"line\">         * TTL 是由发送主机设置的，以防止数据包不断在 IP 互联网络上永不终止地循环。转发 IP 数据包时，要求路由器至少将 TTL 减小 1。</div><div class=\"line\">         *  </div><div class=\"line\">         * 但是= =，注意这里的和上面的那种不是一个概念，这里只是模拟了上面的概念，但也是用来标志缓存存活时间的。</div><div class=\"line\">         */</div><div class=\"line\">        public long ttl;</div><div class=\"line\"></div><div class=\"line\">        /** </div><div class=\"line\">         * Soft TTL for this record. </div><div class=\"line\">         * </div><div class=\"line\">         * 根据refreshNeeded()函数来看</div><div class=\"line\">         * 意思是需要更新缓存的时间点</div><div class=\"line\">         */</div><div class=\"line\">        public long softTtl;</div><div class=\"line\"></div><div class=\"line\">        /** </div><div class=\"line\">         * Headers from the response resulting in this cache entry. </div><div class=\"line\">         * 用来指向上一次response的header</div><div class=\"line\">         */</div><div class=\"line\">        public Map&lt;String, String&gt; responseHeaders;</div><div class=\"line\"></div><div class=\"line\">        private CacheHeader() &#123; &#125;</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * Instantiates a new CacheHeader object</div><div class=\"line\">         * @param key The key that identifies the cache entry</div><div class=\"line\">         * @param entry The cache entry.</div><div class=\"line\">         */</div><div class=\"line\">        public CacheHeader(String key, Entry entry) &#123;</div><div class=\"line\">            this.key = key;</div><div class=\"line\">            this.size = entry.data.length;</div><div class=\"line\">            this.etag = entry.etag;</div><div class=\"line\">            this.serverDate = entry.serverDate;</div><div class=\"line\">            this.lastModified = entry.lastModified;</div><div class=\"line\">            this.ttl = entry.ttl;</div><div class=\"line\">            this.softTtl = entry.softTtl;</div><div class=\"line\">            this.responseHeaders = entry.responseHeaders;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * Reads the header off of an InputStream and returns a CacheHeader object.</div><div class=\"line\">         * 从InputStream中读取数据并组建一个CacheHeader对象实例</div><div class=\"line\">         * @param is The InputStream to read from.</div><div class=\"line\">         * @throws IOException</div><div class=\"line\">         */</div><div class=\"line\">        public static CacheHeader readHeader(InputStream is) throws IOException &#123;</div><div class=\"line\">            CacheHeader entry = new CacheHeader();</div><div class=\"line\">            int magic = readInt(is);</div><div class=\"line\">            if (magic != CACHE_MAGIC) &#123;</div><div class=\"line\">                // don&apos;t bother deleting, it&apos;ll get pruned eventually</div><div class=\"line\">                throw new IOException();</div><div class=\"line\">            &#125;</div><div class=\"line\">            entry.key = readString(is);</div><div class=\"line\">            entry.etag = readString(is);</div><div class=\"line\">            if (entry.etag.equals(&quot;&quot;)) &#123;</div><div class=\"line\">                entry.etag = null;</div><div class=\"line\">            &#125;</div><div class=\"line\">            entry.serverDate = readLong(is);</div><div class=\"line\">            entry.lastModified = readLong(is);</div><div class=\"line\">            entry.ttl = readLong(is);</div><div class=\"line\">            entry.softTtl = readLong(is);</div><div class=\"line\">            entry.responseHeaders = readStringStringMap(is);</div><div class=\"line\"></div><div class=\"line\">            return entry;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * Creates a cache entry for the specified data.</div><div class=\"line\">         * 从CacheHeader转换成Entry类的实例</div><div class=\"line\">         */</div><div class=\"line\">        public Entry toCacheEntry(byte[] data) &#123;</div><div class=\"line\">            Entry e = new Entry();</div><div class=\"line\">            e.data = data;</div><div class=\"line\">            e.etag = etag;</div><div class=\"line\">            e.serverDate = serverDate;</div><div class=\"line\">            e.lastModified = lastModified;</div><div class=\"line\">            e.ttl = ttl;</div><div class=\"line\">            e.softTtl = softTtl;</div><div class=\"line\">            e.responseHeaders = responseHeaders;</div><div class=\"line\">            return e;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * Writes the contents of this CacheHeader to the specified OutputStream.</div><div class=\"line\">         * 将CacheHeader里面的数据写入指定的OutputStream中</div><div class=\"line\">         */</div><div class=\"line\">        public boolean writeHeader(OutputStream os) &#123;</div><div class=\"line\">            try &#123;</div><div class=\"line\">                writeInt(os, CACHE_MAGIC);</div><div class=\"line\">                writeString(os, key);</div><div class=\"line\">                writeString(os, etag == null ? &quot;&quot; : etag);</div><div class=\"line\">                writeLong(os, serverDate);</div><div class=\"line\">                writeLong(os, lastModified);</div><div class=\"line\">                writeLong(os, ttl);</div><div class=\"line\">                writeLong(os, softTtl);</div><div class=\"line\">                writeStringStringMap(responseHeaders, os);</div><div class=\"line\">                os.flush();</div><div class=\"line\">                return true;</div><div class=\"line\">            &#125; catch (IOException e) &#123;</div><div class=\"line\">                VolleyLog.d(&quot;%s&quot;, e.toString());</div><div class=\"line\">                return false;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * 继承了FilterInputStream</div><div class=\"line\">     * 没啥特别的= =</div><div class=\"line\">     */</div><div class=\"line\"></div><div class=\"line\">    private static class CountingInputStream extends FilterInputStream &#123;</div><div class=\"line\"></div><div class=\"line\">        private int bytesRead = 0;</div><div class=\"line\"></div><div class=\"line\">        private CountingInputStream(InputStream in) &#123;</div><div class=\"line\">            super(in);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        @Override</div><div class=\"line\">        public int read() throws IOException &#123;</div><div class=\"line\">            int result = super.read();</div><div class=\"line\">            if (result != -1) &#123;</div><div class=\"line\">                bytesRead++;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return result;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        @Override</div><div class=\"line\">        public int read(byte[] buffer, int offset, int count) throws IOException &#123;</div><div class=\"line\">            int result = super.read(buffer, offset, count);</div><div class=\"line\">            if (result != -1) &#123;</div><div class=\"line\">                bytesRead += result;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return result;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /*</div><div class=\"line\">     * Homebrewed simple serialization system used for reading and writing cache</div><div class=\"line\">     * headers on disk. Once upon a time, this used the standard Java</div><div class=\"line\">     * Object&#123;Input,Output&#125;Stream, but the default implementation relies heavily</div><div class=\"line\">     * on reflection (even for standard types) and generates a ton of garbage.</div><div class=\"line\">     * </div><div class=\"line\">     */</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Simple wrapper around &#123;@link InputStream#read()&#125; that throws EOFException</div><div class=\"line\">     * instead of returning -1.</div><div class=\"line\">     * 如果文件读到了末尾直接抛出异常</div><div class=\"line\">     */</div><div class=\"line\">    private static int read(InputStream is) throws IOException &#123;</div><div class=\"line\">        int b = is.read();</div><div class=\"line\">        if (b == -1) &#123;</div><div class=\"line\">            throw new EOFException();</div><div class=\"line\">        &#125;</div><div class=\"line\">        return b;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * 刚开始看到这里的时候没有明白是什么意思= =</div><div class=\"line\">     * 就不明白了，好好的一个int类型的数据</div><div class=\"line\">     * 为什么非要分段写入呢，一个字节一个字节的写入</div><div class=\"line\">     * 后来查了资料才发现，OutputStream及其子类的write()方法</div><div class=\"line\">     * 一次都只能写入一个byte，int类型有4个byte，分四次写入没什么问题咯</div><div class=\"line\">     */</div><div class=\"line\"></div><div class=\"line\">    static void writeInt(OutputStream os, int n) throws IOException &#123;</div><div class=\"line\">        os.write((n &gt;&gt; 0) &amp; 0xff);</div><div class=\"line\">        os.write((n &gt;&gt; 8) &amp; 0xff);</div><div class=\"line\">        os.write((n &gt;&gt; 16) &amp; 0xff);</div><div class=\"line\">        os.write((n &gt;&gt; 24) &amp; 0xff);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    static int readInt(InputStream is) throws IOException &#123;</div><div class=\"line\">        int n = 0;</div><div class=\"line\">        n |= (read(is) &lt;&lt; 0);</div><div class=\"line\">        n |= (read(is) &lt;&lt; 8);</div><div class=\"line\">        n |= (read(is) &lt;&lt; 16);</div><div class=\"line\">        n |= (read(is) &lt;&lt; 24);</div><div class=\"line\">        return n;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    static void writeLong(OutputStream os, long n) throws IOException &#123;</div><div class=\"line\">        os.write((byte)(n &gt;&gt;&gt; 0));</div><div class=\"line\">        os.write((byte)(n &gt;&gt;&gt; 8));</div><div class=\"line\">        os.write((byte)(n &gt;&gt;&gt; 16));</div><div class=\"line\">        os.write((byte)(n &gt;&gt;&gt; 24));</div><div class=\"line\">        os.write((byte)(n &gt;&gt;&gt; 32));</div><div class=\"line\">        os.write((byte)(n &gt;&gt;&gt; 40));</div><div class=\"line\">        os.write((byte)(n &gt;&gt;&gt; 48));</div><div class=\"line\">        os.write((byte)(n &gt;&gt;&gt; 56));</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    static long readLong(InputStream is) throws IOException &#123;</div><div class=\"line\">        long n = 0;</div><div class=\"line\">        n |= ((read(is) &amp; 0xFFL) &lt;&lt; 0);</div><div class=\"line\">        n |= ((read(is) &amp; 0xFFL) &lt;&lt; 8);</div><div class=\"line\">        n |= ((read(is) &amp; 0xFFL) &lt;&lt; 16);</div><div class=\"line\">        n |= ((read(is) &amp; 0xFFL) &lt;&lt; 24);</div><div class=\"line\">        n |= ((read(is) &amp; 0xFFL) &lt;&lt; 32);</div><div class=\"line\">        n |= ((read(is) &amp; 0xFFL) &lt;&lt; 40);</div><div class=\"line\">        n |= ((read(is) &amp; 0xFFL) &lt;&lt; 48);</div><div class=\"line\">        n |= ((read(is) &amp; 0xFFL) &lt;&lt; 56);</div><div class=\"line\">        return n;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    static void writeString(OutputStream os, String s) throws IOException &#123;</div><div class=\"line\">        byte[] b = s.getBytes(&quot;UTF-8&quot;);</div><div class=\"line\">        writeLong(os, b.length);</div><div class=\"line\">        os.write(b, 0, b.length);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    static String readString(InputStream is) throws IOException &#123;</div><div class=\"line\">        int n = (int) readLong(is);</div><div class=\"line\">        byte[] b = streamToBytes(is, n);</div><div class=\"line\">        return new String(b, &quot;UTF-8&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    static void writeStringStringMap(Map&lt;String, String&gt; map, OutputStream os) throws IOException &#123;</div><div class=\"line\">        if (map != null) &#123;</div><div class=\"line\">            writeInt(os, map.size());</div><div class=\"line\">            for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</div><div class=\"line\">                writeString(os, entry.getKey());</div><div class=\"line\">                writeString(os, entry.getValue());</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            writeInt(os, 0);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * 从InputStream中读取key类型为String，值类型也为String的Map</div><div class=\"line\">     */ </div><div class=\"line\">    static Map&lt;String, String&gt; readStringStringMap(InputStream is) throws IOException &#123;</div><div class=\"line\">        int size = readInt(is);</div><div class=\"line\">        Map&lt;String, String&gt; result = (size == 0)</div><div class=\"line\">                ? Collections.&lt;String, String&gt;emptyMap()</div><div class=\"line\">                : new HashMap&lt;String, String&gt;(size);</div><div class=\"line\">        for (int i = 0; i &lt; size; i++) &#123;</div><div class=\"line\"></div><div class=\"line\">            //将读出来的byte[]转换成String</div><div class=\"line\"></div><div class=\"line\">            String key = readString(is).intern();</div><div class=\"line\">            String value = readString(is).intern();</div><div class=\"line\">            result.put(key, value);</div><div class=\"line\">        &#125;</div><div class=\"line\">        return result;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>涉及到缓存读写的这个实现类当时阅读的时候还是花了不少时间的= =，人太笨了没办法orz，有什么不妥的地方还望各位juju多多指教，小达感激不尽0.0。下面还有Request.java等类等着去解析呢，Volley中的主角要登场了╭(╯^╰)╮。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"1-前言-可直接无视跳过\"><a href=\"#1-前言-可直接无视跳过\" class=\"headerlink\" title=\"1. 前言(可直接无视跳过\"></a>1. 前言(可直接无视跳过</h3><p>前面涉及到网络的部分都介绍完了，在处理网络请求返回的数据时，会根据request结果是否需要缓存来进行不同的处理。如需要缓存结果，就涉及到了<code>Cache.java</code>及其默认实现类<code>DiskBasedCache.java</code>。</p>","more":"<h3 id=\"2-Cache-java\"><a href=\"#2-Cache-java\" class=\"headerlink\" title=\"2. Cache.java\"></a>2. Cache.java</h3><p>用于处理缓存的接口，里面有很多抽象的方法等着被实现，里面还有一个static类<code>Entry</code>,里面有些关于缓存的单元信息。(例如，缓存的内容，缓存过期的时间，缓存需要刷新的时间等等）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div></pre></td><td class=\"code\"><pre><div class=\"line\">package com.android.volley;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\"> * An interface for a cache keyed by a String with * a byte array as data.</div><div class=\"line\"> * 一个用于缓存的接口</div><div class=\"line\"> */</div><div class=\"line\">public interface Cache &#123;</div><div class=\"line\">    /**</div><div class=\"line\">     * Retrieves an entry from the cache.</div><div class=\"line\">     * 用来获取缓存的入口，通过传入的key</div><div class=\"line\">     * </div><div class=\"line\">     * @param key Cache key</div><div class=\"line\">     * 这个key应该是request对应其缓存的唯一key</div><div class=\"line\">     *</div><div class=\"line\">     * @return An &#123;@link Entry&#125; or null in the event of a cache miss</div><div class=\"line\">     */</div><div class=\"line\">    public Entry get(String key);</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Adds or replaces an entry to the cache.</div><div class=\"line\">     * 添加或者给request更新缓存</div><div class=\"line\">     * @param key Cache key</div><div class=\"line\">     * @param entry Data to store and metadata for cache coherency, TTL, etc.</div><div class=\"line\">     */</div><div class=\"line\">    public void put(String key, Entry entry);</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Performs any potentially long-running actions needed to initialize the cache;</div><div class=\"line\">     * will be called from a worker thread.</div><div class=\"line\">     */</div><div class=\"line\">    public void initialize();</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Invalidates an entry in the cache.</div><div class=\"line\">     * 这个函数是将key对应的缓存置于过期</div><div class=\"line\">     * 分为fully expire和soft expire， 目前还不知道是什么意思 = =</div><div class=\"line\">     * </div><div class=\"line\">     * @param key Cache key</div><div class=\"line\">     * @param fullExpire True to fully expire the entry, false to soft expire</div><div class=\"line\">     */</div><div class=\"line\">    public void invalidate(String key, boolean fullExpire);</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Removes an entry from the cache.</div><div class=\"line\">     * 将key对应的缓存直接移除掉</div><div class=\"line\">     * </div><div class=\"line\">     * @param key Cache key</div><div class=\"line\">     */</div><div class=\"line\">    public void remove(String key);</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Empties the cache.</div><div class=\"line\">     * 清除所有的缓存</div><div class=\"line\">     */</div><div class=\"line\">    public void clear();</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Data and metadata for an entry returned by the cache.</div><div class=\"line\">     */</div><div class=\"line\">    public static class Entry &#123;</div><div class=\"line\">        /** The data returned from cache. */</div><div class=\"line\">        public byte[] data;</div><div class=\"line\"></div><div class=\"line\">        /** ETag for cache coherency. */</div><div class=\"line\">        public String etag;</div><div class=\"line\"></div><div class=\"line\">        /** Date of this response as reported by the server. */</div><div class=\"line\">        public long serverDate;</div><div class=\"line\"></div><div class=\"line\">        /** The last modified date for the requested object. */</div><div class=\"line\">        public long lastModified;</div><div class=\"line\"></div><div class=\"line\">        /** TTL for this record.</div><div class=\"line\">         *  根据后面的isExpired()函数来看</div><div class=\"line\">         *  该条数据的意思应该是缓存过期的时间 </div><div class=\"line\">         */</div><div class=\"line\">        public long ttl;</div><div class=\"line\"></div><div class=\"line\">        /** Soft TTL for this record. </div><div class=\"line\">         *  根据refreshNeeded()函数来看</div><div class=\"line\">         *  意思是需要更新缓存的时间点</div><div class=\"line\">         */</div><div class=\"line\">        public long softTtl;</div><div class=\"line\"></div><div class=\"line\">        /** Immutable response headers as received from server; must be non-null. */</div><div class=\"line\">        public Map&lt;String, String&gt; responseHeaders = Collections.emptyMap();</div><div class=\"line\"></div><div class=\"line\">       /** </div><div class=\"line\">         * True if the entry is expired. </div><div class=\"line\">         * 用来查看缓存是否过期了</div><div class=\"line\">         */</div><div class=\"line\">        public boolean isExpired() &#123;</div><div class=\"line\">            return this.ttl &lt; System.currentTimeMillis();</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        /** True if a refresh is needed from the original data source. */</div><div class=\"line\">        public boolean refreshNeeded() &#123;</div><div class=\"line\">            return this.softTtl &lt; System.currentTimeMillis();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"3-DiskBasedCache-java\"><a href=\"#3-DiskBasedCache-java\" class=\"headerlink\" title=\"3. DiskBasedCache.java\"></a>3. DiskBasedCache.java</h3><p>实现了Cache.java接口，专门和本地存储的文件打交道，负责缓存的写入与读取。涉及到了一部分InputStream和OutputStream还有File的知识。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div><div class=\"line\">204</div><div class=\"line\">205</div><div class=\"line\">206</div><div class=\"line\">207</div><div class=\"line\">208</div><div class=\"line\">209</div><div class=\"line\">210</div><div class=\"line\">211</div><div class=\"line\">212</div><div class=\"line\">213</div><div class=\"line\">214</div><div class=\"line\">215</div><div class=\"line\">216</div><div class=\"line\">217</div><div class=\"line\">218</div><div class=\"line\">219</div><div class=\"line\">220</div><div class=\"line\">221</div><div class=\"line\">222</div><div class=\"line\">223</div><div class=\"line\">224</div><div class=\"line\">225</div><div class=\"line\">226</div><div class=\"line\">227</div><div class=\"line\">228</div><div class=\"line\">229</div><div class=\"line\">230</div><div class=\"line\">231</div><div class=\"line\">232</div><div class=\"line\">233</div><div class=\"line\">234</div><div class=\"line\">235</div><div class=\"line\">236</div><div class=\"line\">237</div><div class=\"line\">238</div><div class=\"line\">239</div><div class=\"line\">240</div><div class=\"line\">241</div><div class=\"line\">242</div><div class=\"line\">243</div><div class=\"line\">244</div><div class=\"line\">245</div><div class=\"line\">246</div><div class=\"line\">247</div><div class=\"line\">248</div><div class=\"line\">249</div><div class=\"line\">250</div><div class=\"line\">251</div><div class=\"line\">252</div><div class=\"line\">253</div><div class=\"line\">254</div><div class=\"line\">255</div><div class=\"line\">256</div><div class=\"line\">257</div><div class=\"line\">258</div><div class=\"line\">259</div><div class=\"line\">260</div><div class=\"line\">261</div><div class=\"line\">262</div><div class=\"line\">263</div><div class=\"line\">264</div><div class=\"line\">265</div><div class=\"line\">266</div><div class=\"line\">267</div><div class=\"line\">268</div><div class=\"line\">269</div><div class=\"line\">270</div><div class=\"line\">271</div><div class=\"line\">272</div><div class=\"line\">273</div><div class=\"line\">274</div><div class=\"line\">275</div><div class=\"line\">276</div><div class=\"line\">277</div><div class=\"line\">278</div><div class=\"line\">279</div><div class=\"line\">280</div><div class=\"line\">281</div><div class=\"line\">282</div><div class=\"line\">283</div><div class=\"line\">284</div><div class=\"line\">285</div><div class=\"line\">286</div><div class=\"line\">287</div><div class=\"line\">288</div><div class=\"line\">289</div><div class=\"line\">290</div><div class=\"line\">291</div><div class=\"line\">292</div><div class=\"line\">293</div><div class=\"line\">294</div><div class=\"line\">295</div><div class=\"line\">296</div><div class=\"line\">297</div><div class=\"line\">298</div><div class=\"line\">299</div><div class=\"line\">300</div><div class=\"line\">301</div><div class=\"line\">302</div><div class=\"line\">303</div><div class=\"line\">304</div><div class=\"line\">305</div><div class=\"line\">306</div><div class=\"line\">307</div><div class=\"line\">308</div><div class=\"line\">309</div><div class=\"line\">310</div><div class=\"line\">311</div><div class=\"line\">312</div><div class=\"line\">313</div><div class=\"line\">314</div><div class=\"line\">315</div><div class=\"line\">316</div><div class=\"line\">317</div><div class=\"line\">318</div><div class=\"line\">319</div><div class=\"line\">320</div><div class=\"line\">321</div><div class=\"line\">322</div><div class=\"line\">323</div><div class=\"line\">324</div><div class=\"line\">325</div><div class=\"line\">326</div><div class=\"line\">327</div><div class=\"line\">328</div><div class=\"line\">329</div><div class=\"line\">330</div><div class=\"line\">331</div><div class=\"line\">332</div><div class=\"line\">333</div><div class=\"line\">334</div><div class=\"line\">335</div><div class=\"line\">336</div><div class=\"line\">337</div><div class=\"line\">338</div><div class=\"line\">339</div><div class=\"line\">340</div><div class=\"line\">341</div><div class=\"line\">342</div><div class=\"line\">343</div><div class=\"line\">344</div><div class=\"line\">345</div><div class=\"line\">346</div><div class=\"line\">347</div><div class=\"line\">348</div><div class=\"line\">349</div><div class=\"line\">350</div><div class=\"line\">351</div><div class=\"line\">352</div><div class=\"line\">353</div><div class=\"line\">354</div><div class=\"line\">355</div><div class=\"line\">356</div><div class=\"line\">357</div><div class=\"line\">358</div><div class=\"line\">359</div><div class=\"line\">360</div><div class=\"line\">361</div><div class=\"line\">362</div><div class=\"line\">363</div><div class=\"line\">364</div><div class=\"line\">365</div><div class=\"line\">366</div><div class=\"line\">367</div><div class=\"line\">368</div><div class=\"line\">369</div><div class=\"line\">370</div><div class=\"line\">371</div><div class=\"line\">372</div><div class=\"line\">373</div><div class=\"line\">374</div><div class=\"line\">375</div><div class=\"line\">376</div><div class=\"line\">377</div><div class=\"line\">378</div><div class=\"line\">379</div><div class=\"line\">380</div><div class=\"line\">381</div><div class=\"line\">382</div><div class=\"line\">383</div><div class=\"line\">384</div><div class=\"line\">385</div><div class=\"line\">386</div><div class=\"line\">387</div><div class=\"line\">388</div><div class=\"line\">389</div><div class=\"line\">390</div><div class=\"line\">391</div><div class=\"line\">392</div><div class=\"line\">393</div><div class=\"line\">394</div><div class=\"line\">395</div><div class=\"line\">396</div><div class=\"line\">397</div><div class=\"line\">398</div><div class=\"line\">399</div><div class=\"line\">400</div><div class=\"line\">401</div><div class=\"line\">402</div><div class=\"line\">403</div><div class=\"line\">404</div><div class=\"line\">405</div><div class=\"line\">406</div><div class=\"line\">407</div><div class=\"line\">408</div><div class=\"line\">409</div><div class=\"line\">410</div><div class=\"line\">411</div><div class=\"line\">412</div><div class=\"line\">413</div><div class=\"line\">414</div><div class=\"line\">415</div><div class=\"line\">416</div><div class=\"line\">417</div><div class=\"line\">418</div><div class=\"line\">419</div><div class=\"line\">420</div><div class=\"line\">421</div><div class=\"line\">422</div><div class=\"line\">423</div><div class=\"line\">424</div><div class=\"line\">425</div><div class=\"line\">426</div><div class=\"line\">427</div><div class=\"line\">428</div><div class=\"line\">429</div><div class=\"line\">430</div><div class=\"line\">431</div><div class=\"line\">432</div><div class=\"line\">433</div><div class=\"line\">434</div><div class=\"line\">435</div><div class=\"line\">436</div><div class=\"line\">437</div><div class=\"line\">438</div><div class=\"line\">439</div><div class=\"line\">440</div><div class=\"line\">441</div><div class=\"line\">442</div><div class=\"line\">443</div><div class=\"line\">444</div><div class=\"line\">445</div><div class=\"line\">446</div><div class=\"line\">447</div><div class=\"line\">448</div><div class=\"line\">449</div><div class=\"line\">450</div><div class=\"line\">451</div><div class=\"line\">452</div><div class=\"line\">453</div><div class=\"line\">454</div><div class=\"line\">455</div><div class=\"line\">456</div><div class=\"line\">457</div><div class=\"line\">458</div><div class=\"line\">459</div><div class=\"line\">460</div><div class=\"line\">461</div><div class=\"line\">462</div><div class=\"line\">463</div><div class=\"line\">464</div><div class=\"line\">465</div><div class=\"line\">466</div><div class=\"line\">467</div><div class=\"line\">468</div><div class=\"line\">469</div><div class=\"line\">470</div><div class=\"line\">471</div><div class=\"line\">472</div><div class=\"line\">473</div><div class=\"line\">474</div><div class=\"line\">475</div><div class=\"line\">476</div><div class=\"line\">477</div><div class=\"line\">478</div><div class=\"line\">479</div><div class=\"line\">480</div><div class=\"line\">481</div><div class=\"line\">482</div><div class=\"line\">483</div><div class=\"line\">484</div><div class=\"line\">485</div><div class=\"line\">486</div><div class=\"line\">487</div><div class=\"line\">488</div><div class=\"line\">489</div><div class=\"line\">490</div><div class=\"line\">491</div><div class=\"line\">492</div><div class=\"line\">493</div><div class=\"line\">494</div><div class=\"line\">495</div><div class=\"line\">496</div><div class=\"line\">497</div><div class=\"line\">498</div><div class=\"line\">499</div><div class=\"line\">500</div><div class=\"line\">501</div><div class=\"line\">502</div><div class=\"line\">503</div><div class=\"line\">504</div><div class=\"line\">505</div><div class=\"line\">506</div><div class=\"line\">507</div><div class=\"line\">508</div><div class=\"line\">509</div><div class=\"line\">510</div><div class=\"line\">511</div><div class=\"line\">512</div><div class=\"line\">513</div><div class=\"line\">514</div><div class=\"line\">515</div><div class=\"line\">516</div><div class=\"line\">517</div><div class=\"line\">518</div><div class=\"line\">519</div><div class=\"line\">520</div><div class=\"line\">521</div><div class=\"line\">522</div><div class=\"line\">523</div><div class=\"line\">524</div><div class=\"line\">525</div><div class=\"line\">526</div><div class=\"line\">527</div><div class=\"line\">528</div><div class=\"line\">529</div><div class=\"line\">530</div><div class=\"line\">531</div><div class=\"line\">532</div><div class=\"line\">533</div><div class=\"line\">534</div><div class=\"line\">535</div><div class=\"line\">536</div><div class=\"line\">537</div><div class=\"line\">538</div><div class=\"line\">539</div><div class=\"line\">540</div><div class=\"line\">541</div><div class=\"line\">542</div><div class=\"line\">543</div><div class=\"line\">544</div><div class=\"line\">545</div><div class=\"line\">546</div><div class=\"line\">547</div><div class=\"line\">548</div><div class=\"line\">549</div><div class=\"line\">550</div><div class=\"line\">551</div><div class=\"line\">552</div><div class=\"line\">553</div><div class=\"line\">554</div><div class=\"line\">555</div><div class=\"line\">556</div><div class=\"line\">557</div><div class=\"line\">558</div><div class=\"line\">559</div><div class=\"line\">560</div><div class=\"line\">561</div><div class=\"line\">562</div><div class=\"line\">563</div><div class=\"line\">564</div><div class=\"line\">565</div><div class=\"line\">566</div><div class=\"line\">567</div><div class=\"line\">568</div><div class=\"line\">569</div><div class=\"line\">570</div><div class=\"line\">571</div><div class=\"line\">572</div><div class=\"line\">573</div><div class=\"line\">574</div><div class=\"line\">575</div><div class=\"line\">576</div><div class=\"line\">577</div><div class=\"line\">578</div><div class=\"line\">579</div><div class=\"line\">580</div><div class=\"line\">581</div><div class=\"line\">582</div><div class=\"line\">583</div><div class=\"line\">584</div><div class=\"line\">585</div><div class=\"line\">586</div><div class=\"line\">587</div><div class=\"line\">588</div><div class=\"line\">589</div><div class=\"line\">590</div><div class=\"line\">591</div><div class=\"line\">592</div><div class=\"line\">593</div><div class=\"line\">594</div><div class=\"line\">595</div><div class=\"line\">596</div><div class=\"line\">597</div><div class=\"line\">598</div><div class=\"line\">599</div><div class=\"line\">600</div><div class=\"line\">601</div><div class=\"line\">602</div><div class=\"line\">603</div><div class=\"line\">604</div><div class=\"line\">605</div><div class=\"line\">606</div><div class=\"line\">607</div><div class=\"line\">608</div><div class=\"line\">609</div><div class=\"line\">610</div><div class=\"line\">611</div><div class=\"line\">612</div><div class=\"line\">613</div><div class=\"line\">614</div><div class=\"line\">615</div><div class=\"line\">616</div><div class=\"line\">617</div><div class=\"line\">618</div><div class=\"line\">619</div><div class=\"line\">620</div><div class=\"line\">621</div><div class=\"line\">622</div><div class=\"line\">623</div><div class=\"line\">624</div><div class=\"line\">625</div><div class=\"line\">626</div><div class=\"line\">627</div><div class=\"line\">628</div><div class=\"line\">629</div><div class=\"line\">630</div><div class=\"line\">631</div><div class=\"line\">632</div><div class=\"line\">633</div><div class=\"line\">634</div><div class=\"line\">635</div><div class=\"line\">636</div><div class=\"line\">637</div><div class=\"line\">638</div><div class=\"line\">639</div><div class=\"line\">640</div><div class=\"line\">641</div><div class=\"line\">642</div><div class=\"line\">643</div><div class=\"line\">644</div><div class=\"line\">645</div><div class=\"line\">646</div><div class=\"line\">647</div><div class=\"line\">648</div><div class=\"line\">649</div><div class=\"line\">650</div><div class=\"line\">651</div><div class=\"line\">652</div><div class=\"line\">653</div><div class=\"line\">654</div><div class=\"line\">655</div><div class=\"line\">656</div><div class=\"line\">657</div><div class=\"line\">658</div><div class=\"line\">659</div><div class=\"line\">660</div><div class=\"line\">661</div><div class=\"line\">662</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * Cache implementation that caches files directly onto the hard disk in the specified</div><div class=\"line\"> * directory. The default disk usage size is 5MB, but is configurable.</div><div class=\"line\"> * 实现了Cache接口</div><div class=\"line\"> * 专门用于和本地文件交互的一个类</div><div class=\"line\"> * 存入缓存和取出缓存等功能</div><div class=\"line\"> */</div><div class=\"line\">public class DiskBasedCache implements Cache &#123;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Map of the Key, CacheHeader pairs </div><div class=\"line\">     * CacheHeader.java为本类中的一个static类</div><div class=\"line\">     * 里面存放着一些</div><div class=\"line\">     */</div><div class=\"line\">    private final Map&lt;String, CacheHeader&gt; mEntries =</div><div class=\"line\">            new LinkedHashMap&lt;String, CacheHeader&gt;(16, .75f, true);</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * Total amount of space currently used by the cache in bytes. </div><div class=\"line\">     * 当前缓存的总大小</div><div class=\"line\">     */</div><div class=\"line\">    private long mTotalSize = 0;</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * The root directory to use for the cache. </div><div class=\"line\">     * 缓存的根目录</div><div class=\"line\">     */</div><div class=\"line\">    private final File mRootDirectory;</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * The maximum size of the cache in bytes. </div><div class=\"line\">     * 缓存能接受的最大字节数</div><div class=\"line\">     */</div><div class=\"line\">    private final int mMaxCacheSizeInBytes;</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * Default maximum disk usage in bytes.</div><div class=\"line\">     * 默认缓存能使用的最大空间</div><div class=\"line\">     */</div><div class=\"line\">    private static final int DEFAULT_DISK_USAGE_BYTES = 5 * 1024 * 1024;</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * High water mark percentage for the cache</div><div class=\"line\">     * 类似于水位警戒线一样的标识</div><div class=\"line\">     */</div><div class=\"line\">    private static final float HYSTERESIS_FACTOR = 0.9f;</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * Magic number for current version of cache file format. </div><div class=\"line\">     * </div><div class=\"line\">     */</div><div class=\"line\">    private static final int CACHE_MAGIC = 0x20150306;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Constructs an instance of the DiskBasedCache at the specified directory.</div><div class=\"line\">     * 在指定的目录下面创建一个DiskBasedCache</div><div class=\"line\">     *</div><div class=\"line\">     * @param rootDirectory The root directory of the cache.</div><div class=\"line\">     * @param maxCacheSizeInBytes The maximum size of the cache in bytes.</div><div class=\"line\">     */</div><div class=\"line\">    public DiskBasedCache(File rootDirectory, int maxCacheSizeInBytes) &#123;</div><div class=\"line\">        mRootDirectory = rootDirectory;</div><div class=\"line\">        mMaxCacheSizeInBytes = maxCacheSizeInBytes;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Constructs an instance of the DiskBasedCache at the specified directory using</div><div class=\"line\">     * the default maximum cache size of 5MB.</div><div class=\"line\">     * @param rootDirectory The root directory of the cache.</div><div class=\"line\">     */</div><div class=\"line\">    public DiskBasedCache(File rootDirectory) &#123;</div><div class=\"line\">        this(rootDirectory, DEFAULT_DISK_USAGE_BYTES);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Clears the cache. Deletes all cached files from disk.</div><div class=\"line\">     * 清除当前目录下的缓存，删除所有缓存文件 </div><div class=\"line\">     */</div><div class=\"line\">    @Override</div><div class=\"line\">    public synchronized void clear() &#123;</div><div class=\"line\">        File[] files = mRootDirectory.listFiles();</div><div class=\"line\">        if (files != null) &#123;</div><div class=\"line\">            for (File file : files) &#123;</div><div class=\"line\">                file.delete();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        mEntries.clear();</div><div class=\"line\">        mTotalSize = 0;</div><div class=\"line\">        VolleyLog.d(&quot;Cache cleared.&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Returns the cache entry with the specified key if it exists, null otherwise.</div><div class=\"line\">     * 通过特殊的key，来获取与缓存交流的接口(entry)</div><div class=\"line\">     * 如果没有的话则返回null</div><div class=\"line\">     */</div><div class=\"line\">    @Override</div><div class=\"line\">    public synchronized Entry get(String key) &#123;</div><div class=\"line\"></div><div class=\"line\">        CacheHeader entry = mEntries.get(key);</div><div class=\"line\">        // if the entry does not exist, return.</div><div class=\"line\">        if (entry == null) &#123;</div><div class=\"line\">            return null;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        //依据key获取缓存的文件，如果不存在则创建一个</div><div class=\"line\">        File file = getFileForKey(key);</div><div class=\"line\"></div><div class=\"line\">        CountingInputStream cis = null;</div><div class=\"line\"></div><div class=\"line\">        try &#123;</div><div class=\"line\"></div><div class=\"line\">            cis = new CountingInputStream(new BufferedInputStream(new FileInputStream(file)));</div><div class=\"line\">            CacheHeader.readHeader(cis); // eat header</div><div class=\"line\">            byte[] data = streamToBytes(cis, (int) (file.length() - cis.bytesRead));</div><div class=\"line\">            return entry.toCacheEntry(data);</div><div class=\"line\"></div><div class=\"line\">        &#125; catch (IOException e) &#123;</div><div class=\"line\">            VolleyLog.d(&quot;%s: %s&quot;, file.getAbsolutePath(), e.toString());</div><div class=\"line\">            remove(key);</div><div class=\"line\">            return null;</div><div class=\"line\">        &#125;  catch (NegativeArraySizeException e) &#123;</div><div class=\"line\">            VolleyLog.d(&quot;%s: %s&quot;, file.getAbsolutePath(), e.toString());</div><div class=\"line\">            remove(key);</div><div class=\"line\">            return null;</div><div class=\"line\">        &#125; finally &#123;</div><div class=\"line\">            if (cis != null) &#123;</div><div class=\"line\">                try &#123;</div><div class=\"line\">                    cis.close();</div><div class=\"line\">                &#125; catch (IOException ioe) &#123;</div><div class=\"line\">                    return null;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Initializes the DiskBasedCache by scanning for all files currently in the</div><div class=\"line\">     * specified root directory. Creates the root directory if necessary.</div><div class=\"line\">     * 对缓存目录的初始化工作，检查目录是否存在</div><div class=\"line\">     * 如果不存在就给重新创建一个</div><div class=\"line\">     */</div><div class=\"line\">    @Override</div><div class=\"line\">    public synchronized void initialize() &#123;</div><div class=\"line\">        if (!mRootDirectory.exists()) &#123;</div><div class=\"line\">            if (!mRootDirectory.mkdirs()) &#123;</div><div class=\"line\">                VolleyLog.e(&quot;Unable to create cache dir %s&quot;, mRootDirectory.getAbsolutePath());</div><div class=\"line\">            &#125;</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * 如果缓存目录已经存在了</div><div class=\"line\">         * 则将缓存目录下面的文件都扫描一遍</div><div class=\"line\">         * 将关于缓存文件的部分信息加载到内存中来</div><div class=\"line\">         * 方便后面对缓存的查询等工作</div><div class=\"line\">         */</div><div class=\"line\"></div><div class=\"line\">        File[] files = mRootDirectory.listFiles();</div><div class=\"line\">        if (files == null) &#123;</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        for (File file : files) &#123;</div><div class=\"line\">            BufferedInputStream fis = null;</div><div class=\"line\">            try &#123;</div><div class=\"line\">                fis = new BufferedInputStream(new FileInputStream(file));</div><div class=\"line\">                CacheHeader entry = CacheHeader.readHeader(fis);</div><div class=\"line\">                entry.size = file.length();</div><div class=\"line\">                putEntry(entry.key, entry);</div><div class=\"line\">            &#125; catch (IOException e) &#123;</div><div class=\"line\">                if (file != null) &#123;</div><div class=\"line\">                   file.delete();</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; finally &#123;</div><div class=\"line\">                try &#123;</div><div class=\"line\">                    if (fis != null) &#123;</div><div class=\"line\">                        fis.close();</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125; catch (IOException ignored) &#123; &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Invalidates an entry in the cache.</div><div class=\"line\">     * 将key对应的缓存作废</div><div class=\"line\">     * 如果fullExpire为true，则将整个entry作废</div><div class=\"line\">     * 如果为false,则只是软作废，也就是将缓存置于需要刷新的状态</div><div class=\"line\">     *</div><div class=\"line\">     * @param key Cache key</div><div class=\"line\">     * @param fullExpire True to fully expire the entry, false to soft expire</div><div class=\"line\">     */</div><div class=\"line\">    @Override</div><div class=\"line\">    public synchronized void invalidate(String key, boolean fullExpire) &#123;</div><div class=\"line\">        Entry entry = get(key);</div><div class=\"line\">        if (entry != null) &#123;</div><div class=\"line\">            entry.softTtl = 0;</div><div class=\"line\">            if (fullExpire) &#123;</div><div class=\"line\">                entry.ttl = 0;</div><div class=\"line\">            &#125;</div><div class=\"line\">            put(key, entry);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Puts the entry with the specified key into the cache.</div><div class=\"line\">     * 将entry中包含的信息存放到key对应的缓存文件中去</div><div class=\"line\">     */</div><div class=\"line\">    @Override</div><div class=\"line\">    public synchronized void put(String key, Entry entry) &#123;</div><div class=\"line\"></div><div class=\"line\">        pruneIfNeeded(entry.data.length);</div><div class=\"line\"></div><div class=\"line\">        File file = getFileForKey(key);</div><div class=\"line\">        try &#123;</div><div class=\"line\">            BufferedOutputStream fos = new BufferedOutputStream(new FileOutputStream(file));</div><div class=\"line\">            CacheHeader e = new CacheHeader(key, entry);</div><div class=\"line\">            boolean success = e.writeHeader(fos);</div><div class=\"line\">            if (!success) &#123;</div><div class=\"line\">                fos.close();</div><div class=\"line\">                VolleyLog.d(&quot;Failed to write header for %s&quot;, file.getAbsolutePath());</div><div class=\"line\">                throw new IOException();</div><div class=\"line\">            &#125;</div><div class=\"line\">            fos.write(entry.data);</div><div class=\"line\">            fos.close();</div><div class=\"line\">            putEntry(key, e);</div><div class=\"line\">            return;</div><div class=\"line\">        &#125; catch (IOException e) &#123;</div><div class=\"line\">        &#125;</div><div class=\"line\">        boolean deleted = file.delete();</div><div class=\"line\">        if (!deleted) &#123;</div><div class=\"line\">            VolleyLog.d(&quot;Could not clean up file %s&quot;, file.getAbsolutePath());</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Removes the specified key from the cache if it exists.</div><div class=\"line\">     */</div><div class=\"line\">    @Override</div><div class=\"line\">    public synchronized void remove(String key) &#123;</div><div class=\"line\">        boolean deleted = getFileForKey(key).delete();</div><div class=\"line\">        removeEntry(key);</div><div class=\"line\">        if (!deleted) &#123;</div><div class=\"line\">            VolleyLog.d(&quot;Could not delete cache entry for key=%s, filename=%s&quot;,</div><div class=\"line\">                    key, getFilenameForKey(key));</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Creates a pseudo-unique filename for the specified cache key.</div><div class=\"line\">     * 通过给定的key，前半段的hashCode和后半段的hashCode连接起来</div><div class=\"line\">     * 作为一个独一无二的文件名</div><div class=\"line\">     * @param key The key to generate a file name for.</div><div class=\"line\">     * @return A pseudo-unique filename.</div><div class=\"line\">     */</div><div class=\"line\">    private String getFilenameForKey(String key) &#123;</div><div class=\"line\">        int firstHalfLength = key.length() / 2;</div><div class=\"line\">        String localFilename = String.valueOf(key.substring(0, firstHalfLength).hashCode());</div><div class=\"line\">        localFilename += String.valueOf(key.substring(firstHalfLength).hashCode());</div><div class=\"line\">        return localFilename;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Returns a file object for the given cache key.</div><div class=\"line\">     * 通过调用getFilenameForKey()方法来获取相对路径</div><div class=\"line\">     */</div><div class=\"line\">    public File getFileForKey(String key) &#123;</div><div class=\"line\">        return new File(mRootDirectory, getFilenameForKey(key));</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Prunes the cache to fit the amount of bytes specified.</div><div class=\"line\">     * 从已有的缓存中清除数据</div><div class=\"line\">     * 直到扫出了一片neededSapce大小的空地为止</div><div class=\"line\">     * @param neededSpace The amount of bytes we are trying to fit into the cache.</div><div class=\"line\">     */</div><div class=\"line\">    private void pruneIfNeeded(int neededSpace) &#123;</div><div class=\"line\">        if ((mTotalSize + neededSpace) &lt; mMaxCacheSizeInBytes) &#123;</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (VolleyLog.DEBUG) &#123;</div><div class=\"line\">            VolleyLog.v(&quot;Pruning old cache entries.&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        long before = mTotalSize;</div><div class=\"line\">        int prunedFiles = 0;</div><div class=\"line\">        long startTime = SystemClock.elapsedRealtime();</div><div class=\"line\"></div><div class=\"line\">        Iterator&lt;Map.Entry&lt;String, CacheHeader&gt;&gt; iterator = mEntries.entrySet().iterator();</div><div class=\"line\"></div><div class=\"line\">        while (iterator.hasNext()) &#123;</div><div class=\"line\"></div><div class=\"line\">            Map.Entry&lt;String, CacheHeader&gt; entry = iterator.next();</div><div class=\"line\"></div><div class=\"line\">            CacheHeader e = entry.getValue();</div><div class=\"line\"></div><div class=\"line\">            boolean deleted = getFileForKey(e.key).delete();</div><div class=\"line\"></div><div class=\"line\">            if (deleted) &#123;</div><div class=\"line\">                mTotalSize -= e.size;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">               VolleyLog.d(&quot;Could not delete cache entry for key=%s, filename=%s&quot;,</div><div class=\"line\">                       e.key, getFilenameForKey(e.key));</div><div class=\"line\">            &#125;</div><div class=\"line\">            iterator.remove();</div><div class=\"line\">            prunedFiles++;</div><div class=\"line\"></div><div class=\"line\">            /**</div><div class=\"line\">             * 一直清除缓存</div><div class=\"line\">             * 直到存入这个neededSapce之后还有一小部分空余的地方</div><div class=\"line\">             */</div><div class=\"line\">            if ((mTotalSize + neededSpace) &lt; mMaxCacheSizeInBytes * HYSTERESIS_FACTOR) &#123;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (VolleyLog.DEBUG) &#123;</div><div class=\"line\">            VolleyLog.v(&quot;pruned %d files, %d bytes, %d ms&quot;,</div><div class=\"line\">                    prunedFiles, (mTotalSize - before), SystemClock.elapsedRealtime() - startTime);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Puts the entry with the specified key into the cache.</div><div class=\"line\">     * 将目录下指定的缓存加载到mEntries中去</div><div class=\"line\">     * 为了方便之后对缓存的读写操作</div><div class=\"line\">     * 全部读写一遍放在内存里面，对查询什么的都会方便很多</div><div class=\"line\">     *</div><div class=\"line\">     * @param key The key to identify the entry by.</div><div class=\"line\">     * @param entry The entry to cache.</div><div class=\"line\">     */</div><div class=\"line\">    private void putEntry(String key, CacheHeader entry) &#123;</div><div class=\"line\">        if (!mEntries.containsKey(key)) &#123;</div><div class=\"line\">            mTotalSize += entry.size;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            CacheHeader oldEntry = mEntries.get(key);</div><div class=\"line\">            mTotalSize += (entry.size - oldEntry.size);</div><div class=\"line\">        &#125;</div><div class=\"line\">        mEntries.put(key, entry);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Removes the entry identified by &apos;key&apos; from the cache.</div><div class=\"line\">     */</div><div class=\"line\">    private void removeEntry(String key) &#123;</div><div class=\"line\">        CacheHeader entry = mEntries.get(key);</div><div class=\"line\">        if (entry != null) &#123;</div><div class=\"line\">            mTotalSize -= entry.size;</div><div class=\"line\">            mEntries.remove(key);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Reads the contents of an InputStream into a byte[].</div><div class=\"line\">     * 从InputStream中读取指定长度的数据</div><div class=\"line\">     * </div><div class=\"line\">     */</div><div class=\"line\">    private static byte[] streamToBytes(InputStream in, int length) throws IOException &#123;</div><div class=\"line\">        byte[] bytes = new byte[length];</div><div class=\"line\">        int count;</div><div class=\"line\">        int pos = 0;</div><div class=\"line\">        while (pos &lt; length &amp;&amp; ((count = in.read(bytes, pos, length - pos)) != -1)) &#123;</div><div class=\"line\">            pos += count;</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (pos != length) &#123;</div><div class=\"line\">            throw new IOException(&quot;Expected &quot; + length + &quot; bytes, read &quot; + pos + &quot; bytes&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        return bytes;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Handles holding onto the cache headers for an entry.</div><div class=\"line\">     */</div><div class=\"line\">    // Visible for testing.</div><div class=\"line\">    static class CacheHeader &#123;</div><div class=\"line\">        /** </div><div class=\"line\">         * The size of the data identified by this CacheHeader. (This is not</div><div class=\"line\">         * serialized to disk.</div><div class=\"line\">         * </div><div class=\"line\">         * CacheHeader所表示的数据段的大小 </div><div class=\"line\">         */</div><div class=\"line\">        public long size;</div><div class=\"line\"></div><div class=\"line\">        /** </div><div class=\"line\">         * The key that identifies the cache entry. </div><div class=\"line\">         * 这个key应该是request对应其缓存的唯一key</div><div class=\"line\">         */</div><div class=\"line\">        public String key;</div><div class=\"line\"></div><div class=\"line\">        /** </div><div class=\"line\">         * ETag for cache coherence.</div><div class=\"line\">         *</div><div class=\"line\">         */</div><div class=\"line\">        public String etag;</div><div class=\"line\"></div><div class=\"line\">        /** </div><div class=\"line\">         * Date of this response as reported by the server. </div><div class=\"line\">         * 缓存起来的数据返回的日期</div><div class=\"line\">         */</div><div class=\"line\">        public long serverDate;</div><div class=\"line\"></div><div class=\"line\">        /** </div><div class=\"line\">         * The last modified date for the requested object. </div><div class=\"line\">         * 最后一次更改的时间</div><div class=\"line\">         */</div><div class=\"line\">        public long lastModified;</div><div class=\"line\"></div><div class=\"line\">        /** </div><div class=\"line\">         * TTL for this record. </div><div class=\"line\">         * ping时候返回的TTL=128的概念如下</div><div class=\"line\">         * TTL：生存时间</div><div class=\"line\">         * 指定数据报被路由器丢弃之前允许通过的网段数量。</div><div class=\"line\">         * TTL 是由发送主机设置的，以防止数据包不断在 IP 互联网络上永不终止地循环。转发 IP 数据包时，要求路由器至少将 TTL 减小 1。</div><div class=\"line\">         *  </div><div class=\"line\">         * 但是= =，注意这里的和上面的那种不是一个概念，这里只是模拟了上面的概念，但也是用来标志缓存存活时间的。</div><div class=\"line\">         */</div><div class=\"line\">        public long ttl;</div><div class=\"line\"></div><div class=\"line\">        /** </div><div class=\"line\">         * Soft TTL for this record. </div><div class=\"line\">         * </div><div class=\"line\">         * 根据refreshNeeded()函数来看</div><div class=\"line\">         * 意思是需要更新缓存的时间点</div><div class=\"line\">         */</div><div class=\"line\">        public long softTtl;</div><div class=\"line\"></div><div class=\"line\">        /** </div><div class=\"line\">         * Headers from the response resulting in this cache entry. </div><div class=\"line\">         * 用来指向上一次response的header</div><div class=\"line\">         */</div><div class=\"line\">        public Map&lt;String, String&gt; responseHeaders;</div><div class=\"line\"></div><div class=\"line\">        private CacheHeader() &#123; &#125;</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * Instantiates a new CacheHeader object</div><div class=\"line\">         * @param key The key that identifies the cache entry</div><div class=\"line\">         * @param entry The cache entry.</div><div class=\"line\">         */</div><div class=\"line\">        public CacheHeader(String key, Entry entry) &#123;</div><div class=\"line\">            this.key = key;</div><div class=\"line\">            this.size = entry.data.length;</div><div class=\"line\">            this.etag = entry.etag;</div><div class=\"line\">            this.serverDate = entry.serverDate;</div><div class=\"line\">            this.lastModified = entry.lastModified;</div><div class=\"line\">            this.ttl = entry.ttl;</div><div class=\"line\">            this.softTtl = entry.softTtl;</div><div class=\"line\">            this.responseHeaders = entry.responseHeaders;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * Reads the header off of an InputStream and returns a CacheHeader object.</div><div class=\"line\">         * 从InputStream中读取数据并组建一个CacheHeader对象实例</div><div class=\"line\">         * @param is The InputStream to read from.</div><div class=\"line\">         * @throws IOException</div><div class=\"line\">         */</div><div class=\"line\">        public static CacheHeader readHeader(InputStream is) throws IOException &#123;</div><div class=\"line\">            CacheHeader entry = new CacheHeader();</div><div class=\"line\">            int magic = readInt(is);</div><div class=\"line\">            if (magic != CACHE_MAGIC) &#123;</div><div class=\"line\">                // don&apos;t bother deleting, it&apos;ll get pruned eventually</div><div class=\"line\">                throw new IOException();</div><div class=\"line\">            &#125;</div><div class=\"line\">            entry.key = readString(is);</div><div class=\"line\">            entry.etag = readString(is);</div><div class=\"line\">            if (entry.etag.equals(&quot;&quot;)) &#123;</div><div class=\"line\">                entry.etag = null;</div><div class=\"line\">            &#125;</div><div class=\"line\">            entry.serverDate = readLong(is);</div><div class=\"line\">            entry.lastModified = readLong(is);</div><div class=\"line\">            entry.ttl = readLong(is);</div><div class=\"line\">            entry.softTtl = readLong(is);</div><div class=\"line\">            entry.responseHeaders = readStringStringMap(is);</div><div class=\"line\"></div><div class=\"line\">            return entry;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * Creates a cache entry for the specified data.</div><div class=\"line\">         * 从CacheHeader转换成Entry类的实例</div><div class=\"line\">         */</div><div class=\"line\">        public Entry toCacheEntry(byte[] data) &#123;</div><div class=\"line\">            Entry e = new Entry();</div><div class=\"line\">            e.data = data;</div><div class=\"line\">            e.etag = etag;</div><div class=\"line\">            e.serverDate = serverDate;</div><div class=\"line\">            e.lastModified = lastModified;</div><div class=\"line\">            e.ttl = ttl;</div><div class=\"line\">            e.softTtl = softTtl;</div><div class=\"line\">            e.responseHeaders = responseHeaders;</div><div class=\"line\">            return e;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * Writes the contents of this CacheHeader to the specified OutputStream.</div><div class=\"line\">         * 将CacheHeader里面的数据写入指定的OutputStream中</div><div class=\"line\">         */</div><div class=\"line\">        public boolean writeHeader(OutputStream os) &#123;</div><div class=\"line\">            try &#123;</div><div class=\"line\">                writeInt(os, CACHE_MAGIC);</div><div class=\"line\">                writeString(os, key);</div><div class=\"line\">                writeString(os, etag == null ? &quot;&quot; : etag);</div><div class=\"line\">                writeLong(os, serverDate);</div><div class=\"line\">                writeLong(os, lastModified);</div><div class=\"line\">                writeLong(os, ttl);</div><div class=\"line\">                writeLong(os, softTtl);</div><div class=\"line\">                writeStringStringMap(responseHeaders, os);</div><div class=\"line\">                os.flush();</div><div class=\"line\">                return true;</div><div class=\"line\">            &#125; catch (IOException e) &#123;</div><div class=\"line\">                VolleyLog.d(&quot;%s&quot;, e.toString());</div><div class=\"line\">                return false;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * 继承了FilterInputStream</div><div class=\"line\">     * 没啥特别的= =</div><div class=\"line\">     */</div><div class=\"line\"></div><div class=\"line\">    private static class CountingInputStream extends FilterInputStream &#123;</div><div class=\"line\"></div><div class=\"line\">        private int bytesRead = 0;</div><div class=\"line\"></div><div class=\"line\">        private CountingInputStream(InputStream in) &#123;</div><div class=\"line\">            super(in);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        @Override</div><div class=\"line\">        public int read() throws IOException &#123;</div><div class=\"line\">            int result = super.read();</div><div class=\"line\">            if (result != -1) &#123;</div><div class=\"line\">                bytesRead++;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return result;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        @Override</div><div class=\"line\">        public int read(byte[] buffer, int offset, int count) throws IOException &#123;</div><div class=\"line\">            int result = super.read(buffer, offset, count);</div><div class=\"line\">            if (result != -1) &#123;</div><div class=\"line\">                bytesRead += result;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return result;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /*</div><div class=\"line\">     * Homebrewed simple serialization system used for reading and writing cache</div><div class=\"line\">     * headers on disk. Once upon a time, this used the standard Java</div><div class=\"line\">     * Object&#123;Input,Output&#125;Stream, but the default implementation relies heavily</div><div class=\"line\">     * on reflection (even for standard types) and generates a ton of garbage.</div><div class=\"line\">     * </div><div class=\"line\">     */</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Simple wrapper around &#123;@link InputStream#read()&#125; that throws EOFException</div><div class=\"line\">     * instead of returning -1.</div><div class=\"line\">     * 如果文件读到了末尾直接抛出异常</div><div class=\"line\">     */</div><div class=\"line\">    private static int read(InputStream is) throws IOException &#123;</div><div class=\"line\">        int b = is.read();</div><div class=\"line\">        if (b == -1) &#123;</div><div class=\"line\">            throw new EOFException();</div><div class=\"line\">        &#125;</div><div class=\"line\">        return b;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * 刚开始看到这里的时候没有明白是什么意思= =</div><div class=\"line\">     * 就不明白了，好好的一个int类型的数据</div><div class=\"line\">     * 为什么非要分段写入呢，一个字节一个字节的写入</div><div class=\"line\">     * 后来查了资料才发现，OutputStream及其子类的write()方法</div><div class=\"line\">     * 一次都只能写入一个byte，int类型有4个byte，分四次写入没什么问题咯</div><div class=\"line\">     */</div><div class=\"line\"></div><div class=\"line\">    static void writeInt(OutputStream os, int n) throws IOException &#123;</div><div class=\"line\">        os.write((n &gt;&gt; 0) &amp; 0xff);</div><div class=\"line\">        os.write((n &gt;&gt; 8) &amp; 0xff);</div><div class=\"line\">        os.write((n &gt;&gt; 16) &amp; 0xff);</div><div class=\"line\">        os.write((n &gt;&gt; 24) &amp; 0xff);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    static int readInt(InputStream is) throws IOException &#123;</div><div class=\"line\">        int n = 0;</div><div class=\"line\">        n |= (read(is) &lt;&lt; 0);</div><div class=\"line\">        n |= (read(is) &lt;&lt; 8);</div><div class=\"line\">        n |= (read(is) &lt;&lt; 16);</div><div class=\"line\">        n |= (read(is) &lt;&lt; 24);</div><div class=\"line\">        return n;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    static void writeLong(OutputStream os, long n) throws IOException &#123;</div><div class=\"line\">        os.write((byte)(n &gt;&gt;&gt; 0));</div><div class=\"line\">        os.write((byte)(n &gt;&gt;&gt; 8));</div><div class=\"line\">        os.write((byte)(n &gt;&gt;&gt; 16));</div><div class=\"line\">        os.write((byte)(n &gt;&gt;&gt; 24));</div><div class=\"line\">        os.write((byte)(n &gt;&gt;&gt; 32));</div><div class=\"line\">        os.write((byte)(n &gt;&gt;&gt; 40));</div><div class=\"line\">        os.write((byte)(n &gt;&gt;&gt; 48));</div><div class=\"line\">        os.write((byte)(n &gt;&gt;&gt; 56));</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    static long readLong(InputStream is) throws IOException &#123;</div><div class=\"line\">        long n = 0;</div><div class=\"line\">        n |= ((read(is) &amp; 0xFFL) &lt;&lt; 0);</div><div class=\"line\">        n |= ((read(is) &amp; 0xFFL) &lt;&lt; 8);</div><div class=\"line\">        n |= ((read(is) &amp; 0xFFL) &lt;&lt; 16);</div><div class=\"line\">        n |= ((read(is) &amp; 0xFFL) &lt;&lt; 24);</div><div class=\"line\">        n |= ((read(is) &amp; 0xFFL) &lt;&lt; 32);</div><div class=\"line\">        n |= ((read(is) &amp; 0xFFL) &lt;&lt; 40);</div><div class=\"line\">        n |= ((read(is) &amp; 0xFFL) &lt;&lt; 48);</div><div class=\"line\">        n |= ((read(is) &amp; 0xFFL) &lt;&lt; 56);</div><div class=\"line\">        return n;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    static void writeString(OutputStream os, String s) throws IOException &#123;</div><div class=\"line\">        byte[] b = s.getBytes(&quot;UTF-8&quot;);</div><div class=\"line\">        writeLong(os, b.length);</div><div class=\"line\">        os.write(b, 0, b.length);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    static String readString(InputStream is) throws IOException &#123;</div><div class=\"line\">        int n = (int) readLong(is);</div><div class=\"line\">        byte[] b = streamToBytes(is, n);</div><div class=\"line\">        return new String(b, &quot;UTF-8&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    static void writeStringStringMap(Map&lt;String, String&gt; map, OutputStream os) throws IOException &#123;</div><div class=\"line\">        if (map != null) &#123;</div><div class=\"line\">            writeInt(os, map.size());</div><div class=\"line\">            for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</div><div class=\"line\">                writeString(os, entry.getKey());</div><div class=\"line\">                writeString(os, entry.getValue());</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            writeInt(os, 0);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * 从InputStream中读取key类型为String，值类型也为String的Map</div><div class=\"line\">     */ </div><div class=\"line\">    static Map&lt;String, String&gt; readStringStringMap(InputStream is) throws IOException &#123;</div><div class=\"line\">        int size = readInt(is);</div><div class=\"line\">        Map&lt;String, String&gt; result = (size == 0)</div><div class=\"line\">                ? Collections.&lt;String, String&gt;emptyMap()</div><div class=\"line\">                : new HashMap&lt;String, String&gt;(size);</div><div class=\"line\">        for (int i = 0; i &lt; size; i++) &#123;</div><div class=\"line\"></div><div class=\"line\">            //将读出来的byte[]转换成String</div><div class=\"line\"></div><div class=\"line\">            String key = readString(is).intern();</div><div class=\"line\">            String value = readString(is).intern();</div><div class=\"line\">            result.put(key, value);</div><div class=\"line\">        &#125;</div><div class=\"line\">        return result;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>涉及到缓存读写的这个实现类当时阅读的时候还是花了不少时间的= =，人太笨了没办法orz，有什么不妥的地方还望各位juju多多指教，小达感激不尽0.0。下面还有Request.java等类等着去解析呢，Volley中的主角要登场了╭(╯^╰)╮。</p>"},{"title":"关于字符编码","date":"2017-03-21T06:42:28.000Z","_content":"\n## 关于字符编码\n\n### 1. 字符集和字符编码\n\n&#160;&#160;&#160;&#160;各种文字和符号的总称为字符，多个字符集合为字符集，不同字符集包含字符个数不同，常见字符集有ASCII、ISO 8859、GB2312、BIG5、GB18030、Unicode等。\n\n&#160;&#160;&#160;&#160;编码和字符集不同，字符集在传输的过程中需要进行编码，编码方式有UTF-8、UTF-16等等，字符变吗就是以二进制的数字来对应字符集的字符。\n\n&#160;&#160;&#160;&#160;一般国家制定字符集和编码的时候都是同时进行的，平常说的GBK等有字符集和编码两层意思。\n\n> Unicode字符集有多种编码方式，如UTF-8、UTF-16等；ASCII只有一种；\n\n\n<!--more-->\n\n### 2. 内码\n&#160;&#160;&#160;&#160;内码指的是“将资讯编码后，透过某种方式储存在特定记忆装置时，装置内部的编码形式”。在不同的系统中，会有不同的内码。\n在以往的英文系统中，内码为ASCII。在繁体中文系统中，目前常用的内码为大五码（Big5）。在简体中文系统中，内码则为国标码（国家标准代码：现在强制要求使用GB18030标准；较旧计算机仍然使用GB2312）。而统一码（Unicode）则为另一常见内码。\n\n### 3. 字符编码分类\n\n#### 3.1 ASCII编码\n&#160;&#160;&#160;&#160;ASCII（American Standard Code for Information Interchange，美国信息互换标准代码）是基于拉丁字母的一套电脑编码系统。[字符编码表](http://zh.wikipedia.org/zh-cn/ASCII)\n\n- 单字节编码 ： 单字节字符串使用一个字节存放一个字符（SBCS,Single Byte Character System）。如：\"Bob123\"占6个字节。\n- 缺点 ： 只能显示26个字符、阿拉伯数字、英文标点\n\n#### 3.2 ANSI编码\n&#160;&#160;&#160;&#160;为了支持更多语言，通常使用0x800~xFF范围的两个字节来表示一个字符，例如“中”使用[0xD6,0xD0]这两个字节存储。不用国家制定了不同的标准，使用两个字节来表示一个字符的各种汉字延伸编码方式称为ANSI编码。简体中文系统下，ANSI编码代表GB2312编码。\n\n#### 3.3 Unicode编码\n&#160;&#160;&#160;&#160;为了国际间信息交流方便，制定了Unicode字符集，为每种语言中的字符设定了统一并唯一的数字编号。\n\n&#160;&#160;&#160;&#160;Unicode字符集简写为UCS(Unicode Character Set)。早期的unicodeUnicode标准有UCS-2、UCS-4的说法。UCS-2用两个字节编码，UCS-4用4个字节编码。\n\n### 4. 编码区别\n#### 4.1 GB2312、GBK、GB18030\n\n1. **GB2312**\n\tASCII码中127号之后的奇异符号们直接取消掉, 规定：一个小于127的字符的意义与原来相同，但两个大于127的字符连在一起时，表示一个汉字，前面的一个字节（称之为高字节）从0xA1用到0xF7，后面一个字节（低字节）从0xA1到0xFE，这样我们就可以组合出大约7000多个简体汉字了。这就是常说的\"全角\"字符，而原来在127号以下的那些就叫\"半角\"字符了。这种汉字方案叫做 \"GB2312\"。GB2312 是对 ASCII 的中文扩展。兼容ASCII。\n2. **GBK**\n\t不再要求低字节一定是127号之后的内码，只要第一个字节是大于127就固定表示这是一个汉字的开始，不管后面跟的是不是扩展字符集里的内容。对GB2312的扩展\n3. **GB18030**\n\t在GBK基础上扩展了少数民族的文字\n\n#### 4.2 UTF-8、UTF-16\n&#160;&#160;&#160;&#160;Unicode中所有字符都使用一个\"Unicode\"进行表示，采用双字节编码，和单字节编码的ASCII编码不兼容。UTF即UCS Transformation Format，即UCS转换(传输)格式。是将Unicode编码规则和计算机的实际编码对应起来的规则，流行的UTF有两种，UTF-8和UTF-16。\n\n1. **UTF-8**\n| UCS-2编码(16进制)  | UTF-8 字节流(二进制) |\n|--------|--------|\n|    0000 - 007F    |    0xxxxxxx    |\n|    0080 - 07FF    |    110xxxxx 10xxxxxx    |\n|    0800 - FFFF    |   1110xxxx 10xxxxxx 10xxxxxx      |\n\n&#160;&#160;&#160;&#160;例如“汉”字的Unicode编码是6C49。6C49在0800-FFFF之间，所以肯定要用3字节模板了：1110xxxx 10xxxxxx 10xxxxxx。将6C49写成二进制是：0110 110001 001001，用这个比特流依次代替模板中的x，得到：11100110 10110001 10001001，即E6 B1 89。\n\n&#160;&#160;&#160;&#160;UTF-16以16位为单元对UCS进行编码。对于小于0x10000的UCS码，UTF-16编码就等于UCS码对应的16位无符号整数。对于不小于0x10000的UCS码，定义了一个算法。不过由于实际使用的UCS2，或者UCS4的BMP必然小于0x10000，所以就目前而言，可以认为UTF-16和UCS-2基本相同。但UCS-2只是一个编码方案，UTF-16却要用于实际的传输，所以就不得不考虑字节序的问题。\n\n2. **UTF-16**\n\n&#160;&#160;&#160;&#160;UTF-16以16位为单元对UCS进行编码。对于小于0x10000的UCS码，UTF-16编码就等于UCS码对应的16位无符号整数。对于不小于0x10000的UCS码，定义了一个算法。不过由于实际使用的UCS2，或者UCS4的BMP必然小于0x10000，所以就目前而言，可以认为UTF-16和UCS-2基本相同。但UCS-2只是一个编码方案，UTF-16却要用于实际的传输，所以就不得不考虑字节序的问题。\n\n&#160;&#160;&#160;&#160;UTF-16不兼容ASCII。\n\n#### 5.1 UTF的字节序和BOM\n\n##### 5.1.1 字节序列\n&#160;&#160;&#160;&#160;UTF-8以字节为编码单元，而UTF-16两个字节编码单元，解释UTF-16文本前，先要弄清每个编码单元的字节序。Unicode规范中推荐的标记字节顺序的方法是BOM，也就是Byte Order Mark。\n\n&#160;&#160;&#160;&#160;在UCS编码中有一个叫做\"ZERO WIDTH NO-BREAK SPACE\"的字符，它的编码是FEFF。而FFFE在UCS中是不存在的字符，所以不应该出现在实际传输中。UCS规范建议我们在传输字节流前，先传输字符\"ZERO WIDTH NO-BREAK SPACE\"。这样如果接收者收到FEFF，就表明这个字节流是Big-Endian的；如果收到FFFE，就表明这个字节流是Little-Endian的。因此字符\"ZERO WIDTH NO-BREAK SPACE\"又被称作BOM。","source":"_posts/关于字符编码.md","raw":"---\ntitle: 关于字符编码\ndate: 2017-03-21 14:42:28\ntags: other\n\n---\n\n## 关于字符编码\n\n### 1. 字符集和字符编码\n\n&#160;&#160;&#160;&#160;各种文字和符号的总称为字符，多个字符集合为字符集，不同字符集包含字符个数不同，常见字符集有ASCII、ISO 8859、GB2312、BIG5、GB18030、Unicode等。\n\n&#160;&#160;&#160;&#160;编码和字符集不同，字符集在传输的过程中需要进行编码，编码方式有UTF-8、UTF-16等等，字符变吗就是以二进制的数字来对应字符集的字符。\n\n&#160;&#160;&#160;&#160;一般国家制定字符集和编码的时候都是同时进行的，平常说的GBK等有字符集和编码两层意思。\n\n> Unicode字符集有多种编码方式，如UTF-8、UTF-16等；ASCII只有一种；\n\n\n<!--more-->\n\n### 2. 内码\n&#160;&#160;&#160;&#160;内码指的是“将资讯编码后，透过某种方式储存在特定记忆装置时，装置内部的编码形式”。在不同的系统中，会有不同的内码。\n在以往的英文系统中，内码为ASCII。在繁体中文系统中，目前常用的内码为大五码（Big5）。在简体中文系统中，内码则为国标码（国家标准代码：现在强制要求使用GB18030标准；较旧计算机仍然使用GB2312）。而统一码（Unicode）则为另一常见内码。\n\n### 3. 字符编码分类\n\n#### 3.1 ASCII编码\n&#160;&#160;&#160;&#160;ASCII（American Standard Code for Information Interchange，美国信息互换标准代码）是基于拉丁字母的一套电脑编码系统。[字符编码表](http://zh.wikipedia.org/zh-cn/ASCII)\n\n- 单字节编码 ： 单字节字符串使用一个字节存放一个字符（SBCS,Single Byte Character System）。如：\"Bob123\"占6个字节。\n- 缺点 ： 只能显示26个字符、阿拉伯数字、英文标点\n\n#### 3.2 ANSI编码\n&#160;&#160;&#160;&#160;为了支持更多语言，通常使用0x800~xFF范围的两个字节来表示一个字符，例如“中”使用[0xD6,0xD0]这两个字节存储。不用国家制定了不同的标准，使用两个字节来表示一个字符的各种汉字延伸编码方式称为ANSI编码。简体中文系统下，ANSI编码代表GB2312编码。\n\n#### 3.3 Unicode编码\n&#160;&#160;&#160;&#160;为了国际间信息交流方便，制定了Unicode字符集，为每种语言中的字符设定了统一并唯一的数字编号。\n\n&#160;&#160;&#160;&#160;Unicode字符集简写为UCS(Unicode Character Set)。早期的unicodeUnicode标准有UCS-2、UCS-4的说法。UCS-2用两个字节编码，UCS-4用4个字节编码。\n\n### 4. 编码区别\n#### 4.1 GB2312、GBK、GB18030\n\n1. **GB2312**\n\tASCII码中127号之后的奇异符号们直接取消掉, 规定：一个小于127的字符的意义与原来相同，但两个大于127的字符连在一起时，表示一个汉字，前面的一个字节（称之为高字节）从0xA1用到0xF7，后面一个字节（低字节）从0xA1到0xFE，这样我们就可以组合出大约7000多个简体汉字了。这就是常说的\"全角\"字符，而原来在127号以下的那些就叫\"半角\"字符了。这种汉字方案叫做 \"GB2312\"。GB2312 是对 ASCII 的中文扩展。兼容ASCII。\n2. **GBK**\n\t不再要求低字节一定是127号之后的内码，只要第一个字节是大于127就固定表示这是一个汉字的开始，不管后面跟的是不是扩展字符集里的内容。对GB2312的扩展\n3. **GB18030**\n\t在GBK基础上扩展了少数民族的文字\n\n#### 4.2 UTF-8、UTF-16\n&#160;&#160;&#160;&#160;Unicode中所有字符都使用一个\"Unicode\"进行表示，采用双字节编码，和单字节编码的ASCII编码不兼容。UTF即UCS Transformation Format，即UCS转换(传输)格式。是将Unicode编码规则和计算机的实际编码对应起来的规则，流行的UTF有两种，UTF-8和UTF-16。\n\n1. **UTF-8**\n| UCS-2编码(16进制)  | UTF-8 字节流(二进制) |\n|--------|--------|\n|    0000 - 007F    |    0xxxxxxx    |\n|    0080 - 07FF    |    110xxxxx 10xxxxxx    |\n|    0800 - FFFF    |   1110xxxx 10xxxxxx 10xxxxxx      |\n\n&#160;&#160;&#160;&#160;例如“汉”字的Unicode编码是6C49。6C49在0800-FFFF之间，所以肯定要用3字节模板了：1110xxxx 10xxxxxx 10xxxxxx。将6C49写成二进制是：0110 110001 001001，用这个比特流依次代替模板中的x，得到：11100110 10110001 10001001，即E6 B1 89。\n\n&#160;&#160;&#160;&#160;UTF-16以16位为单元对UCS进行编码。对于小于0x10000的UCS码，UTF-16编码就等于UCS码对应的16位无符号整数。对于不小于0x10000的UCS码，定义了一个算法。不过由于实际使用的UCS2，或者UCS4的BMP必然小于0x10000，所以就目前而言，可以认为UTF-16和UCS-2基本相同。但UCS-2只是一个编码方案，UTF-16却要用于实际的传输，所以就不得不考虑字节序的问题。\n\n2. **UTF-16**\n\n&#160;&#160;&#160;&#160;UTF-16以16位为单元对UCS进行编码。对于小于0x10000的UCS码，UTF-16编码就等于UCS码对应的16位无符号整数。对于不小于0x10000的UCS码，定义了一个算法。不过由于实际使用的UCS2，或者UCS4的BMP必然小于0x10000，所以就目前而言，可以认为UTF-16和UCS-2基本相同。但UCS-2只是一个编码方案，UTF-16却要用于实际的传输，所以就不得不考虑字节序的问题。\n\n&#160;&#160;&#160;&#160;UTF-16不兼容ASCII。\n\n#### 5.1 UTF的字节序和BOM\n\n##### 5.1.1 字节序列\n&#160;&#160;&#160;&#160;UTF-8以字节为编码单元，而UTF-16两个字节编码单元，解释UTF-16文本前，先要弄清每个编码单元的字节序。Unicode规范中推荐的标记字节顺序的方法是BOM，也就是Byte Order Mark。\n\n&#160;&#160;&#160;&#160;在UCS编码中有一个叫做\"ZERO WIDTH NO-BREAK SPACE\"的字符，它的编码是FEFF。而FFFE在UCS中是不存在的字符，所以不应该出现在实际传输中。UCS规范建议我们在传输字节流前，先传输字符\"ZERO WIDTH NO-BREAK SPACE\"。这样如果接收者收到FEFF，就表明这个字节流是Big-Endian的；如果收到FFFE，就表明这个字节流是Little-Endian的。因此字符\"ZERO WIDTH NO-BREAK SPACE\"又被称作BOM。","slug":"关于字符编码","published":1,"updated":"2020-07-03T02:40:48.122Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc5n2qhb000rw8r1d990ys1d","content":"<h2 id=\"关于字符编码\"><a href=\"#关于字符编码\" class=\"headerlink\" title=\"关于字符编码\"></a>关于字符编码</h2><h3 id=\"1-字符集和字符编码\"><a href=\"#1-字符集和字符编码\" class=\"headerlink\" title=\"1. 字符集和字符编码\"></a>1. 字符集和字符编码</h3><p>&#160;&#160;&#160;&#160;各种文字和符号的总称为字符，多个字符集合为字符集，不同字符集包含字符个数不同，常见字符集有ASCII、ISO 8859、GB2312、BIG5、GB18030、Unicode等。</p>\n<p>&#160;&#160;&#160;&#160;编码和字符集不同，字符集在传输的过程中需要进行编码，编码方式有UTF-8、UTF-16等等，字符变吗就是以二进制的数字来对应字符集的字符。</p>\n<p>&#160;&#160;&#160;&#160;一般国家制定字符集和编码的时候都是同时进行的，平常说的GBK等有字符集和编码两层意思。</p>\n<blockquote>\n<p>Unicode字符集有多种编码方式，如UTF-8、UTF-16等；ASCII只有一种；</p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"2-内码\"><a href=\"#2-内码\" class=\"headerlink\" title=\"2. 内码\"></a>2. 内码</h3><p>&#160;&#160;&#160;&#160;内码指的是“将资讯编码后，透过某种方式储存在特定记忆装置时，装置内部的编码形式”。在不同的系统中，会有不同的内码。<br>在以往的英文系统中，内码为ASCII。在繁体中文系统中，目前常用的内码为大五码（Big5）。在简体中文系统中，内码则为国标码（国家标准代码：现在强制要求使用GB18030标准；较旧计算机仍然使用GB2312）。而统一码（Unicode）则为另一常见内码。</p>\n<h3 id=\"3-字符编码分类\"><a href=\"#3-字符编码分类\" class=\"headerlink\" title=\"3. 字符编码分类\"></a>3. 字符编码分类</h3><h4 id=\"3-1-ASCII编码\"><a href=\"#3-1-ASCII编码\" class=\"headerlink\" title=\"3.1 ASCII编码\"></a>3.1 ASCII编码</h4><p>&#160;&#160;&#160;&#160;ASCII（American Standard Code for Information Interchange，美国信息互换标准代码）是基于拉丁字母的一套电脑编码系统。<a href=\"http://zh.wikipedia.org/zh-cn/ASCII\" target=\"_blank\" rel=\"noopener\">字符编码表</a></p>\n<ul>\n<li>单字节编码 ： 单字节字符串使用一个字节存放一个字符（SBCS,Single Byte Character System）。如：”Bob123”占6个字节。</li>\n<li>缺点 ： 只能显示26个字符、阿拉伯数字、英文标点</li>\n</ul>\n<h4 id=\"3-2-ANSI编码\"><a href=\"#3-2-ANSI编码\" class=\"headerlink\" title=\"3.2 ANSI编码\"></a>3.2 ANSI编码</h4><p>&#160;&#160;&#160;&#160;为了支持更多语言，通常使用0x800~xFF范围的两个字节来表示一个字符，例如“中”使用[0xD6,0xD0]这两个字节存储。不用国家制定了不同的标准，使用两个字节来表示一个字符的各种汉字延伸编码方式称为ANSI编码。简体中文系统下，ANSI编码代表GB2312编码。</p>\n<h4 id=\"3-3-Unicode编码\"><a href=\"#3-3-Unicode编码\" class=\"headerlink\" title=\"3.3 Unicode编码\"></a>3.3 Unicode编码</h4><p>&#160;&#160;&#160;&#160;为了国际间信息交流方便，制定了Unicode字符集，为每种语言中的字符设定了统一并唯一的数字编号。</p>\n<p>&#160;&#160;&#160;&#160;Unicode字符集简写为UCS(Unicode Character Set)。早期的unicodeUnicode标准有UCS-2、UCS-4的说法。UCS-2用两个字节编码，UCS-4用4个字节编码。</p>\n<h3 id=\"4-编码区别\"><a href=\"#4-编码区别\" class=\"headerlink\" title=\"4. 编码区别\"></a>4. 编码区别</h3><h4 id=\"4-1-GB2312、GBK、GB18030\"><a href=\"#4-1-GB2312、GBK、GB18030\" class=\"headerlink\" title=\"4.1 GB2312、GBK、GB18030\"></a>4.1 GB2312、GBK、GB18030</h4><ol>\n<li><strong>GB2312</strong><br> ASCII码中127号之后的奇异符号们直接取消掉, 规定：一个小于127的字符的意义与原来相同，但两个大于127的字符连在一起时，表示一个汉字，前面的一个字节（称之为高字节）从0xA1用到0xF7，后面一个字节（低字节）从0xA1到0xFE，这样我们就可以组合出大约7000多个简体汉字了。这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。这种汉字方案叫做 “GB2312”。GB2312 是对 ASCII 的中文扩展。兼容ASCII。</li>\n<li><strong>GBK</strong><br> 不再要求低字节一定是127号之后的内码，只要第一个字节是大于127就固定表示这是一个汉字的开始，不管后面跟的是不是扩展字符集里的内容。对GB2312的扩展</li>\n<li><strong>GB18030</strong><br> 在GBK基础上扩展了少数民族的文字</li>\n</ol>\n<h4 id=\"4-2-UTF-8、UTF-16\"><a href=\"#4-2-UTF-8、UTF-16\" class=\"headerlink\" title=\"4.2 UTF-8、UTF-16\"></a>4.2 UTF-8、UTF-16</h4><p>&#160;&#160;&#160;&#160;Unicode中所有字符都使用一个”Unicode”进行表示，采用双字节编码，和单字节编码的ASCII编码不兼容。UTF即UCS Transformation Format，即UCS转换(传输)格式。是将Unicode编码规则和计算机的实际编码对应起来的规则，流行的UTF有两种，UTF-8和UTF-16。</p>\n<ol>\n<li><strong>UTF-8</strong><br>| UCS-2编码(16进制)  | UTF-8 字节流(二进制) |<br>|——–|——–|<br>|    0000 - 007F    |    0xxxxxxx    |<br>|    0080 - 07FF    |    110xxxxx 10xxxxxx    |<br>|    0800 - FFFF    |   1110xxxx 10xxxxxx 10xxxxxx      |</li>\n</ol>\n<p>&#160;&#160;&#160;&#160;例如“汉”字的Unicode编码是6C49。6C49在0800-FFFF之间，所以肯定要用3字节模板了：1110xxxx 10xxxxxx 10xxxxxx。将6C49写成二进制是：0110 110001 001001，用这个比特流依次代替模板中的x，得到：11100110 10110001 10001001，即E6 B1 89。</p>\n<p>&#160;&#160;&#160;&#160;UTF-16以16位为单元对UCS进行编码。对于小于0x10000的UCS码，UTF-16编码就等于UCS码对应的16位无符号整数。对于不小于0x10000的UCS码，定义了一个算法。不过由于实际使用的UCS2，或者UCS4的BMP必然小于0x10000，所以就目前而言，可以认为UTF-16和UCS-2基本相同。但UCS-2只是一个编码方案，UTF-16却要用于实际的传输，所以就不得不考虑字节序的问题。</p>\n<ol>\n<li><strong>UTF-16</strong></li>\n</ol>\n<p>&#160;&#160;&#160;&#160;UTF-16以16位为单元对UCS进行编码。对于小于0x10000的UCS码，UTF-16编码就等于UCS码对应的16位无符号整数。对于不小于0x10000的UCS码，定义了一个算法。不过由于实际使用的UCS2，或者UCS4的BMP必然小于0x10000，所以就目前而言，可以认为UTF-16和UCS-2基本相同。但UCS-2只是一个编码方案，UTF-16却要用于实际的传输，所以就不得不考虑字节序的问题。</p>\n<p>&#160;&#160;&#160;&#160;UTF-16不兼容ASCII。</p>\n<h4 id=\"5-1-UTF的字节序和BOM\"><a href=\"#5-1-UTF的字节序和BOM\" class=\"headerlink\" title=\"5.1 UTF的字节序和BOM\"></a>5.1 UTF的字节序和BOM</h4><h5 id=\"5-1-1-字节序列\"><a href=\"#5-1-1-字节序列\" class=\"headerlink\" title=\"5.1.1 字节序列\"></a>5.1.1 字节序列</h5><p>&#160;&#160;&#160;&#160;UTF-8以字节为编码单元，而UTF-16两个字节编码单元，解释UTF-16文本前，先要弄清每个编码单元的字节序。Unicode规范中推荐的标记字节顺序的方法是BOM，也就是Byte Order Mark。</p>\n<p>&#160;&#160;&#160;&#160;在UCS编码中有一个叫做”ZERO WIDTH NO-BREAK SPACE”的字符，它的编码是FEFF。而FFFE在UCS中是不存在的字符，所以不应该出现在实际传输中。UCS规范建议我们在传输字节流前，先传输字符”ZERO WIDTH NO-BREAK SPACE”。这样如果接收者收到FEFF，就表明这个字节流是Big-Endian的；如果收到FFFE，就表明这个字节流是Little-Endian的。因此字符”ZERO WIDTH NO-BREAK SPACE”又被称作BOM。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"关于字符编码\"><a href=\"#关于字符编码\" class=\"headerlink\" title=\"关于字符编码\"></a>关于字符编码</h2><h3 id=\"1-字符集和字符编码\"><a href=\"#1-字符集和字符编码\" class=\"headerlink\" title=\"1. 字符集和字符编码\"></a>1. 字符集和字符编码</h3><p>&#160;&#160;&#160;&#160;各种文字和符号的总称为字符，多个字符集合为字符集，不同字符集包含字符个数不同，常见字符集有ASCII、ISO 8859、GB2312、BIG5、GB18030、Unicode等。</p>\n<p>&#160;&#160;&#160;&#160;编码和字符集不同，字符集在传输的过程中需要进行编码，编码方式有UTF-8、UTF-16等等，字符变吗就是以二进制的数字来对应字符集的字符。</p>\n<p>&#160;&#160;&#160;&#160;一般国家制定字符集和编码的时候都是同时进行的，平常说的GBK等有字符集和编码两层意思。</p>\n<blockquote>\n<p>Unicode字符集有多种编码方式，如UTF-8、UTF-16等；ASCII只有一种；</p>\n</blockquote>","more":"<h3 id=\"2-内码\"><a href=\"#2-内码\" class=\"headerlink\" title=\"2. 内码\"></a>2. 内码</h3><p>&#160;&#160;&#160;&#160;内码指的是“将资讯编码后，透过某种方式储存在特定记忆装置时，装置内部的编码形式”。在不同的系统中，会有不同的内码。<br>在以往的英文系统中，内码为ASCII。在繁体中文系统中，目前常用的内码为大五码（Big5）。在简体中文系统中，内码则为国标码（国家标准代码：现在强制要求使用GB18030标准；较旧计算机仍然使用GB2312）。而统一码（Unicode）则为另一常见内码。</p>\n<h3 id=\"3-字符编码分类\"><a href=\"#3-字符编码分类\" class=\"headerlink\" title=\"3. 字符编码分类\"></a>3. 字符编码分类</h3><h4 id=\"3-1-ASCII编码\"><a href=\"#3-1-ASCII编码\" class=\"headerlink\" title=\"3.1 ASCII编码\"></a>3.1 ASCII编码</h4><p>&#160;&#160;&#160;&#160;ASCII（American Standard Code for Information Interchange，美国信息互换标准代码）是基于拉丁字母的一套电脑编码系统。<a href=\"http://zh.wikipedia.org/zh-cn/ASCII\" target=\"_blank\" rel=\"noopener\">字符编码表</a></p>\n<ul>\n<li>单字节编码 ： 单字节字符串使用一个字节存放一个字符（SBCS,Single Byte Character System）。如：”Bob123”占6个字节。</li>\n<li>缺点 ： 只能显示26个字符、阿拉伯数字、英文标点</li>\n</ul>\n<h4 id=\"3-2-ANSI编码\"><a href=\"#3-2-ANSI编码\" class=\"headerlink\" title=\"3.2 ANSI编码\"></a>3.2 ANSI编码</h4><p>&#160;&#160;&#160;&#160;为了支持更多语言，通常使用0x800~xFF范围的两个字节来表示一个字符，例如“中”使用[0xD6,0xD0]这两个字节存储。不用国家制定了不同的标准，使用两个字节来表示一个字符的各种汉字延伸编码方式称为ANSI编码。简体中文系统下，ANSI编码代表GB2312编码。</p>\n<h4 id=\"3-3-Unicode编码\"><a href=\"#3-3-Unicode编码\" class=\"headerlink\" title=\"3.3 Unicode编码\"></a>3.3 Unicode编码</h4><p>&#160;&#160;&#160;&#160;为了国际间信息交流方便，制定了Unicode字符集，为每种语言中的字符设定了统一并唯一的数字编号。</p>\n<p>&#160;&#160;&#160;&#160;Unicode字符集简写为UCS(Unicode Character Set)。早期的unicodeUnicode标准有UCS-2、UCS-4的说法。UCS-2用两个字节编码，UCS-4用4个字节编码。</p>\n<h3 id=\"4-编码区别\"><a href=\"#4-编码区别\" class=\"headerlink\" title=\"4. 编码区别\"></a>4. 编码区别</h3><h4 id=\"4-1-GB2312、GBK、GB18030\"><a href=\"#4-1-GB2312、GBK、GB18030\" class=\"headerlink\" title=\"4.1 GB2312、GBK、GB18030\"></a>4.1 GB2312、GBK、GB18030</h4><ol>\n<li><strong>GB2312</strong><br> ASCII码中127号之后的奇异符号们直接取消掉, 规定：一个小于127的字符的意义与原来相同，但两个大于127的字符连在一起时，表示一个汉字，前面的一个字节（称之为高字节）从0xA1用到0xF7，后面一个字节（低字节）从0xA1到0xFE，这样我们就可以组合出大约7000多个简体汉字了。这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。这种汉字方案叫做 “GB2312”。GB2312 是对 ASCII 的中文扩展。兼容ASCII。</li>\n<li><strong>GBK</strong><br> 不再要求低字节一定是127号之后的内码，只要第一个字节是大于127就固定表示这是一个汉字的开始，不管后面跟的是不是扩展字符集里的内容。对GB2312的扩展</li>\n<li><strong>GB18030</strong><br> 在GBK基础上扩展了少数民族的文字</li>\n</ol>\n<h4 id=\"4-2-UTF-8、UTF-16\"><a href=\"#4-2-UTF-8、UTF-16\" class=\"headerlink\" title=\"4.2 UTF-8、UTF-16\"></a>4.2 UTF-8、UTF-16</h4><p>&#160;&#160;&#160;&#160;Unicode中所有字符都使用一个”Unicode”进行表示，采用双字节编码，和单字节编码的ASCII编码不兼容。UTF即UCS Transformation Format，即UCS转换(传输)格式。是将Unicode编码规则和计算机的实际编码对应起来的规则，流行的UTF有两种，UTF-8和UTF-16。</p>\n<ol>\n<li><strong>UTF-8</strong><br>| UCS-2编码(16进制)  | UTF-8 字节流(二进制) |<br>|——–|——–|<br>|    0000 - 007F    |    0xxxxxxx    |<br>|    0080 - 07FF    |    110xxxxx 10xxxxxx    |<br>|    0800 - FFFF    |   1110xxxx 10xxxxxx 10xxxxxx      |</li>\n</ol>\n<p>&#160;&#160;&#160;&#160;例如“汉”字的Unicode编码是6C49。6C49在0800-FFFF之间，所以肯定要用3字节模板了：1110xxxx 10xxxxxx 10xxxxxx。将6C49写成二进制是：0110 110001 001001，用这个比特流依次代替模板中的x，得到：11100110 10110001 10001001，即E6 B1 89。</p>\n<p>&#160;&#160;&#160;&#160;UTF-16以16位为单元对UCS进行编码。对于小于0x10000的UCS码，UTF-16编码就等于UCS码对应的16位无符号整数。对于不小于0x10000的UCS码，定义了一个算法。不过由于实际使用的UCS2，或者UCS4的BMP必然小于0x10000，所以就目前而言，可以认为UTF-16和UCS-2基本相同。但UCS-2只是一个编码方案，UTF-16却要用于实际的传输，所以就不得不考虑字节序的问题。</p>\n<ol>\n<li><strong>UTF-16</strong></li>\n</ol>\n<p>&#160;&#160;&#160;&#160;UTF-16以16位为单元对UCS进行编码。对于小于0x10000的UCS码，UTF-16编码就等于UCS码对应的16位无符号整数。对于不小于0x10000的UCS码，定义了一个算法。不过由于实际使用的UCS2，或者UCS4的BMP必然小于0x10000，所以就目前而言，可以认为UTF-16和UCS-2基本相同。但UCS-2只是一个编码方案，UTF-16却要用于实际的传输，所以就不得不考虑字节序的问题。</p>\n<p>&#160;&#160;&#160;&#160;UTF-16不兼容ASCII。</p>\n<h4 id=\"5-1-UTF的字节序和BOM\"><a href=\"#5-1-UTF的字节序和BOM\" class=\"headerlink\" title=\"5.1 UTF的字节序和BOM\"></a>5.1 UTF的字节序和BOM</h4><h5 id=\"5-1-1-字节序列\"><a href=\"#5-1-1-字节序列\" class=\"headerlink\" title=\"5.1.1 字节序列\"></a>5.1.1 字节序列</h5><p>&#160;&#160;&#160;&#160;UTF-8以字节为编码单元，而UTF-16两个字节编码单元，解释UTF-16文本前，先要弄清每个编码单元的字节序。Unicode规范中推荐的标记字节顺序的方法是BOM，也就是Byte Order Mark。</p>\n<p>&#160;&#160;&#160;&#160;在UCS编码中有一个叫做”ZERO WIDTH NO-BREAK SPACE”的字符，它的编码是FEFF。而FFFE在UCS中是不存在的字符，所以不应该出现在实际传输中。UCS规范建议我们在传输字节流前，先传输字符”ZERO WIDTH NO-BREAK SPACE”。这样如果接收者收到FEFF，就表明这个字节流是Big-Endian的；如果收到FFFE，就表明这个字节流是Little-Endian的。因此字符”ZERO WIDTH NO-BREAK SPACE”又被称作BOM。</p>"},{"title":"Volley框架解析-四-Network接口及其实现","date":"2017-03-20T15:34:06.000Z","_content":"\n## Volley框架解析(四)-----Network接口及其默认实现类解析\n\n### 1. 前言\n&#160;&#160;&#160;&#160;前面的三篇Volley框架解析文章已经从Volley对外暴露的接口Volley.java开始，向下慢慢深入到了RequestQueue.java，这个Volley中比较核心的类，然后又分析了Volley中负责主要request调度工作的两类Dispatcher，`NetworkDispatcher`以及`CacheDispatcher`。应该是将一个request从新建，到加入队列中等待处理，如何被处理以及返回结果或者error这一系列的流程理顺了。\n\n&#160;&#160;&#160;&#160;但是对于一些细节的问题还是不清楚，例如request究竟是如何发送出去，通过`NetworkResponse networkResponse = mNetwork.performRequest(request);`这么一句话就返回了结果(response)，这里面发生了些什么还不得而知，还有`Network#performRequest()`和`HttpStack#performRequest()`这两个函数之间有什么区别和联系等等。\n\n<!--more-->\n\n### [](#2-_Network-java \"2\\. Network.java\")2\\. Network.java\n\n&#160;&#160;&#160;&#160;最早接触到Network这个类是在`Volley.java`中的`newRequestQueue()`函数里面，`Network network = new BasicNetwork(stack);`创建了一个Network接口引用，并指向了一个Volley中的默认实现类的实例`BasicNetwork.java`，这个默认实现类也会在这篇博客的后面详细的解析。\n\n&#160;&#160;&#160;&#160;经过前面几篇博客的分析，`Volley.java`仅仅是持有而没有使用，仅将这个引用传递给了`NetworkDispatcher.java`中，只有在`NetworkDispatcher.java`类中用到了这个Network接口，在`NetowkrDispatcher.java`中存在着这么一行代码，\n\n```\nNetworkResponse networkResponse = mNetwork.performRequest(request);\n\n```\n\n&#160;&#160;&#160;&#160;仅仅用了一句话就将request发送出去了，并且还拿回来了一个`NetworkResponse.java`类对象。里面发生了什么= =，先进去Network.java里面看看：\n\n```\npackage com.android.volley;\n\n/**\n * An interface for performing requests.\n */\npublic interface Network {\n    /**\n     * Performs the specified request.\n     * 用来发送特定的请求\n     *\n     * @param request Request to process\n     * 即将被发送的request\n     *\n     * @return A {@link NetworkResponse} with data and caching metadata; will never be null\n     * 请求之后返回的response, 是volley自己构造出来的一个response\n     * 里面包含了返回的请求码等等。\n     *\n     * @throws VolleyError on errors\n     */\n    public NetworkResponse performRequest(Request<?> request) throws VolleyError;\n}\n\n```\n\n对，没有看错= =，就这么点东西，仅仅一个抽象方法而已，Network.java就是一个等待被实现的接口，想看真东西，还需要进去`Network network = new BasicNetwork(stack);`里面所提到的`BasicNetwork.java`看看。\n\n### [](#3-_BasicNetwork-java \"3\\. BasicNetwork.java\")3\\. BasicNetwork.java\n\n`Network.java`接口的默认实现类，该类里面会处理一些request发送前后的处理工作，主要是对请求返回的httpResponse处理，以及对请求失败进行retry或者抛出异常的处理。\n\n```\npackage com.android.volley.toolbox;\n\n/**\n * A network performing Volley requests over an {@link HttpStack}.\n * 一个用来执行Volley中request的类\n * 在HttpStack的基础之上\n * 因为主要还是调用HttpStack接口的performRequest\n * 在这个里面的performRequest主要还是做一些整理工作\n * 比如将｛@link HttpStack#performRequest()｝方法返回的HttpResponse\n * 解析成Volley自己实现的NetworkResponse.java\n */\n\npublic class BasicNetwork implements Network {\n\n    //是否允许打lo的boolean常变量\n    protected static final boolean DEBUG = VolleyLog.DEBUG;\n\n    /**\n     * 这是一个阀值，用来判断一个request是否请求响应过慢了= =\n     * 在后面的作用就是，如果响应时间超过了这个阀值\n     * 打出log说明这个request有些慢，为了更好的反应request当前状态\n     */\n    private static int SLOW_REQUEST_THRESHOLD_MS = 3000;\n\n    /**\n     * 默认ByteArrayPool的大小\n     * 现在只需要知道ByteArrayPool.java是Volley用来从输入流中读取数据并将其转换成字节数组的工具即可\n     * 在这篇博客后面会介绍，表担心~= =\n     */\n    private static int DEFAULT_POOL_SIZE = 4096;\n\n    /**\n     * 网络请求的真正接口\n     * 为什么这么说咧，BasicNetwork里面的performRequest()函数\n     * 调用了HttpStack里的performRequest()，真正的网络请求还是通过HttpStack里面的方法实现的\n     * 在Volley中实现了HttpStack接口的类有两个 HurlStack.java和HttpClientStack.java\n     * 针对了不同Android系统版本，用不同的方法实现了请求。\n     */\n    protected final HttpStack mHttpStack;\n\n    //表急，后面会介绍到的，现在知道是一个用于数据转换的工具类就好了\n    protected final ByteArrayPool mPool;\n\n    /**\n     * @param httpStack HTTP stack to be used\n     * 传入的HttpStack实现类引用\n     * 整个网络请求的较核心部分就在HttpStack实现类上面咯\n     */\n    public BasicNetwork(HttpStack httpStack) {\n        // If a pool isn't passed in, then build a small default pool that will give us a lot of\n        // benefit and not use too much memory.\n        this(httpStack, new ByteArrayPool(DEFAULT_POOL_SIZE));\n    }\n\n    /**\n     * @param httpStack HTTP stack to be used\n     * @param pool a buffer pool that improves GC performance in copy operations\n     * Volley接口分离的很明显，而且在构造函数里面也提供了很多种\n     * 可以定制出适合自己的ByteArrayPool衍生类\n     * 当然也可以自己来实现HttpStack的衍生类\n     */\n    public BasicNetwork(HttpStack httpStack, ByteArrayPool pool) {\n        mHttpStack = httpStack;\n        mPool = pool;\n    }\n\n    /**\n     * 这个方法重写的是Network的方法\n     * 在这个里面再调用HttpStack里面的performRequest方法\n     */\n    @Override\n    public NetworkResponse performRequest(Request<?> request) throws VolleyError {\n\n        /**\n         * Returns milliseconds since boot, including time spent in sleep.\n         * 为了方便计算每个request所用的时间\n         * 在处理每个request之前都记下此刻unix时间戳\n         */\n        long requestStart = SystemClock.elapsedRealtime();\n\n        /**\n         * 进入死循环= =\n         * 还没弄清楚为什么要死循环\n         */\n        while (true) {\n\n            /**\n             * 指向HttpResponse实例的引用\n             * 是调用HttpStack方法performRequest()之后返回的结果\n             */\n            HttpResponse httpResponse = null;\n\n            /**\n             * 返回的HttpResponse还需要经过处理\n             * 并不是返回回来就是能直接使用的数据\n             * 需要通过上面的ByteArrayPool将Entity转换成byte[]\n             * 这个就是指向解析后的byte[]的\n             */\n            byte[] responseContents = null;\n\n            //用来存放response里面header的信息，包含了状态码等\n            Map<String, String> responseHeaders = Collections.emptyMap();\n\n            try {\n                /**\n                 * Gather headers.\n                 * 设置header\n                 * 从缓存中收集上次相同request的信息\n                 */\n                Map<String, String> headers = new HashMap<String, String>();\n\n                /**\n                 * 将缓存的信息加入到headers中\n                 * headers会跟随request一起发送给服务器\n                 * 在函数的定义处会讲解\n                 */\n                addCacheHeaders(headers, request.getCacheEntry());\n\n                /**\n                 * 通过调用HttpStack接口的performRequest()方法\n                 * 获取服务器返回的HttpResponse\n                 */\n                httpResponse = mHttpStack.performRequest(request, headers);\n\n                /**\n                 * The first line of a Response message is the Status-Line, \n                 * consisting of the protocol version followed by a numeric status code and its associated textual phrase\n                 * with each element separated by SP characters. \n                 * No CR or LF is allowed except in the final CRLF sequence.\n                 * 请求返回的response第一行就是包含了状态码的一行\n                 */\n                StatusLine statusLine = httpResponse.getStatusLine();\n                int statusCode = statusLine.getStatusCode();\n\n                /**\n                 * 将头部解析成键值对的形式再返回\n                 */\n                responseHeaders = convertHeaders(httpResponse.getAllHeaders());\n\n                /**\n                 * Handle cache validation.\n                 * 处理缓存信息\n                 * 如果返回的状态码是304(HttpStatus.SC_NOT_MODIFIED)\n                 * 则进行如下的处理\n                 */\n                if (statusCode == HttpStatus.SC_NOT_MODIFIED) {\n\n                    /**\n                     * 如果缓存为空的话\n                     * 那就说明该请求的返回的response的body就是null\n                     * 直接构造一个NetworkResponse返回\n                     */\n                    Entry entry = request.getCacheEntry();\n                    if (entry == null) {\n                        return new NetworkResponse(HttpStatus.SC_NOT_MODIFIED, null,\n                                responseHeaders, true,\n                                SystemClock.elapsedRealtime() - requestStart);\n                    }\n\n                    // A HTTP 304 response does not have all header fields. We\n                    // have to use the header fields from the cache entry plus\n                    // the new ones from the response.\n                    // http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.5\n                    /**\n                     * 一个返回码为304的HttpResponse的header缺少一些信息\n                     * 需要我们将cache中的一些header信息加入到其中\n                     * 这样组成一个完整的NetworkResponse返回\n                     */\n                    entry.responseHeaders.putAll(responseHeaders);\n                    return new NetworkResponse(HttpStatus.SC_NOT_MODIFIED, entry.data,\n                            entry.responseHeaders, true,\n                            SystemClock.elapsedRealtime() - requestStart);\n                }\n\n                /**\n                 * Handle moved resources\n                 * 处理了重定向的问题\n                 * 并将request的mRedirectUrl设定成了新的url\n                 */\n                if (statusCode == HttpStatus.SC_MOVED_PERMANENTLY || statusCode == HttpStatus.SC_MOVED_TEMPORARILY) {\n                    String newUrl = responseHeaders.get(\"Location\");\n                    request.setRedirectUrl(newUrl);\n                }\n\n                /**\n                 * Some responses such as 204s do not have content.  We must check.\n                 * 204(无内容)服务器成功处理了请求，但没有返回任何内容。\n                 * \n                 */\n                if (httpResponse.getEntity() != null) {\n                    /**\n                     * 如果entity不为Null\n                     * 将其转换成byte数组\n                     * 利用之前提到过的ByteArrayPool.java类\n                     */\n                  responseContents = entityToBytes(httpResponse.getEntity());\n                } else {\n                  // Add 0 byte response as a way of honestly representing a\n                  // no-content request.\n                  responseContents = new byte[0];\n                }\n\n                /**\n                 * if the request is slow, log it.\n                 * 获取request已经占用的时间(requestLifetime)\n                 * 判断是否需要打出request的超时状态\n                 */\n                long requestLifetime = SystemClock.elapsedRealtime() - requestStart;\n                logSlowRequests(requestLifetime, request, responseContents, statusLine);\n\n                /**\n                 * 如果状态码位于200之下或者是299之上(200-299 用于表示请求成功)\n                 * 则抛出IOException异常= =为什么非要抛出这个异常\n                 * 在前面过滤掉了(304等情况)\n                 */\n                if (statusCode < 200 || statusCode > 299) {\n                    throw new IOException();\n                }\n\n                /**\n                 * 经过上面的层层过滤\n                 * 最后留下了200~299之间的请求成功response\n                 * 通过HttpResponse里面的信息构造出一个volley自己封装的NetworkResponse对象\n                 */\n                return new NetworkResponse(statusCode, responseContents, responseHeaders, false,\n                        SystemClock.elapsedRealtime() - requestStart);\n\n                /**\n                 * 抛出了异常之后，会用attemptREtryOnException()方法来尝试retry\n                 * 主要做的工作就是看是否还有retry的机会，如果有则不停通过这个死循环\n                 * 进行请求，直到请求成功或者请求的机会用完为止\n                 */\n            } catch (SocketTimeoutException e) {\n                attemptRetryOnException(\"socket\", request, new TimeoutError());\n            } catch (ConnectTimeoutException e) {·\n                attemptRetryOnException(\"connection\", request, new TimeoutError());\n            } catch (MalformedURLException e) {\n                throw new RuntimeException(\"Bad URL \" + request.getUrl(), e);\n            } catch (IOException e) {\n                /**\n                 * 状态码在0~200以及299之上的response\n                 * 处理的套路\n                 */\n                int statusCode = 0;\n                NetworkResponse networkResponse = null;\n                if (httpResponse != null) {\n                    statusCode = httpResponse.getStatusLine().getStatusCode();\n                } else {\n                    //如果状态码为0，则抛出NoConnectionError\n                    throw new NoConnectionError(e);\n                }\n                /**\n                 * 如果有重定向的情况发生\n                 * 用log打出\n                 */\n                if (statusCode == HttpStatus.SC_MOVED_PERMANENTLY || \n                        statusCode == HttpStatus.SC_MOVED_TEMPORARILY) {\n                    VolleyLog.e(\"Request at %s has been redirected to %s\", request.getOriginUrl(), request.getUrl());\n                } else {\n                    VolleyLog.e(\"Unexpected response code %d for %s\", statusCode, request.getUrl());\n                }\n\n                /**\n                 * 如果返回的content内容不为Null\n                 * 则构造出一个NetworkResponse\n                 * 否则抛出NetworkError\n                 */\n                if (responseContents != null) {\n\n                    networkResponse = new NetworkResponse(statusCode, responseContents,\n                            responseHeaders, false, SystemClock.elapsedRealtime() - requestStart);\n\n                    /**\n                     * 抛出了异常之后，会用attemptREtryOnException()方法来尝试retry\n                     * 主要做的工作就是看是否还有retry的机会，如果有则不停通过这个死循环\n                     * 进行请求，直到请求成功或者请求的机会用完为止\n                     */\n                    if (statusCode == HttpStatus.SC_UNAUTHORIZED ||\n                            statusCode == HttpStatus.SC_FORBIDDEN) {\n                        attemptRetryOnException(\"auth\",\n                                request, new AuthFailureError(networkResponse));\n                    } else if (statusCode == HttpStatus.SC_MOVED_PERMANENTLY || \n                                statusCode == HttpStatus.SC_MOVED_TEMPORARILY) {\n                        attemptRetryOnException(\"redirect\",\n                                request, new AuthFailureError(networkResponse));\n                    } else {\n                        // TODO: Only throw ServerError for 5xx status codes.\n                        throw new ServerError(networkResponse);\n                    }\n                } else {\n                    throw new NetworkError(networkResponse);\n                }\n            }\n        }\n    }\n\n    /**\n     * Logs requests that took over SLOW_REQUEST_THRESHOLD_MS to complete.\n     * 如果request用时超出了预先设定的阀值\n     * 则打出log用于debug时候的提示\n     */\n    private void logSlowRequests(long requestLifetime, Request<?> request,\n            byte[] responseContents, StatusLine statusLine) {\n        if (DEBUG || requestLifetime > SLOW_REQUEST_THRESHOLD_MS) {\n            VolleyLog.d(\"HTTP response for request=<%s> [lifetime=%d], [size=%s], \" +\n                    \"[rc=%d], [retryCount=%s]\", request, requestLifetime,\n                    responseContents != null ? responseContents.length : \"null\",\n                    statusLine.getStatusCode(), request.getRetryPolicy().getCurrentRetryCount());\n        }\n    }\n\n    /**\n     * Attempts to prepare the request for a retry. If there are no more attempts remaining in the\n     * request's retry policy, a timeout exception is thrown.\n     * 每次尝试都会使retry机会减少1，如果机会没有了，则抛出请求超时的exception\n     *\n     * @param request The request to use.\n     */\n    private static void attemptRetryOnException(String logPrefix, Request<?> request,\n            VolleyError exception) throws VolleyError {\n        RetryPolicy retryPolicy = request.getRetryPolicy();\n        int oldTimeout = request.getTimeoutMs();\n\n        try {\n            retryPolicy.retry(exception);\n        } catch (VolleyError e) {\n            request.addMarker(\n                    String.format(\"%s-timeout-giveup [timeout=%s]\", logPrefix, oldTimeout));\n            throw e;\n        }\n        request.addMarker(String.format(\"%s-retry [timeout=%s]\", logPrefix, oldTimeout));\n    }\n\n    /**\n     * 添加上缓存的header\n     * 如果有之前的缓存的信息\n     * 将里面的信息取出放入header中\n     * \n     * 这里面涉及到了一个条件请求\n     * 如果有缓存的话，header上面会带上一个If-Modified-Since关键字\n     * 服务器会先比较信息modified的时间，如果服务端的数据没有发生变化就返回304(也就是上面的 HttpStatus.SC_NOT_MODIFIED)\n     * 如果服务器的数据发生了变化，则会返回状态码200以及请求需要的数据(意思就是本地的数据需要刷新了，缓存不管用了)\n     */\n    private void addCacheHeaders(Map<String, String> headers, Cache.Entry entry) {\n        // If there's no cache entry, we're done.\n        if (entry == null) {\n            return;\n        }\n\n        if (entry.etag != null) {\n            headers.put(\"If-None-Match\", entry.etag);\n        }\n\n        if (entry.lastModified > 0) {\n            Date refTime = new Date(entry.lastModified);\n            headers.put(\"If-Modified-Since\", DateUtils.formatDate(refTime));\n        }\n    }\n\n    protected void logError(String what, String url, long start) {\n        long now = SystemClock.elapsedRealtime();\n        VolleyLog.v(\"HTTP ERROR(%s) %d ms to fetch %s\", what, (now - start), url);\n    }\n\n    /** \n     * Reads the contents of HttpEntity into a byte[].\n     * 从HttpEntity中读取数据，并通过ByteArrayPool将其转换成byte[]\n     * 暂时不用管太多= =，等后面介绍到ByteArrayPool.java的时候就会明白\n     */\n    private byte[] entityToBytes(HttpEntity entity) throws IOException, ServerError {\n\n        PoolingByteArrayOutputStream bytes =\n                new PoolingByteArrayOutputStream(mPool, (int) entity.getContentLength());\n\n        byte[] buffer = null;\n\n        try {\n            InputStream in = entity.getContent();\n            if (in == null) {\n                throw new ServerError();\n            }\n\n            /**\n             * 获取一个大小为1024的缓冲区\n             */\n            buffer = mPool.getBuf(1024);\n\n            int count;\n            //将content的内容通过流每次最大读出1024个byte, 全部读出并写入bytes\n            while ((count = in.read(buffer)) != -1) {\n                bytes.write(buffer, 0, count);\n            }\n            return bytes.toByteArray();\n        } finally {\n            try {\n                // Close the InputStream and release the resources by \"consuming the content\".\n                entity.consumeContent();\n            } catch (IOException e) {\n                // This can happen if there was an exception above that left the entity in\n                // an invalid state.\n                VolleyLog.v(\"Error occured when calling consumingContent\");\n            }\n            /**\n             * 在所有工作完成之后\n             * 需要将从mPool中拿出的buffer缓冲区回收\n             */\n            mPool.returnBuf(buffer);\n            bytes.close();\n        }\n    }\n\n    /**\n     * Converts Headers[] to Map<String, String>.\n     * 将返回的response里面的header[]\n     * 全部转换成Map里面的键值对形式\n     */\n    protected static Map<String, String> convertHeaders(Header[] headers) {\n        Map<String, String> result = new TreeMap<String, String>(String.CASE_INSENSITIVE_ORDER);\n        for (int i = 0; i < headers.length; i++) {\n            result.put(headers[i].getName(), headers[i].getValue());\n        }\n        return result;\n    }\n}\n\n```\n\n### [](#4-_ByteArrayPool-java \"4\\. ByteArrayPool.java\")4\\. ByteArrayPool.java\n\nByteArrayPool.java是用来将HttpResponse中Entity通过stream的形式转换成byte[],主要的作用是提供缓冲区，用来辅助流数据的读取，在使用完成之后需要将使用过的缓冲区还给ByteArrayPool，ByteArrayPool里会对这些byte[]进行简单的回收处理。\n\n```\n/**\n * 用来给外界提供byte[]作为缓冲区的一个工具类\n */\npublic class ByteArrayPool {\n    /**\n     * The buffer pool, arranged both by last use and by buffer size \n     */\n    private List<byte[]> mBuffersByLastUse = new LinkedList<byte[]>();\n    private List<byte[]> mBuffersBySize = new ArrayList<byte[]>(64);\n\n    /**\n     * The total size of the buffers in the pool\n     * 缓冲池的当前大小\n     */\n    private int mCurrentSize = 0;\n\n    /**\n     * The maximum aggregate size of the buffers in the pool. Old buffers are discarded to stay\n     * under this limit.\n     * 缓冲池当前的大小的阀值\n     * 超过了该值则会对缓冲池进行回收处理\n     */\n    private final int mSizeLimit;\n\n    /**\n     * Compares buffers by size\n     * 比较两个缓冲区的大小的规则\n     * 如果返回一个负数，则表示前一个数要小\n     * 如果返回0，则表示两个数字相等\n     * 如果返回一个正数，则表示后一个数要小\n     * \n     */\n    protected static final Comparator<byte[]> BUF_COMPARATOR = new Comparator<byte[]>() {\n        @Override\n        public int compare(byte[] lhs, byte[] rhs) {\n            return lhs.length - rhs.length;\n        }\n    };\n\n    /**\n     * @param sizeLimit the maximum size of the pool, in bytes\n     * 用来修改缓冲池的大小阀值\n     */\n    public ByteArrayPool(int sizeLimit) {\n        mSizeLimit = sizeLimit;\n    }\n\n    /**\n     * Returns a buffer from the pool if one is available in the requested size, or allocates a new\n     * one if a pooled one is not available.\n     * 从mBuffersBySize中调出一个缓冲区来\n     * 如果大小符合要求，则直接返回给调用者\n     * 如果没有符合要求的，直接创建一个新的byte[]返回\n     *\n     * @param len the minimum size, in bytes, of the requested buffer. The returned buffer may be\n     *        larger.\n     * @return a byte[] buffer is always returned.\n     */\n    public synchronized byte[] getBuf(int len) {\n        for (int i = 0; i < mBuffersBySize.size(); i++) {\n            byte[] buf = mBuffersBySize.get(i);\n            if (buf.length >= len) {\n                mCurrentSize -= buf.length;\n                mBuffersBySize.remove(i);\n                mBuffersByLastUse.remove(buf);\n                return buf;\n            }\n        }\n        return new byte[len];\n    }\n\n    /**\n     * Returns a buffer to the pool, throwing away old buffers if the pool would exceed its allotted\n     * size.\n     * \n     * @param buf the buffer to return to the pool.\n     */\n    public synchronized void returnBuf(byte[] buf) {\n\n        //如果buf为空或者超出了规定的大小，不管就行了，这种缓冲区用不着回收，因为= =根本就不符合要求嘛\n\n        if (buf == null || buf.length > mSizeLimit) {\n            return;\n        }\n\n        //如果buf符合要求，则将其加入到最近使用的队列中去\n\n        mBuffersByLastUse.add(buf);\n\n        /**\n         * 通过二分查找，比较规则为BUF_COMPARATOR，找出新进来的buf应该处于的位置\n         * 随后将buf插入到mBufferBySize的队列里面\n         */\n        int pos = Collections.binarySearch(mBuffersBySize, buf, BUF_COMPARATOR);\n        if (pos < 0) {\n            pos = -pos - 1;\n        }\n\n        mBuffersBySize.add(pos, buf);\n\n        //当前总缓冲区大小变大\n        mCurrentSize += buf.length;\n\n        //对整个缓冲池的大小做出调整\n        trim();\n    }\n\n    /**\n     * Removes buffers from the pool until it is under its size limit.\n     * 调整缓冲区的大小\n     * 直到mCurrentSize在限制大小之下\n     */\n    private synchronized void trim() {\n\n        while (mCurrentSize > mSizeLimit) {\n            byte[] buf = mBuffersByLastUse.remove(0);\n            mBuffersBySize.remove(buf);\n            mCurrentSize -= buf.length;\n        }\n    }\n\n}\n\n```\n\n### [](#5-_RetryPolicy-java \"5\\. RetryPolicy.java\")5\\. RetryPolicy.java\n\n在BasicNetwork.java这个类中，通过死循环加上try,catch的方式，不停的对一个request进行重复的处理，里面涉及到了`RetryPolicy.java`接口以及其默认实现类，这个接口是用来专门处理一个request在发送以及得到服务器响应返回结果的过程中出现的问题。通过有限次数的不断扩大request响应时间阀值，再次发送request的方式来达到一个retry的目的。和`Network.java`类似的，`RetryPolicy.java`也仅仅就是提供了抽象方法，想把具体的实现内容弄明白还需要去默认实现类`DefaultRetryPolicy.java`中去。\n\n```\npackage com.android.volley;\n\n/**\n * Retry policy for a request.\n * 该类用来管理request的调整及重新发送\n * 所谓调整就是将request响应时间(timeout)放宽\n */\npublic interface RetryPolicy {\n\n    /**\n     * Returns the current timeout (used for logging).\n     */\n    public int getCurrentTimeout();\n\n    /**\n     * Returns the current retry count (used for logging).\n     */\n    public int getCurrentRetryCount();\n\n    /**\n     * Prepares for the next retry by applying a backoff to the timeout.\n     * 为下一次request做好准备，通过不停地来放宽timeout时间限制\n     * 在DefaultRetryPolicy.java中好理解一些\n     * \n     * @param error The error code of the last attempt.\n     * @throws VolleyError In the event that the retry could not be performed (for example if we\n     * ran out of attempts), the passed in error is thrown.\n     */\n    public void retry(VolleyError error) throws VolleyError;\n}\n\n```\n\n### [](#6-_DefaultRetryPolicy-java \"6\\. DefaultRetryPolicy.java\")6\\. DefaultRetryPolicy.java\n\n`DefaultRetryPolicy.java`描述了对待Volley中涉及Network的request的策略方针，可以理解为重试策略方针，也就是对那些在网络请求失败的request处理方法。里面包含了retry的最大次数(`mMaxNumRetries`)，当前请求次数(`mCurrentRetryCount`)以及请求超时的时间阀值(`mCurrentTimeoutMs`)等。每个Request里面都包含了一个`RetryPolicy.java`实现类，在处理的时候可以通过`getRetryPolicy()`方法获得。\n\n```\npackage com.android.volley;\n\n/**\n * Default retry policy for requests.\n */\npublic class DefaultRetryPolicy implements RetryPolicy {\n    /** \n     * The current timeout in milliseconds. \n     * 请求超时的时间数\n     */\n    private int mCurrentTimeoutMs;\n\n    /** \n     * The current retry count.\n     * 当前请求的重试次数\n     */\n    private int mCurrentRetryCount;\n\n    /**\n     * The maximum number of attempts. \n     * 重复尝试的最大次数\n     **/\n    private final int mMaxNumRetries;\n\n    /**\n     * The backoff multiplier for the policy.\n     * 暂时不明白这个有什么用\n     * 根据后面的来看好像是一个用于放宽timeout时间限制的系数\n     * 这个系数越大每次retry的时候放宽的程度也就越大\n     */\n    private final float mBackoffMultiplier;\n\n    /** The default socket timeout in milliseconds */\n    public static final int DEFAULT_TIMEOUT_MS = 2500;\n\n    /** The default number of retries */\n    public static final int DEFAULT_MAX_RETRIES = 0;\n\n    /** The default backoff multiplier */\n    public static final float DEFAULT_BACKOFF_MULT = 1f;\n\n    /**\n     * Constructs a new retry policy using the default timeouts.\n     * 默认的构造器，2.5s的超时，\n     * 最大重试数为0，也就是request请求超时了就不要再自动重试了\n     */\n    public DefaultRetryPolicy() {\n        this(DEFAULT_TIMEOUT_MS, DEFAULT_MAX_RETRIES, DEFAULT_BACKOFF_MULT);\n    }\n\n    /**\n     * Constructs a new retry policy.\n     * @param initialTimeoutMs The initial timeout for the policy.\n     * @param maxNumRetries The maximum number of retries.\n     * @param backoffMultiplier Backoff multiplier for the policy.\n     */\n    public DefaultRetryPolicy(int initialTimeoutMs, int maxNumRetries, float backoffMultiplier) {\n        mCurrentTimeoutMs = initialTimeoutMs;\n        mMaxNumRetries = maxNumRetries;\n        mBackoffMultiplier = backoffMultiplier;\n    }\n\n    /**\n     * Returns the current timeout.\n     */\n    @Override\n    public int getCurrentTimeout() {\n        return mCurrentTimeoutMs;\n    }\n\n    /**\n     * Returns the current retry count.\n     */\n    @Override\n    public int getCurrentRetryCount() {\n        return mCurrentRetryCount;\n    }\n\n    /**\n     * Returns the backoff multiplier for the policy.\n     */\n    public float getBackoffMultiplier() {\n        return mBackoffMultiplier;\n    }\n\n    /**\n     * Prepares for the next retry by applying a backoff to the timeout.\n     * 该方法定义在RetryPolicy.java中。\n     * 为下一次重试request做准备，好像是通过延长服务器响应时间的限制 = =\n     * 每次对timeout的时间限制都放宽了mBackoffMultiplier个单位。让服务器多一点时间去响应\n     * \n     * @param error The error code of the last attempt.\n     * 最后一次request服务器给出的错误码\n     */\n    @Override\n    public void retry(VolleyError error) throws VolleyError {\n        mCurrentRetryCount++;\n        mCurrentTimeoutMs += (mCurrentTimeoutMs * mBackoffMultiplier);\n        if (!hasAttemptRemaining()) {\n            throw error;\n        }\n    }\n\n    /**\n     * Returns true if this policy has attempts remaining, false otherwise.\n     * 这个是用来判断是否还有retry机会的\n     */\n    protected boolean hasAttemptRemaining() {\n        return mCurrentRetryCount <= mMaxNumRetries;\n    }\n}\n\n```\n\n到这里对`Network.java`接口以及`RetryPolicy.java`接口的代码就分析完了，现在是清楚了在`NetworkDispatcher.java`调用了`mNetwork.performRequest()`之后发生了什么事情，还弄清楚了request在网络请求发送之后，出现了各种问题会怎么处理(重试策略)，但还不知道最核心的网络请求是如何发生的，也就是在`BasicNetwork.java`中的下面这行代码。\n\n```\nhttpResponse = mHttpStack.performRequest(request, headers);\n\n```\n\n这行代码就涉及到了后面的`HttpStack.java`接口及其两个实现类了。","source":"_posts/Volley框架解析-四-Network接口及其实现.md","raw":"---\ntitle: Volley框架解析-四-Network接口及其实现\ndate: 2017-03-20 23:34:06\ntags: volley\n\n---\n\n## Volley框架解析(四)-----Network接口及其默认实现类解析\n\n### 1. 前言\n&#160;&#160;&#160;&#160;前面的三篇Volley框架解析文章已经从Volley对外暴露的接口Volley.java开始，向下慢慢深入到了RequestQueue.java，这个Volley中比较核心的类，然后又分析了Volley中负责主要request调度工作的两类Dispatcher，`NetworkDispatcher`以及`CacheDispatcher`。应该是将一个request从新建，到加入队列中等待处理，如何被处理以及返回结果或者error这一系列的流程理顺了。\n\n&#160;&#160;&#160;&#160;但是对于一些细节的问题还是不清楚，例如request究竟是如何发送出去，通过`NetworkResponse networkResponse = mNetwork.performRequest(request);`这么一句话就返回了结果(response)，这里面发生了些什么还不得而知，还有`Network#performRequest()`和`HttpStack#performRequest()`这两个函数之间有什么区别和联系等等。\n\n<!--more-->\n\n### [](#2-_Network-java \"2\\. Network.java\")2\\. Network.java\n\n&#160;&#160;&#160;&#160;最早接触到Network这个类是在`Volley.java`中的`newRequestQueue()`函数里面，`Network network = new BasicNetwork(stack);`创建了一个Network接口引用，并指向了一个Volley中的默认实现类的实例`BasicNetwork.java`，这个默认实现类也会在这篇博客的后面详细的解析。\n\n&#160;&#160;&#160;&#160;经过前面几篇博客的分析，`Volley.java`仅仅是持有而没有使用，仅将这个引用传递给了`NetworkDispatcher.java`中，只有在`NetworkDispatcher.java`类中用到了这个Network接口，在`NetowkrDispatcher.java`中存在着这么一行代码，\n\n```\nNetworkResponse networkResponse = mNetwork.performRequest(request);\n\n```\n\n&#160;&#160;&#160;&#160;仅仅用了一句话就将request发送出去了，并且还拿回来了一个`NetworkResponse.java`类对象。里面发生了什么= =，先进去Network.java里面看看：\n\n```\npackage com.android.volley;\n\n/**\n * An interface for performing requests.\n */\npublic interface Network {\n    /**\n     * Performs the specified request.\n     * 用来发送特定的请求\n     *\n     * @param request Request to process\n     * 即将被发送的request\n     *\n     * @return A {@link NetworkResponse} with data and caching metadata; will never be null\n     * 请求之后返回的response, 是volley自己构造出来的一个response\n     * 里面包含了返回的请求码等等。\n     *\n     * @throws VolleyError on errors\n     */\n    public NetworkResponse performRequest(Request<?> request) throws VolleyError;\n}\n\n```\n\n对，没有看错= =，就这么点东西，仅仅一个抽象方法而已，Network.java就是一个等待被实现的接口，想看真东西，还需要进去`Network network = new BasicNetwork(stack);`里面所提到的`BasicNetwork.java`看看。\n\n### [](#3-_BasicNetwork-java \"3\\. BasicNetwork.java\")3\\. BasicNetwork.java\n\n`Network.java`接口的默认实现类，该类里面会处理一些request发送前后的处理工作，主要是对请求返回的httpResponse处理，以及对请求失败进行retry或者抛出异常的处理。\n\n```\npackage com.android.volley.toolbox;\n\n/**\n * A network performing Volley requests over an {@link HttpStack}.\n * 一个用来执行Volley中request的类\n * 在HttpStack的基础之上\n * 因为主要还是调用HttpStack接口的performRequest\n * 在这个里面的performRequest主要还是做一些整理工作\n * 比如将｛@link HttpStack#performRequest()｝方法返回的HttpResponse\n * 解析成Volley自己实现的NetworkResponse.java\n */\n\npublic class BasicNetwork implements Network {\n\n    //是否允许打lo的boolean常变量\n    protected static final boolean DEBUG = VolleyLog.DEBUG;\n\n    /**\n     * 这是一个阀值，用来判断一个request是否请求响应过慢了= =\n     * 在后面的作用就是，如果响应时间超过了这个阀值\n     * 打出log说明这个request有些慢，为了更好的反应request当前状态\n     */\n    private static int SLOW_REQUEST_THRESHOLD_MS = 3000;\n\n    /**\n     * 默认ByteArrayPool的大小\n     * 现在只需要知道ByteArrayPool.java是Volley用来从输入流中读取数据并将其转换成字节数组的工具即可\n     * 在这篇博客后面会介绍，表担心~= =\n     */\n    private static int DEFAULT_POOL_SIZE = 4096;\n\n    /**\n     * 网络请求的真正接口\n     * 为什么这么说咧，BasicNetwork里面的performRequest()函数\n     * 调用了HttpStack里的performRequest()，真正的网络请求还是通过HttpStack里面的方法实现的\n     * 在Volley中实现了HttpStack接口的类有两个 HurlStack.java和HttpClientStack.java\n     * 针对了不同Android系统版本，用不同的方法实现了请求。\n     */\n    protected final HttpStack mHttpStack;\n\n    //表急，后面会介绍到的，现在知道是一个用于数据转换的工具类就好了\n    protected final ByteArrayPool mPool;\n\n    /**\n     * @param httpStack HTTP stack to be used\n     * 传入的HttpStack实现类引用\n     * 整个网络请求的较核心部分就在HttpStack实现类上面咯\n     */\n    public BasicNetwork(HttpStack httpStack) {\n        // If a pool isn't passed in, then build a small default pool that will give us a lot of\n        // benefit and not use too much memory.\n        this(httpStack, new ByteArrayPool(DEFAULT_POOL_SIZE));\n    }\n\n    /**\n     * @param httpStack HTTP stack to be used\n     * @param pool a buffer pool that improves GC performance in copy operations\n     * Volley接口分离的很明显，而且在构造函数里面也提供了很多种\n     * 可以定制出适合自己的ByteArrayPool衍生类\n     * 当然也可以自己来实现HttpStack的衍生类\n     */\n    public BasicNetwork(HttpStack httpStack, ByteArrayPool pool) {\n        mHttpStack = httpStack;\n        mPool = pool;\n    }\n\n    /**\n     * 这个方法重写的是Network的方法\n     * 在这个里面再调用HttpStack里面的performRequest方法\n     */\n    @Override\n    public NetworkResponse performRequest(Request<?> request) throws VolleyError {\n\n        /**\n         * Returns milliseconds since boot, including time spent in sleep.\n         * 为了方便计算每个request所用的时间\n         * 在处理每个request之前都记下此刻unix时间戳\n         */\n        long requestStart = SystemClock.elapsedRealtime();\n\n        /**\n         * 进入死循环= =\n         * 还没弄清楚为什么要死循环\n         */\n        while (true) {\n\n            /**\n             * 指向HttpResponse实例的引用\n             * 是调用HttpStack方法performRequest()之后返回的结果\n             */\n            HttpResponse httpResponse = null;\n\n            /**\n             * 返回的HttpResponse还需要经过处理\n             * 并不是返回回来就是能直接使用的数据\n             * 需要通过上面的ByteArrayPool将Entity转换成byte[]\n             * 这个就是指向解析后的byte[]的\n             */\n            byte[] responseContents = null;\n\n            //用来存放response里面header的信息，包含了状态码等\n            Map<String, String> responseHeaders = Collections.emptyMap();\n\n            try {\n                /**\n                 * Gather headers.\n                 * 设置header\n                 * 从缓存中收集上次相同request的信息\n                 */\n                Map<String, String> headers = new HashMap<String, String>();\n\n                /**\n                 * 将缓存的信息加入到headers中\n                 * headers会跟随request一起发送给服务器\n                 * 在函数的定义处会讲解\n                 */\n                addCacheHeaders(headers, request.getCacheEntry());\n\n                /**\n                 * 通过调用HttpStack接口的performRequest()方法\n                 * 获取服务器返回的HttpResponse\n                 */\n                httpResponse = mHttpStack.performRequest(request, headers);\n\n                /**\n                 * The first line of a Response message is the Status-Line, \n                 * consisting of the protocol version followed by a numeric status code and its associated textual phrase\n                 * with each element separated by SP characters. \n                 * No CR or LF is allowed except in the final CRLF sequence.\n                 * 请求返回的response第一行就是包含了状态码的一行\n                 */\n                StatusLine statusLine = httpResponse.getStatusLine();\n                int statusCode = statusLine.getStatusCode();\n\n                /**\n                 * 将头部解析成键值对的形式再返回\n                 */\n                responseHeaders = convertHeaders(httpResponse.getAllHeaders());\n\n                /**\n                 * Handle cache validation.\n                 * 处理缓存信息\n                 * 如果返回的状态码是304(HttpStatus.SC_NOT_MODIFIED)\n                 * 则进行如下的处理\n                 */\n                if (statusCode == HttpStatus.SC_NOT_MODIFIED) {\n\n                    /**\n                     * 如果缓存为空的话\n                     * 那就说明该请求的返回的response的body就是null\n                     * 直接构造一个NetworkResponse返回\n                     */\n                    Entry entry = request.getCacheEntry();\n                    if (entry == null) {\n                        return new NetworkResponse(HttpStatus.SC_NOT_MODIFIED, null,\n                                responseHeaders, true,\n                                SystemClock.elapsedRealtime() - requestStart);\n                    }\n\n                    // A HTTP 304 response does not have all header fields. We\n                    // have to use the header fields from the cache entry plus\n                    // the new ones from the response.\n                    // http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.5\n                    /**\n                     * 一个返回码为304的HttpResponse的header缺少一些信息\n                     * 需要我们将cache中的一些header信息加入到其中\n                     * 这样组成一个完整的NetworkResponse返回\n                     */\n                    entry.responseHeaders.putAll(responseHeaders);\n                    return new NetworkResponse(HttpStatus.SC_NOT_MODIFIED, entry.data,\n                            entry.responseHeaders, true,\n                            SystemClock.elapsedRealtime() - requestStart);\n                }\n\n                /**\n                 * Handle moved resources\n                 * 处理了重定向的问题\n                 * 并将request的mRedirectUrl设定成了新的url\n                 */\n                if (statusCode == HttpStatus.SC_MOVED_PERMANENTLY || statusCode == HttpStatus.SC_MOVED_TEMPORARILY) {\n                    String newUrl = responseHeaders.get(\"Location\");\n                    request.setRedirectUrl(newUrl);\n                }\n\n                /**\n                 * Some responses such as 204s do not have content.  We must check.\n                 * 204(无内容)服务器成功处理了请求，但没有返回任何内容。\n                 * \n                 */\n                if (httpResponse.getEntity() != null) {\n                    /**\n                     * 如果entity不为Null\n                     * 将其转换成byte数组\n                     * 利用之前提到过的ByteArrayPool.java类\n                     */\n                  responseContents = entityToBytes(httpResponse.getEntity());\n                } else {\n                  // Add 0 byte response as a way of honestly representing a\n                  // no-content request.\n                  responseContents = new byte[0];\n                }\n\n                /**\n                 * if the request is slow, log it.\n                 * 获取request已经占用的时间(requestLifetime)\n                 * 判断是否需要打出request的超时状态\n                 */\n                long requestLifetime = SystemClock.elapsedRealtime() - requestStart;\n                logSlowRequests(requestLifetime, request, responseContents, statusLine);\n\n                /**\n                 * 如果状态码位于200之下或者是299之上(200-299 用于表示请求成功)\n                 * 则抛出IOException异常= =为什么非要抛出这个异常\n                 * 在前面过滤掉了(304等情况)\n                 */\n                if (statusCode < 200 || statusCode > 299) {\n                    throw new IOException();\n                }\n\n                /**\n                 * 经过上面的层层过滤\n                 * 最后留下了200~299之间的请求成功response\n                 * 通过HttpResponse里面的信息构造出一个volley自己封装的NetworkResponse对象\n                 */\n                return new NetworkResponse(statusCode, responseContents, responseHeaders, false,\n                        SystemClock.elapsedRealtime() - requestStart);\n\n                /**\n                 * 抛出了异常之后，会用attemptREtryOnException()方法来尝试retry\n                 * 主要做的工作就是看是否还有retry的机会，如果有则不停通过这个死循环\n                 * 进行请求，直到请求成功或者请求的机会用完为止\n                 */\n            } catch (SocketTimeoutException e) {\n                attemptRetryOnException(\"socket\", request, new TimeoutError());\n            } catch (ConnectTimeoutException e) {·\n                attemptRetryOnException(\"connection\", request, new TimeoutError());\n            } catch (MalformedURLException e) {\n                throw new RuntimeException(\"Bad URL \" + request.getUrl(), e);\n            } catch (IOException e) {\n                /**\n                 * 状态码在0~200以及299之上的response\n                 * 处理的套路\n                 */\n                int statusCode = 0;\n                NetworkResponse networkResponse = null;\n                if (httpResponse != null) {\n                    statusCode = httpResponse.getStatusLine().getStatusCode();\n                } else {\n                    //如果状态码为0，则抛出NoConnectionError\n                    throw new NoConnectionError(e);\n                }\n                /**\n                 * 如果有重定向的情况发生\n                 * 用log打出\n                 */\n                if (statusCode == HttpStatus.SC_MOVED_PERMANENTLY || \n                        statusCode == HttpStatus.SC_MOVED_TEMPORARILY) {\n                    VolleyLog.e(\"Request at %s has been redirected to %s\", request.getOriginUrl(), request.getUrl());\n                } else {\n                    VolleyLog.e(\"Unexpected response code %d for %s\", statusCode, request.getUrl());\n                }\n\n                /**\n                 * 如果返回的content内容不为Null\n                 * 则构造出一个NetworkResponse\n                 * 否则抛出NetworkError\n                 */\n                if (responseContents != null) {\n\n                    networkResponse = new NetworkResponse(statusCode, responseContents,\n                            responseHeaders, false, SystemClock.elapsedRealtime() - requestStart);\n\n                    /**\n                     * 抛出了异常之后，会用attemptREtryOnException()方法来尝试retry\n                     * 主要做的工作就是看是否还有retry的机会，如果有则不停通过这个死循环\n                     * 进行请求，直到请求成功或者请求的机会用完为止\n                     */\n                    if (statusCode == HttpStatus.SC_UNAUTHORIZED ||\n                            statusCode == HttpStatus.SC_FORBIDDEN) {\n                        attemptRetryOnException(\"auth\",\n                                request, new AuthFailureError(networkResponse));\n                    } else if (statusCode == HttpStatus.SC_MOVED_PERMANENTLY || \n                                statusCode == HttpStatus.SC_MOVED_TEMPORARILY) {\n                        attemptRetryOnException(\"redirect\",\n                                request, new AuthFailureError(networkResponse));\n                    } else {\n                        // TODO: Only throw ServerError for 5xx status codes.\n                        throw new ServerError(networkResponse);\n                    }\n                } else {\n                    throw new NetworkError(networkResponse);\n                }\n            }\n        }\n    }\n\n    /**\n     * Logs requests that took over SLOW_REQUEST_THRESHOLD_MS to complete.\n     * 如果request用时超出了预先设定的阀值\n     * 则打出log用于debug时候的提示\n     */\n    private void logSlowRequests(long requestLifetime, Request<?> request,\n            byte[] responseContents, StatusLine statusLine) {\n        if (DEBUG || requestLifetime > SLOW_REQUEST_THRESHOLD_MS) {\n            VolleyLog.d(\"HTTP response for request=<%s> [lifetime=%d], [size=%s], \" +\n                    \"[rc=%d], [retryCount=%s]\", request, requestLifetime,\n                    responseContents != null ? responseContents.length : \"null\",\n                    statusLine.getStatusCode(), request.getRetryPolicy().getCurrentRetryCount());\n        }\n    }\n\n    /**\n     * Attempts to prepare the request for a retry. If there are no more attempts remaining in the\n     * request's retry policy, a timeout exception is thrown.\n     * 每次尝试都会使retry机会减少1，如果机会没有了，则抛出请求超时的exception\n     *\n     * @param request The request to use.\n     */\n    private static void attemptRetryOnException(String logPrefix, Request<?> request,\n            VolleyError exception) throws VolleyError {\n        RetryPolicy retryPolicy = request.getRetryPolicy();\n        int oldTimeout = request.getTimeoutMs();\n\n        try {\n            retryPolicy.retry(exception);\n        } catch (VolleyError e) {\n            request.addMarker(\n                    String.format(\"%s-timeout-giveup [timeout=%s]\", logPrefix, oldTimeout));\n            throw e;\n        }\n        request.addMarker(String.format(\"%s-retry [timeout=%s]\", logPrefix, oldTimeout));\n    }\n\n    /**\n     * 添加上缓存的header\n     * 如果有之前的缓存的信息\n     * 将里面的信息取出放入header中\n     * \n     * 这里面涉及到了一个条件请求\n     * 如果有缓存的话，header上面会带上一个If-Modified-Since关键字\n     * 服务器会先比较信息modified的时间，如果服务端的数据没有发生变化就返回304(也就是上面的 HttpStatus.SC_NOT_MODIFIED)\n     * 如果服务器的数据发生了变化，则会返回状态码200以及请求需要的数据(意思就是本地的数据需要刷新了，缓存不管用了)\n     */\n    private void addCacheHeaders(Map<String, String> headers, Cache.Entry entry) {\n        // If there's no cache entry, we're done.\n        if (entry == null) {\n            return;\n        }\n\n        if (entry.etag != null) {\n            headers.put(\"If-None-Match\", entry.etag);\n        }\n\n        if (entry.lastModified > 0) {\n            Date refTime = new Date(entry.lastModified);\n            headers.put(\"If-Modified-Since\", DateUtils.formatDate(refTime));\n        }\n    }\n\n    protected void logError(String what, String url, long start) {\n        long now = SystemClock.elapsedRealtime();\n        VolleyLog.v(\"HTTP ERROR(%s) %d ms to fetch %s\", what, (now - start), url);\n    }\n\n    /** \n     * Reads the contents of HttpEntity into a byte[].\n     * 从HttpEntity中读取数据，并通过ByteArrayPool将其转换成byte[]\n     * 暂时不用管太多= =，等后面介绍到ByteArrayPool.java的时候就会明白\n     */\n    private byte[] entityToBytes(HttpEntity entity) throws IOException, ServerError {\n\n        PoolingByteArrayOutputStream bytes =\n                new PoolingByteArrayOutputStream(mPool, (int) entity.getContentLength());\n\n        byte[] buffer = null;\n\n        try {\n            InputStream in = entity.getContent();\n            if (in == null) {\n                throw new ServerError();\n            }\n\n            /**\n             * 获取一个大小为1024的缓冲区\n             */\n            buffer = mPool.getBuf(1024);\n\n            int count;\n            //将content的内容通过流每次最大读出1024个byte, 全部读出并写入bytes\n            while ((count = in.read(buffer)) != -1) {\n                bytes.write(buffer, 0, count);\n            }\n            return bytes.toByteArray();\n        } finally {\n            try {\n                // Close the InputStream and release the resources by \"consuming the content\".\n                entity.consumeContent();\n            } catch (IOException e) {\n                // This can happen if there was an exception above that left the entity in\n                // an invalid state.\n                VolleyLog.v(\"Error occured when calling consumingContent\");\n            }\n            /**\n             * 在所有工作完成之后\n             * 需要将从mPool中拿出的buffer缓冲区回收\n             */\n            mPool.returnBuf(buffer);\n            bytes.close();\n        }\n    }\n\n    /**\n     * Converts Headers[] to Map<String, String>.\n     * 将返回的response里面的header[]\n     * 全部转换成Map里面的键值对形式\n     */\n    protected static Map<String, String> convertHeaders(Header[] headers) {\n        Map<String, String> result = new TreeMap<String, String>(String.CASE_INSENSITIVE_ORDER);\n        for (int i = 0; i < headers.length; i++) {\n            result.put(headers[i].getName(), headers[i].getValue());\n        }\n        return result;\n    }\n}\n\n```\n\n### [](#4-_ByteArrayPool-java \"4\\. ByteArrayPool.java\")4\\. ByteArrayPool.java\n\nByteArrayPool.java是用来将HttpResponse中Entity通过stream的形式转换成byte[],主要的作用是提供缓冲区，用来辅助流数据的读取，在使用完成之后需要将使用过的缓冲区还给ByteArrayPool，ByteArrayPool里会对这些byte[]进行简单的回收处理。\n\n```\n/**\n * 用来给外界提供byte[]作为缓冲区的一个工具类\n */\npublic class ByteArrayPool {\n    /**\n     * The buffer pool, arranged both by last use and by buffer size \n     */\n    private List<byte[]> mBuffersByLastUse = new LinkedList<byte[]>();\n    private List<byte[]> mBuffersBySize = new ArrayList<byte[]>(64);\n\n    /**\n     * The total size of the buffers in the pool\n     * 缓冲池的当前大小\n     */\n    private int mCurrentSize = 0;\n\n    /**\n     * The maximum aggregate size of the buffers in the pool. Old buffers are discarded to stay\n     * under this limit.\n     * 缓冲池当前的大小的阀值\n     * 超过了该值则会对缓冲池进行回收处理\n     */\n    private final int mSizeLimit;\n\n    /**\n     * Compares buffers by size\n     * 比较两个缓冲区的大小的规则\n     * 如果返回一个负数，则表示前一个数要小\n     * 如果返回0，则表示两个数字相等\n     * 如果返回一个正数，则表示后一个数要小\n     * \n     */\n    protected static final Comparator<byte[]> BUF_COMPARATOR = new Comparator<byte[]>() {\n        @Override\n        public int compare(byte[] lhs, byte[] rhs) {\n            return lhs.length - rhs.length;\n        }\n    };\n\n    /**\n     * @param sizeLimit the maximum size of the pool, in bytes\n     * 用来修改缓冲池的大小阀值\n     */\n    public ByteArrayPool(int sizeLimit) {\n        mSizeLimit = sizeLimit;\n    }\n\n    /**\n     * Returns a buffer from the pool if one is available in the requested size, or allocates a new\n     * one if a pooled one is not available.\n     * 从mBuffersBySize中调出一个缓冲区来\n     * 如果大小符合要求，则直接返回给调用者\n     * 如果没有符合要求的，直接创建一个新的byte[]返回\n     *\n     * @param len the minimum size, in bytes, of the requested buffer. The returned buffer may be\n     *        larger.\n     * @return a byte[] buffer is always returned.\n     */\n    public synchronized byte[] getBuf(int len) {\n        for (int i = 0; i < mBuffersBySize.size(); i++) {\n            byte[] buf = mBuffersBySize.get(i);\n            if (buf.length >= len) {\n                mCurrentSize -= buf.length;\n                mBuffersBySize.remove(i);\n                mBuffersByLastUse.remove(buf);\n                return buf;\n            }\n        }\n        return new byte[len];\n    }\n\n    /**\n     * Returns a buffer to the pool, throwing away old buffers if the pool would exceed its allotted\n     * size.\n     * \n     * @param buf the buffer to return to the pool.\n     */\n    public synchronized void returnBuf(byte[] buf) {\n\n        //如果buf为空或者超出了规定的大小，不管就行了，这种缓冲区用不着回收，因为= =根本就不符合要求嘛\n\n        if (buf == null || buf.length > mSizeLimit) {\n            return;\n        }\n\n        //如果buf符合要求，则将其加入到最近使用的队列中去\n\n        mBuffersByLastUse.add(buf);\n\n        /**\n         * 通过二分查找，比较规则为BUF_COMPARATOR，找出新进来的buf应该处于的位置\n         * 随后将buf插入到mBufferBySize的队列里面\n         */\n        int pos = Collections.binarySearch(mBuffersBySize, buf, BUF_COMPARATOR);\n        if (pos < 0) {\n            pos = -pos - 1;\n        }\n\n        mBuffersBySize.add(pos, buf);\n\n        //当前总缓冲区大小变大\n        mCurrentSize += buf.length;\n\n        //对整个缓冲池的大小做出调整\n        trim();\n    }\n\n    /**\n     * Removes buffers from the pool until it is under its size limit.\n     * 调整缓冲区的大小\n     * 直到mCurrentSize在限制大小之下\n     */\n    private synchronized void trim() {\n\n        while (mCurrentSize > mSizeLimit) {\n            byte[] buf = mBuffersByLastUse.remove(0);\n            mBuffersBySize.remove(buf);\n            mCurrentSize -= buf.length;\n        }\n    }\n\n}\n\n```\n\n### [](#5-_RetryPolicy-java \"5\\. RetryPolicy.java\")5\\. RetryPolicy.java\n\n在BasicNetwork.java这个类中，通过死循环加上try,catch的方式，不停的对一个request进行重复的处理，里面涉及到了`RetryPolicy.java`接口以及其默认实现类，这个接口是用来专门处理一个request在发送以及得到服务器响应返回结果的过程中出现的问题。通过有限次数的不断扩大request响应时间阀值，再次发送request的方式来达到一个retry的目的。和`Network.java`类似的，`RetryPolicy.java`也仅仅就是提供了抽象方法，想把具体的实现内容弄明白还需要去默认实现类`DefaultRetryPolicy.java`中去。\n\n```\npackage com.android.volley;\n\n/**\n * Retry policy for a request.\n * 该类用来管理request的调整及重新发送\n * 所谓调整就是将request响应时间(timeout)放宽\n */\npublic interface RetryPolicy {\n\n    /**\n     * Returns the current timeout (used for logging).\n     */\n    public int getCurrentTimeout();\n\n    /**\n     * Returns the current retry count (used for logging).\n     */\n    public int getCurrentRetryCount();\n\n    /**\n     * Prepares for the next retry by applying a backoff to the timeout.\n     * 为下一次request做好准备，通过不停地来放宽timeout时间限制\n     * 在DefaultRetryPolicy.java中好理解一些\n     * \n     * @param error The error code of the last attempt.\n     * @throws VolleyError In the event that the retry could not be performed (for example if we\n     * ran out of attempts), the passed in error is thrown.\n     */\n    public void retry(VolleyError error) throws VolleyError;\n}\n\n```\n\n### [](#6-_DefaultRetryPolicy-java \"6\\. DefaultRetryPolicy.java\")6\\. DefaultRetryPolicy.java\n\n`DefaultRetryPolicy.java`描述了对待Volley中涉及Network的request的策略方针，可以理解为重试策略方针，也就是对那些在网络请求失败的request处理方法。里面包含了retry的最大次数(`mMaxNumRetries`)，当前请求次数(`mCurrentRetryCount`)以及请求超时的时间阀值(`mCurrentTimeoutMs`)等。每个Request里面都包含了一个`RetryPolicy.java`实现类，在处理的时候可以通过`getRetryPolicy()`方法获得。\n\n```\npackage com.android.volley;\n\n/**\n * Default retry policy for requests.\n */\npublic class DefaultRetryPolicy implements RetryPolicy {\n    /** \n     * The current timeout in milliseconds. \n     * 请求超时的时间数\n     */\n    private int mCurrentTimeoutMs;\n\n    /** \n     * The current retry count.\n     * 当前请求的重试次数\n     */\n    private int mCurrentRetryCount;\n\n    /**\n     * The maximum number of attempts. \n     * 重复尝试的最大次数\n     **/\n    private final int mMaxNumRetries;\n\n    /**\n     * The backoff multiplier for the policy.\n     * 暂时不明白这个有什么用\n     * 根据后面的来看好像是一个用于放宽timeout时间限制的系数\n     * 这个系数越大每次retry的时候放宽的程度也就越大\n     */\n    private final float mBackoffMultiplier;\n\n    /** The default socket timeout in milliseconds */\n    public static final int DEFAULT_TIMEOUT_MS = 2500;\n\n    /** The default number of retries */\n    public static final int DEFAULT_MAX_RETRIES = 0;\n\n    /** The default backoff multiplier */\n    public static final float DEFAULT_BACKOFF_MULT = 1f;\n\n    /**\n     * Constructs a new retry policy using the default timeouts.\n     * 默认的构造器，2.5s的超时，\n     * 最大重试数为0，也就是request请求超时了就不要再自动重试了\n     */\n    public DefaultRetryPolicy() {\n        this(DEFAULT_TIMEOUT_MS, DEFAULT_MAX_RETRIES, DEFAULT_BACKOFF_MULT);\n    }\n\n    /**\n     * Constructs a new retry policy.\n     * @param initialTimeoutMs The initial timeout for the policy.\n     * @param maxNumRetries The maximum number of retries.\n     * @param backoffMultiplier Backoff multiplier for the policy.\n     */\n    public DefaultRetryPolicy(int initialTimeoutMs, int maxNumRetries, float backoffMultiplier) {\n        mCurrentTimeoutMs = initialTimeoutMs;\n        mMaxNumRetries = maxNumRetries;\n        mBackoffMultiplier = backoffMultiplier;\n    }\n\n    /**\n     * Returns the current timeout.\n     */\n    @Override\n    public int getCurrentTimeout() {\n        return mCurrentTimeoutMs;\n    }\n\n    /**\n     * Returns the current retry count.\n     */\n    @Override\n    public int getCurrentRetryCount() {\n        return mCurrentRetryCount;\n    }\n\n    /**\n     * Returns the backoff multiplier for the policy.\n     */\n    public float getBackoffMultiplier() {\n        return mBackoffMultiplier;\n    }\n\n    /**\n     * Prepares for the next retry by applying a backoff to the timeout.\n     * 该方法定义在RetryPolicy.java中。\n     * 为下一次重试request做准备，好像是通过延长服务器响应时间的限制 = =\n     * 每次对timeout的时间限制都放宽了mBackoffMultiplier个单位。让服务器多一点时间去响应\n     * \n     * @param error The error code of the last attempt.\n     * 最后一次request服务器给出的错误码\n     */\n    @Override\n    public void retry(VolleyError error) throws VolleyError {\n        mCurrentRetryCount++;\n        mCurrentTimeoutMs += (mCurrentTimeoutMs * mBackoffMultiplier);\n        if (!hasAttemptRemaining()) {\n            throw error;\n        }\n    }\n\n    /**\n     * Returns true if this policy has attempts remaining, false otherwise.\n     * 这个是用来判断是否还有retry机会的\n     */\n    protected boolean hasAttemptRemaining() {\n        return mCurrentRetryCount <= mMaxNumRetries;\n    }\n}\n\n```\n\n到这里对`Network.java`接口以及`RetryPolicy.java`接口的代码就分析完了，现在是清楚了在`NetworkDispatcher.java`调用了`mNetwork.performRequest()`之后发生了什么事情，还弄清楚了request在网络请求发送之后，出现了各种问题会怎么处理(重试策略)，但还不知道最核心的网络请求是如何发生的，也就是在`BasicNetwork.java`中的下面这行代码。\n\n```\nhttpResponse = mHttpStack.performRequest(request, headers);\n\n```\n\n这行代码就涉及到了后面的`HttpStack.java`接口及其两个实现类了。","slug":"Volley框架解析-四-Network接口及其实现","published":1,"updated":"2020-07-03T02:40:48.122Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckc5n2qhc000tw8r1jpqza1pq","content":"<h2 id=\"Volley框架解析-四-—–Network接口及其默认实现类解析\"><a href=\"#Volley框架解析-四-—–Network接口及其默认实现类解析\" class=\"headerlink\" title=\"Volley框架解析(四)—–Network接口及其默认实现类解析\"></a>Volley框架解析(四)—–Network接口及其默认实现类解析</h2><h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h3><p>&#160;&#160;&#160;&#160;前面的三篇Volley框架解析文章已经从Volley对外暴露的接口Volley.java开始，向下慢慢深入到了RequestQueue.java，这个Volley中比较核心的类，然后又分析了Volley中负责主要request调度工作的两类Dispatcher，<code>NetworkDispatcher</code>以及<code>CacheDispatcher</code>。应该是将一个request从新建，到加入队列中等待处理，如何被处理以及返回结果或者error这一系列的流程理顺了。</p>\n<p>&#160;&#160;&#160;&#160;但是对于一些细节的问题还是不清楚，例如request究竟是如何发送出去，通过<code>NetworkResponse networkResponse = mNetwork.performRequest(request);</code>这么一句话就返回了结果(response)，这里面发生了些什么还不得而知，还有<code>Network#performRequest()</code>和<code>HttpStack#performRequest()</code>这两个函数之间有什么区别和联系等等。</p>\n<a id=\"more\"></a>\n<h3 id=\"2-Network-java\"><a href=\"#2-Network-java\" class=\"headerlink\" title=\"2. Network.java\"></a><a href=\"#2-_Network-java\" title=\"2\\. Network.java\"></a>2. Network.java</h3><p>&#160;&#160;&#160;&#160;最早接触到Network这个类是在<code>Volley.java</code>中的<code>newRequestQueue()</code>函数里面，<code>Network network = new BasicNetwork(stack);</code>创建了一个Network接口引用，并指向了一个Volley中的默认实现类的实例<code>BasicNetwork.java</code>，这个默认实现类也会在这篇博客的后面详细的解析。</p>\n<p>&#160;&#160;&#160;&#160;经过前面几篇博客的分析，<code>Volley.java</code>仅仅是持有而没有使用，仅将这个引用传递给了<code>NetworkDispatcher.java</code>中，只有在<code>NetworkDispatcher.java</code>类中用到了这个Network接口，在<code>NetowkrDispatcher.java</code>中存在着这么一行代码，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">NetworkResponse networkResponse = mNetwork.performRequest(request);</div></pre></td></tr></table></figure>\n<p>&#160;&#160;&#160;&#160;仅仅用了一句话就将request发送出去了，并且还拿回来了一个<code>NetworkResponse.java</code>类对象。里面发生了什么= =，先进去Network.java里面看看：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">package com.android.volley;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\"> * An interface for performing requests.</div><div class=\"line\"> */</div><div class=\"line\">public interface Network &#123;</div><div class=\"line\">    /**</div><div class=\"line\">     * Performs the specified request.</div><div class=\"line\">     * 用来发送特定的请求</div><div class=\"line\">     *</div><div class=\"line\">     * @param request Request to process</div><div class=\"line\">     * 即将被发送的request</div><div class=\"line\">     *</div><div class=\"line\">     * @return A &#123;@link NetworkResponse&#125; with data and caching metadata; will never be null</div><div class=\"line\">     * 请求之后返回的response, 是volley自己构造出来的一个response</div><div class=\"line\">     * 里面包含了返回的请求码等等。</div><div class=\"line\">     *</div><div class=\"line\">     * @throws VolleyError on errors</div><div class=\"line\">     */</div><div class=\"line\">    public NetworkResponse performRequest(Request&lt;?&gt; request) throws VolleyError;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>对，没有看错= =，就这么点东西，仅仅一个抽象方法而已，Network.java就是一个等待被实现的接口，想看真东西，还需要进去<code>Network network = new BasicNetwork(stack);</code>里面所提到的<code>BasicNetwork.java</code>看看。</p>\n<h3 id=\"3-BasicNetwork-java\"><a href=\"#3-BasicNetwork-java\" class=\"headerlink\" title=\"3. BasicNetwork.java\"></a><a href=\"#3-_BasicNetwork-java\" title=\"3\\. BasicNetwork.java\"></a>3. BasicNetwork.java</h3><p><code>Network.java</code>接口的默认实现类，该类里面会处理一些request发送前后的处理工作，主要是对请求返回的httpResponse处理，以及对请求失败进行retry或者抛出异常的处理。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div><div class=\"line\">204</div><div class=\"line\">205</div><div class=\"line\">206</div><div class=\"line\">207</div><div class=\"line\">208</div><div class=\"line\">209</div><div class=\"line\">210</div><div class=\"line\">211</div><div class=\"line\">212</div><div class=\"line\">213</div><div class=\"line\">214</div><div class=\"line\">215</div><div class=\"line\">216</div><div class=\"line\">217</div><div class=\"line\">218</div><div class=\"line\">219</div><div class=\"line\">220</div><div class=\"line\">221</div><div class=\"line\">222</div><div class=\"line\">223</div><div class=\"line\">224</div><div class=\"line\">225</div><div class=\"line\">226</div><div class=\"line\">227</div><div class=\"line\">228</div><div class=\"line\">229</div><div class=\"line\">230</div><div class=\"line\">231</div><div class=\"line\">232</div><div class=\"line\">233</div><div class=\"line\">234</div><div class=\"line\">235</div><div class=\"line\">236</div><div class=\"line\">237</div><div class=\"line\">238</div><div class=\"line\">239</div><div class=\"line\">240</div><div class=\"line\">241</div><div class=\"line\">242</div><div class=\"line\">243</div><div class=\"line\">244</div><div class=\"line\">245</div><div class=\"line\">246</div><div class=\"line\">247</div><div class=\"line\">248</div><div class=\"line\">249</div><div class=\"line\">250</div><div class=\"line\">251</div><div class=\"line\">252</div><div class=\"line\">253</div><div class=\"line\">254</div><div class=\"line\">255</div><div class=\"line\">256</div><div class=\"line\">257</div><div class=\"line\">258</div><div class=\"line\">259</div><div class=\"line\">260</div><div class=\"line\">261</div><div class=\"line\">262</div><div class=\"line\">263</div><div class=\"line\">264</div><div class=\"line\">265</div><div class=\"line\">266</div><div class=\"line\">267</div><div class=\"line\">268</div><div class=\"line\">269</div><div class=\"line\">270</div><div class=\"line\">271</div><div class=\"line\">272</div><div class=\"line\">273</div><div class=\"line\">274</div><div class=\"line\">275</div><div class=\"line\">276</div><div class=\"line\">277</div><div class=\"line\">278</div><div class=\"line\">279</div><div class=\"line\">280</div><div class=\"line\">281</div><div class=\"line\">282</div><div class=\"line\">283</div><div class=\"line\">284</div><div class=\"line\">285</div><div class=\"line\">286</div><div class=\"line\">287</div><div class=\"line\">288</div><div class=\"line\">289</div><div class=\"line\">290</div><div class=\"line\">291</div><div class=\"line\">292</div><div class=\"line\">293</div><div class=\"line\">294</div><div class=\"line\">295</div><div class=\"line\">296</div><div class=\"line\">297</div><div class=\"line\">298</div><div class=\"line\">299</div><div class=\"line\">300</div><div class=\"line\">301</div><div class=\"line\">302</div><div class=\"line\">303</div><div class=\"line\">304</div><div class=\"line\">305</div><div class=\"line\">306</div><div class=\"line\">307</div><div class=\"line\">308</div><div class=\"line\">309</div><div class=\"line\">310</div><div class=\"line\">311</div><div class=\"line\">312</div><div class=\"line\">313</div><div class=\"line\">314</div><div class=\"line\">315</div><div class=\"line\">316</div><div class=\"line\">317</div><div class=\"line\">318</div><div class=\"line\">319</div><div class=\"line\">320</div><div class=\"line\">321</div><div class=\"line\">322</div><div class=\"line\">323</div><div class=\"line\">324</div><div class=\"line\">325</div><div class=\"line\">326</div><div class=\"line\">327</div><div class=\"line\">328</div><div class=\"line\">329</div><div class=\"line\">330</div><div class=\"line\">331</div><div class=\"line\">332</div><div class=\"line\">333</div><div class=\"line\">334</div><div class=\"line\">335</div><div class=\"line\">336</div><div class=\"line\">337</div><div class=\"line\">338</div><div class=\"line\">339</div><div class=\"line\">340</div><div class=\"line\">341</div><div class=\"line\">342</div><div class=\"line\">343</div><div class=\"line\">344</div><div class=\"line\">345</div><div class=\"line\">346</div><div class=\"line\">347</div><div class=\"line\">348</div><div class=\"line\">349</div><div class=\"line\">350</div><div class=\"line\">351</div><div class=\"line\">352</div><div class=\"line\">353</div><div class=\"line\">354</div><div class=\"line\">355</div><div class=\"line\">356</div><div class=\"line\">357</div><div class=\"line\">358</div><div class=\"line\">359</div><div class=\"line\">360</div><div class=\"line\">361</div><div class=\"line\">362</div><div class=\"line\">363</div><div class=\"line\">364</div><div class=\"line\">365</div><div class=\"line\">366</div><div class=\"line\">367</div><div class=\"line\">368</div><div class=\"line\">369</div><div class=\"line\">370</div><div class=\"line\">371</div><div class=\"line\">372</div><div class=\"line\">373</div><div class=\"line\">374</div><div class=\"line\">375</div><div class=\"line\">376</div><div class=\"line\">377</div><div class=\"line\">378</div><div class=\"line\">379</div><div class=\"line\">380</div><div class=\"line\">381</div><div class=\"line\">382</div><div class=\"line\">383</div><div class=\"line\">384</div><div class=\"line\">385</div><div class=\"line\">386</div><div class=\"line\">387</div><div class=\"line\">388</div><div class=\"line\">389</div><div class=\"line\">390</div><div class=\"line\">391</div><div class=\"line\">392</div><div class=\"line\">393</div><div class=\"line\">394</div><div class=\"line\">395</div><div class=\"line\">396</div><div class=\"line\">397</div><div class=\"line\">398</div><div class=\"line\">399</div><div class=\"line\">400</div><div class=\"line\">401</div><div class=\"line\">402</div><div class=\"line\">403</div><div class=\"line\">404</div><div class=\"line\">405</div><div class=\"line\">406</div><div class=\"line\">407</div><div class=\"line\">408</div><div class=\"line\">409</div><div class=\"line\">410</div><div class=\"line\">411</div><div class=\"line\">412</div><div class=\"line\">413</div><div class=\"line\">414</div><div class=\"line\">415</div><div class=\"line\">416</div><div class=\"line\">417</div><div class=\"line\">418</div><div class=\"line\">419</div><div class=\"line\">420</div><div class=\"line\">421</div><div class=\"line\">422</div><div class=\"line\">423</div><div class=\"line\">424</div></pre></td><td class=\"code\"><pre><div class=\"line\">package com.android.volley.toolbox;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\"> * A network performing Volley requests over an &#123;@link HttpStack&#125;.</div><div class=\"line\"> * 一个用来执行Volley中request的类</div><div class=\"line\"> * 在HttpStack的基础之上</div><div class=\"line\"> * 因为主要还是调用HttpStack接口的performRequest</div><div class=\"line\"> * 在这个里面的performRequest主要还是做一些整理工作</div><div class=\"line\"> * 比如将｛@link HttpStack#performRequest()｝方法返回的HttpResponse</div><div class=\"line\"> * 解析成Volley自己实现的NetworkResponse.java</div><div class=\"line\"> */</div><div class=\"line\"></div><div class=\"line\">public class BasicNetwork implements Network &#123;</div><div class=\"line\"></div><div class=\"line\">    //是否允许打lo的boolean常变量</div><div class=\"line\">    protected static final boolean DEBUG = VolleyLog.DEBUG;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * 这是一个阀值，用来判断一个request是否请求响应过慢了= =</div><div class=\"line\">     * 在后面的作用就是，如果响应时间超过了这个阀值</div><div class=\"line\">     * 打出log说明这个request有些慢，为了更好的反应request当前状态</div><div class=\"line\">     */</div><div class=\"line\">    private static int SLOW_REQUEST_THRESHOLD_MS = 3000;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * 默认ByteArrayPool的大小</div><div class=\"line\">     * 现在只需要知道ByteArrayPool.java是Volley用来从输入流中读取数据并将其转换成字节数组的工具即可</div><div class=\"line\">     * 在这篇博客后面会介绍，表担心~= =</div><div class=\"line\">     */</div><div class=\"line\">    private static int DEFAULT_POOL_SIZE = 4096;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * 网络请求的真正接口</div><div class=\"line\">     * 为什么这么说咧，BasicNetwork里面的performRequest()函数</div><div class=\"line\">     * 调用了HttpStack里的performRequest()，真正的网络请求还是通过HttpStack里面的方法实现的</div><div class=\"line\">     * 在Volley中实现了HttpStack接口的类有两个 HurlStack.java和HttpClientStack.java</div><div class=\"line\">     * 针对了不同Android系统版本，用不同的方法实现了请求。</div><div class=\"line\">     */</div><div class=\"line\">    protected final HttpStack mHttpStack;</div><div class=\"line\"></div><div class=\"line\">    //表急，后面会介绍到的，现在知道是一个用于数据转换的工具类就好了</div><div class=\"line\">    protected final ByteArrayPool mPool;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * @param httpStack HTTP stack to be used</div><div class=\"line\">     * 传入的HttpStack实现类引用</div><div class=\"line\">     * 整个网络请求的较核心部分就在HttpStack实现类上面咯</div><div class=\"line\">     */</div><div class=\"line\">    public BasicNetwork(HttpStack httpStack) &#123;</div><div class=\"line\">        // If a pool isn&apos;t passed in, then build a small default pool that will give us a lot of</div><div class=\"line\">        // benefit and not use too much memory.</div><div class=\"line\">        this(httpStack, new ByteArrayPool(DEFAULT_POOL_SIZE));</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * @param httpStack HTTP stack to be used</div><div class=\"line\">     * @param pool a buffer pool that improves GC performance in copy operations</div><div class=\"line\">     * Volley接口分离的很明显，而且在构造函数里面也提供了很多种</div><div class=\"line\">     * 可以定制出适合自己的ByteArrayPool衍生类</div><div class=\"line\">     * 当然也可以自己来实现HttpStack的衍生类</div><div class=\"line\">     */</div><div class=\"line\">    public BasicNetwork(HttpStack httpStack, ByteArrayPool pool) &#123;</div><div class=\"line\">        mHttpStack = httpStack;</div><div class=\"line\">        mPool = pool;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * 这个方法重写的是Network的方法</div><div class=\"line\">     * 在这个里面再调用HttpStack里面的performRequest方法</div><div class=\"line\">     */</div><div class=\"line\">    @Override</div><div class=\"line\">    public NetworkResponse performRequest(Request&lt;?&gt; request) throws VolleyError &#123;</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * Returns milliseconds since boot, including time spent in sleep.</div><div class=\"line\">         * 为了方便计算每个request所用的时间</div><div class=\"line\">         * 在处理每个request之前都记下此刻unix时间戳</div><div class=\"line\">         */</div><div class=\"line\">        long requestStart = SystemClock.elapsedRealtime();</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * 进入死循环= =</div><div class=\"line\">         * 还没弄清楚为什么要死循环</div><div class=\"line\">         */</div><div class=\"line\">        while (true) &#123;</div><div class=\"line\"></div><div class=\"line\">            /**</div><div class=\"line\">             * 指向HttpResponse实例的引用</div><div class=\"line\">             * 是调用HttpStack方法performRequest()之后返回的结果</div><div class=\"line\">             */</div><div class=\"line\">            HttpResponse httpResponse = null;</div><div class=\"line\"></div><div class=\"line\">            /**</div><div class=\"line\">             * 返回的HttpResponse还需要经过处理</div><div class=\"line\">             * 并不是返回回来就是能直接使用的数据</div><div class=\"line\">             * 需要通过上面的ByteArrayPool将Entity转换成byte[]</div><div class=\"line\">             * 这个就是指向解析后的byte[]的</div><div class=\"line\">             */</div><div class=\"line\">            byte[] responseContents = null;</div><div class=\"line\"></div><div class=\"line\">            //用来存放response里面header的信息，包含了状态码等</div><div class=\"line\">            Map&lt;String, String&gt; responseHeaders = Collections.emptyMap();</div><div class=\"line\"></div><div class=\"line\">            try &#123;</div><div class=\"line\">                /**</div><div class=\"line\">                 * Gather headers.</div><div class=\"line\">                 * 设置header</div><div class=\"line\">                 * 从缓存中收集上次相同request的信息</div><div class=\"line\">                 */</div><div class=\"line\">                Map&lt;String, String&gt; headers = new HashMap&lt;String, String&gt;();</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * 将缓存的信息加入到headers中</div><div class=\"line\">                 * headers会跟随request一起发送给服务器</div><div class=\"line\">                 * 在函数的定义处会讲解</div><div class=\"line\">                 */</div><div class=\"line\">                addCacheHeaders(headers, request.getCacheEntry());</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * 通过调用HttpStack接口的performRequest()方法</div><div class=\"line\">                 * 获取服务器返回的HttpResponse</div><div class=\"line\">                 */</div><div class=\"line\">                httpResponse = mHttpStack.performRequest(request, headers);</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * The first line of a Response message is the Status-Line, </div><div class=\"line\">                 * consisting of the protocol version followed by a numeric status code and its associated textual phrase</div><div class=\"line\">                 * with each element separated by SP characters. </div><div class=\"line\">                 * No CR or LF is allowed except in the final CRLF sequence.</div><div class=\"line\">                 * 请求返回的response第一行就是包含了状态码的一行</div><div class=\"line\">                 */</div><div class=\"line\">                StatusLine statusLine = httpResponse.getStatusLine();</div><div class=\"line\">                int statusCode = statusLine.getStatusCode();</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * 将头部解析成键值对的形式再返回</div><div class=\"line\">                 */</div><div class=\"line\">                responseHeaders = convertHeaders(httpResponse.getAllHeaders());</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * Handle cache validation.</div><div class=\"line\">                 * 处理缓存信息</div><div class=\"line\">                 * 如果返回的状态码是304(HttpStatus.SC_NOT_MODIFIED)</div><div class=\"line\">                 * 则进行如下的处理</div><div class=\"line\">                 */</div><div class=\"line\">                if (statusCode == HttpStatus.SC_NOT_MODIFIED) &#123;</div><div class=\"line\"></div><div class=\"line\">                    /**</div><div class=\"line\">                     * 如果缓存为空的话</div><div class=\"line\">                     * 那就说明该请求的返回的response的body就是null</div><div class=\"line\">                     * 直接构造一个NetworkResponse返回</div><div class=\"line\">                     */</div><div class=\"line\">                    Entry entry = request.getCacheEntry();</div><div class=\"line\">                    if (entry == null) &#123;</div><div class=\"line\">                        return new NetworkResponse(HttpStatus.SC_NOT_MODIFIED, null,</div><div class=\"line\">                                responseHeaders, true,</div><div class=\"line\">                                SystemClock.elapsedRealtime() - requestStart);</div><div class=\"line\">                    &#125;</div><div class=\"line\"></div><div class=\"line\">                    // A HTTP 304 response does not have all header fields. We</div><div class=\"line\">                    // have to use the header fields from the cache entry plus</div><div class=\"line\">                    // the new ones from the response.</div><div class=\"line\">                    // http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.5</div><div class=\"line\">                    /**</div><div class=\"line\">                     * 一个返回码为304的HttpResponse的header缺少一些信息</div><div class=\"line\">                     * 需要我们将cache中的一些header信息加入到其中</div><div class=\"line\">                     * 这样组成一个完整的NetworkResponse返回</div><div class=\"line\">                     */</div><div class=\"line\">                    entry.responseHeaders.putAll(responseHeaders);</div><div class=\"line\">                    return new NetworkResponse(HttpStatus.SC_NOT_MODIFIED, entry.data,</div><div class=\"line\">                            entry.responseHeaders, true,</div><div class=\"line\">                            SystemClock.elapsedRealtime() - requestStart);</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * Handle moved resources</div><div class=\"line\">                 * 处理了重定向的问题</div><div class=\"line\">                 * 并将request的mRedirectUrl设定成了新的url</div><div class=\"line\">                 */</div><div class=\"line\">                if (statusCode == HttpStatus.SC_MOVED_PERMANENTLY || statusCode == HttpStatus.SC_MOVED_TEMPORARILY) &#123;</div><div class=\"line\">                    String newUrl = responseHeaders.get(&quot;Location&quot;);</div><div class=\"line\">                    request.setRedirectUrl(newUrl);</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * Some responses such as 204s do not have content.  We must check.</div><div class=\"line\">                 * 204(无内容)服务器成功处理了请求，但没有返回任何内容。</div><div class=\"line\">                 * </div><div class=\"line\">                 */</div><div class=\"line\">                if (httpResponse.getEntity() != null) &#123;</div><div class=\"line\">                    /**</div><div class=\"line\">                     * 如果entity不为Null</div><div class=\"line\">                     * 将其转换成byte数组</div><div class=\"line\">                     * 利用之前提到过的ByteArrayPool.java类</div><div class=\"line\">                     */</div><div class=\"line\">                  responseContents = entityToBytes(httpResponse.getEntity());</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                  // Add 0 byte response as a way of honestly representing a</div><div class=\"line\">                  // no-content request.</div><div class=\"line\">                  responseContents = new byte[0];</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * if the request is slow, log it.</div><div class=\"line\">                 * 获取request已经占用的时间(requestLifetime)</div><div class=\"line\">                 * 判断是否需要打出request的超时状态</div><div class=\"line\">                 */</div><div class=\"line\">                long requestLifetime = SystemClock.elapsedRealtime() - requestStart;</div><div class=\"line\">                logSlowRequests(requestLifetime, request, responseContents, statusLine);</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * 如果状态码位于200之下或者是299之上(200-299 用于表示请求成功)</div><div class=\"line\">                 * 则抛出IOException异常= =为什么非要抛出这个异常</div><div class=\"line\">                 * 在前面过滤掉了(304等情况)</div><div class=\"line\">                 */</div><div class=\"line\">                if (statusCode &lt; 200 || statusCode &gt; 299) &#123;</div><div class=\"line\">                    throw new IOException();</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * 经过上面的层层过滤</div><div class=\"line\">                 * 最后留下了200~299之间的请求成功response</div><div class=\"line\">                 * 通过HttpResponse里面的信息构造出一个volley自己封装的NetworkResponse对象</div><div class=\"line\">                 */</div><div class=\"line\">                return new NetworkResponse(statusCode, responseContents, responseHeaders, false,</div><div class=\"line\">                        SystemClock.elapsedRealtime() - requestStart);</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * 抛出了异常之后，会用attemptREtryOnException()方法来尝试retry</div><div class=\"line\">                 * 主要做的工作就是看是否还有retry的机会，如果有则不停通过这个死循环</div><div class=\"line\">                 * 进行请求，直到请求成功或者请求的机会用完为止</div><div class=\"line\">                 */</div><div class=\"line\">            &#125; catch (SocketTimeoutException e) &#123;</div><div class=\"line\">                attemptRetryOnException(&quot;socket&quot;, request, new TimeoutError());</div><div class=\"line\">            &#125; catch (ConnectTimeoutException e) &#123;·</div><div class=\"line\">                attemptRetryOnException(&quot;connection&quot;, request, new TimeoutError());</div><div class=\"line\">            &#125; catch (MalformedURLException e) &#123;</div><div class=\"line\">                throw new RuntimeException(&quot;Bad URL &quot; + request.getUrl(), e);</div><div class=\"line\">            &#125; catch (IOException e) &#123;</div><div class=\"line\">                /**</div><div class=\"line\">                 * 状态码在0~200以及299之上的response</div><div class=\"line\">                 * 处理的套路</div><div class=\"line\">                 */</div><div class=\"line\">                int statusCode = 0;</div><div class=\"line\">                NetworkResponse networkResponse = null;</div><div class=\"line\">                if (httpResponse != null) &#123;</div><div class=\"line\">                    statusCode = httpResponse.getStatusLine().getStatusCode();</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    //如果状态码为0，则抛出NoConnectionError</div><div class=\"line\">                    throw new NoConnectionError(e);</div><div class=\"line\">                &#125;</div><div class=\"line\">                /**</div><div class=\"line\">                 * 如果有重定向的情况发生</div><div class=\"line\">                 * 用log打出</div><div class=\"line\">                 */</div><div class=\"line\">                if (statusCode == HttpStatus.SC_MOVED_PERMANENTLY || </div><div class=\"line\">                        statusCode == HttpStatus.SC_MOVED_TEMPORARILY) &#123;</div><div class=\"line\">                    VolleyLog.e(&quot;Request at %s has been redirected to %s&quot;, request.getOriginUrl(), request.getUrl());</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    VolleyLog.e(&quot;Unexpected response code %d for %s&quot;, statusCode, request.getUrl());</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * 如果返回的content内容不为Null</div><div class=\"line\">                 * 则构造出一个NetworkResponse</div><div class=\"line\">                 * 否则抛出NetworkError</div><div class=\"line\">                 */</div><div class=\"line\">                if (responseContents != null) &#123;</div><div class=\"line\"></div><div class=\"line\">                    networkResponse = new NetworkResponse(statusCode, responseContents,</div><div class=\"line\">                            responseHeaders, false, SystemClock.elapsedRealtime() - requestStart);</div><div class=\"line\"></div><div class=\"line\">                    /**</div><div class=\"line\">                     * 抛出了异常之后，会用attemptREtryOnException()方法来尝试retry</div><div class=\"line\">                     * 主要做的工作就是看是否还有retry的机会，如果有则不停通过这个死循环</div><div class=\"line\">                     * 进行请求，直到请求成功或者请求的机会用完为止</div><div class=\"line\">                     */</div><div class=\"line\">                    if (statusCode == HttpStatus.SC_UNAUTHORIZED ||</div><div class=\"line\">                            statusCode == HttpStatus.SC_FORBIDDEN) &#123;</div><div class=\"line\">                        attemptRetryOnException(&quot;auth&quot;,</div><div class=\"line\">                                request, new AuthFailureError(networkResponse));</div><div class=\"line\">                    &#125; else if (statusCode == HttpStatus.SC_MOVED_PERMANENTLY || </div><div class=\"line\">                                statusCode == HttpStatus.SC_MOVED_TEMPORARILY) &#123;</div><div class=\"line\">                        attemptRetryOnException(&quot;redirect&quot;,</div><div class=\"line\">                                request, new AuthFailureError(networkResponse));</div><div class=\"line\">                    &#125; else &#123;</div><div class=\"line\">                        // TODO: Only throw ServerError for 5xx status codes.</div><div class=\"line\">                        throw new ServerError(networkResponse);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    throw new NetworkError(networkResponse);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Logs requests that took over SLOW_REQUEST_THRESHOLD_MS to complete.</div><div class=\"line\">     * 如果request用时超出了预先设定的阀值</div><div class=\"line\">     * 则打出log用于debug时候的提示</div><div class=\"line\">     */</div><div class=\"line\">    private void logSlowRequests(long requestLifetime, Request&lt;?&gt; request,</div><div class=\"line\">            byte[] responseContents, StatusLine statusLine) &#123;</div><div class=\"line\">        if (DEBUG || requestLifetime &gt; SLOW_REQUEST_THRESHOLD_MS) &#123;</div><div class=\"line\">            VolleyLog.d(&quot;HTTP response for request=&lt;%s&gt; [lifetime=%d], [size=%s], &quot; +</div><div class=\"line\">                    &quot;[rc=%d], [retryCount=%s]&quot;, request, requestLifetime,</div><div class=\"line\">                    responseContents != null ? responseContents.length : &quot;null&quot;,</div><div class=\"line\">                    statusLine.getStatusCode(), request.getRetryPolicy().getCurrentRetryCount());</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Attempts to prepare the request for a retry. If there are no more attempts remaining in the</div><div class=\"line\">     * request&apos;s retry policy, a timeout exception is thrown.</div><div class=\"line\">     * 每次尝试都会使retry机会减少1，如果机会没有了，则抛出请求超时的exception</div><div class=\"line\">     *</div><div class=\"line\">     * @param request The request to use.</div><div class=\"line\">     */</div><div class=\"line\">    private static void attemptRetryOnException(String logPrefix, Request&lt;?&gt; request,</div><div class=\"line\">            VolleyError exception) throws VolleyError &#123;</div><div class=\"line\">        RetryPolicy retryPolicy = request.getRetryPolicy();</div><div class=\"line\">        int oldTimeout = request.getTimeoutMs();</div><div class=\"line\"></div><div class=\"line\">        try &#123;</div><div class=\"line\">            retryPolicy.retry(exception);</div><div class=\"line\">        &#125; catch (VolleyError e) &#123;</div><div class=\"line\">            request.addMarker(</div><div class=\"line\">                    String.format(&quot;%s-timeout-giveup [timeout=%s]&quot;, logPrefix, oldTimeout));</div><div class=\"line\">            throw e;</div><div class=\"line\">        &#125;</div><div class=\"line\">        request.addMarker(String.format(&quot;%s-retry [timeout=%s]&quot;, logPrefix, oldTimeout));</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * 添加上缓存的header</div><div class=\"line\">     * 如果有之前的缓存的信息</div><div class=\"line\">     * 将里面的信息取出放入header中</div><div class=\"line\">     * </div><div class=\"line\">     * 这里面涉及到了一个条件请求</div><div class=\"line\">     * 如果有缓存的话，header上面会带上一个If-Modified-Since关键字</div><div class=\"line\">     * 服务器会先比较信息modified的时间，如果服务端的数据没有发生变化就返回304(也就是上面的 HttpStatus.SC_NOT_MODIFIED)</div><div class=\"line\">     * 如果服务器的数据发生了变化，则会返回状态码200以及请求需要的数据(意思就是本地的数据需要刷新了，缓存不管用了)</div><div class=\"line\">     */</div><div class=\"line\">    private void addCacheHeaders(Map&lt;String, String&gt; headers, Cache.Entry entry) &#123;</div><div class=\"line\">        // If there&apos;s no cache entry, we&apos;re done.</div><div class=\"line\">        if (entry == null) &#123;</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (entry.etag != null) &#123;</div><div class=\"line\">            headers.put(&quot;If-None-Match&quot;, entry.etag);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (entry.lastModified &gt; 0) &#123;</div><div class=\"line\">            Date refTime = new Date(entry.lastModified);</div><div class=\"line\">            headers.put(&quot;If-Modified-Since&quot;, DateUtils.formatDate(refTime));</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    protected void logError(String what, String url, long start) &#123;</div><div class=\"line\">        long now = SystemClock.elapsedRealtime();</div><div class=\"line\">        VolleyLog.v(&quot;HTTP ERROR(%s) %d ms to fetch %s&quot;, what, (now - start), url);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * Reads the contents of HttpEntity into a byte[].</div><div class=\"line\">     * 从HttpEntity中读取数据，并通过ByteArrayPool将其转换成byte[]</div><div class=\"line\">     * 暂时不用管太多= =，等后面介绍到ByteArrayPool.java的时候就会明白</div><div class=\"line\">     */</div><div class=\"line\">    private byte[] entityToBytes(HttpEntity entity) throws IOException, ServerError &#123;</div><div class=\"line\"></div><div class=\"line\">        PoolingByteArrayOutputStream bytes =</div><div class=\"line\">                new PoolingByteArrayOutputStream(mPool, (int) entity.getContentLength());</div><div class=\"line\"></div><div class=\"line\">        byte[] buffer = null;</div><div class=\"line\"></div><div class=\"line\">        try &#123;</div><div class=\"line\">            InputStream in = entity.getContent();</div><div class=\"line\">            if (in == null) &#123;</div><div class=\"line\">                throw new ServerError();</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            /**</div><div class=\"line\">             * 获取一个大小为1024的缓冲区</div><div class=\"line\">             */</div><div class=\"line\">            buffer = mPool.getBuf(1024);</div><div class=\"line\"></div><div class=\"line\">            int count;</div><div class=\"line\">            //将content的内容通过流每次最大读出1024个byte, 全部读出并写入bytes</div><div class=\"line\">            while ((count = in.read(buffer)) != -1) &#123;</div><div class=\"line\">                bytes.write(buffer, 0, count);</div><div class=\"line\">            &#125;</div><div class=\"line\">            return bytes.toByteArray();</div><div class=\"line\">        &#125; finally &#123;</div><div class=\"line\">            try &#123;</div><div class=\"line\">                // Close the InputStream and release the resources by &quot;consuming the content&quot;.</div><div class=\"line\">                entity.consumeContent();</div><div class=\"line\">            &#125; catch (IOException e) &#123;</div><div class=\"line\">                // This can happen if there was an exception above that left the entity in</div><div class=\"line\">                // an invalid state.</div><div class=\"line\">                VolleyLog.v(&quot;Error occured when calling consumingContent&quot;);</div><div class=\"line\">            &#125;</div><div class=\"line\">            /**</div><div class=\"line\">             * 在所有工作完成之后</div><div class=\"line\">             * 需要将从mPool中拿出的buffer缓冲区回收</div><div class=\"line\">             */</div><div class=\"line\">            mPool.returnBuf(buffer);</div><div class=\"line\">            bytes.close();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Converts Headers[] to Map&lt;String, String&gt;.</div><div class=\"line\">     * 将返回的response里面的header[]</div><div class=\"line\">     * 全部转换成Map里面的键值对形式</div><div class=\"line\">     */</div><div class=\"line\">    protected static Map&lt;String, String&gt; convertHeaders(Header[] headers) &#123;</div><div class=\"line\">        Map&lt;String, String&gt; result = new TreeMap&lt;String, String&gt;(String.CASE_INSENSITIVE_ORDER);</div><div class=\"line\">        for (int i = 0; i &lt; headers.length; i++) &#123;</div><div class=\"line\">            result.put(headers[i].getName(), headers[i].getValue());</div><div class=\"line\">        &#125;</div><div class=\"line\">        return result;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"4-ByteArrayPool-java\"><a href=\"#4-ByteArrayPool-java\" class=\"headerlink\" title=\"4. ByteArrayPool.java\"></a><a href=\"#4-_ByteArrayPool-java\" title=\"4\\. ByteArrayPool.java\"></a>4. ByteArrayPool.java</h3><p>ByteArrayPool.java是用来将HttpResponse中Entity通过stream的形式转换成byte[],主要的作用是提供缓冲区，用来辅助流数据的读取，在使用完成之后需要将使用过的缓冲区还给ByteArrayPool，ByteArrayPool里会对这些byte[]进行简单的回收处理。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * 用来给外界提供byte[]作为缓冲区的一个工具类</div><div class=\"line\"> */</div><div class=\"line\">public class ByteArrayPool &#123;</div><div class=\"line\">    /**</div><div class=\"line\">     * The buffer pool, arranged both by last use and by buffer size </div><div class=\"line\">     */</div><div class=\"line\">    private List&lt;byte[]&gt; mBuffersByLastUse = new LinkedList&lt;byte[]&gt;();</div><div class=\"line\">    private List&lt;byte[]&gt; mBuffersBySize = new ArrayList&lt;byte[]&gt;(64);</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * The total size of the buffers in the pool</div><div class=\"line\">     * 缓冲池的当前大小</div><div class=\"line\">     */</div><div class=\"line\">    private int mCurrentSize = 0;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * The maximum aggregate size of the buffers in the pool. Old buffers are discarded to stay</div><div class=\"line\">     * under this limit.</div><div class=\"line\">     * 缓冲池当前的大小的阀值</div><div class=\"line\">     * 超过了该值则会对缓冲池进行回收处理</div><div class=\"line\">     */</div><div class=\"line\">    private final int mSizeLimit;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Compares buffers by size</div><div class=\"line\">     * 比较两个缓冲区的大小的规则</div><div class=\"line\">     * 如果返回一个负数，则表示前一个数要小</div><div class=\"line\">     * 如果返回0，则表示两个数字相等</div><div class=\"line\">     * 如果返回一个正数，则表示后一个数要小</div><div class=\"line\">     * </div><div class=\"line\">     */</div><div class=\"line\">    protected static final Comparator&lt;byte[]&gt; BUF_COMPARATOR = new Comparator&lt;byte[]&gt;() &#123;</div><div class=\"line\">        @Override</div><div class=\"line\">        public int compare(byte[] lhs, byte[] rhs) &#123;</div><div class=\"line\">            return lhs.length - rhs.length;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * @param sizeLimit the maximum size of the pool, in bytes</div><div class=\"line\">     * 用来修改缓冲池的大小阀值</div><div class=\"line\">     */</div><div class=\"line\">    public ByteArrayPool(int sizeLimit) &#123;</div><div class=\"line\">        mSizeLimit = sizeLimit;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Returns a buffer from the pool if one is available in the requested size, or allocates a new</div><div class=\"line\">     * one if a pooled one is not available.</div><div class=\"line\">     * 从mBuffersBySize中调出一个缓冲区来</div><div class=\"line\">     * 如果大小符合要求，则直接返回给调用者</div><div class=\"line\">     * 如果没有符合要求的，直接创建一个新的byte[]返回</div><div class=\"line\">     *</div><div class=\"line\">     * @param len the minimum size, in bytes, of the requested buffer. The returned buffer may be</div><div class=\"line\">     *        larger.</div><div class=\"line\">     * @return a byte[] buffer is always returned.</div><div class=\"line\">     */</div><div class=\"line\">    public synchronized byte[] getBuf(int len) &#123;</div><div class=\"line\">        for (int i = 0; i &lt; mBuffersBySize.size(); i++) &#123;</div><div class=\"line\">            byte[] buf = mBuffersBySize.get(i);</div><div class=\"line\">            if (buf.length &gt;= len) &#123;</div><div class=\"line\">                mCurrentSize -= buf.length;</div><div class=\"line\">                mBuffersBySize.remove(i);</div><div class=\"line\">                mBuffersByLastUse.remove(buf);</div><div class=\"line\">                return buf;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return new byte[len];</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Returns a buffer to the pool, throwing away old buffers if the pool would exceed its allotted</div><div class=\"line\">     * size.</div><div class=\"line\">     * </div><div class=\"line\">     * @param buf the buffer to return to the pool.</div><div class=\"line\">     */</div><div class=\"line\">    public synchronized void returnBuf(byte[] buf) &#123;</div><div class=\"line\"></div><div class=\"line\">        //如果buf为空或者超出了规定的大小，不管就行了，这种缓冲区用不着回收，因为= =根本就不符合要求嘛</div><div class=\"line\"></div><div class=\"line\">        if (buf == null || buf.length &gt; mSizeLimit) &#123;</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        //如果buf符合要求，则将其加入到最近使用的队列中去</div><div class=\"line\"></div><div class=\"line\">        mBuffersByLastUse.add(buf);</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * 通过二分查找，比较规则为BUF_COMPARATOR，找出新进来的buf应该处于的位置</div><div class=\"line\">         * 随后将buf插入到mBufferBySize的队列里面</div><div class=\"line\">         */</div><div class=\"line\">        int pos = Collections.binarySearch(mBuffersBySize, buf, BUF_COMPARATOR);</div><div class=\"line\">        if (pos &lt; 0) &#123;</div><div class=\"line\">            pos = -pos - 1;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        mBuffersBySize.add(pos, buf);</div><div class=\"line\"></div><div class=\"line\">        //当前总缓冲区大小变大</div><div class=\"line\">        mCurrentSize += buf.length;</div><div class=\"line\"></div><div class=\"line\">        //对整个缓冲池的大小做出调整</div><div class=\"line\">        trim();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Removes buffers from the pool until it is under its size limit.</div><div class=\"line\">     * 调整缓冲区的大小</div><div class=\"line\">     * 直到mCurrentSize在限制大小之下</div><div class=\"line\">     */</div><div class=\"line\">    private synchronized void trim() &#123;</div><div class=\"line\"></div><div class=\"line\">        while (mCurrentSize &gt; mSizeLimit) &#123;</div><div class=\"line\">            byte[] buf = mBuffersByLastUse.remove(0);</div><div class=\"line\">            mBuffersBySize.remove(buf);</div><div class=\"line\">            mCurrentSize -= buf.length;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"5-RetryPolicy-java\"><a href=\"#5-RetryPolicy-java\" class=\"headerlink\" title=\"5. RetryPolicy.java\"></a><a href=\"#5-_RetryPolicy-java\" title=\"5\\. RetryPolicy.java\"></a>5. RetryPolicy.java</h3><p>在BasicNetwork.java这个类中，通过死循环加上try,catch的方式，不停的对一个request进行重复的处理，里面涉及到了<code>RetryPolicy.java</code>接口以及其默认实现类，这个接口是用来专门处理一个request在发送以及得到服务器响应返回结果的过程中出现的问题。通过有限次数的不断扩大request响应时间阀值，再次发送request的方式来达到一个retry的目的。和<code>Network.java</code>类似的，<code>RetryPolicy.java</code>也仅仅就是提供了抽象方法，想把具体的实现内容弄明白还需要去默认实现类<code>DefaultRetryPolicy.java</code>中去。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">package com.android.volley;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\"> * Retry policy for a request.</div><div class=\"line\"> * 该类用来管理request的调整及重新发送</div><div class=\"line\"> * 所谓调整就是将request响应时间(timeout)放宽</div><div class=\"line\"> */</div><div class=\"line\">public interface RetryPolicy &#123;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Returns the current timeout (used for logging).</div><div class=\"line\">     */</div><div class=\"line\">    public int getCurrentTimeout();</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Returns the current retry count (used for logging).</div><div class=\"line\">     */</div><div class=\"line\">    public int getCurrentRetryCount();</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Prepares for the next retry by applying a backoff to the timeout.</div><div class=\"line\">     * 为下一次request做好准备，通过不停地来放宽timeout时间限制</div><div class=\"line\">     * 在DefaultRetryPolicy.java中好理解一些</div><div class=\"line\">     * </div><div class=\"line\">     * @param error The error code of the last attempt.</div><div class=\"line\">     * @throws VolleyError In the event that the retry could not be performed (for example if we</div><div class=\"line\">     * ran out of attempts), the passed in error is thrown.</div><div class=\"line\">     */</div><div class=\"line\">    public void retry(VolleyError error) throws VolleyError;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"6-DefaultRetryPolicy-java\"><a href=\"#6-DefaultRetryPolicy-java\" class=\"headerlink\" title=\"6. DefaultRetryPolicy.java\"></a><a href=\"#6-_DefaultRetryPolicy-java\" title=\"6\\. DefaultRetryPolicy.java\"></a>6. DefaultRetryPolicy.java</h3><p><code>DefaultRetryPolicy.java</code>描述了对待Volley中涉及Network的request的策略方针，可以理解为重试策略方针，也就是对那些在网络请求失败的request处理方法。里面包含了retry的最大次数(<code>mMaxNumRetries</code>)，当前请求次数(<code>mCurrentRetryCount</code>)以及请求超时的时间阀值(<code>mCurrentTimeoutMs</code>)等。每个Request里面都包含了一个<code>RetryPolicy.java</code>实现类，在处理的时候可以通过<code>getRetryPolicy()</code>方法获得。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div></pre></td><td class=\"code\"><pre><div class=\"line\">package com.android.volley;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\"> * Default retry policy for requests.</div><div class=\"line\"> */</div><div class=\"line\">public class DefaultRetryPolicy implements RetryPolicy &#123;</div><div class=\"line\">    /** </div><div class=\"line\">     * The current timeout in milliseconds. </div><div class=\"line\">     * 请求超时的时间数</div><div class=\"line\">     */</div><div class=\"line\">    private int mCurrentTimeoutMs;</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * The current retry count.</div><div class=\"line\">     * 当前请求的重试次数</div><div class=\"line\">     */</div><div class=\"line\">    private int mCurrentRetryCount;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * The maximum number of attempts. </div><div class=\"line\">     * 重复尝试的最大次数</div><div class=\"line\">     **/</div><div class=\"line\">    private final int mMaxNumRetries;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * The backoff multiplier for the policy.</div><div class=\"line\">     * 暂时不明白这个有什么用</div><div class=\"line\">     * 根据后面的来看好像是一个用于放宽timeout时间限制的系数</div><div class=\"line\">     * 这个系数越大每次retry的时候放宽的程度也就越大</div><div class=\"line\">     */</div><div class=\"line\">    private final float mBackoffMultiplier;</div><div class=\"line\"></div><div class=\"line\">    /** The default socket timeout in milliseconds */</div><div class=\"line\">    public static final int DEFAULT_TIMEOUT_MS = 2500;</div><div class=\"line\"></div><div class=\"line\">    /** The default number of retries */</div><div class=\"line\">    public static final int DEFAULT_MAX_RETRIES = 0;</div><div class=\"line\"></div><div class=\"line\">    /** The default backoff multiplier */</div><div class=\"line\">    public static final float DEFAULT_BACKOFF_MULT = 1f;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Constructs a new retry policy using the default timeouts.</div><div class=\"line\">     * 默认的构造器，2.5s的超时，</div><div class=\"line\">     * 最大重试数为0，也就是request请求超时了就不要再自动重试了</div><div class=\"line\">     */</div><div class=\"line\">    public DefaultRetryPolicy() &#123;</div><div class=\"line\">        this(DEFAULT_TIMEOUT_MS, DEFAULT_MAX_RETRIES, DEFAULT_BACKOFF_MULT);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Constructs a new retry policy.</div><div class=\"line\">     * @param initialTimeoutMs The initial timeout for the policy.</div><div class=\"line\">     * @param maxNumRetries The maximum number of retries.</div><div class=\"line\">     * @param backoffMultiplier Backoff multiplier for the policy.</div><div class=\"line\">     */</div><div class=\"line\">    public DefaultRetryPolicy(int initialTimeoutMs, int maxNumRetries, float backoffMultiplier) &#123;</div><div class=\"line\">        mCurrentTimeoutMs = initialTimeoutMs;</div><div class=\"line\">        mMaxNumRetries = maxNumRetries;</div><div class=\"line\">        mBackoffMultiplier = backoffMultiplier;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Returns the current timeout.</div><div class=\"line\">     */</div><div class=\"line\">    @Override</div><div class=\"line\">    public int getCurrentTimeout() &#123;</div><div class=\"line\">        return mCurrentTimeoutMs;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Returns the current retry count.</div><div class=\"line\">     */</div><div class=\"line\">    @Override</div><div class=\"line\">    public int getCurrentRetryCount() &#123;</div><div class=\"line\">        return mCurrentRetryCount;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Returns the backoff multiplier for the policy.</div><div class=\"line\">     */</div><div class=\"line\">    public float getBackoffMultiplier() &#123;</div><div class=\"line\">        return mBackoffMultiplier;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Prepares for the next retry by applying a backoff to the timeout.</div><div class=\"line\">     * 该方法定义在RetryPolicy.java中。</div><div class=\"line\">     * 为下一次重试request做准备，好像是通过延长服务器响应时间的限制 = =</div><div class=\"line\">     * 每次对timeout的时间限制都放宽了mBackoffMultiplier个单位。让服务器多一点时间去响应</div><div class=\"line\">     * </div><div class=\"line\">     * @param error The error code of the last attempt.</div><div class=\"line\">     * 最后一次request服务器给出的错误码</div><div class=\"line\">     */</div><div class=\"line\">    @Override</div><div class=\"line\">    public void retry(VolleyError error) throws VolleyError &#123;</div><div class=\"line\">        mCurrentRetryCount++;</div><div class=\"line\">        mCurrentTimeoutMs += (mCurrentTimeoutMs * mBackoffMultiplier);</div><div class=\"line\">        if (!hasAttemptRemaining()) &#123;</div><div class=\"line\">            throw error;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Returns true if this policy has attempts remaining, false otherwise.</div><div class=\"line\">     * 这个是用来判断是否还有retry机会的</div><div class=\"line\">     */</div><div class=\"line\">    protected boolean hasAttemptRemaining() &#123;</div><div class=\"line\">        return mCurrentRetryCount &lt;= mMaxNumRetries;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>到这里对<code>Network.java</code>接口以及<code>RetryPolicy.java</code>接口的代码就分析完了，现在是清楚了在<code>NetworkDispatcher.java</code>调用了<code>mNetwork.performRequest()</code>之后发生了什么事情，还弄清楚了request在网络请求发送之后，出现了各种问题会怎么处理(重试策略)，但还不知道最核心的网络请求是如何发生的，也就是在<code>BasicNetwork.java</code>中的下面这行代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">httpResponse = mHttpStack.performRequest(request, headers);</div></pre></td></tr></table></figure>\n<p>这行代码就涉及到了后面的<code>HttpStack.java</code>接口及其两个实现类了。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"Volley框架解析-四-—–Network接口及其默认实现类解析\"><a href=\"#Volley框架解析-四-—–Network接口及其默认实现类解析\" class=\"headerlink\" title=\"Volley框架解析(四)—–Network接口及其默认实现类解析\"></a>Volley框架解析(四)—–Network接口及其默认实现类解析</h2><h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h3><p>&#160;&#160;&#160;&#160;前面的三篇Volley框架解析文章已经从Volley对外暴露的接口Volley.java开始，向下慢慢深入到了RequestQueue.java，这个Volley中比较核心的类，然后又分析了Volley中负责主要request调度工作的两类Dispatcher，<code>NetworkDispatcher</code>以及<code>CacheDispatcher</code>。应该是将一个request从新建，到加入队列中等待处理，如何被处理以及返回结果或者error这一系列的流程理顺了。</p>\n<p>&#160;&#160;&#160;&#160;但是对于一些细节的问题还是不清楚，例如request究竟是如何发送出去，通过<code>NetworkResponse networkResponse = mNetwork.performRequest(request);</code>这么一句话就返回了结果(response)，这里面发生了些什么还不得而知，还有<code>Network#performRequest()</code>和<code>HttpStack#performRequest()</code>这两个函数之间有什么区别和联系等等。</p>","more":"<h3 id=\"2-Network-java\"><a href=\"#2-Network-java\" class=\"headerlink\" title=\"2. Network.java\"></a><a href=\"#2-_Network-java\" title=\"2\\. Network.java\"></a>2. Network.java</h3><p>&#160;&#160;&#160;&#160;最早接触到Network这个类是在<code>Volley.java</code>中的<code>newRequestQueue()</code>函数里面，<code>Network network = new BasicNetwork(stack);</code>创建了一个Network接口引用，并指向了一个Volley中的默认实现类的实例<code>BasicNetwork.java</code>，这个默认实现类也会在这篇博客的后面详细的解析。</p>\n<p>&#160;&#160;&#160;&#160;经过前面几篇博客的分析，<code>Volley.java</code>仅仅是持有而没有使用，仅将这个引用传递给了<code>NetworkDispatcher.java</code>中，只有在<code>NetworkDispatcher.java</code>类中用到了这个Network接口，在<code>NetowkrDispatcher.java</code>中存在着这么一行代码，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">NetworkResponse networkResponse = mNetwork.performRequest(request);</div></pre></td></tr></table></figure>\n<p>&#160;&#160;&#160;&#160;仅仅用了一句话就将request发送出去了，并且还拿回来了一个<code>NetworkResponse.java</code>类对象。里面发生了什么= =，先进去Network.java里面看看：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">package com.android.volley;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\"> * An interface for performing requests.</div><div class=\"line\"> */</div><div class=\"line\">public interface Network &#123;</div><div class=\"line\">    /**</div><div class=\"line\">     * Performs the specified request.</div><div class=\"line\">     * 用来发送特定的请求</div><div class=\"line\">     *</div><div class=\"line\">     * @param request Request to process</div><div class=\"line\">     * 即将被发送的request</div><div class=\"line\">     *</div><div class=\"line\">     * @return A &#123;@link NetworkResponse&#125; with data and caching metadata; will never be null</div><div class=\"line\">     * 请求之后返回的response, 是volley自己构造出来的一个response</div><div class=\"line\">     * 里面包含了返回的请求码等等。</div><div class=\"line\">     *</div><div class=\"line\">     * @throws VolleyError on errors</div><div class=\"line\">     */</div><div class=\"line\">    public NetworkResponse performRequest(Request&lt;?&gt; request) throws VolleyError;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>对，没有看错= =，就这么点东西，仅仅一个抽象方法而已，Network.java就是一个等待被实现的接口，想看真东西，还需要进去<code>Network network = new BasicNetwork(stack);</code>里面所提到的<code>BasicNetwork.java</code>看看。</p>\n<h3 id=\"3-BasicNetwork-java\"><a href=\"#3-BasicNetwork-java\" class=\"headerlink\" title=\"3. BasicNetwork.java\"></a><a href=\"#3-_BasicNetwork-java\" title=\"3\\. BasicNetwork.java\"></a>3. BasicNetwork.java</h3><p><code>Network.java</code>接口的默认实现类，该类里面会处理一些request发送前后的处理工作，主要是对请求返回的httpResponse处理，以及对请求失败进行retry或者抛出异常的处理。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div><div class=\"line\">204</div><div class=\"line\">205</div><div class=\"line\">206</div><div class=\"line\">207</div><div class=\"line\">208</div><div class=\"line\">209</div><div class=\"line\">210</div><div class=\"line\">211</div><div class=\"line\">212</div><div class=\"line\">213</div><div class=\"line\">214</div><div class=\"line\">215</div><div class=\"line\">216</div><div class=\"line\">217</div><div class=\"line\">218</div><div class=\"line\">219</div><div class=\"line\">220</div><div class=\"line\">221</div><div class=\"line\">222</div><div class=\"line\">223</div><div class=\"line\">224</div><div class=\"line\">225</div><div class=\"line\">226</div><div class=\"line\">227</div><div class=\"line\">228</div><div class=\"line\">229</div><div class=\"line\">230</div><div class=\"line\">231</div><div class=\"line\">232</div><div class=\"line\">233</div><div class=\"line\">234</div><div class=\"line\">235</div><div class=\"line\">236</div><div class=\"line\">237</div><div class=\"line\">238</div><div class=\"line\">239</div><div class=\"line\">240</div><div class=\"line\">241</div><div class=\"line\">242</div><div class=\"line\">243</div><div class=\"line\">244</div><div class=\"line\">245</div><div class=\"line\">246</div><div class=\"line\">247</div><div class=\"line\">248</div><div class=\"line\">249</div><div class=\"line\">250</div><div class=\"line\">251</div><div class=\"line\">252</div><div class=\"line\">253</div><div class=\"line\">254</div><div class=\"line\">255</div><div class=\"line\">256</div><div class=\"line\">257</div><div class=\"line\">258</div><div class=\"line\">259</div><div class=\"line\">260</div><div class=\"line\">261</div><div class=\"line\">262</div><div class=\"line\">263</div><div class=\"line\">264</div><div class=\"line\">265</div><div class=\"line\">266</div><div class=\"line\">267</div><div class=\"line\">268</div><div class=\"line\">269</div><div class=\"line\">270</div><div class=\"line\">271</div><div class=\"line\">272</div><div class=\"line\">273</div><div class=\"line\">274</div><div class=\"line\">275</div><div class=\"line\">276</div><div class=\"line\">277</div><div class=\"line\">278</div><div class=\"line\">279</div><div class=\"line\">280</div><div class=\"line\">281</div><div class=\"line\">282</div><div class=\"line\">283</div><div class=\"line\">284</div><div class=\"line\">285</div><div class=\"line\">286</div><div class=\"line\">287</div><div class=\"line\">288</div><div class=\"line\">289</div><div class=\"line\">290</div><div class=\"line\">291</div><div class=\"line\">292</div><div class=\"line\">293</div><div class=\"line\">294</div><div class=\"line\">295</div><div class=\"line\">296</div><div class=\"line\">297</div><div class=\"line\">298</div><div class=\"line\">299</div><div class=\"line\">300</div><div class=\"line\">301</div><div class=\"line\">302</div><div class=\"line\">303</div><div class=\"line\">304</div><div class=\"line\">305</div><div class=\"line\">306</div><div class=\"line\">307</div><div class=\"line\">308</div><div class=\"line\">309</div><div class=\"line\">310</div><div class=\"line\">311</div><div class=\"line\">312</div><div class=\"line\">313</div><div class=\"line\">314</div><div class=\"line\">315</div><div class=\"line\">316</div><div class=\"line\">317</div><div class=\"line\">318</div><div class=\"line\">319</div><div class=\"line\">320</div><div class=\"line\">321</div><div class=\"line\">322</div><div class=\"line\">323</div><div class=\"line\">324</div><div class=\"line\">325</div><div class=\"line\">326</div><div class=\"line\">327</div><div class=\"line\">328</div><div class=\"line\">329</div><div class=\"line\">330</div><div class=\"line\">331</div><div class=\"line\">332</div><div class=\"line\">333</div><div class=\"line\">334</div><div class=\"line\">335</div><div class=\"line\">336</div><div class=\"line\">337</div><div class=\"line\">338</div><div class=\"line\">339</div><div class=\"line\">340</div><div class=\"line\">341</div><div class=\"line\">342</div><div class=\"line\">343</div><div class=\"line\">344</div><div class=\"line\">345</div><div class=\"line\">346</div><div class=\"line\">347</div><div class=\"line\">348</div><div class=\"line\">349</div><div class=\"line\">350</div><div class=\"line\">351</div><div class=\"line\">352</div><div class=\"line\">353</div><div class=\"line\">354</div><div class=\"line\">355</div><div class=\"line\">356</div><div class=\"line\">357</div><div class=\"line\">358</div><div class=\"line\">359</div><div class=\"line\">360</div><div class=\"line\">361</div><div class=\"line\">362</div><div class=\"line\">363</div><div class=\"line\">364</div><div class=\"line\">365</div><div class=\"line\">366</div><div class=\"line\">367</div><div class=\"line\">368</div><div class=\"line\">369</div><div class=\"line\">370</div><div class=\"line\">371</div><div class=\"line\">372</div><div class=\"line\">373</div><div class=\"line\">374</div><div class=\"line\">375</div><div class=\"line\">376</div><div class=\"line\">377</div><div class=\"line\">378</div><div class=\"line\">379</div><div class=\"line\">380</div><div class=\"line\">381</div><div class=\"line\">382</div><div class=\"line\">383</div><div class=\"line\">384</div><div class=\"line\">385</div><div class=\"line\">386</div><div class=\"line\">387</div><div class=\"line\">388</div><div class=\"line\">389</div><div class=\"line\">390</div><div class=\"line\">391</div><div class=\"line\">392</div><div class=\"line\">393</div><div class=\"line\">394</div><div class=\"line\">395</div><div class=\"line\">396</div><div class=\"line\">397</div><div class=\"line\">398</div><div class=\"line\">399</div><div class=\"line\">400</div><div class=\"line\">401</div><div class=\"line\">402</div><div class=\"line\">403</div><div class=\"line\">404</div><div class=\"line\">405</div><div class=\"line\">406</div><div class=\"line\">407</div><div class=\"line\">408</div><div class=\"line\">409</div><div class=\"line\">410</div><div class=\"line\">411</div><div class=\"line\">412</div><div class=\"line\">413</div><div class=\"line\">414</div><div class=\"line\">415</div><div class=\"line\">416</div><div class=\"line\">417</div><div class=\"line\">418</div><div class=\"line\">419</div><div class=\"line\">420</div><div class=\"line\">421</div><div class=\"line\">422</div><div class=\"line\">423</div><div class=\"line\">424</div></pre></td><td class=\"code\"><pre><div class=\"line\">package com.android.volley.toolbox;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\"> * A network performing Volley requests over an &#123;@link HttpStack&#125;.</div><div class=\"line\"> * 一个用来执行Volley中request的类</div><div class=\"line\"> * 在HttpStack的基础之上</div><div class=\"line\"> * 因为主要还是调用HttpStack接口的performRequest</div><div class=\"line\"> * 在这个里面的performRequest主要还是做一些整理工作</div><div class=\"line\"> * 比如将｛@link HttpStack#performRequest()｝方法返回的HttpResponse</div><div class=\"line\"> * 解析成Volley自己实现的NetworkResponse.java</div><div class=\"line\"> */</div><div class=\"line\"></div><div class=\"line\">public class BasicNetwork implements Network &#123;</div><div class=\"line\"></div><div class=\"line\">    //是否允许打lo的boolean常变量</div><div class=\"line\">    protected static final boolean DEBUG = VolleyLog.DEBUG;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * 这是一个阀值，用来判断一个request是否请求响应过慢了= =</div><div class=\"line\">     * 在后面的作用就是，如果响应时间超过了这个阀值</div><div class=\"line\">     * 打出log说明这个request有些慢，为了更好的反应request当前状态</div><div class=\"line\">     */</div><div class=\"line\">    private static int SLOW_REQUEST_THRESHOLD_MS = 3000;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * 默认ByteArrayPool的大小</div><div class=\"line\">     * 现在只需要知道ByteArrayPool.java是Volley用来从输入流中读取数据并将其转换成字节数组的工具即可</div><div class=\"line\">     * 在这篇博客后面会介绍，表担心~= =</div><div class=\"line\">     */</div><div class=\"line\">    private static int DEFAULT_POOL_SIZE = 4096;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * 网络请求的真正接口</div><div class=\"line\">     * 为什么这么说咧，BasicNetwork里面的performRequest()函数</div><div class=\"line\">     * 调用了HttpStack里的performRequest()，真正的网络请求还是通过HttpStack里面的方法实现的</div><div class=\"line\">     * 在Volley中实现了HttpStack接口的类有两个 HurlStack.java和HttpClientStack.java</div><div class=\"line\">     * 针对了不同Android系统版本，用不同的方法实现了请求。</div><div class=\"line\">     */</div><div class=\"line\">    protected final HttpStack mHttpStack;</div><div class=\"line\"></div><div class=\"line\">    //表急，后面会介绍到的，现在知道是一个用于数据转换的工具类就好了</div><div class=\"line\">    protected final ByteArrayPool mPool;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * @param httpStack HTTP stack to be used</div><div class=\"line\">     * 传入的HttpStack实现类引用</div><div class=\"line\">     * 整个网络请求的较核心部分就在HttpStack实现类上面咯</div><div class=\"line\">     */</div><div class=\"line\">    public BasicNetwork(HttpStack httpStack) &#123;</div><div class=\"line\">        // If a pool isn&apos;t passed in, then build a small default pool that will give us a lot of</div><div class=\"line\">        // benefit and not use too much memory.</div><div class=\"line\">        this(httpStack, new ByteArrayPool(DEFAULT_POOL_SIZE));</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * @param httpStack HTTP stack to be used</div><div class=\"line\">     * @param pool a buffer pool that improves GC performance in copy operations</div><div class=\"line\">     * Volley接口分离的很明显，而且在构造函数里面也提供了很多种</div><div class=\"line\">     * 可以定制出适合自己的ByteArrayPool衍生类</div><div class=\"line\">     * 当然也可以自己来实现HttpStack的衍生类</div><div class=\"line\">     */</div><div class=\"line\">    public BasicNetwork(HttpStack httpStack, ByteArrayPool pool) &#123;</div><div class=\"line\">        mHttpStack = httpStack;</div><div class=\"line\">        mPool = pool;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * 这个方法重写的是Network的方法</div><div class=\"line\">     * 在这个里面再调用HttpStack里面的performRequest方法</div><div class=\"line\">     */</div><div class=\"line\">    @Override</div><div class=\"line\">    public NetworkResponse performRequest(Request&lt;?&gt; request) throws VolleyError &#123;</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * Returns milliseconds since boot, including time spent in sleep.</div><div class=\"line\">         * 为了方便计算每个request所用的时间</div><div class=\"line\">         * 在处理每个request之前都记下此刻unix时间戳</div><div class=\"line\">         */</div><div class=\"line\">        long requestStart = SystemClock.elapsedRealtime();</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * 进入死循环= =</div><div class=\"line\">         * 还没弄清楚为什么要死循环</div><div class=\"line\">         */</div><div class=\"line\">        while (true) &#123;</div><div class=\"line\"></div><div class=\"line\">            /**</div><div class=\"line\">             * 指向HttpResponse实例的引用</div><div class=\"line\">             * 是调用HttpStack方法performRequest()之后返回的结果</div><div class=\"line\">             */</div><div class=\"line\">            HttpResponse httpResponse = null;</div><div class=\"line\"></div><div class=\"line\">            /**</div><div class=\"line\">             * 返回的HttpResponse还需要经过处理</div><div class=\"line\">             * 并不是返回回来就是能直接使用的数据</div><div class=\"line\">             * 需要通过上面的ByteArrayPool将Entity转换成byte[]</div><div class=\"line\">             * 这个就是指向解析后的byte[]的</div><div class=\"line\">             */</div><div class=\"line\">            byte[] responseContents = null;</div><div class=\"line\"></div><div class=\"line\">            //用来存放response里面header的信息，包含了状态码等</div><div class=\"line\">            Map&lt;String, String&gt; responseHeaders = Collections.emptyMap();</div><div class=\"line\"></div><div class=\"line\">            try &#123;</div><div class=\"line\">                /**</div><div class=\"line\">                 * Gather headers.</div><div class=\"line\">                 * 设置header</div><div class=\"line\">                 * 从缓存中收集上次相同request的信息</div><div class=\"line\">                 */</div><div class=\"line\">                Map&lt;String, String&gt; headers = new HashMap&lt;String, String&gt;();</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * 将缓存的信息加入到headers中</div><div class=\"line\">                 * headers会跟随request一起发送给服务器</div><div class=\"line\">                 * 在函数的定义处会讲解</div><div class=\"line\">                 */</div><div class=\"line\">                addCacheHeaders(headers, request.getCacheEntry());</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * 通过调用HttpStack接口的performRequest()方法</div><div class=\"line\">                 * 获取服务器返回的HttpResponse</div><div class=\"line\">                 */</div><div class=\"line\">                httpResponse = mHttpStack.performRequest(request, headers);</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * The first line of a Response message is the Status-Line, </div><div class=\"line\">                 * consisting of the protocol version followed by a numeric status code and its associated textual phrase</div><div class=\"line\">                 * with each element separated by SP characters. </div><div class=\"line\">                 * No CR or LF is allowed except in the final CRLF sequence.</div><div class=\"line\">                 * 请求返回的response第一行就是包含了状态码的一行</div><div class=\"line\">                 */</div><div class=\"line\">                StatusLine statusLine = httpResponse.getStatusLine();</div><div class=\"line\">                int statusCode = statusLine.getStatusCode();</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * 将头部解析成键值对的形式再返回</div><div class=\"line\">                 */</div><div class=\"line\">                responseHeaders = convertHeaders(httpResponse.getAllHeaders());</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * Handle cache validation.</div><div class=\"line\">                 * 处理缓存信息</div><div class=\"line\">                 * 如果返回的状态码是304(HttpStatus.SC_NOT_MODIFIED)</div><div class=\"line\">                 * 则进行如下的处理</div><div class=\"line\">                 */</div><div class=\"line\">                if (statusCode == HttpStatus.SC_NOT_MODIFIED) &#123;</div><div class=\"line\"></div><div class=\"line\">                    /**</div><div class=\"line\">                     * 如果缓存为空的话</div><div class=\"line\">                     * 那就说明该请求的返回的response的body就是null</div><div class=\"line\">                     * 直接构造一个NetworkResponse返回</div><div class=\"line\">                     */</div><div class=\"line\">                    Entry entry = request.getCacheEntry();</div><div class=\"line\">                    if (entry == null) &#123;</div><div class=\"line\">                        return new NetworkResponse(HttpStatus.SC_NOT_MODIFIED, null,</div><div class=\"line\">                                responseHeaders, true,</div><div class=\"line\">                                SystemClock.elapsedRealtime() - requestStart);</div><div class=\"line\">                    &#125;</div><div class=\"line\"></div><div class=\"line\">                    // A HTTP 304 response does not have all header fields. We</div><div class=\"line\">                    // have to use the header fields from the cache entry plus</div><div class=\"line\">                    // the new ones from the response.</div><div class=\"line\">                    // http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.5</div><div class=\"line\">                    /**</div><div class=\"line\">                     * 一个返回码为304的HttpResponse的header缺少一些信息</div><div class=\"line\">                     * 需要我们将cache中的一些header信息加入到其中</div><div class=\"line\">                     * 这样组成一个完整的NetworkResponse返回</div><div class=\"line\">                     */</div><div class=\"line\">                    entry.responseHeaders.putAll(responseHeaders);</div><div class=\"line\">                    return new NetworkResponse(HttpStatus.SC_NOT_MODIFIED, entry.data,</div><div class=\"line\">                            entry.responseHeaders, true,</div><div class=\"line\">                            SystemClock.elapsedRealtime() - requestStart);</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * Handle moved resources</div><div class=\"line\">                 * 处理了重定向的问题</div><div class=\"line\">                 * 并将request的mRedirectUrl设定成了新的url</div><div class=\"line\">                 */</div><div class=\"line\">                if (statusCode == HttpStatus.SC_MOVED_PERMANENTLY || statusCode == HttpStatus.SC_MOVED_TEMPORARILY) &#123;</div><div class=\"line\">                    String newUrl = responseHeaders.get(&quot;Location&quot;);</div><div class=\"line\">                    request.setRedirectUrl(newUrl);</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * Some responses such as 204s do not have content.  We must check.</div><div class=\"line\">                 * 204(无内容)服务器成功处理了请求，但没有返回任何内容。</div><div class=\"line\">                 * </div><div class=\"line\">                 */</div><div class=\"line\">                if (httpResponse.getEntity() != null) &#123;</div><div class=\"line\">                    /**</div><div class=\"line\">                     * 如果entity不为Null</div><div class=\"line\">                     * 将其转换成byte数组</div><div class=\"line\">                     * 利用之前提到过的ByteArrayPool.java类</div><div class=\"line\">                     */</div><div class=\"line\">                  responseContents = entityToBytes(httpResponse.getEntity());</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                  // Add 0 byte response as a way of honestly representing a</div><div class=\"line\">                  // no-content request.</div><div class=\"line\">                  responseContents = new byte[0];</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * if the request is slow, log it.</div><div class=\"line\">                 * 获取request已经占用的时间(requestLifetime)</div><div class=\"line\">                 * 判断是否需要打出request的超时状态</div><div class=\"line\">                 */</div><div class=\"line\">                long requestLifetime = SystemClock.elapsedRealtime() - requestStart;</div><div class=\"line\">                logSlowRequests(requestLifetime, request, responseContents, statusLine);</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * 如果状态码位于200之下或者是299之上(200-299 用于表示请求成功)</div><div class=\"line\">                 * 则抛出IOException异常= =为什么非要抛出这个异常</div><div class=\"line\">                 * 在前面过滤掉了(304等情况)</div><div class=\"line\">                 */</div><div class=\"line\">                if (statusCode &lt; 200 || statusCode &gt; 299) &#123;</div><div class=\"line\">                    throw new IOException();</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * 经过上面的层层过滤</div><div class=\"line\">                 * 最后留下了200~299之间的请求成功response</div><div class=\"line\">                 * 通过HttpResponse里面的信息构造出一个volley自己封装的NetworkResponse对象</div><div class=\"line\">                 */</div><div class=\"line\">                return new NetworkResponse(statusCode, responseContents, responseHeaders, false,</div><div class=\"line\">                        SystemClock.elapsedRealtime() - requestStart);</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * 抛出了异常之后，会用attemptREtryOnException()方法来尝试retry</div><div class=\"line\">                 * 主要做的工作就是看是否还有retry的机会，如果有则不停通过这个死循环</div><div class=\"line\">                 * 进行请求，直到请求成功或者请求的机会用完为止</div><div class=\"line\">                 */</div><div class=\"line\">            &#125; catch (SocketTimeoutException e) &#123;</div><div class=\"line\">                attemptRetryOnException(&quot;socket&quot;, request, new TimeoutError());</div><div class=\"line\">            &#125; catch (ConnectTimeoutException e) &#123;·</div><div class=\"line\">                attemptRetryOnException(&quot;connection&quot;, request, new TimeoutError());</div><div class=\"line\">            &#125; catch (MalformedURLException e) &#123;</div><div class=\"line\">                throw new RuntimeException(&quot;Bad URL &quot; + request.getUrl(), e);</div><div class=\"line\">            &#125; catch (IOException e) &#123;</div><div class=\"line\">                /**</div><div class=\"line\">                 * 状态码在0~200以及299之上的response</div><div class=\"line\">                 * 处理的套路</div><div class=\"line\">                 */</div><div class=\"line\">                int statusCode = 0;</div><div class=\"line\">                NetworkResponse networkResponse = null;</div><div class=\"line\">                if (httpResponse != null) &#123;</div><div class=\"line\">                    statusCode = httpResponse.getStatusLine().getStatusCode();</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    //如果状态码为0，则抛出NoConnectionError</div><div class=\"line\">                    throw new NoConnectionError(e);</div><div class=\"line\">                &#125;</div><div class=\"line\">                /**</div><div class=\"line\">                 * 如果有重定向的情况发生</div><div class=\"line\">                 * 用log打出</div><div class=\"line\">                 */</div><div class=\"line\">                if (statusCode == HttpStatus.SC_MOVED_PERMANENTLY || </div><div class=\"line\">                        statusCode == HttpStatus.SC_MOVED_TEMPORARILY) &#123;</div><div class=\"line\">                    VolleyLog.e(&quot;Request at %s has been redirected to %s&quot;, request.getOriginUrl(), request.getUrl());</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    VolleyLog.e(&quot;Unexpected response code %d for %s&quot;, statusCode, request.getUrl());</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                /**</div><div class=\"line\">                 * 如果返回的content内容不为Null</div><div class=\"line\">                 * 则构造出一个NetworkResponse</div><div class=\"line\">                 * 否则抛出NetworkError</div><div class=\"line\">                 */</div><div class=\"line\">                if (responseContents != null) &#123;</div><div class=\"line\"></div><div class=\"line\">                    networkResponse = new NetworkResponse(statusCode, responseContents,</div><div class=\"line\">                            responseHeaders, false, SystemClock.elapsedRealtime() - requestStart);</div><div class=\"line\"></div><div class=\"line\">                    /**</div><div class=\"line\">                     * 抛出了异常之后，会用attemptREtryOnException()方法来尝试retry</div><div class=\"line\">                     * 主要做的工作就是看是否还有retry的机会，如果有则不停通过这个死循环</div><div class=\"line\">                     * 进行请求，直到请求成功或者请求的机会用完为止</div><div class=\"line\">                     */</div><div class=\"line\">                    if (statusCode == HttpStatus.SC_UNAUTHORIZED ||</div><div class=\"line\">                            statusCode == HttpStatus.SC_FORBIDDEN) &#123;</div><div class=\"line\">                        attemptRetryOnException(&quot;auth&quot;,</div><div class=\"line\">                                request, new AuthFailureError(networkResponse));</div><div class=\"line\">                    &#125; else if (statusCode == HttpStatus.SC_MOVED_PERMANENTLY || </div><div class=\"line\">                                statusCode == HttpStatus.SC_MOVED_TEMPORARILY) &#123;</div><div class=\"line\">                        attemptRetryOnException(&quot;redirect&quot;,</div><div class=\"line\">                                request, new AuthFailureError(networkResponse));</div><div class=\"line\">                    &#125; else &#123;</div><div class=\"line\">                        // TODO: Only throw ServerError for 5xx status codes.</div><div class=\"line\">                        throw new ServerError(networkResponse);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    throw new NetworkError(networkResponse);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Logs requests that took over SLOW_REQUEST_THRESHOLD_MS to complete.</div><div class=\"line\">     * 如果request用时超出了预先设定的阀值</div><div class=\"line\">     * 则打出log用于debug时候的提示</div><div class=\"line\">     */</div><div class=\"line\">    private void logSlowRequests(long requestLifetime, Request&lt;?&gt; request,</div><div class=\"line\">            byte[] responseContents, StatusLine statusLine) &#123;</div><div class=\"line\">        if (DEBUG || requestLifetime &gt; SLOW_REQUEST_THRESHOLD_MS) &#123;</div><div class=\"line\">            VolleyLog.d(&quot;HTTP response for request=&lt;%s&gt; [lifetime=%d], [size=%s], &quot; +</div><div class=\"line\">                    &quot;[rc=%d], [retryCount=%s]&quot;, request, requestLifetime,</div><div class=\"line\">                    responseContents != null ? responseContents.length : &quot;null&quot;,</div><div class=\"line\">                    statusLine.getStatusCode(), request.getRetryPolicy().getCurrentRetryCount());</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Attempts to prepare the request for a retry. If there are no more attempts remaining in the</div><div class=\"line\">     * request&apos;s retry policy, a timeout exception is thrown.</div><div class=\"line\">     * 每次尝试都会使retry机会减少1，如果机会没有了，则抛出请求超时的exception</div><div class=\"line\">     *</div><div class=\"line\">     * @param request The request to use.</div><div class=\"line\">     */</div><div class=\"line\">    private static void attemptRetryOnException(String logPrefix, Request&lt;?&gt; request,</div><div class=\"line\">            VolleyError exception) throws VolleyError &#123;</div><div class=\"line\">        RetryPolicy retryPolicy = request.getRetryPolicy();</div><div class=\"line\">        int oldTimeout = request.getTimeoutMs();</div><div class=\"line\"></div><div class=\"line\">        try &#123;</div><div class=\"line\">            retryPolicy.retry(exception);</div><div class=\"line\">        &#125; catch (VolleyError e) &#123;</div><div class=\"line\">            request.addMarker(</div><div class=\"line\">                    String.format(&quot;%s-timeout-giveup [timeout=%s]&quot;, logPrefix, oldTimeout));</div><div class=\"line\">            throw e;</div><div class=\"line\">        &#125;</div><div class=\"line\">        request.addMarker(String.format(&quot;%s-retry [timeout=%s]&quot;, logPrefix, oldTimeout));</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * 添加上缓存的header</div><div class=\"line\">     * 如果有之前的缓存的信息</div><div class=\"line\">     * 将里面的信息取出放入header中</div><div class=\"line\">     * </div><div class=\"line\">     * 这里面涉及到了一个条件请求</div><div class=\"line\">     * 如果有缓存的话，header上面会带上一个If-Modified-Since关键字</div><div class=\"line\">     * 服务器会先比较信息modified的时间，如果服务端的数据没有发生变化就返回304(也就是上面的 HttpStatus.SC_NOT_MODIFIED)</div><div class=\"line\">     * 如果服务器的数据发生了变化，则会返回状态码200以及请求需要的数据(意思就是本地的数据需要刷新了，缓存不管用了)</div><div class=\"line\">     */</div><div class=\"line\">    private void addCacheHeaders(Map&lt;String, String&gt; headers, Cache.Entry entry) &#123;</div><div class=\"line\">        // If there&apos;s no cache entry, we&apos;re done.</div><div class=\"line\">        if (entry == null) &#123;</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (entry.etag != null) &#123;</div><div class=\"line\">            headers.put(&quot;If-None-Match&quot;, entry.etag);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (entry.lastModified &gt; 0) &#123;</div><div class=\"line\">            Date refTime = new Date(entry.lastModified);</div><div class=\"line\">            headers.put(&quot;If-Modified-Since&quot;, DateUtils.formatDate(refTime));</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    protected void logError(String what, String url, long start) &#123;</div><div class=\"line\">        long now = SystemClock.elapsedRealtime();</div><div class=\"line\">        VolleyLog.v(&quot;HTTP ERROR(%s) %d ms to fetch %s&quot;, what, (now - start), url);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * Reads the contents of HttpEntity into a byte[].</div><div class=\"line\">     * 从HttpEntity中读取数据，并通过ByteArrayPool将其转换成byte[]</div><div class=\"line\">     * 暂时不用管太多= =，等后面介绍到ByteArrayPool.java的时候就会明白</div><div class=\"line\">     */</div><div class=\"line\">    private byte[] entityToBytes(HttpEntity entity) throws IOException, ServerError &#123;</div><div class=\"line\"></div><div class=\"line\">        PoolingByteArrayOutputStream bytes =</div><div class=\"line\">                new PoolingByteArrayOutputStream(mPool, (int) entity.getContentLength());</div><div class=\"line\"></div><div class=\"line\">        byte[] buffer = null;</div><div class=\"line\"></div><div class=\"line\">        try &#123;</div><div class=\"line\">            InputStream in = entity.getContent();</div><div class=\"line\">            if (in == null) &#123;</div><div class=\"line\">                throw new ServerError();</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            /**</div><div class=\"line\">             * 获取一个大小为1024的缓冲区</div><div class=\"line\">             */</div><div class=\"line\">            buffer = mPool.getBuf(1024);</div><div class=\"line\"></div><div class=\"line\">            int count;</div><div class=\"line\">            //将content的内容通过流每次最大读出1024个byte, 全部读出并写入bytes</div><div class=\"line\">            while ((count = in.read(buffer)) != -1) &#123;</div><div class=\"line\">                bytes.write(buffer, 0, count);</div><div class=\"line\">            &#125;</div><div class=\"line\">            return bytes.toByteArray();</div><div class=\"line\">        &#125; finally &#123;</div><div class=\"line\">            try &#123;</div><div class=\"line\">                // Close the InputStream and release the resources by &quot;consuming the content&quot;.</div><div class=\"line\">                entity.consumeContent();</div><div class=\"line\">            &#125; catch (IOException e) &#123;</div><div class=\"line\">                // This can happen if there was an exception above that left the entity in</div><div class=\"line\">                // an invalid state.</div><div class=\"line\">                VolleyLog.v(&quot;Error occured when calling consumingContent&quot;);</div><div class=\"line\">            &#125;</div><div class=\"line\">            /**</div><div class=\"line\">             * 在所有工作完成之后</div><div class=\"line\">             * 需要将从mPool中拿出的buffer缓冲区回收</div><div class=\"line\">             */</div><div class=\"line\">            mPool.returnBuf(buffer);</div><div class=\"line\">            bytes.close();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Converts Headers[] to Map&lt;String, String&gt;.</div><div class=\"line\">     * 将返回的response里面的header[]</div><div class=\"line\">     * 全部转换成Map里面的键值对形式</div><div class=\"line\">     */</div><div class=\"line\">    protected static Map&lt;String, String&gt; convertHeaders(Header[] headers) &#123;</div><div class=\"line\">        Map&lt;String, String&gt; result = new TreeMap&lt;String, String&gt;(String.CASE_INSENSITIVE_ORDER);</div><div class=\"line\">        for (int i = 0; i &lt; headers.length; i++) &#123;</div><div class=\"line\">            result.put(headers[i].getName(), headers[i].getValue());</div><div class=\"line\">        &#125;</div><div class=\"line\">        return result;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"4-ByteArrayPool-java\"><a href=\"#4-ByteArrayPool-java\" class=\"headerlink\" title=\"4. ByteArrayPool.java\"></a><a href=\"#4-_ByteArrayPool-java\" title=\"4\\. ByteArrayPool.java\"></a>4. ByteArrayPool.java</h3><p>ByteArrayPool.java是用来将HttpResponse中Entity通过stream的形式转换成byte[],主要的作用是提供缓冲区，用来辅助流数据的读取，在使用完成之后需要将使用过的缓冲区还给ByteArrayPool，ByteArrayPool里会对这些byte[]进行简单的回收处理。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * 用来给外界提供byte[]作为缓冲区的一个工具类</div><div class=\"line\"> */</div><div class=\"line\">public class ByteArrayPool &#123;</div><div class=\"line\">    /**</div><div class=\"line\">     * The buffer pool, arranged both by last use and by buffer size </div><div class=\"line\">     */</div><div class=\"line\">    private List&lt;byte[]&gt; mBuffersByLastUse = new LinkedList&lt;byte[]&gt;();</div><div class=\"line\">    private List&lt;byte[]&gt; mBuffersBySize = new ArrayList&lt;byte[]&gt;(64);</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * The total size of the buffers in the pool</div><div class=\"line\">     * 缓冲池的当前大小</div><div class=\"line\">     */</div><div class=\"line\">    private int mCurrentSize = 0;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * The maximum aggregate size of the buffers in the pool. Old buffers are discarded to stay</div><div class=\"line\">     * under this limit.</div><div class=\"line\">     * 缓冲池当前的大小的阀值</div><div class=\"line\">     * 超过了该值则会对缓冲池进行回收处理</div><div class=\"line\">     */</div><div class=\"line\">    private final int mSizeLimit;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Compares buffers by size</div><div class=\"line\">     * 比较两个缓冲区的大小的规则</div><div class=\"line\">     * 如果返回一个负数，则表示前一个数要小</div><div class=\"line\">     * 如果返回0，则表示两个数字相等</div><div class=\"line\">     * 如果返回一个正数，则表示后一个数要小</div><div class=\"line\">     * </div><div class=\"line\">     */</div><div class=\"line\">    protected static final Comparator&lt;byte[]&gt; BUF_COMPARATOR = new Comparator&lt;byte[]&gt;() &#123;</div><div class=\"line\">        @Override</div><div class=\"line\">        public int compare(byte[] lhs, byte[] rhs) &#123;</div><div class=\"line\">            return lhs.length - rhs.length;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * @param sizeLimit the maximum size of the pool, in bytes</div><div class=\"line\">     * 用来修改缓冲池的大小阀值</div><div class=\"line\">     */</div><div class=\"line\">    public ByteArrayPool(int sizeLimit) &#123;</div><div class=\"line\">        mSizeLimit = sizeLimit;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Returns a buffer from the pool if one is available in the requested size, or allocates a new</div><div class=\"line\">     * one if a pooled one is not available.</div><div class=\"line\">     * 从mBuffersBySize中调出一个缓冲区来</div><div class=\"line\">     * 如果大小符合要求，则直接返回给调用者</div><div class=\"line\">     * 如果没有符合要求的，直接创建一个新的byte[]返回</div><div class=\"line\">     *</div><div class=\"line\">     * @param len the minimum size, in bytes, of the requested buffer. The returned buffer may be</div><div class=\"line\">     *        larger.</div><div class=\"line\">     * @return a byte[] buffer is always returned.</div><div class=\"line\">     */</div><div class=\"line\">    public synchronized byte[] getBuf(int len) &#123;</div><div class=\"line\">        for (int i = 0; i &lt; mBuffersBySize.size(); i++) &#123;</div><div class=\"line\">            byte[] buf = mBuffersBySize.get(i);</div><div class=\"line\">            if (buf.length &gt;= len) &#123;</div><div class=\"line\">                mCurrentSize -= buf.length;</div><div class=\"line\">                mBuffersBySize.remove(i);</div><div class=\"line\">                mBuffersByLastUse.remove(buf);</div><div class=\"line\">                return buf;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return new byte[len];</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Returns a buffer to the pool, throwing away old buffers if the pool would exceed its allotted</div><div class=\"line\">     * size.</div><div class=\"line\">     * </div><div class=\"line\">     * @param buf the buffer to return to the pool.</div><div class=\"line\">     */</div><div class=\"line\">    public synchronized void returnBuf(byte[] buf) &#123;</div><div class=\"line\"></div><div class=\"line\">        //如果buf为空或者超出了规定的大小，不管就行了，这种缓冲区用不着回收，因为= =根本就不符合要求嘛</div><div class=\"line\"></div><div class=\"line\">        if (buf == null || buf.length &gt; mSizeLimit) &#123;</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        //如果buf符合要求，则将其加入到最近使用的队列中去</div><div class=\"line\"></div><div class=\"line\">        mBuffersByLastUse.add(buf);</div><div class=\"line\"></div><div class=\"line\">        /**</div><div class=\"line\">         * 通过二分查找，比较规则为BUF_COMPARATOR，找出新进来的buf应该处于的位置</div><div class=\"line\">         * 随后将buf插入到mBufferBySize的队列里面</div><div class=\"line\">         */</div><div class=\"line\">        int pos = Collections.binarySearch(mBuffersBySize, buf, BUF_COMPARATOR);</div><div class=\"line\">        if (pos &lt; 0) &#123;</div><div class=\"line\">            pos = -pos - 1;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        mBuffersBySize.add(pos, buf);</div><div class=\"line\"></div><div class=\"line\">        //当前总缓冲区大小变大</div><div class=\"line\">        mCurrentSize += buf.length;</div><div class=\"line\"></div><div class=\"line\">        //对整个缓冲池的大小做出调整</div><div class=\"line\">        trim();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Removes buffers from the pool until it is under its size limit.</div><div class=\"line\">     * 调整缓冲区的大小</div><div class=\"line\">     * 直到mCurrentSize在限制大小之下</div><div class=\"line\">     */</div><div class=\"line\">    private synchronized void trim() &#123;</div><div class=\"line\"></div><div class=\"line\">        while (mCurrentSize &gt; mSizeLimit) &#123;</div><div class=\"line\">            byte[] buf = mBuffersByLastUse.remove(0);</div><div class=\"line\">            mBuffersBySize.remove(buf);</div><div class=\"line\">            mCurrentSize -= buf.length;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"5-RetryPolicy-java\"><a href=\"#5-RetryPolicy-java\" class=\"headerlink\" title=\"5. RetryPolicy.java\"></a><a href=\"#5-_RetryPolicy-java\" title=\"5\\. RetryPolicy.java\"></a>5. RetryPolicy.java</h3><p>在BasicNetwork.java这个类中，通过死循环加上try,catch的方式，不停的对一个request进行重复的处理，里面涉及到了<code>RetryPolicy.java</code>接口以及其默认实现类，这个接口是用来专门处理一个request在发送以及得到服务器响应返回结果的过程中出现的问题。通过有限次数的不断扩大request响应时间阀值，再次发送request的方式来达到一个retry的目的。和<code>Network.java</code>类似的，<code>RetryPolicy.java</code>也仅仅就是提供了抽象方法，想把具体的实现内容弄明白还需要去默认实现类<code>DefaultRetryPolicy.java</code>中去。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">package com.android.volley;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\"> * Retry policy for a request.</div><div class=\"line\"> * 该类用来管理request的调整及重新发送</div><div class=\"line\"> * 所谓调整就是将request响应时间(timeout)放宽</div><div class=\"line\"> */</div><div class=\"line\">public interface RetryPolicy &#123;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Returns the current timeout (used for logging).</div><div class=\"line\">     */</div><div class=\"line\">    public int getCurrentTimeout();</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Returns the current retry count (used for logging).</div><div class=\"line\">     */</div><div class=\"line\">    public int getCurrentRetryCount();</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Prepares for the next retry by applying a backoff to the timeout.</div><div class=\"line\">     * 为下一次request做好准备，通过不停地来放宽timeout时间限制</div><div class=\"line\">     * 在DefaultRetryPolicy.java中好理解一些</div><div class=\"line\">     * </div><div class=\"line\">     * @param error The error code of the last attempt.</div><div class=\"line\">     * @throws VolleyError In the event that the retry could not be performed (for example if we</div><div class=\"line\">     * ran out of attempts), the passed in error is thrown.</div><div class=\"line\">     */</div><div class=\"line\">    public void retry(VolleyError error) throws VolleyError;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"6-DefaultRetryPolicy-java\"><a href=\"#6-DefaultRetryPolicy-java\" class=\"headerlink\" title=\"6. DefaultRetryPolicy.java\"></a><a href=\"#6-_DefaultRetryPolicy-java\" title=\"6\\. DefaultRetryPolicy.java\"></a>6. DefaultRetryPolicy.java</h3><p><code>DefaultRetryPolicy.java</code>描述了对待Volley中涉及Network的request的策略方针，可以理解为重试策略方针，也就是对那些在网络请求失败的request处理方法。里面包含了retry的最大次数(<code>mMaxNumRetries</code>)，当前请求次数(<code>mCurrentRetryCount</code>)以及请求超时的时间阀值(<code>mCurrentTimeoutMs</code>)等。每个Request里面都包含了一个<code>RetryPolicy.java</code>实现类，在处理的时候可以通过<code>getRetryPolicy()</code>方法获得。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div></pre></td><td class=\"code\"><pre><div class=\"line\">package com.android.volley;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\"> * Default retry policy for requests.</div><div class=\"line\"> */</div><div class=\"line\">public class DefaultRetryPolicy implements RetryPolicy &#123;</div><div class=\"line\">    /** </div><div class=\"line\">     * The current timeout in milliseconds. </div><div class=\"line\">     * 请求超时的时间数</div><div class=\"line\">     */</div><div class=\"line\">    private int mCurrentTimeoutMs;</div><div class=\"line\"></div><div class=\"line\">    /** </div><div class=\"line\">     * The current retry count.</div><div class=\"line\">     * 当前请求的重试次数</div><div class=\"line\">     */</div><div class=\"line\">    private int mCurrentRetryCount;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * The maximum number of attempts. </div><div class=\"line\">     * 重复尝试的最大次数</div><div class=\"line\">     **/</div><div class=\"line\">    private final int mMaxNumRetries;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * The backoff multiplier for the policy.</div><div class=\"line\">     * 暂时不明白这个有什么用</div><div class=\"line\">     * 根据后面的来看好像是一个用于放宽timeout时间限制的系数</div><div class=\"line\">     * 这个系数越大每次retry的时候放宽的程度也就越大</div><div class=\"line\">     */</div><div class=\"line\">    private final float mBackoffMultiplier;</div><div class=\"line\"></div><div class=\"line\">    /** The default socket timeout in milliseconds */</div><div class=\"line\">    public static final int DEFAULT_TIMEOUT_MS = 2500;</div><div class=\"line\"></div><div class=\"line\">    /** The default number of retries */</div><div class=\"line\">    public static final int DEFAULT_MAX_RETRIES = 0;</div><div class=\"line\"></div><div class=\"line\">    /** The default backoff multiplier */</div><div class=\"line\">    public static final float DEFAULT_BACKOFF_MULT = 1f;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Constructs a new retry policy using the default timeouts.</div><div class=\"line\">     * 默认的构造器，2.5s的超时，</div><div class=\"line\">     * 最大重试数为0，也就是request请求超时了就不要再自动重试了</div><div class=\"line\">     */</div><div class=\"line\">    public DefaultRetryPolicy() &#123;</div><div class=\"line\">        this(DEFAULT_TIMEOUT_MS, DEFAULT_MAX_RETRIES, DEFAULT_BACKOFF_MULT);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Constructs a new retry policy.</div><div class=\"line\">     * @param initialTimeoutMs The initial timeout for the policy.</div><div class=\"line\">     * @param maxNumRetries The maximum number of retries.</div><div class=\"line\">     * @param backoffMultiplier Backoff multiplier for the policy.</div><div class=\"line\">     */</div><div class=\"line\">    public DefaultRetryPolicy(int initialTimeoutMs, int maxNumRetries, float backoffMultiplier) &#123;</div><div class=\"line\">        mCurrentTimeoutMs = initialTimeoutMs;</div><div class=\"line\">        mMaxNumRetries = maxNumRetries;</div><div class=\"line\">        mBackoffMultiplier = backoffMultiplier;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Returns the current timeout.</div><div class=\"line\">     */</div><div class=\"line\">    @Override</div><div class=\"line\">    public int getCurrentTimeout() &#123;</div><div class=\"line\">        return mCurrentTimeoutMs;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Returns the current retry count.</div><div class=\"line\">     */</div><div class=\"line\">    @Override</div><div class=\"line\">    public int getCurrentRetryCount() &#123;</div><div class=\"line\">        return mCurrentRetryCount;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Returns the backoff multiplier for the policy.</div><div class=\"line\">     */</div><div class=\"line\">    public float getBackoffMultiplier() &#123;</div><div class=\"line\">        return mBackoffMultiplier;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Prepares for the next retry by applying a backoff to the timeout.</div><div class=\"line\">     * 该方法定义在RetryPolicy.java中。</div><div class=\"line\">     * 为下一次重试request做准备，好像是通过延长服务器响应时间的限制 = =</div><div class=\"line\">     * 每次对timeout的时间限制都放宽了mBackoffMultiplier个单位。让服务器多一点时间去响应</div><div class=\"line\">     * </div><div class=\"line\">     * @param error The error code of the last attempt.</div><div class=\"line\">     * 最后一次request服务器给出的错误码</div><div class=\"line\">     */</div><div class=\"line\">    @Override</div><div class=\"line\">    public void retry(VolleyError error) throws VolleyError &#123;</div><div class=\"line\">        mCurrentRetryCount++;</div><div class=\"line\">        mCurrentTimeoutMs += (mCurrentTimeoutMs * mBackoffMultiplier);</div><div class=\"line\">        if (!hasAttemptRemaining()) &#123;</div><div class=\"line\">            throw error;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">     * Returns true if this policy has attempts remaining, false otherwise.</div><div class=\"line\">     * 这个是用来判断是否还有retry机会的</div><div class=\"line\">     */</div><div class=\"line\">    protected boolean hasAttemptRemaining() &#123;</div><div class=\"line\">        return mCurrentRetryCount &lt;= mMaxNumRetries;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>到这里对<code>Network.java</code>接口以及<code>RetryPolicy.java</code>接口的代码就分析完了，现在是清楚了在<code>NetworkDispatcher.java</code>调用了<code>mNetwork.performRequest()</code>之后发生了什么事情，还弄清楚了request在网络请求发送之后，出现了各种问题会怎么处理(重试策略)，但还不知道最核心的网络请求是如何发生的，也就是在<code>BasicNetwork.java</code>中的下面这行代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">httpResponse = mHttpStack.performRequest(request, headers);</div></pre></td></tr></table></figure>\n<p>这行代码就涉及到了后面的<code>HttpStack.java</code>接口及其两个实现类了。</p>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ckc5n2qgt0000w8r185msl1ai","tag_id":"ckc5n2qgy0004w8r1jnzrd02g","_id":"ckc5n2qh20009w8r12eib0lsp"},{"post_id":"ckc5n2qh2000aw8r1vw9z4e2v","tag_id":"ckc5n2qh20008w8r1ky1u4nu3","_id":"ckc5n2qh4000dw8r1tj8pzd4u"},{"post_id":"ckc5n2qgw0002w8r1w5ri93w1","tag_id":"ckc5n2qh20008w8r1ky1u4nu3","_id":"ckc5n2qh5000fw8r16jtg4o32"},{"post_id":"ckc5n2qh3000bw8r1p7eagb1n","tag_id":"ckc5n2qh20008w8r1ky1u4nu3","_id":"ckc5n2qh6000iw8r13w9ejeur"},{"post_id":"ckc5n2qgz0005w8r1j7lkzgfl","tag_id":"ckc5n2qh4000cw8r1nnjc121y","_id":"ckc5n2qh8000kw8r18xeu1i6z"},{"post_id":"ckc5n2qh00006w8r13m985ufw","tag_id":"ckc5n2qh4000cw8r1nnjc121y","_id":"ckc5n2qha000ow8r1rtwvxgt1"},{"post_id":"ckc5n2qh10007w8r1h6wlbk2z","tag_id":"ckc5n2qh4000cw8r1nnjc121y","_id":"ckc5n2qhc000sw8r16v6hfgcx"},{"post_id":"ckc5n2qh4000ew8r1n0mgp1om","tag_id":"ckc5n2qhb000qw8r157nzc2og","_id":"ckc5n2qhd000vw8r1gu4x4dc7"},{"post_id":"ckc5n2qhc000tw8r1jpqza1pq","tag_id":"ckc5n2qhb000qw8r157nzc2og","_id":"ckc5n2qhd000ww8r197yfcv4k"},{"post_id":"ckc5n2qh5000gw8r1n8kw5kxw","tag_id":"ckc5n2qhb000qw8r157nzc2og","_id":"ckc5n2qhe000yw8r1hirf0d8k"},{"post_id":"ckc5n2qh7000jw8r1xyrf6pze","tag_id":"ckc5n2qhb000qw8r157nzc2og","_id":"ckc5n2qhf0010w8r1rc372jqx"},{"post_id":"ckc5n2qh8000lw8r1ykhwncn3","tag_id":"ckc5n2qhb000qw8r157nzc2og","_id":"ckc5n2qhf0012w8r1g35sa4bi"},{"post_id":"ckc5n2qh9000nw8r1gq7seq1u","tag_id":"ckc5n2qhb000qw8r157nzc2og","_id":"ckc5n2qhg0014w8r15dkv1lph"},{"post_id":"ckc5n2qha000pw8r1rwj1hpks","tag_id":"ckc5n2qhb000qw8r157nzc2og","_id":"ckc5n2qhg0016w8r1fgny0n4c"},{"post_id":"ckc5n2qhb000rw8r1d990ys1d","tag_id":"ckc5n2qhg0015w8r1xcs4rfkp","_id":"ckc5n2qhg0017w8r1ww73hph7"}],"Tag":[{"name":"hexo","_id":"ckc5n2qgy0004w8r1jnzrd02g"},{"name":"Android","_id":"ckc5n2qh20008w8r1ky1u4nu3"},{"name":"React-Native","_id":"ckc5n2qh4000cw8r1nnjc121y"},{"name":"volley","_id":"ckc5n2qhb000qw8r157nzc2og"},{"name":"other","_id":"ckc5n2qhg0015w8r1xcs4rfkp"}]}}